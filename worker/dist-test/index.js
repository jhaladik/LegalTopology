var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj2, key, value) => key in obj2 ? __defProp(obj2, key, { enumerable: true, configurable: true, writable: true, value }) : obj2[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __require = /* @__PURE__ */ ((x2) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x2, {
  get: (a2, b2) => (typeof require !== "undefined" ? require : a2)[b2]
}) : x2)(function(x2) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x2 + '" is not supported');
});
var __esm = (fn2, res) => function __init() {
  return fn2 && (res = (0, fn2[__getOwnPropNames(fn2)[0]])(fn2 = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to2, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to2, key) && key !== except)
        __defProp(to2, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to2;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __publicField = (obj2, key, value) => {
  __defNormalProp(obj2, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj2, member, msg) => {
  if (!member.has(obj2))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj2, member, getter) => {
  __accessCheck(obj2, member, "read from private field");
  return getter ? getter.call(obj2) : member.get(obj2);
};
var __privateAdd = (obj2, member, value) => {
  if (member.has(obj2))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj2) : member.set(obj2, value);
};
var __privateSet = (obj2, member, value, setter) => {
  __accessCheck(obj2, member, "write to private field");
  setter ? setter.call(obj2, value) : member.set(obj2, value);
  return value;
};
var __privateWrapper = (obj2, member, setter, getter) => ({
  set _(value) {
    __privateSet(obj2, member, value, setter);
  },
  get _() {
    return __privateGet(obj2, member, getter);
  }
});
var __privateMethod = (obj2, member, method) => {
  __accessCheck(obj2, member, "access private method");
  return method;
};

// node_modules/unenv/dist/runtime/_internal/utils.mjs
function createNotImplementedError(name) {
  return new Error(`[unenv] ${name} is not implemented yet!`);
}
function notImplemented(name) {
  const fn2 = /* @__PURE__ */ __name(() => {
    throw createNotImplementedError(name);
  }, "fn");
  return Object.assign(fn2, { __unenv__: true });
}
function notImplementedClass(name) {
  return class {
    __unenv__ = true;
    constructor() {
      throw new Error(`[unenv] ${name} is not implemented yet!`);
    }
  };
}
var init_utils = __esm({
  "node_modules/unenv/dist/runtime/_internal/utils.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    __name(createNotImplementedError, "createNotImplementedError");
    __name(notImplemented, "notImplemented");
    __name(notImplementedClass, "notImplementedClass");
  }
});

// node_modules/unenv/dist/runtime/node/internal/perf_hooks/performance.mjs
var _timeOrigin, _performanceNow, nodeTiming, PerformanceEntry, PerformanceMark, PerformanceMeasure, PerformanceResourceTiming, PerformanceObserverEntryList, Performance, PerformanceObserver, performance;
var init_performance = __esm({
  "node_modules/unenv/dist/runtime/node/internal/perf_hooks/performance.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_utils();
    _timeOrigin = globalThis.performance?.timeOrigin ?? Date.now();
    _performanceNow = globalThis.performance?.now ? globalThis.performance.now.bind(globalThis.performance) : () => Date.now() - _timeOrigin;
    nodeTiming = {
      name: "node",
      entryType: "node",
      startTime: 0,
      duration: 0,
      nodeStart: 0,
      v8Start: 0,
      bootstrapComplete: 0,
      environment: 0,
      loopStart: 0,
      loopExit: 0,
      idleTime: 0,
      uvMetricsInfo: {
        loopCount: 0,
        events: 0,
        eventsWaiting: 0
      },
      detail: void 0,
      toJSON() {
        return this;
      }
    };
    PerformanceEntry = class {
      __unenv__ = true;
      detail;
      entryType = "event";
      name;
      startTime;
      constructor(name, options) {
        this.name = name;
        this.startTime = options?.startTime || _performanceNow();
        this.detail = options?.detail;
      }
      get duration() {
        return _performanceNow() - this.startTime;
      }
      toJSON() {
        return {
          name: this.name,
          entryType: this.entryType,
          startTime: this.startTime,
          duration: this.duration,
          detail: this.detail
        };
      }
    };
    __name(PerformanceEntry, "PerformanceEntry");
    PerformanceMark = /* @__PURE__ */ __name(class PerformanceMark2 extends PerformanceEntry {
      entryType = "mark";
      constructor() {
        super(...arguments);
      }
      get duration() {
        return 0;
      }
    }, "PerformanceMark");
    PerformanceMeasure = class extends PerformanceEntry {
      entryType = "measure";
    };
    __name(PerformanceMeasure, "PerformanceMeasure");
    PerformanceResourceTiming = class extends PerformanceEntry {
      entryType = "resource";
      serverTiming = [];
      connectEnd = 0;
      connectStart = 0;
      decodedBodySize = 0;
      domainLookupEnd = 0;
      domainLookupStart = 0;
      encodedBodySize = 0;
      fetchStart = 0;
      initiatorType = "";
      name = "";
      nextHopProtocol = "";
      redirectEnd = 0;
      redirectStart = 0;
      requestStart = 0;
      responseEnd = 0;
      responseStart = 0;
      secureConnectionStart = 0;
      startTime = 0;
      transferSize = 0;
      workerStart = 0;
      responseStatus = 0;
    };
    __name(PerformanceResourceTiming, "PerformanceResourceTiming");
    PerformanceObserverEntryList = class {
      __unenv__ = true;
      getEntries() {
        return [];
      }
      getEntriesByName(_name, _type) {
        return [];
      }
      getEntriesByType(type) {
        return [];
      }
    };
    __name(PerformanceObserverEntryList, "PerformanceObserverEntryList");
    Performance = class {
      __unenv__ = true;
      timeOrigin = _timeOrigin;
      eventCounts = /* @__PURE__ */ new Map();
      _entries = [];
      _resourceTimingBufferSize = 0;
      navigation = void 0;
      timing = void 0;
      timerify(_fn, _options) {
        throw createNotImplementedError("Performance.timerify");
      }
      get nodeTiming() {
        return nodeTiming;
      }
      eventLoopUtilization() {
        return {};
      }
      markResourceTiming() {
        return new PerformanceResourceTiming("");
      }
      onresourcetimingbufferfull = null;
      now() {
        if (this.timeOrigin === _timeOrigin) {
          return _performanceNow();
        }
        return Date.now() - this.timeOrigin;
      }
      clearMarks(markName) {
        this._entries = markName ? this._entries.filter((e2) => e2.name !== markName) : this._entries.filter((e2) => e2.entryType !== "mark");
      }
      clearMeasures(measureName) {
        this._entries = measureName ? this._entries.filter((e2) => e2.name !== measureName) : this._entries.filter((e2) => e2.entryType !== "measure");
      }
      clearResourceTimings() {
        this._entries = this._entries.filter((e2) => e2.entryType !== "resource" || e2.entryType !== "navigation");
      }
      getEntries() {
        return this._entries;
      }
      getEntriesByName(name, type) {
        return this._entries.filter((e2) => e2.name === name && (!type || e2.entryType === type));
      }
      getEntriesByType(type) {
        return this._entries.filter((e2) => e2.entryType === type);
      }
      mark(name, options) {
        const entry = new PerformanceMark(name, options);
        this._entries.push(entry);
        return entry;
      }
      measure(measureName, startOrMeasureOptions, endMark) {
        let start;
        let end;
        if (typeof startOrMeasureOptions === "string") {
          start = this.getEntriesByName(startOrMeasureOptions, "mark")[0]?.startTime;
          end = this.getEntriesByName(endMark, "mark")[0]?.startTime;
        } else {
          start = Number.parseFloat(startOrMeasureOptions?.start) || this.now();
          end = Number.parseFloat(startOrMeasureOptions?.end) || this.now();
        }
        const entry = new PerformanceMeasure(measureName, {
          startTime: start,
          detail: {
            start,
            end
          }
        });
        this._entries.push(entry);
        return entry;
      }
      setResourceTimingBufferSize(maxSize) {
        this._resourceTimingBufferSize = maxSize;
      }
      addEventListener(type, listener, options) {
        throw createNotImplementedError("Performance.addEventListener");
      }
      removeEventListener(type, listener, options) {
        throw createNotImplementedError("Performance.removeEventListener");
      }
      dispatchEvent(event) {
        throw createNotImplementedError("Performance.dispatchEvent");
      }
      toJSON() {
        return this;
      }
    };
    __name(Performance, "Performance");
    PerformanceObserver = class {
      __unenv__ = true;
      _callback = null;
      constructor(callback) {
        this._callback = callback;
      }
      takeRecords() {
        return [];
      }
      disconnect() {
        throw createNotImplementedError("PerformanceObserver.disconnect");
      }
      observe(options) {
        throw createNotImplementedError("PerformanceObserver.observe");
      }
      bind(fn2) {
        return fn2;
      }
      runInAsyncScope(fn2, thisArg, ...args) {
        return fn2.call(thisArg, ...args);
      }
      asyncId() {
        return 0;
      }
      triggerAsyncId() {
        return 0;
      }
      emitDestroy() {
        return this;
      }
    };
    __name(PerformanceObserver, "PerformanceObserver");
    __publicField(PerformanceObserver, "supportedEntryTypes", []);
    performance = globalThis.performance && "addEventListener" in globalThis.performance ? globalThis.performance : new Performance();
  }
});

// node_modules/unenv/dist/runtime/node/perf_hooks.mjs
var init_perf_hooks = __esm({
  "node_modules/unenv/dist/runtime/node/perf_hooks.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_performance();
  }
});

// node_modules/@cloudflare/unenv-preset/dist/runtime/polyfill/performance.mjs
var init_performance2 = __esm({
  "node_modules/@cloudflare/unenv-preset/dist/runtime/polyfill/performance.mjs"() {
    init_perf_hooks();
    globalThis.performance = performance;
    globalThis.Performance = Performance;
    globalThis.PerformanceEntry = PerformanceEntry;
    globalThis.PerformanceMark = PerformanceMark;
    globalThis.PerformanceMeasure = PerformanceMeasure;
    globalThis.PerformanceObserver = PerformanceObserver;
    globalThis.PerformanceObserverEntryList = PerformanceObserverEntryList;
    globalThis.PerformanceResourceTiming = PerformanceResourceTiming;
  }
});

// node_modules/unenv/dist/runtime/mock/noop.mjs
var noop_default;
var init_noop = __esm({
  "node_modules/unenv/dist/runtime/mock/noop.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    noop_default = Object.assign(() => {
    }, { __unenv__: true });
  }
});

// node_modules/unenv/dist/runtime/node/console.mjs
import { Writable } from "node:stream";
var _console, _ignoreErrors, _stderr, _stdout, log, info, trace, debug, table, error, warn, createTask, clear, count, countReset, dir, dirxml, group, groupEnd, groupCollapsed, profile, profileEnd, time, timeEnd, timeLog, timeStamp, Console, _times, _stdoutErrorHandler, _stderrErrorHandler;
var init_console = __esm({
  "node_modules/unenv/dist/runtime/node/console.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_noop();
    init_utils();
    _console = globalThis.console;
    _ignoreErrors = true;
    _stderr = new Writable();
    _stdout = new Writable();
    log = _console?.log ?? noop_default;
    info = _console?.info ?? log;
    trace = _console?.trace ?? info;
    debug = _console?.debug ?? log;
    table = _console?.table ?? log;
    error = _console?.error ?? log;
    warn = _console?.warn ?? error;
    createTask = _console?.createTask ?? /* @__PURE__ */ notImplemented("console.createTask");
    clear = _console?.clear ?? noop_default;
    count = _console?.count ?? noop_default;
    countReset = _console?.countReset ?? noop_default;
    dir = _console?.dir ?? noop_default;
    dirxml = _console?.dirxml ?? noop_default;
    group = _console?.group ?? noop_default;
    groupEnd = _console?.groupEnd ?? noop_default;
    groupCollapsed = _console?.groupCollapsed ?? noop_default;
    profile = _console?.profile ?? noop_default;
    profileEnd = _console?.profileEnd ?? noop_default;
    time = _console?.time ?? noop_default;
    timeEnd = _console?.timeEnd ?? noop_default;
    timeLog = _console?.timeLog ?? noop_default;
    timeStamp = _console?.timeStamp ?? noop_default;
    Console = _console?.Console ?? /* @__PURE__ */ notImplementedClass("console.Console");
    _times = /* @__PURE__ */ new Map();
    _stdoutErrorHandler = noop_default;
    _stderrErrorHandler = noop_default;
  }
});

// node_modules/@cloudflare/unenv-preset/dist/runtime/node/console.mjs
var workerdConsole, assert, clear2, context, count2, countReset2, createTask2, debug2, dir2, dirxml2, error2, group2, groupCollapsed2, groupEnd2, info2, log2, profile2, profileEnd2, table2, time2, timeEnd2, timeLog2, timeStamp2, trace2, warn2, console_default;
var init_console2 = __esm({
  "node_modules/@cloudflare/unenv-preset/dist/runtime/node/console.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_console();
    workerdConsole = globalThis["console"];
    ({
      assert,
      clear: clear2,
      context: (
        // @ts-expect-error undocumented public API
        context
      ),
      count: count2,
      countReset: countReset2,
      createTask: (
        // @ts-expect-error undocumented public API
        createTask2
      ),
      debug: debug2,
      dir: dir2,
      dirxml: dirxml2,
      error: error2,
      group: group2,
      groupCollapsed: groupCollapsed2,
      groupEnd: groupEnd2,
      info: info2,
      log: log2,
      profile: profile2,
      profileEnd: profileEnd2,
      table: table2,
      time: time2,
      timeEnd: timeEnd2,
      timeLog: timeLog2,
      timeStamp: timeStamp2,
      trace: trace2,
      warn: warn2
    } = workerdConsole);
    Object.assign(workerdConsole, {
      Console,
      _ignoreErrors,
      _stderr,
      _stderrErrorHandler,
      _stdout,
      _stdoutErrorHandler,
      _times
    });
    console_default = workerdConsole;
  }
});

// node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-console
var init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console = __esm({
  "node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-console"() {
    init_console2();
    globalThis.console = console_default;
  }
});

// node_modules/unenv/dist/runtime/node/internal/process/hrtime.mjs
var hrtime;
var init_hrtime = __esm({
  "node_modules/unenv/dist/runtime/node/internal/process/hrtime.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    hrtime = /* @__PURE__ */ Object.assign(/* @__PURE__ */ __name(function hrtime2(startTime) {
      const now = Date.now();
      const seconds = Math.trunc(now / 1e3);
      const nanos = now % 1e3 * 1e6;
      if (startTime) {
        let diffSeconds = seconds - startTime[0];
        let diffNanos = nanos - startTime[0];
        if (diffNanos < 0) {
          diffSeconds = diffSeconds - 1;
          diffNanos = 1e9 + diffNanos;
        }
        return [diffSeconds, diffNanos];
      }
      return [seconds, nanos];
    }, "hrtime"), { bigint: /* @__PURE__ */ __name(function bigint() {
      return BigInt(Date.now() * 1e6);
    }, "bigint") });
  }
});

// node_modules/unenv/dist/runtime/node/internal/tty/read-stream.mjs
import { Socket } from "node:net";
var ReadStream;
var init_read_stream = __esm({
  "node_modules/unenv/dist/runtime/node/internal/tty/read-stream.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    ReadStream = class extends Socket {
      fd;
      constructor(fd) {
        super();
        this.fd = fd;
      }
      isRaw = false;
      setRawMode(mode) {
        this.isRaw = mode;
        return this;
      }
      isTTY = false;
    };
    __name(ReadStream, "ReadStream");
  }
});

// node_modules/unenv/dist/runtime/node/internal/tty/write-stream.mjs
import { Socket as Socket2 } from "node:net";
var WriteStream;
var init_write_stream = __esm({
  "node_modules/unenv/dist/runtime/node/internal/tty/write-stream.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    WriteStream = class extends Socket2 {
      fd;
      constructor(fd) {
        super();
        this.fd = fd;
      }
      clearLine(dir3, callback) {
        callback && callback();
        return false;
      }
      clearScreenDown(callback) {
        callback && callback();
        return false;
      }
      cursorTo(x2, y2, callback) {
        callback && typeof callback === "function" && callback();
        return false;
      }
      moveCursor(dx, dy, callback) {
        callback && callback();
        return false;
      }
      getColorDepth(env3) {
        return 1;
      }
      hasColors(count3, env3) {
        return false;
      }
      getWindowSize() {
        return [this.columns, this.rows];
      }
      columns = 80;
      rows = 24;
      isTTY = false;
    };
    __name(WriteStream, "WriteStream");
  }
});

// node_modules/unenv/dist/runtime/node/tty.mjs
var init_tty = __esm({
  "node_modules/unenv/dist/runtime/node/tty.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_read_stream();
    init_write_stream();
  }
});

// node_modules/unenv/dist/runtime/node/internal/process/process.mjs
import { EventEmitter } from "node:events";
var Process;
var init_process = __esm({
  "node_modules/unenv/dist/runtime/node/internal/process/process.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_tty();
    init_utils();
    Process = class extends EventEmitter {
      env;
      hrtime;
      nextTick;
      constructor(impl) {
        super();
        this.env = impl.env;
        this.hrtime = impl.hrtime;
        this.nextTick = impl.nextTick;
        for (const prop of [...Object.getOwnPropertyNames(Process.prototype), ...Object.getOwnPropertyNames(EventEmitter.prototype)]) {
          const value = this[prop];
          if (typeof value === "function") {
            this[prop] = value.bind(this);
          }
        }
      }
      emitWarning(warning, type, code) {
        console.warn(`${code ? `[${code}] ` : ""}${type ? `${type}: ` : ""}${warning}`);
      }
      emit(...args) {
        return super.emit(...args);
      }
      listeners(eventName) {
        return super.listeners(eventName);
      }
      #stdin;
      #stdout;
      #stderr;
      get stdin() {
        return this.#stdin ??= new ReadStream(0);
      }
      get stdout() {
        return this.#stdout ??= new WriteStream(1);
      }
      get stderr() {
        return this.#stderr ??= new WriteStream(2);
      }
      #cwd = "/";
      chdir(cwd2) {
        this.#cwd = cwd2;
      }
      cwd() {
        return this.#cwd;
      }
      arch = "";
      platform = "";
      argv = [];
      argv0 = "";
      execArgv = [];
      execPath = "";
      title = "";
      pid = 200;
      ppid = 100;
      get version() {
        return "";
      }
      get versions() {
        return {};
      }
      get allowedNodeEnvironmentFlags() {
        return /* @__PURE__ */ new Set();
      }
      get sourceMapsEnabled() {
        return false;
      }
      get debugPort() {
        return 0;
      }
      get throwDeprecation() {
        return false;
      }
      get traceDeprecation() {
        return false;
      }
      get features() {
        return {};
      }
      get release() {
        return {};
      }
      get connected() {
        return false;
      }
      get config() {
        return {};
      }
      get moduleLoadList() {
        return [];
      }
      constrainedMemory() {
        return 0;
      }
      availableMemory() {
        return 0;
      }
      uptime() {
        return 0;
      }
      resourceUsage() {
        return {};
      }
      ref() {
      }
      unref() {
      }
      umask() {
        throw createNotImplementedError("process.umask");
      }
      getBuiltinModule() {
        return void 0;
      }
      getActiveResourcesInfo() {
        throw createNotImplementedError("process.getActiveResourcesInfo");
      }
      exit() {
        throw createNotImplementedError("process.exit");
      }
      reallyExit() {
        throw createNotImplementedError("process.reallyExit");
      }
      kill() {
        throw createNotImplementedError("process.kill");
      }
      abort() {
        throw createNotImplementedError("process.abort");
      }
      dlopen() {
        throw createNotImplementedError("process.dlopen");
      }
      setSourceMapsEnabled() {
        throw createNotImplementedError("process.setSourceMapsEnabled");
      }
      loadEnvFile() {
        throw createNotImplementedError("process.loadEnvFile");
      }
      disconnect() {
        throw createNotImplementedError("process.disconnect");
      }
      cpuUsage() {
        throw createNotImplementedError("process.cpuUsage");
      }
      setUncaughtExceptionCaptureCallback() {
        throw createNotImplementedError("process.setUncaughtExceptionCaptureCallback");
      }
      hasUncaughtExceptionCaptureCallback() {
        throw createNotImplementedError("process.hasUncaughtExceptionCaptureCallback");
      }
      initgroups() {
        throw createNotImplementedError("process.initgroups");
      }
      openStdin() {
        throw createNotImplementedError("process.openStdin");
      }
      assert() {
        throw createNotImplementedError("process.assert");
      }
      binding() {
        throw createNotImplementedError("process.binding");
      }
      permission = { has: /* @__PURE__ */ notImplemented("process.permission.has") };
      report = {
        directory: "",
        filename: "",
        signal: "SIGUSR2",
        compact: false,
        reportOnFatalError: false,
        reportOnSignal: false,
        reportOnUncaughtException: false,
        getReport: /* @__PURE__ */ notImplemented("process.report.getReport"),
        writeReport: /* @__PURE__ */ notImplemented("process.report.writeReport")
      };
      finalization = {
        register: /* @__PURE__ */ notImplemented("process.finalization.register"),
        unregister: /* @__PURE__ */ notImplemented("process.finalization.unregister"),
        registerBeforeExit: /* @__PURE__ */ notImplemented("process.finalization.registerBeforeExit")
      };
      memoryUsage = Object.assign(() => ({
        arrayBuffers: 0,
        rss: 0,
        external: 0,
        heapTotal: 0,
        heapUsed: 0
      }), { rss: () => 0 });
      mainModule = void 0;
      domain = void 0;
      send = void 0;
      exitCode = void 0;
      channel = void 0;
      getegid = void 0;
      geteuid = void 0;
      getgid = void 0;
      getgroups = void 0;
      getuid = void 0;
      setegid = void 0;
      seteuid = void 0;
      setgid = void 0;
      setgroups = void 0;
      setuid = void 0;
      _events = void 0;
      _eventsCount = void 0;
      _exiting = void 0;
      _maxListeners = void 0;
      _debugEnd = void 0;
      _debugProcess = void 0;
      _fatalException = void 0;
      _getActiveHandles = void 0;
      _getActiveRequests = void 0;
      _kill = void 0;
      _preload_modules = void 0;
      _rawDebug = void 0;
      _startProfilerIdleNotifier = void 0;
      _stopProfilerIdleNotifier = void 0;
      _tickCallback = void 0;
      _disconnect = void 0;
      _handleQueue = void 0;
      _pendingMessage = void 0;
      _channel = void 0;
      _send = void 0;
      _linkedBinding = void 0;
    };
    __name(Process, "Process");
  }
});

// node_modules/@cloudflare/unenv-preset/dist/runtime/node/process.mjs
var globalProcess, getBuiltinModule, exit, platform, nextTick, unenvProcess, abort, addListener, allowedNodeEnvironmentFlags, hasUncaughtExceptionCaptureCallback, setUncaughtExceptionCaptureCallback, loadEnvFile, sourceMapsEnabled, arch, argv, argv0, chdir, config, connected, constrainedMemory, availableMemory, cpuUsage, cwd, debugPort, dlopen, disconnect, emit, emitWarning, env2, eventNames, execArgv, execPath, finalization, features, getActiveResourcesInfo, getMaxListeners, hrtime3, kill, listeners, listenerCount, memoryUsage, on, off, once, pid, ppid, prependListener, prependOnceListener, rawListeners, release, removeAllListeners, removeListener, report, resourceUsage, setMaxListeners, setSourceMapsEnabled, stderr, stdin, stdout, title, throwDeprecation, traceDeprecation, umask, uptime, version, versions, domain, initgroups, moduleLoadList, reallyExit, openStdin, assert2, binding, send, exitCode, channel, getegid, geteuid, getgid, getgroups, getuid, setegid, seteuid, setgid, setgroups, setuid, permission, mainModule, _events, _eventsCount, _exiting, _maxListeners, _debugEnd, _debugProcess, _fatalException, _getActiveHandles, _getActiveRequests, _kill, _preload_modules, _rawDebug, _startProfilerIdleNotifier, _stopProfilerIdleNotifier, _tickCallback, _disconnect, _handleQueue, _pendingMessage, _channel, _send, _linkedBinding, _process, process_default;
var init_process2 = __esm({
  "node_modules/@cloudflare/unenv-preset/dist/runtime/node/process.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_hrtime();
    init_process();
    globalProcess = globalThis["process"];
    getBuiltinModule = globalProcess.getBuiltinModule;
    ({ exit, platform, nextTick } = getBuiltinModule(
      "node:process"
    ));
    unenvProcess = new Process({
      env: globalProcess.env,
      hrtime,
      nextTick
    });
    ({
      abort,
      addListener,
      allowedNodeEnvironmentFlags,
      hasUncaughtExceptionCaptureCallback,
      setUncaughtExceptionCaptureCallback,
      loadEnvFile,
      sourceMapsEnabled,
      arch,
      argv,
      argv0,
      chdir,
      config,
      connected,
      constrainedMemory,
      availableMemory,
      cpuUsage,
      cwd,
      debugPort,
      dlopen,
      disconnect,
      emit,
      emitWarning,
      env: env2,
      eventNames,
      execArgv,
      execPath,
      finalization,
      features,
      getActiveResourcesInfo,
      getMaxListeners,
      hrtime: hrtime3,
      kill,
      listeners,
      listenerCount,
      memoryUsage,
      on,
      off,
      once,
      pid,
      ppid,
      prependListener,
      prependOnceListener,
      rawListeners,
      release,
      removeAllListeners,
      removeListener,
      report,
      resourceUsage,
      setMaxListeners,
      setSourceMapsEnabled,
      stderr,
      stdin,
      stdout,
      title,
      throwDeprecation,
      traceDeprecation,
      umask,
      uptime,
      version,
      versions,
      domain,
      initgroups,
      moduleLoadList,
      reallyExit,
      openStdin,
      assert: assert2,
      binding,
      send,
      exitCode,
      channel,
      getegid,
      geteuid,
      getgid,
      getgroups,
      getuid,
      setegid,
      seteuid,
      setgid,
      setgroups,
      setuid,
      permission,
      mainModule,
      _events,
      _eventsCount,
      _exiting,
      _maxListeners,
      _debugEnd,
      _debugProcess,
      _fatalException,
      _getActiveHandles,
      _getActiveRequests,
      _kill,
      _preload_modules,
      _rawDebug,
      _startProfilerIdleNotifier,
      _stopProfilerIdleNotifier,
      _tickCallback,
      _disconnect,
      _handleQueue,
      _pendingMessage,
      _channel,
      _send,
      _linkedBinding
    } = unenvProcess);
    _process = {
      abort,
      addListener,
      allowedNodeEnvironmentFlags,
      hasUncaughtExceptionCaptureCallback,
      setUncaughtExceptionCaptureCallback,
      loadEnvFile,
      sourceMapsEnabled,
      arch,
      argv,
      argv0,
      chdir,
      config,
      connected,
      constrainedMemory,
      availableMemory,
      cpuUsage,
      cwd,
      debugPort,
      dlopen,
      disconnect,
      emit,
      emitWarning,
      env: env2,
      eventNames,
      execArgv,
      execPath,
      exit,
      finalization,
      features,
      getBuiltinModule,
      getActiveResourcesInfo,
      getMaxListeners,
      hrtime: hrtime3,
      kill,
      listeners,
      listenerCount,
      memoryUsage,
      nextTick,
      on,
      off,
      once,
      pid,
      platform,
      ppid,
      prependListener,
      prependOnceListener,
      rawListeners,
      release,
      removeAllListeners,
      removeListener,
      report,
      resourceUsage,
      setMaxListeners,
      setSourceMapsEnabled,
      stderr,
      stdin,
      stdout,
      title,
      throwDeprecation,
      traceDeprecation,
      umask,
      uptime,
      version,
      versions,
      // @ts-expect-error old API
      domain,
      initgroups,
      moduleLoadList,
      reallyExit,
      openStdin,
      assert: assert2,
      binding,
      send,
      exitCode,
      channel,
      getegid,
      geteuid,
      getgid,
      getgroups,
      getuid,
      setegid,
      seteuid,
      setgid,
      setgroups,
      setuid,
      permission,
      mainModule,
      _events,
      _eventsCount,
      _exiting,
      _maxListeners,
      _debugEnd,
      _debugProcess,
      _fatalException,
      _getActiveHandles,
      _getActiveRequests,
      _kill,
      _preload_modules,
      _rawDebug,
      _startProfilerIdleNotifier,
      _stopProfilerIdleNotifier,
      _tickCallback,
      _disconnect,
      _handleQueue,
      _pendingMessage,
      _channel,
      _send,
      _linkedBinding
    };
    process_default = _process;
  }
});

// node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-process
var init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process = __esm({
  "node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-process"() {
    init_process2();
    globalThis.process = process_default;
  }
});

// node_modules/unpdf/dist/pdfjs.mjs
var pdfjs_exports = {};
__export(pdfjs_exports, {
  AbortException: () => AbortException,
  AnnotationEditorLayer: () => AnnotationEditorLayer,
  AnnotationEditorParamsType: () => jl,
  AnnotationEditorType: () => Ll,
  AnnotationEditorUIManager: () => AnnotationEditorUIManager,
  AnnotationLayer: () => AnnotationLayer,
  AnnotationMode: () => Bl,
  AnnotationType: () => Kl,
  ColorPicker: () => ColorPicker,
  DOMSVGFactory: () => DOMSVGFactory,
  DrawLayer: () => DrawLayer,
  FeatureTest: () => util_FeatureTest,
  GlobalWorkerOptions: () => GlobalWorkerOptions,
  ImageKind: () => Vl,
  InvalidPDFException: () => InvalidPDFException,
  MathClamp: () => MathClamp,
  OPS: () => ic,
  OutputScale: () => OutputScale,
  PDFDataRangeTransport: () => PDFDataRangeTransport,
  PDFDateString: () => PDFDateString,
  PDFWorker: () => PDFWorker,
  PasswordResponses: () => oc,
  PermissionFlag: () => $l,
  PixelsPerInch: () => PixelsPerInch,
  RenderingCancelledException: () => RenderingCancelledException,
  ResponseException: () => ResponseException,
  SignatureExtractor: () => SignatureExtractor,
  SupportedImageMimeTypes: () => fc,
  TextLayer: () => TextLayer,
  TouchManager: () => TouchManager,
  Util: () => Util,
  VerbosityLevel: () => tc,
  XfaLayer: () => XfaLayer,
  build: () => ih,
  createValidAbsoluteUrl: () => createValidAbsoluteUrl,
  fetchData: () => fetchData,
  getDocument: () => getDocument,
  getFilenameFromUrl: () => getFilenameFromUrl,
  getPdfFilenameFromUrl: () => getPdfFilenameFromUrl,
  getRGB: () => getRGB,
  getUuid: () => getUuid,
  getXfaPageViewport: () => getXfaPageViewport,
  isDataScheme: () => isDataScheme,
  isPdfFile: () => isPdfFile,
  isValidExplicitDest: () => Ac,
  noContextMenu: () => noContextMenu,
  normalizeUnicode: () => normalizeUnicode,
  setLayerDimensions: () => setLayerDimensions,
  shadow: () => shadow,
  stopEvent: () => stopEvent,
  updateUrlHash: () => updateUrlHash,
  version: () => th
});
function info$1(e2) {
  Kt >= se && console.log(`Info: ${e2}`);
}
function warn$1(e2) {
  Kt >= ne && console.log(`Warning: ${e2}`);
}
function unreachable$1(e2) {
  throw new Error(e2);
}
function assert$1(e2, t2) {
  e2 || unreachable$1(t2);
}
function createValidAbsoluteUrl$1(e2, t2 = null, i2 = null) {
  if (!e2)
    return null;
  if (i2 && "string" == typeof e2) {
    if (i2.addDefaultProtocol && e2.startsWith("www.")) {
      const t3 = e2.match(/\./g);
      t3?.length >= 2 && (e2 = `http://${e2}`);
    }
    if (i2.tryConvertEncoding)
      try {
        e2 = stringToUTF8String$1(e2);
      } catch {
      }
  }
  const a2 = t2 ? URL.parse(e2, t2) : URL.parse(e2);
  return function(e3) {
    switch (e3?.protocol) {
      case "http:":
      case "https:":
      case "ftp:":
      case "mailto:":
      case "tel:":
        return true;
      default:
        return false;
    }
  }(a2) ? a2 : null;
}
function shadow$1(e2, t2, i2, a2 = false) {
  return Object.defineProperty(e2, t2, { value: i2, enumerable: !a2, configurable: true, writable: false }), i2;
}
function bytesToString$1(e2) {
  "object" == typeof e2 && void 0 !== e2?.length || unreachable$1("Invalid argument for bytesToString");
  const t2 = e2.length, i2 = 8192;
  if (t2 < i2)
    return String.fromCharCode.apply(null, e2);
  const a2 = [];
  for (let n2 = 0; n2 < t2; n2 += i2) {
    const s2 = Math.min(n2 + i2, t2), r2 = e2.subarray(n2, s2);
    a2.push(String.fromCharCode.apply(null, r2));
  }
  return a2.join("");
}
function stringToBytes$1(e2) {
  "string" != typeof e2 && unreachable$1("Invalid argument for stringToBytes");
  const t2 = e2.length, i2 = new Uint8Array(t2);
  for (let a2 = 0; a2 < t2; ++a2)
    i2[a2] = 255 & e2.charCodeAt(a2);
  return i2;
}
function string32$1(e2) {
  return String.fromCharCode(e2 >> 24 & 255, e2 >> 16 & 255, e2 >> 8 & 255, 255 & e2);
}
function objectSize(e2) {
  return Object.keys(e2).length;
}
function stringToPDFString(e2, t2 = false) {
  if (e2[0] >= "\xEF") {
    let i3;
    if ("\xFE" === e2[0] && "\xFF" === e2[1] ? (i3 = "utf-16be", e2.length % 2 == 1 && (e2 = e2.slice(0, -1))) : "\xFF" === e2[0] && "\xFE" === e2[1] ? (i3 = "utf-16le", e2.length % 2 == 1 && (e2 = e2.slice(0, -1))) : "\xEF" === e2[0] && "\xBB" === e2[1] && "\xBF" === e2[2] && (i3 = "utf-8"), i3)
      try {
        const a2 = new TextDecoder(i3, { fatal: true }), n2 = stringToBytes$1(e2), s2 = a2.decode(n2);
        return t2 || !s2.includes("\x1B") ? s2 : s2.replaceAll(/\x1b[^\x1b]*(?:\x1b|$)/g, "");
      } catch (e3) {
        warn$1(`stringToPDFString: "${e3}".`);
      }
  }
  const i2 = [];
  for (let a2 = 0, n2 = e2.length; a2 < n2; a2++) {
    const s2 = e2.charCodeAt(a2);
    if (!t2 && 27 === s2) {
      for (; ++a2 < n2 && 27 !== e2.charCodeAt(a2); )
        ;
      continue;
    }
    const r2 = si[s2];
    i2.push(r2 ? String.fromCharCode(r2) : e2.charAt(a2));
  }
  return i2.join("");
}
function stringToUTF8String$1(e2) {
  return decodeURIComponent(escape(e2));
}
function utf8StringToString(e2) {
  return unescape(encodeURIComponent(e2));
}
function isArrayEqual(e2, t2) {
  if (e2.length !== t2.length)
    return false;
  for (let i2 = 0, a2 = e2.length; i2 < a2; i2++)
    if (e2[i2] !== t2[i2])
      return false;
  return true;
}
function getModificationDate(e2 = /* @__PURE__ */ new Date()) {
  e2 instanceof Date || (e2 = new Date(e2));
  return [e2.getUTCFullYear().toString(), (e2.getUTCMonth() + 1).toString().padStart(2, "0"), e2.getUTCDate().toString().padStart(2, "0"), e2.getUTCHours().toString().padStart(2, "0"), e2.getUTCMinutes().toString().padStart(2, "0"), e2.getUTCSeconds().toString().padStart(2, "0")].join("");
}
function MathClamp$1(e2, t2, i2) {
  return Math.min(Math.max(e2, t2), i2);
}
function toHexUtil(e2) {
  return Uint8Array.prototype.toHex ? e2.toHex() : Array.from(e2, (e3) => ai[e3]).join("");
}
function isName(e2, t2) {
  return e2 instanceof Name && (void 0 === t2 || e2.name === t2);
}
function isCmd(e2, t2) {
  return e2 instanceof Cmd && (void 0 === t2 || e2.cmd === t2);
}
function isDict(e2, t2) {
  return e2 instanceof Dict && (void 0 === t2 || isName(e2.get("Type"), t2));
}
function isRefsEqual(e2, t2) {
  return e2.num === t2.num && e2.gen === t2.gen;
}
function getLookupTableFactory(e2) {
  let t2;
  return function() {
    return e2 && (t2 = /* @__PURE__ */ Object.create(null), e2(t2), e2 = null), t2;
  };
}
function arrayBuffersToBytes(e2) {
  const t2 = e2.length;
  if (0 === t2)
    return new Uint8Array(0);
  if (1 === t2)
    return new Uint8Array(e2[0]);
  let i2 = 0;
  for (let a3 = 0; a3 < t2; a3++)
    i2 += e2[a3].byteLength;
  const a2 = new Uint8Array(i2);
  let n2 = 0;
  for (let i3 = 0; i3 < t2; i3++) {
    const t3 = new Uint8Array(e2[i3]);
    a2.set(t3, n2), n2 += t3.byteLength;
  }
  return a2;
}
async function fetchBinaryData(e2) {
  const t2 = await fetch(e2);
  if (!t2.ok)
    throw new Error(`Failed to fetch file "${e2}" with "${t2.statusText}".`);
  return new Uint8Array(await t2.arrayBuffer());
}
function getInheritableProperty({ dict: e2, key: t2, getArray: i2 = false, stopWhenFound: a2 = true }) {
  let n2;
  const s2 = new RefSet();
  for (; e2 instanceof Dict && (!e2.objId || !s2.has(e2.objId)); ) {
    e2.objId && s2.put(e2.objId);
    const r2 = i2 ? e2.getArray(t2) : e2.get(t2);
    if (void 0 !== r2) {
      if (a2)
        return r2;
      (n2 ||= []).push(r2);
    }
    e2 = e2.get("Parent");
  }
  return n2;
}
function toRomanNumerals(e2, t2 = false) {
  assert$1(Number.isInteger(e2) && e2 > 0, "The number should be a positive integer.");
  const i2 = "M".repeat(e2 / 1e3 | 0) + yi[e2 % 1e3 / 100 | 0] + yi[10 + (e2 % 100 / 10 | 0)] + yi[20 + e2 % 10];
  return t2 ? i2.toLowerCase() : i2;
}
function log22(e2) {
  return e2 > 0 ? Math.ceil(Math.log2(e2)) : 0;
}
function readInt8(e2, t2) {
  return e2[t2] << 24 >> 24;
}
function readInt16(e2, t2) {
  return (e2[t2] << 24 | e2[t2 + 1] << 16) >> 16;
}
function readUint16(e2, t2) {
  return e2[t2] << 8 | e2[t2 + 1];
}
function readUint32(e2, t2) {
  return (e2[t2] << 24 | e2[t2 + 1] << 16 | e2[t2 + 2] << 8 | e2[t2 + 3]) >>> 0;
}
function isWhiteSpace(e2) {
  return 32 === e2 || 9 === e2 || 13 === e2 || 10 === e2;
}
function isNumberArray(e2, t2) {
  return Array.isArray(e2) ? (null === t2 || e2.length === t2) && e2.every((e3) => "number" == typeof e3) : ArrayBuffer.isView(e2) && !(e2 instanceof BigInt64Array || e2 instanceof BigUint64Array) && (null === t2 || e2.length === t2);
}
function lookupMatrix(e2, t2) {
  return isNumberArray(e2, 6) ? e2 : t2;
}
function lookupRect(e2, t2) {
  return isNumberArray(e2, 4) ? e2 : t2;
}
function lookupNormalRect(e2, t2) {
  return isNumberArray(e2, 4) ? ni.normalizeRect(e2) : t2;
}
function parseXFAPath(e2) {
  const t2 = /(.+)\[(\d+)\]$/;
  return e2.split(".").map((e3) => {
    const i2 = e3.match(t2);
    return i2 ? { name: i2[1], pos: parseInt(i2[2], 10) } : { name: e3, pos: 0 };
  });
}
function escapePDFName(e2) {
  const t2 = [];
  let i2 = 0;
  for (let a2 = 0, n2 = e2.length; a2 < n2; a2++) {
    const n3 = e2.charCodeAt(a2);
    (n3 < 33 || n3 > 126 || 35 === n3 || 40 === n3 || 41 === n3 || 60 === n3 || 62 === n3 || 91 === n3 || 93 === n3 || 123 === n3 || 125 === n3 || 47 === n3 || 37 === n3) && (i2 < a2 && t2.push(e2.substring(i2, a2)), t2.push(`#${n3.toString(16)}`), i2 = a2 + 1);
  }
  return 0 === t2.length ? e2 : (i2 < e2.length && t2.push(e2.substring(i2, e2.length)), t2.join(""));
}
function escapeString(e2) {
  return e2.replaceAll(/([()\\\n\r])/g, (e3) => "\n" === e3 ? "\\n" : "\r" === e3 ? "\\r" : `\\${e3}`);
}
function _collectJS(e2, t2, i2, a2) {
  if (!e2)
    return;
  let n2 = null;
  if (e2 instanceof Ref) {
    if (a2.has(e2))
      return;
    n2 = e2, a2.put(n2), e2 = t2.fetch(e2);
  }
  if (Array.isArray(e2))
    for (const n3 of e2)
      _collectJS(n3, t2, i2, a2);
  else if (e2 instanceof Dict) {
    if (isName(e2.get("S"), "JavaScript")) {
      const t3 = e2.get("JS");
      let a3;
      t3 instanceof BaseStream ? a3 = t3.getString() : "string" == typeof t3 && (a3 = t3), a3 &&= stringToPDFString(a3, true).replaceAll("\0", ""), a3 && i2.push(a3.trim());
    }
    _collectJS(e2.getRaw("Next"), t2, i2, a2);
  }
  n2 && a2.remove(n2);
}
function collectActions(e2, t2, i2) {
  const a2 = /* @__PURE__ */ Object.create(null), n2 = getInheritableProperty({ dict: t2, key: "AA", stopWhenFound: false });
  if (n2)
    for (let t3 = n2.length - 1; t3 >= 0; t3--) {
      const s2 = n2[t3];
      if (s2 instanceof Dict)
        for (const t4 of s2.getKeys()) {
          const n3 = i2[t4];
          if (!n3)
            continue;
          const r2 = [];
          _collectJS(s2.getRaw(t4), e2, r2, new RefSet()), r2.length > 0 && (a2[n3] = r2);
        }
    }
  if (t2.has("A")) {
    const i3 = [];
    _collectJS(t2.get("A"), e2, i3, new RefSet()), i3.length > 0 && (a2.Action = i3);
  }
  return objectSize(a2) > 0 ? a2 : null;
}
function* codePointIter(e2) {
  for (let t2 = 0, i2 = e2.length; t2 < i2; t2++) {
    const i3 = e2.codePointAt(t2);
    i3 > 55295 && (i3 < 57344 || i3 > 65533) && t2++, yield i3;
  }
}
function encodeToXmlString(e2) {
  const t2 = [];
  let i2 = 0;
  for (let a2 = 0, n2 = e2.length; a2 < n2; a2++) {
    const n3 = e2.codePointAt(a2);
    if (32 <= n3 && n3 <= 126) {
      const s2 = wi[n3];
      s2 && (i2 < a2 && t2.push(e2.substring(i2, a2)), t2.push(s2), i2 = a2 + 1);
    } else
      i2 < a2 && t2.push(e2.substring(i2, a2)), t2.push(`&#x${n3.toString(16).toUpperCase()};`), n3 > 55295 && (n3 < 57344 || n3 > 65533) && a2++, i2 = a2 + 1;
  }
  return 0 === t2.length ? e2 : (i2 < e2.length && t2.push(e2.substring(i2, e2.length)), t2.join(""));
}
function validateFontName(e2, t2 = false) {
  const i2 = /^("|').*("|')$/.exec(e2);
  if (i2 && i2[1] === i2[2]) {
    if (new RegExp(`[^\\\\]${i2[1]}`).test(e2.slice(1, -1)))
      return t2 && warn$1(`FontFamily contains unescaped ${i2[1]}: ${e2}.`), false;
  } else
    for (const i3 of e2.split(/[ \t]+/))
      if (/^(\d|(-(\d|-)))/.test(i3) || !/^[\w-\\]+$/.test(i3))
        return t2 && warn$1(`FontFamily contains invalid <custom-ident>: ${e2}.`), false;
  return true;
}
function validateCSSFont(e2) {
  const t2 = /* @__PURE__ */ new Set(["100", "200", "300", "400", "500", "600", "700", "800", "900", "1000", "normal", "bold", "bolder", "lighter"]), { fontFamily: i2, fontWeight: a2, italicAngle: n2 } = e2;
  if (!validateFontName(i2, true))
    return false;
  const s2 = a2 ? a2.toString() : "";
  e2.fontWeight = t2.has(s2) ? s2 : "400";
  const r2 = parseFloat(n2);
  return e2.italicAngle = isNaN(r2) || r2 < -90 || r2 > 90 ? "14" : n2.toString(), true;
}
function recoverJsURL(e2) {
  const t2 = new RegExp("^\\s*(" + ["app.launchURL", "window.open", "xfa.host.gotoURL"].join("|").replaceAll(".", "\\.") + `)\\((?:'|")([^'"]*)(?:'|")(?:,\\s*(\\w+)\\)|\\))`, "i").exec(e2);
  return t2?.[2] ? { url: t2[2], newWindow: "app.launchURL" === t2[1] && "true" === t2[3] } : null;
}
function numberToString(e2) {
  if (Number.isInteger(e2))
    return e2.toString();
  const t2 = Math.round(100 * e2);
  return t2 % 100 == 0 ? (t2 / 100).toString() : t2 % 10 == 0 ? e2.toFixed(1) : e2.toFixed(2);
}
function getNewAnnotationsMap(e2) {
  if (!e2)
    return null;
  const t2 = /* @__PURE__ */ new Map();
  for (const [i2, a2] of e2) {
    if (!i2.startsWith(g))
      continue;
    let e3 = t2.get(a2.pageIndex);
    e3 || (e3 = [], t2.set(a2.pageIndex, e3)), e3.push(a2);
  }
  return t2.size > 0 ? t2 : null;
}
function stringToAsciiOrUTF16BE(e2) {
  return null == e2 || function(e3) {
    if ("string" != typeof e3)
      return false;
    return !e3 || /^[\x00-\x7F]*$/.test(e3);
  }(e2) ? e2 : stringToUTF16String(e2, true);
}
function stringToUTF16HexString(e2) {
  const t2 = [];
  for (let i2 = 0, a2 = e2.length; i2 < a2; i2++) {
    const a3 = e2.charCodeAt(i2);
    t2.push(ai[a3 >> 8 & 255], ai[255 & a3]);
  }
  return t2.join("");
}
function stringToUTF16String(e2, t2 = false) {
  const i2 = [];
  t2 && i2.push("\xFE\xFF");
  for (let t3 = 0, a2 = e2.length; t3 < a2; t3++) {
    const a3 = e2.charCodeAt(t3);
    i2.push(String.fromCharCode(a3 >> 8 & 255), String.fromCharCode(255 & a3));
  }
  return i2.join("");
}
function getRotationMatrix(e2, t2, i2) {
  switch (e2) {
    case 90:
      return [0, 1, -1, 0, t2, 0];
    case 180:
      return [-1, 0, 0, -1, t2, i2];
    case 270:
      return [0, -1, 1, 0, 0, i2];
    default:
      throw new Error("Invalid rotation");
  }
}
function getSizeInBytes(e2) {
  return Math.ceil(Math.ceil(Math.log2(1 + e2)) / 8);
}
function getUint8ArrayMemory0() {
  return null !== Si && 0 !== Si.byteLength || (Si = new Uint8Array(Ai.memory.buffer)), Si;
}
function passArray8ToWasm0(e2, t2) {
  const i2 = t2(1 * e2.length, 1) >>> 0;
  return getUint8ArrayMemory0().set(e2, i2 / 1), vi = e2.length, i2;
}
function __wbg_get_imports() {
  const e2 = { wbg: {} };
  return e2.wbg.__wbg_copyresult_b08ee7d273f295dd = function(e3, t2) {
    !function(e4, t3) {
      const { _mustAddAlpha: i2, _destBuffer: a2, _destOffset: n2, _destLength: s2, _memoryArray: r2 } = QCMS;
      if (t3 !== s2)
        if (i2)
          for (let i3 = e4, s3 = e4 + t3, o2 = n2; i3 < s3; i3 += 3, o2 += 4)
            a2[o2] = r2[i3], a2[o2 + 1] = r2[i3 + 1], a2[o2 + 2] = r2[i3 + 2], a2[o2 + 3] = 255;
        else
          for (let i3 = e4, s3 = e4 + t3, o2 = n2; i3 < s3; i3 += 3, o2 += 4)
            a2[o2] = r2[i3], a2[o2 + 1] = r2[i3 + 1], a2[o2 + 2] = r2[i3 + 2];
      else
        a2.set(r2.subarray(e4, e4 + t3), n2);
    }(e3 >>> 0, t2 >>> 0);
  }, e2.wbg.__wbg_copyrgb_d60ce17bb05d9b67 = function(e3) {
    !function(e4) {
      const { _destBuffer: t2, _destOffset: i2, _memoryArray: a2 } = QCMS;
      t2[i2] = a2[e4], t2[i2 + 1] = a2[e4 + 1], t2[i2 + 2] = a2[e4 + 2];
    }(e3 >>> 0);
  }, e2.wbg.__wbg_makecssRGB_893bf0cd9fdb302d = function(e3) {
    !function(e4) {
      const { _memoryArray: t2 } = QCMS;
      QCMS._cssColor = QCMS._makeHexColor(t2[e4], t2[e4 + 1], t2[e4 + 2]);
    }(e3 >>> 0);
  }, e2.wbg.__wbindgen_init_externref_table = function() {
    const e3 = Ai.__wbindgen_export_0, t2 = e3.grow(4);
    e3.set(0, void 0), e3.set(t2 + 0, void 0), e3.set(t2 + 1, null), e3.set(t2 + 2, true), e3.set(t2 + 3, false);
  }, e2.wbg.__wbindgen_throw = function(e3, t2) {
    throw new Error((i2 = e3, a2 = t2, i2 >>>= 0, xi.decode(getUint8ArrayMemory0().subarray(i2, i2 + a2))));
    var i2, a2;
  }, e2;
}
function initSync(e2) {
  if (void 0 !== Ai)
    return Ai;
  void 0 !== e2 && (Object.getPrototypeOf(e2) === Object.prototype ? { module: e2 } = e2 : console.warn("using deprecated parameters for `initSync()`; pass a single object instead"));
  const t2 = __wbg_get_imports();
  e2 instanceof WebAssembly.Module || (e2 = new WebAssembly.Module(e2));
  return function(e3) {
    return Ai = e3.exports, Si = null, Ai.__wbindgen_start(), Ai;
  }(new WebAssembly.Instance(e2, t2));
}
function fetchSync(e2) {
  const t2 = new XMLHttpRequest();
  return t2.open("GET", e2, false), t2.responseType = "arraybuffer", t2.send(null), t2.response;
}
function convertToRGBA(e2) {
  switch (e2.kind) {
    case v:
      return convertBlackAndWhiteToRGBA$1(e2);
    case C:
      return function({ src: e3, srcPos: t2 = 0, dest: i2, destPos: a2 = 0, width: n2, height: s2 }) {
        let r2 = 0;
        const o2 = n2 * s2 * 3, l3 = o2 >> 2, c2 = new Uint32Array(e3.buffer, t2, l3);
        if (FeatureTest.isLittleEndian) {
          for (; r2 < l3 - 2; r2 += 3, a2 += 4) {
            const e4 = c2[r2], t3 = c2[r2 + 1], n3 = c2[r2 + 2];
            i2[a2] = 4278190080 | e4, i2[a2 + 1] = e4 >>> 24 | t3 << 8 | 4278190080, i2[a2 + 2] = t3 >>> 16 | n3 << 16 | 4278190080, i2[a2 + 3] = n3 >>> 8 | 4278190080;
          }
          for (let n3 = 4 * r2, s3 = t2 + o2; n3 < s3; n3 += 3)
            i2[a2++] = e3[n3] | e3[n3 + 1] << 8 | e3[n3 + 2] << 16 | 4278190080;
        } else {
          for (; r2 < l3 - 2; r2 += 3, a2 += 4) {
            const e4 = c2[r2], t3 = c2[r2 + 1], n3 = c2[r2 + 2];
            i2[a2] = 255 | e4, i2[a2 + 1] = e4 << 24 | t3 >>> 8 | 255, i2[a2 + 2] = t3 << 16 | n3 >>> 16 | 255, i2[a2 + 3] = n3 << 8 | 255;
          }
          for (let n3 = 4 * r2, s3 = t2 + o2; n3 < s3; n3 += 3)
            i2[a2++] = e3[n3] << 24 | e3[n3 + 1] << 16 | e3[n3 + 2] << 8 | 255;
        }
        return { srcPos: t2 + o2, destPos: a2 };
      }(e2);
  }
  return null;
}
function convertBlackAndWhiteToRGBA$1({ src: e2, srcPos: t2 = 0, dest: i2, width: a2, height: n2, nonBlackColor: s2 = 4294967295, inverseDecode: r2 = false }) {
  const o2 = FeatureTest.isLittleEndian ? 4278190080 : 255, [l3, c2] = r2 ? [s2, o2] : [o2, s2], h2 = a2 >> 3, d2 = 7 & a2, u2 = e2.length;
  i2 = new Uint32Array(i2.buffer);
  let g2 = 0;
  for (let a3 = 0; a3 < n2; a3++) {
    for (const a5 = t2 + h2; t2 < a5; t2++) {
      const a6 = t2 < u2 ? e2[t2] : 255;
      i2[g2++] = 128 & a6 ? c2 : l3, i2[g2++] = 64 & a6 ? c2 : l3, i2[g2++] = 32 & a6 ? c2 : l3, i2[g2++] = 16 & a6 ? c2 : l3, i2[g2++] = 8 & a6 ? c2 : l3, i2[g2++] = 4 & a6 ? c2 : l3, i2[g2++] = 2 & a6 ? c2 : l3, i2[g2++] = 1 & a6 ? c2 : l3;
    }
    if (0 === d2)
      continue;
    const a4 = t2 < u2 ? e2[t2++] : 255;
    for (let e3 = 0; e3 < d2; e3++)
      i2[g2++] = a4 & 1 << 7 - e3 ? c2 : l3;
  }
  return { srcPos: t2, destPos: g2 };
}
function buildHuffmanTable(e2, t2) {
  let i2, a2, n2 = 0, s2 = 16;
  for (; s2 > 0 && !e2[s2 - 1]; )
    s2--;
  const r2 = [{ children: [], index: 0 }];
  let o2, l3 = r2[0];
  for (i2 = 0; i2 < s2; i2++) {
    for (a2 = 0; a2 < e2[i2]; a2++) {
      for (l3 = r2.pop(), l3.children[l3.index] = t2[n2]; l3.index > 0; )
        l3 = r2.pop();
      for (l3.index++, r2.push(l3); r2.length <= i2; )
        r2.push(o2 = { children: [], index: 0 }), l3.children[l3.index] = o2.children, l3 = o2;
      n2++;
    }
    i2 + 1 < s2 && (r2.push(o2 = { children: [], index: 0 }), l3.children[l3.index] = o2.children, l3 = o2);
  }
  return r2[0].children;
}
function getBlockBufferOffset(e2, t2, i2) {
  return 64 * ((e2.blocksPerLine + 1) * t2 + i2);
}
function decodeScan(e2, t2, i2, a2, n2, s2, r2, o2, l3, c2 = false) {
  const h2 = i2.mcusPerLine, d2 = i2.progressive, u2 = t2;
  let g2 = 0, p2 = 0;
  function readBit() {
    if (p2 > 0)
      return p2--, g2 >> p2 & 1;
    if (g2 = e2[t2++], 255 === g2) {
      const a3 = e2[t2++];
      if (a3) {
        if (220 === a3 && c2) {
          const a4 = readUint16(e2, t2 += 2);
          if (t2 += 2, a4 > 0 && a4 !== i2.scanLines)
            throw new DNLMarkerError("Found DNL marker (0xFFDC) while parsing scan data", a4);
        } else if (217 === a3) {
          if (c2) {
            const e3 = y2 * (8 === i2.precision ? 8 : 0);
            if (e3 > 0 && Math.round(i2.scanLines / e3) >= 5)
              throw new DNLMarkerError("Found EOI marker (0xFFD9) while parsing scan data, possibly caused by incorrect `scanLines` parameter", e3);
          }
          throw new EOIMarkerError("Found EOI marker (0xFFD9) while parsing scan data");
        }
        throw new JpegError(`unexpected marker ${(g2 << 8 | a3).toString(16)}`);
      }
    }
    return p2 = 7, g2 >>> 7;
  }
  __name(readBit, "readBit");
  function decodeHuffman(e3) {
    let t3 = e3;
    for (; ; ) {
      switch (t3 = t3[readBit()], typeof t3) {
        case "number":
          return t3;
        case "object":
          continue;
      }
      throw new JpegError("invalid huffman sequence");
    }
  }
  __name(decodeHuffman, "decodeHuffman");
  function receive(e3) {
    let t3 = 0;
    for (; e3 > 0; )
      t3 = t3 << 1 | readBit(), e3--;
    return t3;
  }
  __name(receive, "receive");
  function receiveAndExtend(e3) {
    if (1 === e3)
      return 1 === readBit() ? 1 : -1;
    const t3 = receive(e3);
    return t3 >= 1 << e3 - 1 ? t3 : t3 + (-1 << e3) + 1;
  }
  __name(receiveAndExtend, "receiveAndExtend");
  let f2 = 0;
  let m2, b2 = 0;
  let y2 = 0;
  function decodeMcu(e3, t3, i3, a3, n3) {
    const s3 = i3 % h2;
    y2 = (i3 / h2 | 0) * e3.v + a3;
    const r3 = s3 * e3.h + n3;
    t3(e3, getBlockBufferOffset(e3, y2, r3));
  }
  __name(decodeMcu, "decodeMcu");
  function decodeBlock(e3, t3, i3) {
    y2 = i3 / e3.blocksPerLine | 0;
    const a3 = i3 % e3.blocksPerLine;
    t3(e3, getBlockBufferOffset(e3, y2, a3));
  }
  __name(decodeBlock, "decodeBlock");
  const w2 = a2.length;
  let x2, S2, v2, C2, k2, T2;
  T2 = d2 ? 0 === s2 ? 0 === o2 ? function(e3, t3) {
    const i3 = decodeHuffman(e3.huffmanTableDC), a3 = 0 === i3 ? 0 : receiveAndExtend(i3) << l3;
    e3.blockData[t3] = e3.pred += a3;
  } : function(e3, t3) {
    e3.blockData[t3] |= readBit() << l3;
  } : 0 === o2 ? function(e3, t3) {
    if (f2 > 0)
      return void f2--;
    let i3 = s2;
    const a3 = r2;
    for (; i3 <= a3; ) {
      const a4 = decodeHuffman(e3.huffmanTableAC), n3 = 15 & a4, s3 = a4 >> 4;
      if (0 === n3) {
        if (s3 < 15) {
          f2 = receive(s3) + (1 << s3) - 1;
          break;
        }
        i3 += 16;
        continue;
      }
      i3 += s3;
      const r3 = Ii[i3];
      e3.blockData[t3 + r3] = receiveAndExtend(n3) * (1 << l3), i3++;
    }
  } : function(e3, t3) {
    let i3 = s2;
    const a3 = r2;
    let n3, o3, c3 = 0;
    for (; i3 <= a3; ) {
      const a4 = t3 + Ii[i3], s3 = e3.blockData[a4] < 0 ? -1 : 1;
      switch (b2) {
        case 0:
          if (o3 = decodeHuffman(e3.huffmanTableAC), n3 = 15 & o3, c3 = o3 >> 4, 0 === n3)
            c3 < 15 ? (f2 = receive(c3) + (1 << c3), b2 = 4) : (c3 = 16, b2 = 1);
          else {
            if (1 !== n3)
              throw new JpegError("invalid ACn encoding");
            m2 = receiveAndExtend(n3), b2 = c3 ? 2 : 3;
          }
          continue;
        case 1:
        case 2:
          e3.blockData[a4] ? e3.blockData[a4] += s3 * (readBit() << l3) : (c3--, 0 === c3 && (b2 = 2 === b2 ? 3 : 0));
          break;
        case 3:
          e3.blockData[a4] ? e3.blockData[a4] += s3 * (readBit() << l3) : (e3.blockData[a4] = m2 << l3, b2 = 0);
          break;
        case 4:
          e3.blockData[a4] && (e3.blockData[a4] += s3 * (readBit() << l3));
      }
      i3++;
    }
    4 === b2 && (f2--, 0 === f2 && (b2 = 0));
  } : function(e3, t3) {
    const i3 = decodeHuffman(e3.huffmanTableDC), a3 = 0 === i3 ? 0 : receiveAndExtend(i3);
    e3.blockData[t3] = e3.pred += a3;
    let n3 = 1;
    for (; n3 < 64; ) {
      const i4 = decodeHuffman(e3.huffmanTableAC), a4 = 15 & i4, s3 = i4 >> 4;
      if (0 === a4) {
        if (s3 < 15)
          break;
        n3 += 16;
        continue;
      }
      n3 += s3;
      const r3 = Ii[n3];
      e3.blockData[t3 + r3] = receiveAndExtend(a4), n3++;
    }
  };
  let F2, M2 = 0;
  const D2 = 1 === w2 ? a2[0].blocksPerLine * a2[0].blocksPerColumn : h2 * i2.mcusPerColumn;
  let E2, O2;
  for (; M2 <= D2; ) {
    const i3 = n2 ? Math.min(D2 - M2, n2) : D2;
    if (i3 > 0) {
      for (S2 = 0; S2 < w2; S2++)
        a2[S2].pred = 0;
      if (f2 = 0, 1 === w2)
        for (x2 = a2[0], k2 = 0; k2 < i3; k2++)
          decodeBlock(x2, T2, M2), M2++;
      else
        for (k2 = 0; k2 < i3; k2++) {
          for (S2 = 0; S2 < w2; S2++)
            for (x2 = a2[S2], E2 = x2.h, O2 = x2.v, v2 = 0; v2 < O2; v2++)
              for (C2 = 0; C2 < E2; C2++)
                decodeMcu(x2, T2, M2, v2, C2);
          M2++;
        }
    }
    if (p2 = 0, F2 = findNextFileMarker(e2, t2), !F2)
      break;
    if (F2.invalid) {
      warn$1(`decodeScan - ${i3 > 0 ? "unexpected" : "excessive"} MCU data, current marker is: ${F2.invalid}`), t2 = F2.offset;
    }
    if (!(F2.marker >= 65488 && F2.marker <= 65495))
      break;
    t2 += 2;
  }
  return t2 - u2;
}
function quantizeAndInverse(e2, t2, i2) {
  const a2 = e2.quantizationTable, n2 = e2.blockData;
  let s2, r2, o2, l3, c2, h2, d2, u2, g2, p2, f2, m2, b2, y2, w2, x2, S2;
  if (!a2)
    throw new JpegError("missing required Quantization Table.");
  for (let e3 = 0; e3 < 64; e3 += 8)
    g2 = n2[t2 + e3], p2 = n2[t2 + e3 + 1], f2 = n2[t2 + e3 + 2], m2 = n2[t2 + e3 + 3], b2 = n2[t2 + e3 + 4], y2 = n2[t2 + e3 + 5], w2 = n2[t2 + e3 + 6], x2 = n2[t2 + e3 + 7], g2 *= a2[e3], 0 !== (p2 | f2 | m2 | b2 | y2 | w2 | x2) ? (p2 *= a2[e3 + 1], f2 *= a2[e3 + 2], m2 *= a2[e3 + 3], b2 *= a2[e3 + 4], y2 *= a2[e3 + 5], w2 *= a2[e3 + 6], x2 *= a2[e3 + 7], s2 = Pi * g2 + 128 >> 8, r2 = Pi * b2 + 128 >> 8, o2 = f2, l3 = w2, c2 = Ri * (p2 - x2) + 128 >> 8, u2 = Ri * (p2 + x2) + 128 >> 8, h2 = m2 << 4, d2 = y2 << 4, s2 = s2 + r2 + 1 >> 1, r2 = s2 - r2, S2 = o2 * _i2 + l3 * Oi + 128 >> 8, o2 = o2 * Oi - l3 * _i2 + 128 >> 8, l3 = S2, c2 = c2 + d2 + 1 >> 1, d2 = c2 - d2, u2 = u2 + h2 + 1 >> 1, h2 = u2 - h2, s2 = s2 + l3 + 1 >> 1, l3 = s2 - l3, r2 = r2 + o2 + 1 >> 1, o2 = r2 - o2, S2 = c2 * Ei + u2 * Di + 2048 >> 12, c2 = c2 * Di - u2 * Ei + 2048 >> 12, u2 = S2, S2 = h2 * Mi + d2 * Fi + 2048 >> 12, h2 = h2 * Fi - d2 * Mi + 2048 >> 12, d2 = S2, i2[e3] = s2 + u2, i2[e3 + 7] = s2 - u2, i2[e3 + 1] = r2 + d2, i2[e3 + 6] = r2 - d2, i2[e3 + 2] = o2 + h2, i2[e3 + 5] = o2 - h2, i2[e3 + 3] = l3 + c2, i2[e3 + 4] = l3 - c2) : (S2 = Pi * g2 + 512 >> 10, i2[e3] = S2, i2[e3 + 1] = S2, i2[e3 + 2] = S2, i2[e3 + 3] = S2, i2[e3 + 4] = S2, i2[e3 + 5] = S2, i2[e3 + 6] = S2, i2[e3 + 7] = S2);
  for (let e3 = 0; e3 < 8; ++e3)
    g2 = i2[e3], p2 = i2[e3 + 8], f2 = i2[e3 + 16], m2 = i2[e3 + 24], b2 = i2[e3 + 32], y2 = i2[e3 + 40], w2 = i2[e3 + 48], x2 = i2[e3 + 56], 0 !== (p2 | f2 | m2 | b2 | y2 | w2 | x2) ? (s2 = Pi * g2 + 2048 >> 12, r2 = Pi * b2 + 2048 >> 12, o2 = f2, l3 = w2, c2 = Ri * (p2 - x2) + 2048 >> 12, u2 = Ri * (p2 + x2) + 2048 >> 12, h2 = m2, d2 = y2, s2 = 4112 + (s2 + r2 + 1 >> 1), r2 = s2 - r2, S2 = o2 * _i2 + l3 * Oi + 2048 >> 12, o2 = o2 * Oi - l3 * _i2 + 2048 >> 12, l3 = S2, c2 = c2 + d2 + 1 >> 1, d2 = c2 - d2, u2 = u2 + h2 + 1 >> 1, h2 = u2 - h2, s2 = s2 + l3 + 1 >> 1, l3 = s2 - l3, r2 = r2 + o2 + 1 >> 1, o2 = r2 - o2, S2 = c2 * Ei + u2 * Di + 2048 >> 12, c2 = c2 * Di - u2 * Ei + 2048 >> 12, u2 = S2, S2 = h2 * Mi + d2 * Fi + 2048 >> 12, h2 = h2 * Fi - d2 * Mi + 2048 >> 12, d2 = S2, g2 = s2 + u2, x2 = s2 - u2, p2 = r2 + d2, w2 = r2 - d2, f2 = o2 + h2, y2 = o2 - h2, m2 = l3 + c2, b2 = l3 - c2, g2 < 16 ? g2 = 0 : g2 >= 4080 ? g2 = 255 : g2 >>= 4, p2 < 16 ? p2 = 0 : p2 >= 4080 ? p2 = 255 : p2 >>= 4, f2 < 16 ? f2 = 0 : f2 >= 4080 ? f2 = 255 : f2 >>= 4, m2 < 16 ? m2 = 0 : m2 >= 4080 ? m2 = 255 : m2 >>= 4, b2 < 16 ? b2 = 0 : b2 >= 4080 ? b2 = 255 : b2 >>= 4, y2 < 16 ? y2 = 0 : y2 >= 4080 ? y2 = 255 : y2 >>= 4, w2 < 16 ? w2 = 0 : w2 >= 4080 ? w2 = 255 : w2 >>= 4, x2 < 16 ? x2 = 0 : x2 >= 4080 ? x2 = 255 : x2 >>= 4, n2[t2 + e3] = g2, n2[t2 + e3 + 8] = p2, n2[t2 + e3 + 16] = f2, n2[t2 + e3 + 24] = m2, n2[t2 + e3 + 32] = b2, n2[t2 + e3 + 40] = y2, n2[t2 + e3 + 48] = w2, n2[t2 + e3 + 56] = x2) : (S2 = Pi * g2 + 8192 >> 14, S2 = S2 < -2040 ? 0 : S2 >= 2024 ? 255 : S2 + 2056 >> 4, n2[t2 + e3] = S2, n2[t2 + e3 + 8] = S2, n2[t2 + e3 + 16] = S2, n2[t2 + e3 + 24] = S2, n2[t2 + e3 + 32] = S2, n2[t2 + e3 + 40] = S2, n2[t2 + e3 + 48] = S2, n2[t2 + e3 + 56] = S2);
}
function buildComponentData(e2, t2) {
  const i2 = t2.blocksPerLine, a2 = t2.blocksPerColumn, n2 = new Int16Array(64);
  for (let e3 = 0; e3 < a2; e3++)
    for (let a3 = 0; a3 < i2; a3++) {
      quantizeAndInverse(t2, getBlockBufferOffset(t2, e3, a3), n2);
    }
  return t2.blockData;
}
function findNextFileMarker(e2, t2, i2 = t2) {
  const a2 = e2.length - 1;
  let n2 = i2 < t2 ? i2 : t2;
  if (t2 >= a2)
    return null;
  const s2 = readUint16(e2, t2);
  if (s2 >= 65472 && s2 <= 65534)
    return { invalid: null, marker: s2, offset: t2 };
  let r2 = readUint16(e2, n2);
  for (; !(r2 >= 65472 && r2 <= 65534); ) {
    if (++n2 >= a2)
      return null;
    r2 = readUint16(e2, n2);
  }
  return { invalid: s2.toString(16), marker: r2, offset: n2 };
}
function prepareComponents(e2) {
  const t2 = Math.ceil(e2.samplesPerLine / 8 / e2.maxH), i2 = Math.ceil(e2.scanLines / 8 / e2.maxV);
  for (const a2 of e2.components) {
    const n2 = Math.ceil(Math.ceil(e2.samplesPerLine / 8) * a2.h / e2.maxH), s2 = Math.ceil(Math.ceil(e2.scanLines / 8) * a2.v / e2.maxV), r2 = t2 * a2.h, o2 = 64 * (i2 * a2.v) * (r2 + 1);
    a2.blockData = new Int16Array(o2), a2.blocksPerLine = n2, a2.blocksPerColumn = s2;
  }
  e2.mcusPerLine = t2, e2.mcusPerColumn = i2;
}
function readDataBlock(e2, t2) {
  const i2 = readUint16(e2, t2);
  let a2 = (t2 += 2) + i2 - 2;
  const n2 = findNextFileMarker(e2, a2, t2);
  n2?.invalid && (warn$1("readDataBlock - incorrect length, current marker is: " + n2.invalid), a2 = n2.offset);
  const s2 = e2.subarray(t2, a2);
  return { appData: s2, oldOffset: t2, newOffset: t2 + s2.length };
}
function skipData(e2, t2) {
  const i2 = readUint16(e2, t2), a2 = (t2 += 2) + i2 - 2, n2 = findNextFileMarker(e2, a2, t2);
  return n2?.invalid ? n2.offset : a2;
}
function addState(e2, t2, i2, a2, n2) {
  let s2 = e2;
  for (let e3 = 0, i3 = t2.length - 1; e3 < i3; e3++) {
    const i4 = t2[e3];
    s2 = s2[i4] ||= [];
  }
  s2[t2.at(-1)] = { checkFn: i2, iterateFn: a2, processFn: n2 };
}
function hexToInt(e2, t2) {
  let i2 = 0;
  for (let a2 = 0; a2 <= t2; a2++)
    i2 = i2 << 8 | e2[a2];
  return i2 >>> 0;
}
function hexToStr(e2, t2) {
  return 1 === t2 ? String.fromCharCode(e2[0], e2[1]) : 3 === t2 ? String.fromCharCode(e2[0], e2[1], e2[2], e2[3]) : String.fromCharCode(...e2.subarray(0, t2 + 1));
}
function addHex(e2, t2, i2) {
  let a2 = 0;
  for (let n2 = i2; n2 >= 0; n2--)
    a2 += e2[n2] + t2[n2], e2[n2] = 255 & a2, a2 >>= 8;
}
function incHex(e2, t2) {
  let i2 = 1;
  for (let a2 = t2; a2 >= 0 && i2 > 0; a2--)
    i2 += e2[a2], e2[a2] = 255 & i2, i2 >>= 8;
}
function decodeInteger(e2, t2, i2) {
  const a2 = e2.getContexts(t2);
  let n2 = 1;
  function readBits(e3) {
    let t3 = 0;
    for (let s3 = 0; s3 < e3; s3++) {
      const e4 = i2.readBit(a2, n2);
      n2 = n2 < 256 ? n2 << 1 | e4 : 511 & (n2 << 1 | e4) | 256, t3 = t3 << 1 | e4;
    }
    return t3 >>> 0;
  }
  __name(readBits, "readBits");
  const s2 = readBits(1), r2 = readBits(1) ? readBits(1) ? readBits(1) ? readBits(1) ? readBits(1) ? readBits(32) + 4436 : readBits(12) + 340 : readBits(8) + 84 : readBits(6) + 20 : readBits(4) + 4 : readBits(2);
  let o2;
  return 0 === s2 ? o2 = r2 : r2 > 0 && (o2 = -r2), o2 >= -2147483648 && o2 <= pi ? o2 : null;
}
function decodeIAID(e2, t2, i2) {
  const a2 = e2.getContexts("IAID");
  let n2 = 1;
  for (let e3 = 0; e3 < i2; e3++) {
    n2 = n2 << 1 | t2.readBit(a2, n2);
  }
  return i2 < 31 ? n2 & (1 << i2) - 1 : 2147483647 & n2;
}
function decodeBitmap(e2, t2, i2, a2, n2, s2, r2, o2) {
  if (e2) {
    return decodeMMRBitmap(new Reader(o2.data, o2.start, o2.end), t2, i2, false);
  }
  if (0 === a2 && !n2 && 4 === r2.length && 3 === r2[0].x && -1 === r2[0].y && -3 === r2[1].x && -1 === r2[1].y && 2 === r2[2].x && -2 === r2[2].y && -2 === r2[3].x && -2 === r2[3].y)
    return function(e3, t3, i3) {
      const a3 = i3.decoder, n3 = i3.contextCache.getContexts("GB"), s3 = [];
      let r3, o3, l4, c3, h3, d3, u3;
      for (o3 = 0; o3 < t3; o3++)
        for (h3 = s3[o3] = new Uint8Array(e3), d3 = o3 < 1 ? h3 : s3[o3 - 1], u3 = o3 < 2 ? h3 : s3[o3 - 2], r3 = u3[0] << 13 | u3[1] << 12 | u3[2] << 11 | d3[0] << 7 | d3[1] << 6 | d3[2] << 5 | d3[3] << 4, l4 = 0; l4 < e3; l4++)
          h3[l4] = c3 = a3.readBit(n3, r3), r3 = (31735 & r3) << 1 | (l4 + 3 < e3 ? u3[l4 + 3] << 11 : 0) | (l4 + 4 < e3 ? d3[l4 + 4] << 4 : 0) | c3;
      return s3;
    }(t2, i2, o2);
  const l3 = ea[a2].concat(r2);
  l3.sort((e3, t3) => e3.y - t3.y || e3.x - t3.x);
  const c2 = l3.length, h2 = new Int8Array(c2), d2 = new Int8Array(c2), u2 = [];
  let g2, p2, f2 = 0, m2 = 0, b2 = 0, y2 = 0;
  for (p2 = 0; p2 < c2; p2++)
    h2[p2] = l3[p2].x, d2[p2] = l3[p2].y, m2 = Math.min(m2, l3[p2].x), b2 = Math.max(b2, l3[p2].x), y2 = Math.min(y2, l3[p2].y), p2 < c2 - 1 && l3[p2].y === l3[p2 + 1].y && l3[p2].x === l3[p2 + 1].x - 1 ? f2 |= 1 << c2 - 1 - p2 : u2.push(p2);
  const w2 = u2.length, x2 = new Int8Array(w2), S2 = new Int8Array(w2), v2 = new Uint16Array(w2);
  for (g2 = 0; g2 < w2; g2++)
    p2 = u2[g2], x2[g2] = l3[p2].x, S2[g2] = l3[p2].y, v2[g2] = 1 << c2 - 1 - p2;
  const C2 = -m2, k2 = -y2, T2 = t2 - b2, F2 = ia[a2];
  let M2 = new Uint8Array(t2);
  const D2 = [], E2 = o2.decoder, O2 = o2.contextCache.getContexts("GB");
  let _2, R2, N2, L2, U2, j2 = 0, $2 = 0;
  for (let e3 = 0; e3 < i2; e3++) {
    if (n2) {
      if (j2 ^= E2.readBit(O2, F2), j2) {
        D2.push(M2);
        continue;
      }
    }
    for (M2 = new Uint8Array(M2), D2.push(M2), _2 = 0; _2 < t2; _2++) {
      if (_2 >= C2 && _2 < T2 && e3 >= k2)
        for ($2 = $2 << 1 & f2, p2 = 0; p2 < w2; p2++)
          R2 = e3 + S2[p2], N2 = _2 + x2[p2], L2 = D2[R2][N2], L2 && (L2 = v2[p2], $2 |= L2);
      else
        for ($2 = 0, U2 = c2 - 1, p2 = 0; p2 < c2; p2++, U2--)
          N2 = _2 + h2[p2], N2 >= 0 && N2 < t2 && (R2 = e3 + d2[p2], R2 >= 0 && (L2 = D2[R2][N2], L2 && ($2 |= L2 << U2)));
      const i3 = E2.readBit(O2, $2);
      M2[_2] = i3;
    }
  }
  return D2;
}
function decodeRefinement(e2, t2, i2, a2, n2, s2, r2, o2, l3) {
  let c2 = ta[i2].coding;
  0 === i2 && (c2 = c2.concat([o2[0]]));
  const h2 = c2.length, d2 = new Int32Array(h2), u2 = new Int32Array(h2);
  let g2;
  for (g2 = 0; g2 < h2; g2++)
    d2[g2] = c2[g2].x, u2[g2] = c2[g2].y;
  let p2 = ta[i2].reference;
  0 === i2 && (p2 = p2.concat([o2[1]]));
  const f2 = p2.length, m2 = new Int32Array(f2), b2 = new Int32Array(f2);
  for (g2 = 0; g2 < f2; g2++)
    m2[g2] = p2[g2].x, b2[g2] = p2[g2].y;
  const y2 = a2[0].length, w2 = a2.length, x2 = [], S2 = l3.decoder, v2 = l3.contextCache.getContexts("GR");
  for (let i3 = 0; i3 < t2; i3++) {
    const t3 = new Uint8Array(e2);
    x2.push(t3);
    for (let r3 = 0; r3 < e2; r3++) {
      let o3, l4, c3 = 0;
      for (g2 = 0; g2 < h2; g2++)
        o3 = i3 + u2[g2], l4 = r3 + d2[g2], o3 < 0 || l4 < 0 || l4 >= e2 ? c3 <<= 1 : c3 = c3 << 1 | x2[o3][l4];
      for (g2 = 0; g2 < f2; g2++)
        o3 = i3 + b2[g2] - s2, l4 = r3 + m2[g2] - n2, o3 < 0 || o3 >= w2 || l4 < 0 || l4 >= y2 ? c3 <<= 1 : c3 = c3 << 1 | a2[o3][l4];
      const p3 = S2.readBit(v2, c3);
      t3[r3] = p3;
    }
  }
  return x2;
}
function decodeTextRegion(e2, t2, i2, a2, n2, s2, r2, o2, l3, c2, h2, d2, u2, g2, p2, f2, m2, b2, y2) {
  if (e2 && t2)
    throw new Jbig2Error("refinement with Huffman is not supported");
  const w2 = [];
  let x2, S2;
  for (x2 = 0; x2 < a2; x2++)
    S2 = new Uint8Array(i2), n2 && S2.fill(n2), w2.push(S2);
  const v2 = m2.decoder, C2 = m2.contextCache;
  let k2 = e2 ? -g2.tableDeltaT.decode(y2) : -decodeInteger(C2, "IADT", v2), T2 = 0;
  for (x2 = 0; x2 < s2; ) {
    k2 += e2 ? g2.tableDeltaT.decode(y2) : decodeInteger(C2, "IADT", v2);
    T2 += e2 ? g2.tableFirstS.decode(y2) : decodeInteger(C2, "IAFS", v2);
    let a3 = T2;
    for (; ; ) {
      let n3 = 0;
      r2 > 1 && (n3 = e2 ? y2.readBits(b2) : decodeInteger(C2, "IAIT", v2));
      const s3 = r2 * k2 + n3, T3 = e2 ? g2.symbolIDTable.decode(y2) : decodeIAID(C2, v2, l3), F2 = t2 && (e2 ? y2.readBit() : decodeInteger(C2, "IARI", v2));
      let M2 = o2[T3], D2 = M2[0].length, E2 = M2.length;
      if (F2) {
        const e3 = decodeInteger(C2, "IARDW", v2), t3 = decodeInteger(C2, "IARDH", v2);
        D2 += e3, E2 += t3, M2 = decodeRefinement(D2, E2, p2, M2, (e3 >> 1) + decodeInteger(C2, "IARDX", v2), (t3 >> 1) + decodeInteger(C2, "IARDY", v2), 0, f2, m2);
      }
      let O2 = 0;
      c2 ? 1 & d2 ? O2 = E2 - 1 : a3 += E2 - 1 : d2 > 1 ? a3 += D2 - 1 : O2 = D2 - 1;
      const _2 = s3 - (1 & d2 ? 0 : E2 - 1), R2 = a3 - (2 & d2 ? D2 - 1 : 0);
      let N2, L2, U2;
      if (c2)
        for (N2 = 0; N2 < E2; N2++) {
          if (S2 = w2[R2 + N2], !S2)
            continue;
          U2 = M2[N2];
          const e3 = Math.min(i2 - _2, D2);
          switch (u2) {
            case 0:
              for (L2 = 0; L2 < e3; L2++)
                S2[_2 + L2] |= U2[L2];
              break;
            case 2:
              for (L2 = 0; L2 < e3; L2++)
                S2[_2 + L2] ^= U2[L2];
              break;
            default:
              throw new Jbig2Error(`operator ${u2} is not supported`);
          }
        }
      else
        for (L2 = 0; L2 < E2; L2++)
          if (S2 = w2[_2 + L2], S2)
            switch (U2 = M2[L2], u2) {
              case 0:
                for (N2 = 0; N2 < D2; N2++)
                  S2[R2 + N2] |= U2[N2];
                break;
              case 2:
                for (N2 = 0; N2 < D2; N2++)
                  S2[R2 + N2] ^= U2[N2];
                break;
              default:
                throw new Jbig2Error(`operator ${u2} is not supported`);
            }
      x2++;
      const j2 = e2 ? g2.tableDeltaS.decode(y2) : decodeInteger(C2, "IADS", v2);
      if (null === j2)
        break;
      a3 += O2 + j2 + h2;
    }
  }
  return w2;
}
function readSegmentHeader(e2, t2) {
  const i2 = {};
  i2.number = readUint32(e2, t2);
  const a2 = e2[t2 + 4], n2 = 63 & a2;
  if (!Qi[n2])
    throw new Jbig2Error("invalid segment type: " + n2);
  i2.type = n2, i2.typeName = Qi[n2], i2.deferredNonRetain = !!(128 & a2);
  const s2 = !!(64 & a2), r2 = e2[t2 + 5];
  let o2 = r2 >> 5 & 7;
  const l3 = [31 & r2];
  let c2 = t2 + 6;
  if (7 === r2) {
    o2 = 536870911 & readUint32(e2, c2 - 1), c2 += 3;
    let t3 = o2 + 7 >> 3;
    for (l3[0] = e2[c2++]; --t3 > 0; )
      l3.push(e2[c2++]);
  } else if (5 === r2 || 6 === r2)
    throw new Jbig2Error("invalid referred-to flags");
  i2.retainBits = l3;
  let h2 = 4;
  i2.number <= 256 ? h2 = 1 : i2.number <= 65536 && (h2 = 2);
  const d2 = [];
  let u2, g2;
  for (u2 = 0; u2 < o2; u2++) {
    let t3;
    t3 = 1 === h2 ? e2[c2] : 2 === h2 ? readUint16(e2, c2) : readUint32(e2, c2), d2.push(t3), c2 += h2;
  }
  if (i2.referredTo = d2, s2 ? (i2.pageAssociation = readUint32(e2, c2), c2 += 4) : i2.pageAssociation = e2[c2++], i2.length = readUint32(e2, c2), c2 += 4, 4294967295 === i2.length) {
    if (38 !== n2)
      throw new Jbig2Error("invalid unknown segment length");
    {
      const t3 = readRegionSegmentInformation(e2, c2), a3 = !!(1 & e2[c2 + aa]), n3 = 6, s3 = new Uint8Array(n3);
      for (a3 || (s3[0] = 255, s3[1] = 172), s3[2] = t3.height >>> 24 & 255, s3[3] = t3.height >> 16 & 255, s3[4] = t3.height >> 8 & 255, s3[5] = 255 & t3.height, u2 = c2, g2 = e2.length; u2 < g2; u2++) {
        let t4 = 0;
        for (; t4 < n3 && s3[t4] === e2[u2 + t4]; )
          t4++;
        if (t4 === n3) {
          i2.length = u2 + n3;
          break;
        }
      }
      if (4294967295 === i2.length)
        throw new Jbig2Error("segment end was not found");
    }
  }
  return i2.headerEnd = c2, i2;
}
function readSegments(e2, t2, i2, a2) {
  const n2 = [];
  let s2 = i2;
  for (; s2 < a2; ) {
    const i3 = readSegmentHeader(t2, s2);
    s2 = i3.headerEnd;
    const a3 = { header: i3, data: t2 };
    if (e2.randomAccess || (a3.start = s2, s2 += i3.length, a3.end = s2), n2.push(a3), 51 === i3.type)
      break;
  }
  if (e2.randomAccess)
    for (let e3 = 0, t3 = n2.length; e3 < t3; e3++)
      n2[e3].start = s2, s2 += n2[e3].header.length, n2[e3].end = s2;
  return n2;
}
function readRegionSegmentInformation(e2, t2) {
  return { width: readUint32(e2, t2), height: readUint32(e2, t2 + 4), x: readUint32(e2, t2 + 8), y: readUint32(e2, t2 + 12), combinationOperator: 7 & e2[t2 + 16] };
}
function processSegment(e2, t2) {
  const i2 = e2.header, a2 = e2.data, n2 = e2.end;
  let s2, r2, o2, l3, c2 = e2.start;
  switch (i2.type) {
    case 0:
      const e3 = {}, t3 = readUint16(a2, c2);
      if (e3.huffman = !!(1 & t3), e3.refinement = !!(2 & t3), e3.huffmanDHSelector = t3 >> 2 & 3, e3.huffmanDWSelector = t3 >> 4 & 3, e3.bitmapSizeSelector = t3 >> 6 & 1, e3.aggregationInstancesSelector = t3 >> 7 & 1, e3.bitmapCodingContextUsed = !!(256 & t3), e3.bitmapCodingContextRetained = !!(512 & t3), e3.template = t3 >> 10 & 3, e3.refinementTemplate = t3 >> 12 & 1, c2 += 2, !e3.huffman) {
        for (l3 = 0 === e3.template ? 4 : 1, r2 = [], o2 = 0; o2 < l3; o2++)
          r2.push({ x: readInt8(a2, c2), y: readInt8(a2, c2 + 1) }), c2 += 2;
        e3.at = r2;
      }
      if (e3.refinement && !e3.refinementTemplate) {
        for (r2 = [], o2 = 0; o2 < 2; o2++)
          r2.push({ x: readInt8(a2, c2), y: readInt8(a2, c2 + 1) }), c2 += 2;
        e3.refinementAt = r2;
      }
      e3.numberOfExportedSymbols = readUint32(a2, c2), c2 += 4, e3.numberOfNewSymbols = readUint32(a2, c2), c2 += 4, s2 = [e3, i2.number, i2.referredTo, a2, c2, n2];
      break;
    case 6:
    case 7:
      const h3 = {};
      h3.info = readRegionSegmentInformation(a2, c2), c2 += aa;
      const d2 = readUint16(a2, c2);
      if (c2 += 2, h3.huffman = !!(1 & d2), h3.refinement = !!(2 & d2), h3.logStripSize = d2 >> 2 & 3, h3.stripSize = 1 << h3.logStripSize, h3.referenceCorner = d2 >> 4 & 3, h3.transposed = !!(64 & d2), h3.combinationOperator = d2 >> 7 & 3, h3.defaultPixelValue = d2 >> 9 & 1, h3.dsOffset = d2 << 17 >> 27, h3.refinementTemplate = d2 >> 15 & 1, h3.huffman) {
        const e4 = readUint16(a2, c2);
        c2 += 2, h3.huffmanFS = 3 & e4, h3.huffmanDS = e4 >> 2 & 3, h3.huffmanDT = e4 >> 4 & 3, h3.huffmanRefinementDW = e4 >> 6 & 3, h3.huffmanRefinementDH = e4 >> 8 & 3, h3.huffmanRefinementDX = e4 >> 10 & 3, h3.huffmanRefinementDY = e4 >> 12 & 3, h3.huffmanRefinementSizeSelector = !!(16384 & e4);
      }
      if (h3.refinement && !h3.refinementTemplate) {
        for (r2 = [], o2 = 0; o2 < 2; o2++)
          r2.push({ x: readInt8(a2, c2), y: readInt8(a2, c2 + 1) }), c2 += 2;
        h3.refinementAt = r2;
      }
      h3.numberOfSymbolInstances = readUint32(a2, c2), c2 += 4, s2 = [h3, i2.referredTo, a2, c2, n2];
      break;
    case 16:
      const u2 = {}, g2 = a2[c2++];
      u2.mmr = !!(1 & g2), u2.template = g2 >> 1 & 3, u2.patternWidth = a2[c2++], u2.patternHeight = a2[c2++], u2.maxPatternIndex = readUint32(a2, c2), c2 += 4, s2 = [u2, i2.number, a2, c2, n2];
      break;
    case 22:
    case 23:
      const p2 = {};
      p2.info = readRegionSegmentInformation(a2, c2), c2 += aa;
      const f2 = a2[c2++];
      p2.mmr = !!(1 & f2), p2.template = f2 >> 1 & 3, p2.enableSkip = !!(8 & f2), p2.combinationOperator = f2 >> 4 & 7, p2.defaultPixelValue = f2 >> 7 & 1, p2.gridWidth = readUint32(a2, c2), c2 += 4, p2.gridHeight = readUint32(a2, c2), c2 += 4, p2.gridOffsetX = 4294967295 & readUint32(a2, c2), c2 += 4, p2.gridOffsetY = 4294967295 & readUint32(a2, c2), c2 += 4, p2.gridVectorX = readUint16(a2, c2), c2 += 2, p2.gridVectorY = readUint16(a2, c2), c2 += 2, s2 = [p2, i2.referredTo, a2, c2, n2];
      break;
    case 38:
    case 39:
      const m2 = {};
      m2.info = readRegionSegmentInformation(a2, c2), c2 += aa;
      const b2 = a2[c2++];
      if (m2.mmr = !!(1 & b2), m2.template = b2 >> 1 & 3, m2.prediction = !!(8 & b2), !m2.mmr) {
        for (l3 = 0 === m2.template ? 4 : 1, r2 = [], o2 = 0; o2 < l3; o2++)
          r2.push({ x: readInt8(a2, c2), y: readInt8(a2, c2 + 1) }), c2 += 2;
        m2.at = r2;
      }
      s2 = [m2, a2, c2, n2];
      break;
    case 48:
      const y2 = { width: readUint32(a2, c2), height: readUint32(a2, c2 + 4), resolutionX: readUint32(a2, c2 + 8), resolutionY: readUint32(a2, c2 + 12) };
      4294967295 === y2.height && delete y2.height;
      const w2 = a2[c2 + 16];
      readUint16(a2, c2 + 17), y2.lossless = !!(1 & w2), y2.refinement = !!(2 & w2), y2.defaultPixelValue = w2 >> 2 & 1, y2.combinationOperator = w2 >> 3 & 3, y2.requiresBuffer = !!(32 & w2), y2.combinationOperatorOverride = !!(64 & w2), s2 = [y2];
      break;
    case 49:
    case 50:
    case 51:
    case 62:
      break;
    case 53:
      s2 = [i2.number, a2, c2, n2];
      break;
    default:
      throw new Jbig2Error(`segment type ${i2.typeName}(${i2.type}) is not implemented`);
  }
  const h2 = "on" + i2.typeName;
  h2 in t2 && t2[h2].apply(t2, s2);
}
function processSegments(e2, t2) {
  for (let i2 = 0, a2 = e2.length; i2 < a2; i2++)
    processSegment(e2[i2], t2);
}
function getStandardTable(e2) {
  let t2, i2 = na[e2];
  if (i2)
    return i2;
  switch (e2) {
    case 1:
      t2 = [[0, 1, 4, 0], [16, 2, 8, 2], [272, 3, 16, 6], [65808, 3, 32, 7]];
      break;
    case 2:
      t2 = [[0, 1, 0, 0], [1, 2, 0, 2], [2, 3, 0, 6], [3, 4, 3, 14], [11, 5, 6, 30], [75, 6, 32, 62], [6, 63]];
      break;
    case 3:
      t2 = [[-256, 8, 8, 254], [0, 1, 0, 0], [1, 2, 0, 2], [2, 3, 0, 6], [3, 4, 3, 14], [11, 5, 6, 30], [-257, 8, 32, 255, "lower"], [75, 7, 32, 126], [6, 62]];
      break;
    case 4:
      t2 = [[1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 0, 6], [4, 4, 3, 14], [12, 5, 6, 30], [76, 5, 32, 31]];
      break;
    case 5:
      t2 = [[-255, 7, 8, 126], [1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 0, 6], [4, 4, 3, 14], [12, 5, 6, 30], [-256, 7, 32, 127, "lower"], [76, 6, 32, 62]];
      break;
    case 6:
      t2 = [[-2048, 5, 10, 28], [-1024, 4, 9, 8], [-512, 4, 8, 9], [-256, 4, 7, 10], [-128, 5, 6, 29], [-64, 5, 5, 30], [-32, 4, 5, 11], [0, 2, 7, 0], [128, 3, 7, 2], [256, 3, 8, 3], [512, 4, 9, 12], [1024, 4, 10, 13], [-2049, 6, 32, 62, "lower"], [2048, 6, 32, 63]];
      break;
    case 7:
      t2 = [[-1024, 4, 9, 8], [-512, 3, 8, 0], [-256, 4, 7, 9], [-128, 5, 6, 26], [-64, 5, 5, 27], [-32, 4, 5, 10], [0, 4, 5, 11], [32, 5, 5, 28], [64, 5, 6, 29], [128, 4, 7, 12], [256, 3, 8, 1], [512, 3, 9, 2], [1024, 3, 10, 3], [-1025, 5, 32, 30, "lower"], [2048, 5, 32, 31]];
      break;
    case 8:
      t2 = [[-15, 8, 3, 252], [-7, 9, 1, 508], [-5, 8, 1, 253], [-3, 9, 0, 509], [-2, 7, 0, 124], [-1, 4, 0, 10], [0, 2, 1, 0], [2, 5, 0, 26], [3, 6, 0, 58], [4, 3, 4, 4], [20, 6, 1, 59], [22, 4, 4, 11], [38, 4, 5, 12], [70, 5, 6, 27], [134, 5, 7, 28], [262, 6, 7, 60], [390, 7, 8, 125], [646, 6, 10, 61], [-16, 9, 32, 510, "lower"], [1670, 9, 32, 511], [2, 1]];
      break;
    case 9:
      t2 = [[-31, 8, 4, 252], [-15, 9, 2, 508], [-11, 8, 2, 253], [-7, 9, 1, 509], [-5, 7, 1, 124], [-3, 4, 1, 10], [-1, 3, 1, 2], [1, 3, 1, 3], [3, 5, 1, 26], [5, 6, 1, 58], [7, 3, 5, 4], [39, 6, 2, 59], [43, 4, 5, 11], [75, 4, 6, 12], [139, 5, 7, 27], [267, 5, 8, 28], [523, 6, 8, 60], [779, 7, 9, 125], [1291, 6, 11, 61], [-32, 9, 32, 510, "lower"], [3339, 9, 32, 511], [2, 0]];
      break;
    case 10:
      t2 = [[-21, 7, 4, 122], [-5, 8, 0, 252], [-4, 7, 0, 123], [-3, 5, 0, 24], [-2, 2, 2, 0], [2, 5, 0, 25], [3, 6, 0, 54], [4, 7, 0, 124], [5, 8, 0, 253], [6, 2, 6, 1], [70, 5, 5, 26], [102, 6, 5, 55], [134, 6, 6, 56], [198, 6, 7, 57], [326, 6, 8, 58], [582, 6, 9, 59], [1094, 6, 10, 60], [2118, 7, 11, 125], [-22, 8, 32, 254, "lower"], [4166, 8, 32, 255], [2, 2]];
      break;
    case 11:
      t2 = [[1, 1, 0, 0], [2, 2, 1, 2], [4, 4, 0, 12], [5, 4, 1, 13], [7, 5, 1, 28], [9, 5, 2, 29], [13, 6, 2, 60], [17, 7, 2, 122], [21, 7, 3, 123], [29, 7, 4, 124], [45, 7, 5, 125], [77, 7, 6, 126], [141, 7, 32, 127]];
      break;
    case 12:
      t2 = [[1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 1, 6], [5, 5, 0, 28], [6, 5, 1, 29], [8, 6, 1, 60], [10, 7, 0, 122], [11, 7, 1, 123], [13, 7, 2, 124], [17, 7, 3, 125], [25, 7, 4, 126], [41, 8, 5, 254], [73, 8, 32, 255]];
      break;
    case 13:
      t2 = [[1, 1, 0, 0], [2, 3, 0, 4], [3, 4, 0, 12], [4, 5, 0, 28], [5, 4, 1, 13], [7, 3, 3, 5], [15, 6, 1, 58], [17, 6, 2, 59], [21, 6, 3, 60], [29, 6, 4, 61], [45, 6, 5, 62], [77, 7, 6, 126], [141, 7, 32, 127]];
      break;
    case 14:
      t2 = [[-2, 3, 0, 4], [-1, 3, 0, 5], [0, 1, 0, 0], [1, 3, 0, 6], [2, 3, 0, 7]];
      break;
    case 15:
      t2 = [[-24, 7, 4, 124], [-8, 6, 2, 60], [-4, 5, 1, 28], [-2, 4, 0, 12], [-1, 3, 0, 4], [0, 1, 0, 0], [1, 3, 0, 5], [2, 4, 0, 13], [3, 5, 1, 29], [5, 6, 2, 61], [9, 7, 4, 125], [-25, 7, 32, 126, "lower"], [25, 7, 32, 127]];
      break;
    default:
      throw new Jbig2Error(`standard table B.${e2} does not exist`);
  }
  for (let e3 = 0, i3 = t2.length; e3 < i3; e3++)
    t2[e3] = new HuffmanLine(t2[e3]);
  return i2 = new HuffmanTable(t2, true), na[e2] = i2, i2;
}
function getCustomHuffmanTable(e2, t2, i2) {
  let a2 = 0;
  for (let n2 = 0, s2 = t2.length; n2 < s2; n2++) {
    const s3 = i2[t2[n2]];
    if (s3) {
      if (e2 === a2)
        return s3;
      a2++;
    }
  }
  throw new Jbig2Error("can't find custom Huffman table");
}
function readUncompressedBitmap(e2, t2, i2) {
  const a2 = [];
  for (let n2 = 0; n2 < i2; n2++) {
    const i3 = new Uint8Array(t2);
    a2.push(i3);
    for (let a3 = 0; a3 < t2; a3++)
      i3[a3] = e2.readBit();
    e2.byteAlign();
  }
  return a2;
}
function decodeMMRBitmap(e2, t2, i2, a2) {
  const n2 = new CCITTFaxDecoder(e2, { K: -1, Columns: t2, Rows: i2, BlackIs1: true, EndOfBlock: a2 }), s2 = [];
  let r2, o2 = false;
  for (let e3 = 0; e3 < i2; e3++) {
    const e4 = new Uint8Array(t2);
    s2.push(e4);
    let i3 = -1;
    for (let a3 = 0; a3 < t2; a3++)
      i3 < 0 && (r2 = n2.readNextChar(), -1 === r2 && (r2 = 0, o2 = true), i3 = 7), e4[a3] = r2 >> i3 & 1, i3--;
  }
  if (a2 && !o2) {
    const e3 = 5;
    for (let t3 = 0; t3 < e3 && -1 !== n2.readNextChar(); t3++)
      ;
  }
  return s2;
}
function toHexDigit(e2) {
  return e2 >= 48 && e2 <= 57 ? 15 & e2 : e2 >= 65 && e2 <= 70 || e2 >= 97 && e2 <= 102 ? 9 + (15 & e2) : -1;
}
function strToInt(e2) {
  let t2 = 0;
  for (let i2 = 0; i2 < e2.length; i2++)
    t2 = t2 << 8 | e2.charCodeAt(i2);
  return t2 >>> 0;
}
function expectString(e2) {
  if ("string" != typeof e2)
    throw new ti("Malformed CMap: expected string.");
}
function expectInt(e2) {
  if (!Number.isInteger(e2))
    throw new ti("Malformed CMap: expected int.");
}
function parseBfChar(e2, t2) {
  for (; ; ) {
    let i2 = t2.getObj();
    if (i2 === ci)
      break;
    if (isCmd(i2, "endbfchar"))
      return;
    expectString(i2);
    const a2 = strToInt(i2);
    i2 = t2.getObj(), expectString(i2);
    const n2 = i2;
    e2.mapOne(a2, n2);
  }
}
function parseBfRange(e2, t2) {
  for (; ; ) {
    let i2 = t2.getObj();
    if (i2 === ci)
      break;
    if (isCmd(i2, "endbfrange"))
      return;
    expectString(i2);
    const a2 = strToInt(i2);
    i2 = t2.getObj(), expectString(i2);
    const n2 = strToInt(i2);
    if (i2 = t2.getObj(), Number.isInteger(i2) || "string" == typeof i2) {
      const t3 = Number.isInteger(i2) ? String.fromCharCode(i2) : i2;
      e2.mapBfRange(a2, n2, t3);
    } else {
      if (!isCmd(i2, "["))
        break;
      {
        i2 = t2.getObj();
        const s2 = [];
        for (; !isCmd(i2, "]") && i2 !== ci; )
          s2.push(i2), i2 = t2.getObj();
        e2.mapBfRangeToArray(a2, n2, s2);
      }
    }
  }
  throw new ti("Invalid bf range.");
}
function parseCidChar(e2, t2) {
  for (; ; ) {
    let i2 = t2.getObj();
    if (i2 === ci)
      break;
    if (isCmd(i2, "endcidchar"))
      return;
    expectString(i2);
    const a2 = strToInt(i2);
    i2 = t2.getObj(), expectInt(i2);
    const n2 = i2;
    e2.mapOne(a2, n2);
  }
}
function parseCidRange(e2, t2) {
  for (; ; ) {
    let i2 = t2.getObj();
    if (i2 === ci)
      break;
    if (isCmd(i2, "endcidrange"))
      return;
    expectString(i2);
    const a2 = strToInt(i2);
    i2 = t2.getObj(), expectString(i2);
    const n2 = strToInt(i2);
    i2 = t2.getObj(), expectInt(i2);
    const s2 = i2;
    e2.mapCidRange(a2, n2, s2);
  }
}
function parseCodespaceRange(e2, t2) {
  for (; ; ) {
    let i2 = t2.getObj();
    if (i2 === ci)
      break;
    if (isCmd(i2, "endcodespacerange"))
      return;
    if ("string" != typeof i2)
      break;
    const a2 = strToInt(i2);
    if (i2 = t2.getObj(), "string" != typeof i2)
      break;
    const n2 = strToInt(i2);
    e2.addCodespaceRange(i2.length, a2, n2);
  }
  throw new ti("Invalid codespace range.");
}
function parseWMode(e2, t2) {
  const i2 = t2.getObj();
  Number.isInteger(i2) && (e2.vertical = !!i2);
}
function parseCMapName(e2, t2) {
  const i2 = t2.getObj();
  i2 instanceof Name && (e2.name = i2.name);
}
async function parseCMap(e2, t2, i2, a2) {
  let n2, s2;
  e:
    for (; ; )
      try {
        const i3 = t2.getObj();
        if (i3 === ci)
          break;
        if (i3 instanceof Name)
          "WMode" === i3.name ? parseWMode(e2, t2) : "CMapName" === i3.name && parseCMapName(e2, t2), n2 = i3;
        else if (i3 instanceof Cmd)
          switch (i3.cmd) {
            case "endcmap":
              break e;
            case "usecmap":
              n2 instanceof Name && (s2 = n2.name);
              break;
            case "begincodespacerange":
              parseCodespaceRange(e2, t2);
              break;
            case "beginbfchar":
              parseBfChar(e2, t2);
              break;
            case "begincidchar":
              parseCidChar(e2, t2);
              break;
            case "beginbfrange":
              parseBfRange(e2, t2);
              break;
            case "begincidrange":
              parseCidRange(e2, t2);
          }
      } catch (e3) {
        if (e3 instanceof MissingDataException)
          throw e3;
        warn$1("Invalid cMap data: " + e3);
        continue;
      }
  return !a2 && s2 && (a2 = s2), a2 ? extendCMap(e2, i2, a2) : e2;
}
async function extendCMap(e2, t2, i2) {
  if (e2.useCMap = await createBuiltInCMap(i2, t2), 0 === e2.numCodespaceRanges) {
    const t3 = e2.useCMap.codespaceRanges;
    for (let i3 = 0; i3 < t3.length; i3++)
      e2.codespaceRanges[i3] = t3[i3].slice();
    e2.numCodespaceRanges = e2.useCMap.numCodespaceRanges;
  }
  return e2.useCMap.forEach(function(t3, i3) {
    e2.contains(t3) || e2.mapOne(t3, i3);
  }), e2;
}
async function createBuiltInCMap(e2, t2) {
  if ("Identity-H" === e2)
    return new IdentityCMap(false, 2);
  if ("Identity-V" === e2)
    return new IdentityCMap(true, 2);
  if (!ra.includes(e2))
    throw new Error("Unknown CMap name: " + e2);
  if (!t2)
    throw new Error("Built-in CMap parameters are not provided.");
  const { cMapData: i2, isCompressed: a2 } = await t2(e2), n2 = new CMap(true);
  if (a2)
    return new BinaryCMapReader().process(i2, n2, (e3) => extendCMap(n2, t2, e3));
  const s2 = new Lexer(new Stream(i2));
  return parseCMap(n2, s2, t2, null);
}
function getEncoding(e2) {
  switch (e2) {
    case "WinAnsiEncoding":
      return ua;
    case "StandardEncoding":
      return da;
    case "MacRomanEncoding":
      return ha;
    case "SymbolSetEncoding":
      return ga;
    case "ZapfDingbatsEncoding":
      return pa;
    case "ExpertEncoding":
      return la;
    case "MacExpertEncoding":
      return ca;
    default:
      return null;
  }
}
function getUnicodeForGlyph(e2, t2) {
  let i2 = t2[e2];
  if (void 0 !== i2)
    return i2;
  if (!e2)
    return -1;
  if ("u" === e2[0]) {
    const t3 = e2.length;
    let a2;
    if (7 === t3 && "n" === e2[1] && "i" === e2[2])
      a2 = e2.substring(3);
    else {
      if (!(t3 >= 5 && t3 <= 7))
        return -1;
      a2 = e2.substring(1);
    }
    if (a2 === a2.toUpperCase() && (i2 = parseInt(a2, 16), i2 >= 0))
      return i2;
  }
  return -1;
}
function getUnicodeRangeFor(e2, t2 = -1) {
  if (-1 !== t2) {
    const i2 = ya[t2];
    for (let a2 = 0, n2 = i2.length; a2 < n2; a2 += 2)
      if (e2 >= i2[a2] && e2 <= i2[a2 + 1])
        return t2;
  }
  for (let t3 = 0, i2 = ya.length; t3 < i2; t3++) {
    const i3 = ya[t3];
    for (let a2 = 0, n2 = i3.length; a2 < n2; a2 += 2)
      if (e2 >= i3[a2] && e2 <= i3[a2 + 1])
        return t3;
  }
  return -1;
}
function recoverGlyphName(e2, t2) {
  if (void 0 !== t2[e2])
    return e2;
  const i2 = getUnicodeForGlyph(e2, t2);
  if (-1 !== i2) {
    for (const e3 in t2)
      if (t2[e3] === i2)
        return e3;
  }
  return info$1("Unable to recover a standard glyph name for: " + e2), e2;
}
function type1FontGlyphMapping(e2, t2, i2) {
  const a2 = /* @__PURE__ */ Object.create(null);
  let n2, s2, r2;
  const o2 = !!(e2.flags & Ca);
  if (e2.isInternalFont)
    for (r2 = t2, s2 = 0; s2 < r2.length; s2++)
      n2 = i2.indexOf(r2[s2]), a2[s2] = n2 >= 0 ? n2 : 0;
  else if (e2.baseEncodingName)
    for (r2 = getEncoding(e2.baseEncodingName), s2 = 0; s2 < r2.length; s2++)
      n2 = i2.indexOf(r2[s2]), a2[s2] = n2 >= 0 ? n2 : 0;
  else if (o2)
    for (s2 in t2)
      a2[s2] = t2[s2];
  else
    for (r2 = da, s2 = 0; s2 < r2.length; s2++)
      n2 = i2.indexOf(r2[s2]), a2[s2] = n2 >= 0 ? n2 : 0;
  const l3 = e2.differences;
  let c2;
  if (l3)
    for (s2 in l3) {
      const e3 = l3[s2];
      if (n2 = i2.indexOf(e3), -1 === n2) {
        c2 || (c2 = fa());
        const t3 = recoverGlyphName(e3, c2);
        t3 !== e3 && (n2 = i2.indexOf(t3));
      }
      a2[s2] = n2 >= 0 ? n2 : 0;
    }
  return a2;
}
function normalizeFontName(e2) {
  return e2.replaceAll(/[,_]/g, "-").replaceAll(/\s/g, "");
}
function getStandardFontName(e2) {
  const t2 = normalizeFontName(e2);
  return La()[t2];
}
function isKnownFontName(e2) {
  const t2 = normalizeFontName(e2);
  return !!(La()[t2] || ja()[t2] || $a()[t2] || Ha()[t2]);
}
function getFloat214(e2, t2) {
  return readInt16(e2, t2) / 16384;
}
function getSubroutineBias(e2) {
  const t2 = e2.length;
  let i2 = 32768;
  return t2 < 1240 ? i2 = 107 : t2 < 33900 && (i2 = 1131), i2;
}
function parseCmap(e2, t2, i2) {
  const a2 = 1 === readUint16(e2, t2 + 2) ? readUint32(e2, t2 + 8) : readUint32(e2, t2 + 16), n2 = readUint16(e2, t2 + a2);
  let s2, r2, o2;
  if (4 === n2) {
    readUint16(e2, t2 + a2 + 2);
    const i3 = readUint16(e2, t2 + a2 + 6) >> 1;
    for (r2 = t2 + a2 + 14, s2 = [], o2 = 0; o2 < i3; o2++, r2 += 2)
      s2[o2] = { end: readUint16(e2, r2) };
    for (r2 += 2, o2 = 0; o2 < i3; o2++, r2 += 2)
      s2[o2].start = readUint16(e2, r2);
    for (o2 = 0; o2 < i3; o2++, r2 += 2)
      s2[o2].idDelta = readUint16(e2, r2);
    for (o2 = 0; o2 < i3; o2++, r2 += 2) {
      let t3 = readUint16(e2, r2);
      if (0 !== t3) {
        s2[o2].ids = [];
        for (let i4 = 0, a3 = s2[o2].end - s2[o2].start + 1; i4 < a3; i4++)
          s2[o2].ids[i4] = readUint16(e2, r2 + t3), t3 += 2;
      }
    }
    return s2;
  }
  if (12 === n2) {
    const i3 = readUint32(e2, t2 + a2 + 12);
    for (r2 = t2 + a2 + 16, s2 = [], o2 = 0; o2 < i3; o2++)
      t2 = readUint32(e2, r2), s2.push({ start: t2, end: readUint32(e2, r2 + 4), idDelta: readUint32(e2, r2 + 8) - t2 }), r2 += 12;
    return s2;
  }
  throw new ti(`unsupported cmap: ${n2}`);
}
function parseCff(e2, t2, i2, a2) {
  const n2 = new CFFParser(new Stream(e2, t2, i2 - t2), {}, a2).parse();
  return { glyphs: n2.charStrings.objects, subrs: n2.topDict.privateDict?.subrsIndex?.objects, gsubrs: n2.globalSubrIndex?.objects, isCFFCIDFont: n2.isCIDFont, fdSelect: n2.fdSelect, fdArray: n2.fdArray };
}
function lookupCmap(e2, t2) {
  const i2 = t2.codePointAt(0);
  let a2 = 0, n2 = 0, s2 = e2.length - 1;
  for (; n2 < s2; ) {
    const t3 = n2 + s2 + 1 >> 1;
    i2 < e2[t3].start ? s2 = t3 - 1 : n2 = t3;
  }
  return e2[n2].start <= i2 && i2 <= e2[n2].end && (a2 = e2[n2].idDelta + (e2[n2].ids ? e2[n2].ids[i2 - e2[n2].start] : i2) & 65535), { charCode: i2, glyphId: a2 };
}
function compileGlyf(e2, t2, i2) {
  function moveTo(e3, i3) {
    r2 && t2.add("L", r2), r2 = [e3, i3], t2.add("M", [e3, i3]);
  }
  __name(moveTo, "moveTo");
  function lineTo(e3, i3) {
    t2.add("L", [e3, i3]);
  }
  __name(lineTo, "lineTo");
  function quadraticCurveTo(e3, i3, a3, n3) {
    t2.add("Q", [e3, i3, a3, n3]);
  }
  __name(quadraticCurveTo, "quadraticCurveTo");
  let a2 = 0;
  const n2 = readInt16(e2, a2);
  let s2, r2 = null, o2 = 0, l3 = 0;
  if (a2 += 10, n2 < 0)
    do {
      s2 = readUint16(e2, a2);
      const n3 = readUint16(e2, a2 + 2);
      let r3, c2;
      a2 += 4, 1 & s2 ? (2 & s2 ? (r3 = readInt16(e2, a2), c2 = readInt16(e2, a2 + 2)) : (r3 = readUint16(e2, a2), c2 = readUint16(e2, a2 + 2)), a2 += 4) : 2 & s2 ? (r3 = readInt8(e2, a2++), c2 = readInt8(e2, a2++)) : (r3 = e2[a2++], c2 = e2[a2++]), 2 & s2 ? (o2 = r3, l3 = c2) : (o2 = 0, l3 = 0);
      let h2 = 1, d2 = 1, u2 = 0, g2 = 0;
      8 & s2 ? (h2 = d2 = getFloat214(e2, a2), a2 += 2) : 64 & s2 ? (h2 = getFloat214(e2, a2), d2 = getFloat214(e2, a2 + 2), a2 += 4) : 128 & s2 && (h2 = getFloat214(e2, a2), u2 = getFloat214(e2, a2 + 2), g2 = getFloat214(e2, a2 + 4), d2 = getFloat214(e2, a2 + 6), a2 += 8);
      const p2 = i2.glyphs[n3];
      p2 && (t2.save(), t2.transform([h2, u2, g2, d2, o2, l3]), compileGlyf(p2, t2, i2), t2.restore());
    } while (32 & s2);
  else {
    const t3 = [];
    let i3, r3;
    for (i3 = 0; i3 < n2; i3++)
      t3.push(readUint16(e2, a2)), a2 += 2;
    a2 += 2 + readUint16(e2, a2);
    const c2 = t3.at(-1) + 1, h2 = [];
    for (; h2.length < c2; ) {
      s2 = e2[a2++];
      let t4 = 1;
      for (8 & s2 && (t4 += e2[a2++]); t4-- > 0; )
        h2.push({ flags: s2 });
    }
    for (i3 = 0; i3 < c2; i3++) {
      switch (18 & h2[i3].flags) {
        case 0:
          o2 += readInt16(e2, a2), a2 += 2;
          break;
        case 2:
          o2 -= e2[a2++];
          break;
        case 18:
          o2 += e2[a2++];
      }
      h2[i3].x = o2;
    }
    for (i3 = 0; i3 < c2; i3++) {
      switch (36 & h2[i3].flags) {
        case 0:
          l3 += readInt16(e2, a2), a2 += 2;
          break;
        case 4:
          l3 -= e2[a2++];
          break;
        case 36:
          l3 += e2[a2++];
      }
      h2[i3].y = l3;
    }
    let d2 = 0;
    for (a2 = 0; a2 < n2; a2++) {
      const e3 = t3[a2], n3 = h2.slice(d2, e3 + 1);
      if (1 & n3[0].flags)
        n3.push(n3[0]);
      else if (1 & n3.at(-1).flags)
        n3.unshift(n3.at(-1));
      else {
        const e4 = { flags: 1, x: (n3[0].x + n3.at(-1).x) / 2, y: (n3[0].y + n3.at(-1).y) / 2 };
        n3.unshift(e4), n3.push(e4);
      }
      for (moveTo(n3[0].x, n3[0].y), i3 = 1, r3 = n3.length; i3 < r3; i3++)
        1 & n3[i3].flags ? lineTo(n3[i3].x, n3[i3].y) : 1 & n3[i3 + 1].flags ? (quadraticCurveTo(n3[i3].x, n3[i3].y, n3[i3 + 1].x, n3[i3 + 1].y), i3++) : quadraticCurveTo(n3[i3].x, n3[i3].y, (n3[i3].x + n3[i3 + 1].x) / 2, (n3[i3].y + n3[i3 + 1].y) / 2);
      d2 = e3 + 1;
    }
  }
}
function compileCharString(e2, t2, i2, a2) {
  function moveTo(e3, i3) {
    l3 && t2.add("L", l3), l3 = [e3, i3], t2.add("M", [e3, i3]);
  }
  __name(moveTo, "moveTo");
  function lineTo(e3, i3) {
    t2.add("L", [e3, i3]);
  }
  __name(lineTo, "lineTo");
  function bezierCurveTo(e3, i3, a3, n3, s3, r3) {
    t2.add("C", [e3, i3, a3, n3, s3, r3]);
  }
  __name(bezierCurveTo, "bezierCurveTo");
  const n2 = [];
  let s2 = 0, r2 = 0, o2 = 0, l3 = null;
  !(/* @__PURE__ */ __name(function parse(e3) {
    let l4 = 0;
    for (; l4 < e3.length; ) {
      let c2, h2, d2, u2, g2, p2, f2, m2, b2, y2 = false, w2 = e3[l4++];
      switch (w2) {
        case 1:
        case 3:
        case 18:
        case 23:
          o2 += n2.length >> 1, y2 = true;
          break;
        case 4:
          r2 += n2.pop(), moveTo(s2, r2), y2 = true;
          break;
        case 5:
          for (; n2.length > 0; )
            s2 += n2.shift(), r2 += n2.shift(), lineTo(s2, r2);
          break;
        case 6:
          for (; n2.length > 0 && (s2 += n2.shift(), lineTo(s2, r2), 0 !== n2.length); )
            r2 += n2.shift(), lineTo(s2, r2);
          break;
        case 7:
          for (; n2.length > 0 && (r2 += n2.shift(), lineTo(s2, r2), 0 !== n2.length); )
            s2 += n2.shift(), lineTo(s2, r2);
          break;
        case 8:
          for (; n2.length > 0; )
            c2 = s2 + n2.shift(), d2 = r2 + n2.shift(), h2 = c2 + n2.shift(), u2 = d2 + n2.shift(), s2 = h2 + n2.shift(), r2 = u2 + n2.shift(), bezierCurveTo(c2, d2, h2, u2, s2, r2);
          break;
        case 10:
          if (m2 = n2.pop(), b2 = null, i2.isCFFCIDFont) {
            const e4 = i2.fdSelect.getFDIndex(a2);
            if (e4 >= 0 && e4 < i2.fdArray.length) {
              const t3 = i2.fdArray[e4];
              let a3;
              t3.privateDict?.subrsIndex && (a3 = t3.privateDict.subrsIndex.objects), a3 && (m2 += getSubroutineBias(a3), b2 = a3[m2]);
            } else
              warn$1("Invalid fd index for glyph index.");
          } else
            b2 = i2.subrs[m2 + i2.subrsBias];
          b2 && parse(b2);
          break;
        case 11:
          return;
        case 12:
          switch (w2 = e3[l4++], w2) {
            case 34:
              c2 = s2 + n2.shift(), h2 = c2 + n2.shift(), g2 = r2 + n2.shift(), s2 = h2 + n2.shift(), bezierCurveTo(c2, r2, h2, g2, s2, g2), c2 = s2 + n2.shift(), h2 = c2 + n2.shift(), s2 = h2 + n2.shift(), bezierCurveTo(c2, g2, h2, r2, s2, r2);
              break;
            case 35:
              c2 = s2 + n2.shift(), d2 = r2 + n2.shift(), h2 = c2 + n2.shift(), u2 = d2 + n2.shift(), s2 = h2 + n2.shift(), r2 = u2 + n2.shift(), bezierCurveTo(c2, d2, h2, u2, s2, r2), c2 = s2 + n2.shift(), d2 = r2 + n2.shift(), h2 = c2 + n2.shift(), u2 = d2 + n2.shift(), s2 = h2 + n2.shift(), r2 = u2 + n2.shift(), bezierCurveTo(c2, d2, h2, u2, s2, r2), n2.pop();
              break;
            case 36:
              c2 = s2 + n2.shift(), g2 = r2 + n2.shift(), h2 = c2 + n2.shift(), p2 = g2 + n2.shift(), s2 = h2 + n2.shift(), bezierCurveTo(c2, g2, h2, p2, s2, p2), c2 = s2 + n2.shift(), h2 = c2 + n2.shift(), f2 = p2 + n2.shift(), s2 = h2 + n2.shift(), bezierCurveTo(c2, p2, h2, f2, s2, r2);
              break;
            case 37:
              const e4 = s2, t3 = r2;
              c2 = s2 + n2.shift(), d2 = r2 + n2.shift(), h2 = c2 + n2.shift(), u2 = d2 + n2.shift(), s2 = h2 + n2.shift(), r2 = u2 + n2.shift(), bezierCurveTo(c2, d2, h2, u2, s2, r2), c2 = s2 + n2.shift(), d2 = r2 + n2.shift(), h2 = c2 + n2.shift(), u2 = d2 + n2.shift(), s2 = h2, r2 = u2, Math.abs(s2 - e4) > Math.abs(r2 - t3) ? s2 += n2.shift() : r2 += n2.shift(), bezierCurveTo(c2, d2, h2, u2, s2, r2);
              break;
            default:
              throw new ti(`unknown operator: 12 ${w2}`);
          }
          break;
        case 14:
          if (n2.length >= 4) {
            const e4 = n2.pop(), a3 = n2.pop();
            r2 = n2.pop(), s2 = n2.pop(), t2.save(), t2.translate(s2, r2);
            let o3 = lookupCmap(i2.cmap, String.fromCharCode(i2.glyphNameMap[da[e4]]));
            compileCharString(i2.glyphs[o3.glyphId], t2, i2, o3.glyphId), t2.restore(), o3 = lookupCmap(i2.cmap, String.fromCharCode(i2.glyphNameMap[da[a3]])), compileCharString(i2.glyphs[o3.glyphId], t2, i2, o3.glyphId);
          }
          return;
        case 19:
        case 20:
          o2 += n2.length >> 1, l4 += o2 + 7 >> 3, y2 = true;
          break;
        case 21:
          r2 += n2.pop(), s2 += n2.pop(), moveTo(s2, r2), y2 = true;
          break;
        case 22:
          s2 += n2.pop(), moveTo(s2, r2), y2 = true;
          break;
        case 24:
          for (; n2.length > 2; )
            c2 = s2 + n2.shift(), d2 = r2 + n2.shift(), h2 = c2 + n2.shift(), u2 = d2 + n2.shift(), s2 = h2 + n2.shift(), r2 = u2 + n2.shift(), bezierCurveTo(c2, d2, h2, u2, s2, r2);
          s2 += n2.shift(), r2 += n2.shift(), lineTo(s2, r2);
          break;
        case 25:
          for (; n2.length > 6; )
            s2 += n2.shift(), r2 += n2.shift(), lineTo(s2, r2);
          c2 = s2 + n2.shift(), d2 = r2 + n2.shift(), h2 = c2 + n2.shift(), u2 = d2 + n2.shift(), s2 = h2 + n2.shift(), r2 = u2 + n2.shift(), bezierCurveTo(c2, d2, h2, u2, s2, r2);
          break;
        case 26:
          for (n2.length % 2 && (s2 += n2.shift()); n2.length > 0; )
            c2 = s2, d2 = r2 + n2.shift(), h2 = c2 + n2.shift(), u2 = d2 + n2.shift(), s2 = h2, r2 = u2 + n2.shift(), bezierCurveTo(c2, d2, h2, u2, s2, r2);
          break;
        case 27:
          for (n2.length % 2 && (r2 += n2.shift()); n2.length > 0; )
            c2 = s2 + n2.shift(), d2 = r2, h2 = c2 + n2.shift(), u2 = d2 + n2.shift(), s2 = h2 + n2.shift(), r2 = u2, bezierCurveTo(c2, d2, h2, u2, s2, r2);
          break;
        case 28:
          n2.push(readInt16(e3, l4)), l4 += 2;
          break;
        case 29:
          m2 = n2.pop() + i2.gsubrsBias, b2 = i2.gsubrs[m2], b2 && parse(b2);
          break;
        case 30:
          for (; n2.length > 0 && (c2 = s2, d2 = r2 + n2.shift(), h2 = c2 + n2.shift(), u2 = d2 + n2.shift(), s2 = h2 + n2.shift(), r2 = u2 + (1 === n2.length ? n2.shift() : 0), bezierCurveTo(c2, d2, h2, u2, s2, r2), 0 !== n2.length); )
            c2 = s2 + n2.shift(), d2 = r2, h2 = c2 + n2.shift(), u2 = d2 + n2.shift(), r2 = u2 + n2.shift(), s2 = h2 + (1 === n2.length ? n2.shift() : 0), bezierCurveTo(c2, d2, h2, u2, s2, r2);
          break;
        case 31:
          for (; n2.length > 0 && (c2 = s2 + n2.shift(), d2 = r2, h2 = c2 + n2.shift(), u2 = d2 + n2.shift(), r2 = u2 + n2.shift(), s2 = h2 + (1 === n2.length ? n2.shift() : 0), bezierCurveTo(c2, d2, h2, u2, s2, r2), 0 !== n2.length); )
            c2 = s2, d2 = r2 + n2.shift(), h2 = c2 + n2.shift(), u2 = d2 + n2.shift(), s2 = h2 + n2.shift(), r2 = u2 + (1 === n2.length ? n2.shift() : 0), bezierCurveTo(c2, d2, h2, u2, s2, r2);
          break;
        default:
          if (w2 < 32)
            throw new ti(`unknown operator: ${w2}`);
          w2 < 247 ? n2.push(w2 - 139) : w2 < 251 ? n2.push(256 * (w2 - 247) + e3[l4++] + 108) : w2 < 255 ? n2.push(256 * -(w2 - 251) - e3[l4++] - 108) : (n2.push((e3[l4] << 24 | e3[l4 + 1] << 16 | e3[l4 + 2] << 8 | e3[l4 + 3]) / 65536), l4 += 4);
      }
      y2 && (n2.length = 0);
    }
  }, "parse"))(e2);
}
function writeInt16(e2, t2, i2) {
  e2[t2] = i2 >> 8 & 255, e2[t2 + 1] = 255 & i2;
}
function writeInt32(e2, t2, i2) {
  e2[t2] = i2 >> 24 & 255, e2[t2 + 1] = i2 >> 16 & 255, e2[t2 + 2] = i2 >> 8 & 255, e2[t2 + 3] = 255 & i2;
}
function writeData(e2, t2, i2) {
  if (i2 instanceof Uint8Array)
    e2.set(i2, t2);
  else if ("string" == typeof i2)
    for (let a2 = 0, n2 = i2.length; a2 < n2; a2++)
      e2[t2++] = 255 & i2.charCodeAt(a2);
  else
    for (const a2 of i2)
      e2[t2++] = 255 & a2;
}
function isHexDigit(e2) {
  return e2 >= 48 && e2 <= 57 || e2 >= 65 && e2 <= 70 || e2 >= 97 && e2 <= 102;
}
function decrypt(e2, t2, i2) {
  if (i2 >= e2.length)
    return new Uint8Array(0);
  let a2, n2, s2 = 0 | t2;
  for (a2 = 0; a2 < i2; a2++)
    s2 = 52845 * (e2[a2] + s2) + 22719 & 65535;
  const r2 = e2.length - i2, o2 = new Uint8Array(r2);
  for (a2 = i2, n2 = 0; n2 < r2; a2++, n2++) {
    const t3 = e2[a2];
    o2[n2] = t3 ^ s2 >> 8, s2 = 52845 * (t3 + s2) + 22719 & 65535;
  }
  return o2;
}
function isSpecial(e2) {
  return 47 === e2 || 91 === e2 || 93 === e2 || 123 === e2 || 125 === e2 || 40 === e2 || 41 === e2;
}
function findBlock(e2, t2, i2) {
  const a2 = e2.length, n2 = t2.length, s2 = a2 - n2;
  let r2 = i2, o2 = false;
  for (; r2 < s2; ) {
    let i3 = 0;
    for (; i3 < n2 && e2[r2 + i3] === t2[i3]; )
      i3++;
    if (i3 >= n2) {
      for (r2 += i3; r2 < a2 && isWhiteSpace(e2[r2]); )
        r2++;
      o2 = true;
      break;
    }
    r2++;
  }
  return { found: o2, length: r2 };
}
function adjustWidths(e2) {
  if (!e2.fontMatrix)
    return;
  if (e2.fontMatrix[0] === t[0])
    return;
  const i2 = 1e-3 / e2.fontMatrix[0], a2 = e2.widths;
  for (const e3 in a2)
    a2[e3] *= i2;
  e2.defaultWidth *= i2;
}
function amendFallbackToUnicode(e2) {
  if (!e2.fallbackToUnicode)
    return;
  if (e2.toUnicode instanceof IdentityToUnicodeMap)
    return;
  const t2 = [];
  for (const i2 in e2.fallbackToUnicode)
    e2.toUnicode.has(i2) || (t2[i2] = e2.fallbackToUnicode[i2]);
  t2.length > 0 && e2.toUnicode.amend(t2);
}
function int16(e2, t2) {
  return (e2 << 8) + t2;
}
function writeSignedInt16(e2, t2, i2) {
  e2[t2 + 1] = i2, e2[t2] = i2 >>> 8;
}
function signedInt16(e2, t2) {
  const i2 = (e2 << 8) + t2;
  return 32768 & i2 ? i2 - 65536 : i2;
}
function string16(e2) {
  return String.fromCharCode(e2 >> 8 & 255, 255 & e2);
}
function safeString16(e2) {
  return e2 > 32767 ? e2 = 32767 : e2 < -32768 && (e2 = -32768), String.fromCharCode(e2 >> 8 & 255, 255 & e2);
}
function isTrueTypeCollectionFile(e2) {
  return "ttcf" === bytesToString$1(e2.peekBytes(4));
}
function getFontFileType(e2, { type: t2, subtype: i2, composite: a2 }) {
  let n2, s2;
  return function(e3) {
    const t3 = e3.peekBytes(4);
    return 65536 === readUint32(t3, 0) || "true" === bytesToString$1(t3);
  }(e2) || isTrueTypeCollectionFile(e2) ? n2 = a2 ? "CIDFontType2" : "TrueType" : !function(e3) {
    return "OTTO" === bytesToString$1(e3.peekBytes(4));
  }(e2) ? !function(e3) {
    const t3 = e3.peekBytes(2);
    return 37 === t3[0] && 33 === t3[1] || 128 === t3[0] && 1 === t3[1];
  }(e2) ? !function(e3) {
    const t3 = e3.peekBytes(4);
    return t3[0] >= 1 && t3[3] >= 1 && t3[3] <= 4;
  }(e2) ? (warn$1("getFontFileType: Unable to detect correct font file Type/Subtype."), n2 = t2, s2 = i2) : a2 ? (n2 = "CIDFontType0", s2 = "CIDFontType0C") : (n2 = "MMType1" === t2 ? "MMType1" : "Type1", s2 = "Type1C") : n2 = a2 ? "CIDFontType0" : "MMType1" === t2 ? "MMType1" : "Type1" : n2 = a2 ? "CIDFontType2" : "OpenType", [n2, s2];
}
function applyStandardFontGlyphMap(e2, t2) {
  for (const i2 in t2)
    e2[+i2] = t2[i2];
}
function buildToFontChar(e2, t2, i2) {
  const a2 = [];
  let n2;
  for (let i3 = 0, s2 = e2.length; i3 < s2; i3++)
    n2 = getUnicodeForGlyph(e2[i3], t2), -1 !== n2 && (a2[i3] = n2);
  for (const e3 in i2)
    n2 = getUnicodeForGlyph(i2[e3], t2), -1 !== n2 && (a2[+e3] = n2);
  return a2;
}
function isMacNameRecord(e2) {
  return 1 === e2.platform && 0 === e2.encoding && 0 === e2.language;
}
function isWinNameRecord(e2) {
  return 3 === e2.platform && 1 === e2.encoding && 1033 === e2.language;
}
function convertCidString(e2, t2, i2 = false) {
  switch (t2.length) {
    case 1:
      return t2.charCodeAt(0);
    case 2:
      return t2.charCodeAt(0) << 8 | t2.charCodeAt(1);
  }
  const a2 = `Unsupported CID string (charCode ${e2}): "${t2}".`;
  if (i2)
    throw new ti(a2);
  return warn$1(a2), t2;
}
function adjustMapping(e2, t2, i2, a2) {
  const n2 = /* @__PURE__ */ Object.create(null), s2 = /* @__PURE__ */ new Map(), r2 = [], o2 = /* @__PURE__ */ new Set();
  let l3 = 0;
  let c2 = rn[l3][0], h2 = rn[l3][1];
  const isInPrivateArea = /* @__PURE__ */ __name((e3) => rn[0][0] <= e3 && e3 <= rn[0][1] || rn[1][0] <= e3 && e3 <= rn[1][1], "isInPrivateArea");
  let d2 = null;
  for (const u2 in e2) {
    let g2 = e2[u2];
    if (!t2(g2))
      continue;
    if (c2 > h2) {
      if (l3++, l3 >= rn.length) {
        warn$1("Ran out of space in font private use area.");
        break;
      }
      c2 = rn[l3][0], h2 = rn[l3][1];
    }
    const p2 = c2++;
    0 === g2 && (g2 = i2);
    let f2 = a2.get(u2);
    if ("string" == typeof f2)
      if (1 === f2.length)
        f2 = f2.codePointAt(0);
      else {
        if (!d2) {
          d2 = /* @__PURE__ */ new Map();
          for (let e3 = 64256; e3 <= 64335; e3++) {
            const t3 = String.fromCharCode(e3).normalize("NFKD");
            t3.length > 1 && d2.set(t3, e3);
          }
        }
        f2 = d2.get(f2) || f2.codePointAt(0);
      }
    !f2 || isInPrivateArea(f2) || o2.has(g2) || (s2.set(f2, g2), o2.add(g2)), n2[p2] = g2, r2[u2] = p2;
  }
  return { toFontChar: r2, charCodeToGlyphId: n2, toUnicodeExtraMap: s2, nextAvailableFontCharCode: c2 };
}
function createCmapTable(e2, t2, i2) {
  const a2 = function(e3, t3, i3) {
    const a3 = [];
    for (const t4 in e3)
      e3[t4] >= i3 || a3.push({ fontCharCode: 0 | t4, glyphId: e3[t4] });
    if (t3)
      for (const [e4, n4] of t3)
        n4 >= i3 || a3.push({ fontCharCode: e4, glyphId: n4 });
    0 === a3.length && a3.push({ fontCharCode: 0, glyphId: 0 }), a3.sort((e4, t4) => e4.fontCharCode - t4.fontCharCode);
    const n3 = [], s3 = a3.length;
    for (let e4 = 0; e4 < s3; ) {
      const t4 = a3[e4].fontCharCode, i4 = [a3[e4].glyphId];
      ++e4;
      let r3 = t4;
      for (; e4 < s3 && r3 + 1 === a3[e4].fontCharCode && (i4.push(a3[e4].glyphId), ++r3, ++e4, 65535 !== r3); )
        ;
      n3.push([t4, r3, i4]);
    }
    return n3;
  }(e2, t2, i2), n2 = a2.at(-1)[1] > 65535 ? 2 : 1;
  let s2, r2, o2, l3, c2 = "\0\0" + string16(n2) + "\0\0" + string32$1(4 + 8 * n2);
  for (s2 = a2.length - 1; s2 >= 0 && !(a2[s2][0] <= 65535); --s2)
    ;
  const h2 = s2 + 1;
  a2[s2][0] < 65535 && 65535 === a2[s2][1] && (a2[s2][1] = 65534);
  const d2 = a2[s2][1] < 65535 ? 1 : 0, u2 = h2 + d2, g2 = OpenTypeFileBuilder.getSearchParams(u2, 2);
  let p2, f2, m2, b2, y2 = "", w2 = "", x2 = "", S2 = "", v2 = "", C2 = 0;
  for (s2 = 0, r2 = h2; s2 < r2; s2++) {
    p2 = a2[s2], f2 = p2[0], m2 = p2[1], y2 += string16(f2), w2 += string16(m2), b2 = p2[2];
    let e3 = true;
    for (o2 = 1, l3 = b2.length; o2 < l3; ++o2)
      if (b2[o2] !== b2[o2 - 1] + 1) {
        e3 = false;
        break;
      }
    if (e3) {
      x2 += string16(b2[0] - f2 & 65535), S2 += string16(0);
    } else {
      const e4 = 2 * (u2 - s2) + 2 * C2;
      for (C2 += m2 - f2 + 1, x2 += string16(0), S2 += string16(e4), o2 = 0, l3 = b2.length; o2 < l3; ++o2)
        v2 += string16(b2[o2]);
    }
  }
  d2 > 0 && (w2 += "\xFF\xFF", y2 += "\xFF\xFF", x2 += "\0", S2 += "\0\0");
  const k2 = "\0\0" + string16(2 * u2) + string16(g2.range) + string16(g2.entry) + string16(g2.rangeShift) + w2 + "\0\0" + y2 + x2 + S2 + v2;
  let T2 = "", F2 = "";
  if (n2 > 1) {
    for (c2 += "\0\0\n" + string32$1(4 + 8 * n2 + 4 + k2.length), T2 = "", s2 = 0, r2 = a2.length; s2 < r2; s2++) {
      p2 = a2[s2], f2 = p2[0], b2 = p2[2];
      let e3 = b2[0];
      for (o2 = 1, l3 = b2.length; o2 < l3; ++o2)
        b2[o2] !== b2[o2 - 1] + 1 && (m2 = p2[0] + o2 - 1, T2 += string32$1(f2) + string32$1(m2) + string32$1(e3), f2 = m2 + 1, e3 = b2[o2]);
      T2 += string32$1(f2) + string32$1(p2[1]) + string32$1(e3);
    }
    F2 = "\0\f\0\0" + string32$1(T2.length + 16) + "\0\0\0\0" + string32$1(T2.length / 12);
  }
  return c2 + "\0" + string16(k2.length + 4) + k2 + F2 + T2;
}
function createOS2Table(e2, t2, i2) {
  i2 ||= { unitsPerEm: 0, yMax: 0, yMin: 0, ascent: 0, descent: 0 };
  let a2 = 0, n2 = 0, s2 = 0, r2 = 0, o2 = null, l3 = 0, c2 = -1;
  if (t2) {
    for (let e3 in t2)
      if (e3 |= 0, (o2 > e3 || !o2) && (o2 = e3), l3 < e3 && (l3 = e3), c2 = getUnicodeRangeFor(e3, c2), c2 < 32)
        a2 |= 1 << c2;
      else if (c2 < 64)
        n2 |= 1 << c2 - 32;
      else if (c2 < 96)
        s2 |= 1 << c2 - 64;
      else {
        if (!(c2 < 123))
          throw new ti("Unicode ranges Bits > 123 are reserved for internal usage");
        r2 |= 1 << c2 - 96;
      }
    l3 > 65535 && (l3 = 65535);
  } else
    o2 = 0, l3 = 255;
  const h2 = e2.bbox || [0, 0, 0, 0], d2 = i2.unitsPerEm || (e2.fontMatrix ? 1 / Math.max(...e2.fontMatrix.slice(0, 4).map(Math.abs)) : 1e3), u2 = e2.ascentScaled ? 1 : d2 / on2, g2 = i2.ascent || Math.round(u2 * (e2.ascent || h2[3]));
  let p2 = i2.descent || Math.round(u2 * (e2.descent || h2[1]));
  p2 > 0 && e2.descent > 0 && h2[1] < 0 && (p2 = -p2);
  const f2 = i2.yMax || g2, m2 = -i2.yMin || -p2;
  return "\0$\xF4\0\0\0\x8A\xBB\0\0\0\x8C\x8A\xBB\0\0\xDF\x001\0\0\0\0" + String.fromCharCode(e2.fixedPitch ? 9 : 0) + "\0\0\0\0\0\0" + string32$1(a2) + string32$1(n2) + string32$1(s2) + string32$1(r2) + "*21*" + string16(e2.italicAngle ? 1 : 0) + string16(o2 || e2.firstChar) + string16(l3 || e2.lastChar) + string16(g2) + string16(p2) + "\0d" + string16(f2) + string16(m2) + "\0\0\0\0\0\0\0\0" + string16(e2.xHeight) + string16(e2.capHeight) + string16(0) + string16(o2 || e2.firstChar) + "\0";
}
function createPostTable(e2) {
  return "\0\0\0" + string32$1(Math.floor(65536 * e2.italicAngle)) + "\0\0\0\0" + string32$1(e2.fixedPitch ? 1 : 0) + "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
}
function createPostscriptName(e2) {
  return e2.replaceAll(/[^\x21-\x7E]|[[\](){}<>/%]/g, "").slice(0, 63);
}
function createNameTable(e2, t2) {
  t2 || (t2 = [[], []]);
  const i2 = [t2[0][0] || "Original licence", t2[0][1] || e2, t2[0][2] || "Unknown", t2[0][3] || "uniqueID", t2[0][4] || e2, t2[0][5] || "Version 0.11", t2[0][6] || createPostscriptName(e2), t2[0][7] || "Unknown", t2[0][8] || "Unknown", t2[0][9] || "Unknown"], a2 = [];
  let n2, s2, r2, o2, l3;
  for (n2 = 0, s2 = i2.length; n2 < s2; n2++) {
    l3 = t2[1][n2] || i2[n2];
    const e3 = [];
    for (r2 = 0, o2 = l3.length; r2 < o2; r2++)
      e3.push(string16(l3.charCodeAt(r2)));
    a2.push(e3.join(""));
  }
  const c2 = [i2, a2], h2 = ["\0", "\0"], d2 = ["\0\0", "\0"], u2 = ["\0\0", "	"], g2 = i2.length * h2.length;
  let p2 = "\0\0" + string16(g2) + string16(12 * g2 + 6), f2 = 0;
  for (n2 = 0, s2 = h2.length; n2 < s2; n2++) {
    const e3 = c2[n2];
    for (r2 = 0, o2 = e3.length; r2 < o2; r2++) {
      l3 = e3[r2];
      p2 += h2[n2] + d2[n2] + u2[n2] + string16(r2) + string16(l3.length) + string16(f2), f2 += l3.length;
    }
  }
  return p2 += i2.join("") + a2.join(""), p2;
}
function getB(e2) {
  return mn[e2] ||= function(e3) {
    const t2 = [];
    for (let i2 = 0; i2 <= e3; i2++) {
      const a2 = i2 / e3, n2 = 1 - a2;
      t2.push(new Float32Array([n2 ** 3, 3 * a2 * n2 ** 2, 3 * a2 ** 2 * n2, a2 ** 3]));
    }
    return t2;
  }(e2);
}
function getTilingPatternIR(e2, t2, i2) {
  const a2 = lookupMatrix(t2.getArray("Matrix"), fi), n2 = lookupNormalRect(t2.getArray("BBox"), null);
  if (!n2 || n2[2] - n2[0] === 0 || n2[3] - n2[1] === 0)
    throw new ti("Invalid getTilingPatternIR /BBox array.");
  const s2 = t2.get("XStep");
  if ("number" != typeof s2)
    throw new ti("Invalid getTilingPatternIR /XStep value.");
  const r2 = t2.get("YStep");
  if ("number" != typeof r2)
    throw new ti("Invalid getTilingPatternIR /YStep value.");
  const o2 = t2.get("PaintType");
  if (!Number.isInteger(o2))
    throw new ti("Invalid getTilingPatternIR /PaintType value.");
  const l3 = t2.get("TilingType");
  if (!Number.isInteger(l3))
    throw new ti("Invalid getTilingPatternIR /TilingType value.");
  return ["TilingPattern", i2, e2, a2, n2, s2, r2, o2, l3];
}
function getXfaFontName(e2) {
  const t2 = normalizeFontName(e2);
  return as()[t2];
}
function getXfaFontDict(e2) {
  const t2 = function(e3) {
    const t3 = getXfaFontName(e3);
    if (!t3)
      return null;
    const { baseWidths: i3, baseMapping: a3, factors: n3 } = t3, s2 = n3 ? i3.map((e4, t4) => e4 * n3[t4]) : i3;
    let r2, o2 = -2;
    const l3 = [];
    for (const [e4, t4] of a3.map((e5, t5) => [e5, t5]).sort(([e5], [t5]) => e5 - t5))
      -1 !== e4 && (e4 === o2 + 1 ? (r2.push(s2[t4]), o2 += 1) : (o2 = e4, r2 = [s2[t4]], l3.push(e4, r2)));
    return l3;
  }(e2), i2 = new Dict(null);
  i2.set("BaseFont", Name.get(e2)), i2.set("Type", Name.get("Font")), i2.set("Subtype", Name.get("CIDFontType2")), i2.set("Encoding", Name.get("Identity-H")), i2.set("CIDToGIDMap", Name.get("Identity")), i2.set("W", t2), i2.set("FirstChar", t2[0]), i2.set("LastChar", t2.at(-2) + t2.at(-1).length - 1);
  const a2 = new Dict(null);
  i2.set("FontDescriptor", a2);
  const n2 = new Dict(null);
  return n2.set("Ordering", "Identity"), n2.set("Registry", "Adobe"), n2.set("Supplement", 0), i2.set("CIDSystemInfo", n2), i2;
}
function toNumberArray(e2) {
  return Array.isArray(e2) ? isNumberArray(e2, null) ? e2 : e2.map((e3) => +e3) : null;
}
function isPDFFunction(e2) {
  let t2;
  if (e2 instanceof Dict)
    t2 = e2;
  else {
    if (!(e2 instanceof BaseStream))
      return false;
    t2 = e2.dict;
  }
  return t2.has("FunctionType");
}
function buildAddOperation(e2, t2) {
  return "literal" === t2.type && 0 === t2.number ? e2 : "literal" === e2.type && 0 === e2.number ? t2 : "literal" === t2.type && "literal" === e2.type ? new AstLiteral(e2.number + t2.number) : new AstBinaryOperation("+", e2, t2, e2.min + t2.min, e2.max + t2.max);
}
function buildMulOperation(e2, t2) {
  if ("literal" === t2.type) {
    if (0 === t2.number)
      return new AstLiteral(0);
    if (1 === t2.number)
      return e2;
    if ("literal" === e2.type)
      return new AstLiteral(e2.number * t2.number);
  }
  if ("literal" === e2.type) {
    if (0 === e2.number)
      return new AstLiteral(0);
    if (1 === e2.number)
      return t2;
  }
  const i2 = Math.min(e2.min * t2.min, e2.min * t2.max, e2.max * t2.min, e2.max * t2.max), a2 = Math.max(e2.min * t2.min, e2.min * t2.max, e2.max * t2.min, e2.max * t2.max);
  return new AstBinaryOperation("*", e2, t2, i2, a2);
}
function buildSubOperation(e2, t2) {
  if ("literal" === t2.type) {
    if (0 === t2.number)
      return e2;
    if ("literal" === e2.type)
      return new AstLiteral(e2.number - t2.number);
  }
  return "binary" === t2.type && "-" === t2.op && "literal" === e2.type && 1 === e2.number && "literal" === t2.arg1.type && 1 === t2.arg1.number ? t2.arg2 : new AstBinaryOperation("-", e2, t2, e2.min - t2.max, e2.max - t2.min);
}
function buildMinOperation(e2, t2) {
  return e2.min >= t2 ? new AstLiteral(t2) : e2.max <= t2 ? e2 : new AstMin(e2, t2);
}
function isOdd(e2) {
  return !!(1 & e2);
}
function isEven(e2) {
  return !(1 & e2);
}
function findUnequal(e2, t2, i2) {
  let a2, n2;
  for (a2 = t2, n2 = e2.length; a2 < n2; ++a2)
    if (e2[a2] !== i2)
      return a2;
  return a2;
}
function reverseValues(e2, t2, i2) {
  for (let a2 = t2, n2 = i2 - 1; a2 < n2; ++a2, --n2) {
    const t3 = e2[a2];
    e2[a2] = e2[n2], e2[n2] = t3;
  }
}
function createBidiText(e2, t2, i2 = false) {
  let a2 = "ltr";
  return i2 ? a2 = "ttb" : t2 || (a2 = "rtl"), { str: e2, dir: a2 };
}
function bidi(e2, t2 = -1, i2 = false) {
  let a2 = true;
  const n2 = e2.length;
  if (0 === n2 || i2)
    return createBidiText(e2, a2, i2);
  os.length = n2, ls.length = n2;
  let s2, r2, o2 = 0;
  for (s2 = 0; s2 < n2; ++s2) {
    os[s2] = e2.charAt(s2);
    const t3 = e2.charCodeAt(s2);
    let i3 = "L";
    t3 <= 255 ? i3 = ss[t3] : 1424 <= t3 && t3 <= 1524 ? i3 = "R" : 1536 <= t3 && t3 <= 1791 ? (i3 = rs[255 & t3], i3 || warn$1("Bidi: invalid Unicode character " + t3.toString(16))) : (1792 <= t3 && t3 <= 2220 || 64336 <= t3 && t3 <= 65023 || 65136 <= t3 && t3 <= 65279) && (i3 = "AL"), "R" !== i3 && "AL" !== i3 && "AN" !== i3 || o2++, ls[s2] = i3;
  }
  if (0 === o2)
    return a2 = true, createBidiText(e2, a2);
  -1 === t2 && (o2 / n2 < 0.3 && n2 > 4 ? (a2 = true, t2 = 0) : (a2 = false, t2 = 1));
  const l3 = [];
  for (s2 = 0; s2 < n2; ++s2)
    l3[s2] = t2;
  const c2 = isOdd(t2) ? "R" : "L", h2 = c2, d2 = h2;
  let u2, g2 = h2;
  for (s2 = 0; s2 < n2; ++s2)
    "NSM" === ls[s2] ? ls[s2] = g2 : g2 = ls[s2];
  for (g2 = h2, s2 = 0; s2 < n2; ++s2)
    u2 = ls[s2], "EN" === u2 ? ls[s2] = "AL" === g2 ? "AN" : "EN" : "R" !== u2 && "L" !== u2 && "AL" !== u2 || (g2 = u2);
  for (s2 = 0; s2 < n2; ++s2)
    u2 = ls[s2], "AL" === u2 && (ls[s2] = "R");
  for (s2 = 1; s2 < n2 - 1; ++s2)
    "ES" === ls[s2] && "EN" === ls[s2 - 1] && "EN" === ls[s2 + 1] && (ls[s2] = "EN"), "CS" !== ls[s2] || "EN" !== ls[s2 - 1] && "AN" !== ls[s2 - 1] || ls[s2 + 1] !== ls[s2 - 1] || (ls[s2] = ls[s2 - 1]);
  for (s2 = 0; s2 < n2; ++s2)
    if ("EN" === ls[s2]) {
      for (let e3 = s2 - 1; e3 >= 0 && "ET" === ls[e3]; --e3)
        ls[e3] = "EN";
      for (let e3 = s2 + 1; e3 < n2 && "ET" === ls[e3]; ++e3)
        ls[e3] = "EN";
    }
  for (s2 = 0; s2 < n2; ++s2)
    u2 = ls[s2], "WS" !== u2 && "ES" !== u2 && "ET" !== u2 && "CS" !== u2 || (ls[s2] = "ON");
  for (g2 = h2, s2 = 0; s2 < n2; ++s2)
    u2 = ls[s2], "EN" === u2 ? ls[s2] = "L" === g2 ? "L" : "EN" : "R" !== u2 && "L" !== u2 || (g2 = u2);
  for (s2 = 0; s2 < n2; ++s2)
    if ("ON" === ls[s2]) {
      const e3 = findUnequal(ls, s2 + 1, "ON");
      let t3 = h2;
      s2 > 0 && (t3 = ls[s2 - 1]);
      let i3 = d2;
      e3 + 1 < n2 && (i3 = ls[e3 + 1]), "L" !== t3 && (t3 = "R"), "L" !== i3 && (i3 = "R"), t3 === i3 && ls.fill(t3, s2, e3), s2 = e3 - 1;
    }
  for (s2 = 0; s2 < n2; ++s2)
    "ON" === ls[s2] && (ls[s2] = c2);
  for (s2 = 0; s2 < n2; ++s2)
    u2 = ls[s2], isEven(l3[s2]) ? "R" === u2 ? l3[s2] += 1 : "AN" !== u2 && "EN" !== u2 || (l3[s2] += 2) : "L" !== u2 && "AN" !== u2 && "EN" !== u2 || (l3[s2] += 1);
  let p2, f2 = -1, m2 = 99;
  for (s2 = 0, r2 = l3.length; s2 < r2; ++s2)
    p2 = l3[s2], f2 < p2 && (f2 = p2), m2 > p2 && isOdd(p2) && (m2 = p2);
  for (p2 = f2; p2 >= m2; --p2) {
    let e3 = -1;
    for (s2 = 0, r2 = l3.length; s2 < r2; ++s2)
      l3[s2] < p2 ? e3 >= 0 && (reverseValues(os, e3, s2), e3 = -1) : e3 < 0 && (e3 = s2);
    e3 >= 0 && reverseValues(os, e3, l3.length);
  }
  for (s2 = 0, r2 = os.length; s2 < r2; ++s2) {
    const e3 = os[s2];
    "<" !== e3 && ">" !== e3 || (os[s2] = "");
  }
  return createBidiText(os.join(""), a2);
}
function getFamilyName(e2) {
  const t2 = /* @__PURE__ */ new Set(["thin", "extralight", "ultralight", "demilight", "semilight", "light", "book", "regular", "normal", "medium", "demibold", "semibold", "bold", "extrabold", "ultrabold", "black", "heavy", "extrablack", "ultrablack", "roman", "italic", "oblique", "ultracondensed", "extracondensed", "condensed", "semicondensed", "normal", "semiexpanded", "expanded", "extraexpanded", "ultraexpanded", "bolditalic"]);
  return e2.split(/[- ,+]+/g).filter((e3) => !t2.has(e3.toLowerCase())).join(" ");
}
function generateFont({ alias: e2, local: t2, path: i2, fallback: a2, style: n2, ultimate: s2 }, r2, o2, l3 = true, c2 = true, h2 = "") {
  const d2 = { style: null, ultimate: null };
  if (t2) {
    const e3 = h2 ? ` ${h2}` : "";
    for (const i3 of t2)
      r2.push(`local(${i3}${e3})`);
  }
  if (e2) {
    const t3 = gs.get(e2), s3 = h2 || function(e3) {
      switch (e3) {
        case hs:
          return "Bold";
        case ds:
          return "Italic";
        case us:
          return "Bold Italic";
        default:
          if ("bold" === e3?.weight)
            return "Bold";
          if ("italic" === e3?.style)
            return "Italic";
      }
      return "";
    }(n2);
    Object.assign(d2, generateFont(t3, r2, o2, l3 && !a2, c2 && !i2, s3));
  }
  if (n2 && (d2.style = n2), s2 && (d2.ultimate = s2), l3 && a2) {
    const e3 = gs.get(a2), { ultimate: t3 } = generateFont(e3, r2, o2, l3, c2 && !i2, h2);
    d2.ultimate ||= t3;
  }
  return c2 && i2 && o2 && r2.push(`url(${o2}${i2})`), d2;
}
function getFontSubstitution(e2, t2, i2, a2, n2, s2) {
  if (a2.startsWith("InvalidPDFjsFont_"))
    return null;
  "TrueType" !== s2 && "Type1" !== s2 || !/^[A-Z]{6}\+/.test(a2) || (a2 = a2.slice(7));
  const r2 = a2 = normalizeFontName(a2);
  let o2 = e2.get(r2);
  if (o2)
    return o2;
  let l3 = gs.get(a2);
  if (!l3) {
    for (const [e3, t3] of ps)
      if (a2.startsWith(e3)) {
        a2 = `${t3}${a2.substring(e3.length)}`, l3 = gs.get(a2);
        break;
      }
  }
  let c2 = false;
  l3 || (l3 = gs.get(n2), c2 = true);
  const h2 = `${t2.getDocId()}_s${t2.createFontId()}`;
  if (!l3) {
    if (!validateFontName(a2))
      return warn$1(`Cannot substitute the font because of its name: ${a2}`), e2.set(r2, null), null;
    const t3 = /bold/gi.test(a2), i3 = /oblique|italic/gi.test(a2), n3 = t3 && i3 && us || t3 && hs || i3 && ds || cs;
    return o2 = { css: `"${getFamilyName(a2)}",${h2}`, guessFallback: true, loadedName: h2, baseFontName: a2, src: `local(${a2})`, style: n3 }, e2.set(r2, o2), o2;
  }
  const d2 = [];
  c2 && validateFontName(a2) && d2.push(`local(${a2})`);
  const { style: u2, ultimate: g2 } = generateFont(l3, d2, i2), p2 = null === g2, f2 = p2 ? "" : `,${g2}`;
  return o2 = { css: `"${getFamilyName(a2)}",${h2}${f2}`, guessFallback: p2, loadedName: h2, baseFontName: a2, src: d2.join(","), style: u2 }, e2.set(r2, o2), o2;
}
function resizeImageMask(e2, t2, i2, a2, n2, s2) {
  const r2 = n2 * s2;
  let o2;
  o2 = t2 <= 8 ? new Uint8Array(r2) : t2 <= 16 ? new Uint16Array(r2) : new Uint32Array(r2);
  const l3 = i2 / n2, c2 = a2 / s2;
  let h2, d2, u2, g2, p2 = 0;
  const f2 = new Uint16Array(n2), m2 = i2;
  for (h2 = 0; h2 < n2; h2++)
    f2[h2] = Math.floor(h2 * l3);
  for (h2 = 0; h2 < s2; h2++)
    for (u2 = Math.floor(h2 * c2) * m2, d2 = 0; d2 < n2; d2++)
      g2 = u2 + f2[d2], o2[p2++] = e2[g2];
  return o2;
}
function normalizeBlendMode(e2, t2 = false) {
  if (Array.isArray(e2)) {
    for (const t3 of e2) {
      const e3 = normalizeBlendMode(t3, true);
      if (e3)
        return e3;
    }
    return warn$1(`Unsupported blend mode Array: ${e2}`), "source-over";
  }
  if (!(e2 instanceof Name))
    return t2 ? null : "source-over";
  switch (e2.name) {
    case "Normal":
    case "Compatible":
      return "source-over";
    case "Multiply":
      return "multiply";
    case "Screen":
      return "screen";
    case "Overlay":
      return "overlay";
    case "Darken":
      return "darken";
    case "Lighten":
      return "lighten";
    case "ColorDodge":
      return "color-dodge";
    case "ColorBurn":
      return "color-burn";
    case "HardLight":
      return "hard-light";
    case "SoftLight":
      return "soft-light";
    case "Difference":
      return "difference";
    case "Exclusion":
      return "exclusion";
    case "Hue":
      return "hue";
    case "Saturation":
      return "saturation";
    case "Color":
      return "color";
    case "Luminosity":
      return "luminosity";
  }
  return t2 ? null : (warn$1(`Unsupported blend mode: ${e2.name}`), "source-over");
}
function addCachedImageOps(e2, { objId: t2, fn: i2, args: a2, optionalContent: n2, hasMask: s2 }) {
  t2 && e2.addDependency(t2), e2.addImageOps(i2, a2, n2, s2), i2 === Et && a2[0]?.count > 0 && a2[0].count++;
}
function parseDefaultAppearance(e2) {
  return new DefaultAppearanceEvaluator(e2).parse();
}
function getPdfColor(e2, t2) {
  if (e2[0] === e2[1] && e2[1] === e2[2]) {
    return `${numberToString(e2[0] / 255)} ${t2 ? "g" : "G"}`;
  }
  return Array.from(e2, (e3) => numberToString(e3 / 255)).join(" ") + " " + (t2 ? "rg" : "RG");
}
function clearGlobalCaches() {
  mn = /* @__PURE__ */ Object.create(null), hi = /* @__PURE__ */ Object.create(null), di = /* @__PURE__ */ Object.create(null), ui = /* @__PURE__ */ Object.create(null), Aa.clear(), JpxImage.cleanup();
}
function pickPlatformItem(e2) {
  return e2 instanceof Dict ? e2.has("UF") ? e2.get("UF") : e2.has("F") ? e2.get("F") : e2.has("Unix") ? e2.get("Unix") : e2.has("Mac") ? e2.get("Mac") : e2.has("DOS") ? e2.get("DOS") : null : null;
}
function isWhitespace(e2, t2) {
  const i2 = e2[t2];
  return " " === i2 || "\n" === i2 || "\r" === i2 || "	" === i2;
}
function fetchDest(e2) {
  return e2 instanceof Dict && (e2 = e2.get("D")), Ls(e2) ? e2 : null;
}
function fetchRemoteDest(e2) {
  let t2 = e2.get("D");
  if (t2) {
    if (t2 instanceof Name && (t2 = t2.name), "string" == typeof t2)
      return stringToPDFString(t2, true);
    if (Ls(t2))
      return JSON.stringify(t2);
  }
  return null;
}
function mayHaveChildren(e2) {
  return e2 instanceof Ref || e2 instanceof Dict || e2 instanceof BaseStream || Array.isArray(e2);
}
function addChildren(e2, t2) {
  if (e2 instanceof Dict)
    e2 = e2.getRawValues();
  else if (e2 instanceof BaseStream)
    e2 = e2.dict.getRawValues();
  else if (!Array.isArray(e2))
    return;
  for (const i2 of e2)
    mayHaveChildren(i2) && t2.push(i2);
}
function stripQuotes(e2) {
  return e2.startsWith("'") || e2.startsWith('"') ? e2.slice(1, -1) : e2;
}
function getInteger({ data: e2, defaultValue: t2, validate: i2 }) {
  if (!e2)
    return t2;
  e2 = e2.trim();
  const a2 = parseInt(e2, 10);
  return !isNaN(a2) && i2(a2) ? a2 : t2;
}
function getFloat({ data: e2, defaultValue: t2, validate: i2 }) {
  if (!e2)
    return t2;
  e2 = e2.trim();
  const a2 = parseFloat(e2);
  return !isNaN(a2) && i2(a2) ? a2 : t2;
}
function getKeyword({ data: e2, defaultValue: t2, validate: i2 }) {
  return e2 && i2(e2 = e2.trim()) ? e2 : t2;
}
function getStringOption(e2, t2) {
  return getKeyword({ data: e2, defaultValue: t2[0], validate: (e3) => t2.includes(e3) });
}
function getMeasurement(e2, t2 = "0") {
  if (t2 ||= "0", !e2)
    return getMeasurement(t2);
  const i2 = e2.trim().match(ao);
  if (!i2)
    return getMeasurement(t2);
  const [, a2, n2] = i2, s2 = parseFloat(a2);
  if (isNaN(s2))
    return getMeasurement(t2);
  if (0 === s2)
    return 0;
  const r2 = io[n2];
  return r2 ? r2(s2) : s2;
}
function getRatio(e2) {
  if (!e2)
    return { num: 1, den: 1 };
  const t2 = e2.split(":", 2).map((e3) => parseFloat(e3.trim())).filter((e3) => !isNaN(e3));
  if (1 === t2.length && t2.push(1), 0 === t2.length)
    return { num: 1, den: 1 };
  const [i2, a2] = t2;
  return { num: i2, den: a2 };
}
function getRelevant(e2) {
  return e2 ? e2.trim().split(/\s+/).map((e3) => ({ excluded: "-" === e3[0], viewname: e3.substring(1) })) : [];
}
function selectFont(e2, t2) {
  return "italic" === e2.posture ? "bold" === e2.weight ? t2.bolditalic : t2.italic : "bold" === e2.weight ? t2.bold : t2.regular;
}
function parseIndex(e2) {
  return "*" === (e2 = e2.trim()) ? 1 / 0 : parseInt(e2, 10) || 0;
}
function parseExpression(e2, t2, i2 = true) {
  let a2 = e2.match(no);
  if (!a2)
    return null;
  let [n2] = a2;
  const s2 = [{ name: n2, cacheName: "." + n2, index: 0, js: null, formCalc: null, operator: ro }];
  let r2 = n2.length;
  for (; r2 < e2.length; ) {
    const o2 = r2;
    if ("[" === e2.charAt(r2++)) {
      if (a2 = e2.slice(r2).match(so), !a2)
        return warn$1("XFA - Invalid index in SOM expression"), null;
      s2.at(-1).index = parseIndex(a2[0]), r2 += a2[0].length + 1;
      continue;
    }
    let l3;
    switch (e2.charAt(r2)) {
      case ".":
        if (!t2)
          return null;
        r2++, l3 = oo;
        break;
      case "#":
        r2++, l3 = lo;
        break;
      case "[":
        if (i2)
          return warn$1("XFA - SOM expression contains a FormCalc subexpression which is not supported for now."), null;
        l3 = co;
        break;
      case "(":
        if (i2)
          return warn$1("XFA - SOM expression contains a JavaScript subexpression which is not supported for now."), null;
        l3 = ho;
        break;
      default:
        l3 = ro;
    }
    if (a2 = e2.slice(r2).match(no), !a2)
      break;
    [n2] = a2, r2 += n2.length, s2.push({ name: n2, cacheName: e2.slice(o2, r2), operator: l3, index: 0, js: null, formCalc: null });
  }
  return s2;
}
function searchNode(e2, t2, i2, a2 = true, n2 = true) {
  const s2 = parseExpression(i2, a2);
  if (!s2)
    return null;
  const r2 = uo.get(s2[0].name);
  let o2, l3 = 0;
  r2 ? (o2 = true, e2 = [r2(e2, t2)], l3 = 1) : (o2 = null === t2, e2 = [t2 || e2]);
  for (let i3 = s2.length; l3 < i3; l3++) {
    const { name: i4, cacheName: a3, operator: r3, index: c2 } = s2[l3], h2 = [];
    for (const t3 of e2) {
      if (!t3.isXFAObject)
        continue;
      let e3, s3;
      if (n2 && (s3 = go.get(t3), s3 || (s3 = /* @__PURE__ */ new Map(), go.set(t3, s3)), e3 = s3.get(a3)), !e3) {
        switch (r3) {
          case ro:
            e3 = t3[nr](i4, false);
            break;
          case oo:
            e3 = t3[nr](i4, true);
            break;
          case lo:
            e3 = t3[ar](i4), e3 = e3.isXFAObjectArray ? e3.children : [e3];
        }
        n2 && s3.set(a3, e3);
      }
      e3.length > 0 && h2.push(e3);
    }
    if (0 === h2.length && !o2 && 0 === l3) {
      const i5 = t2[gr]();
      if (!(t2 = i5))
        return null;
      l3 = -1, e2 = [t2];
      continue;
    }
    e2 = isFinite(c2) ? h2.filter((e3) => c2 < e3.length).map((e3) => e3[c2]) : h2.flat();
  }
  return 0 === e2.length ? null : e2;
}
function createDataNode(e2, t2, i2) {
  const a2 = parseExpression(i2);
  if (!a2)
    return null;
  if (a2.some((e3) => e3.operator === oo))
    return null;
  const n2 = uo.get(a2[0].name);
  let s2 = 0;
  n2 ? (e2 = n2(e2, t2), s2 = 1) : e2 = t2 || e2;
  for (let t3 = a2.length; s2 < t3; s2++) {
    const { name: t4, operator: i3, index: n3 } = a2[s2];
    if (!isFinite(n3))
      return a2[s2].index = 0, e2.createNodes(a2.slice(s2));
    let r2;
    switch (i3) {
      case ro:
        r2 = e2[nr](t4, false);
        break;
      case oo:
        r2 = e2[nr](t4, true);
        break;
      case lo:
        r2 = e2[ar](t4), r2 = r2.isXFAObjectArray ? r2.children : [r2];
    }
    if (0 === r2.length)
      return e2.createNodes(a2.slice(s2));
    if (!(n3 < r2.length))
      return a2[s2].index = n3 - r2.length, e2.createNodes(a2.slice(s2));
    {
      const t5 = r2[n3];
      if (!t5.isXFAObject)
        return warn$1("XFA - Cannot create a node."), null;
      e2 = t5;
    }
  }
  return null;
}
function measureToString(e2) {
  return "string" == typeof e2 ? "0px" : Number.isInteger(e2) ? `${e2}px` : `${e2.toFixed(2)}px`;
}
function setMinMaxDimensions(e2, t2) {
  "position" === e2[ur]().layout && (e2.minW > 0 && (t2.minWidth = measureToString(e2.minW)), e2.maxW > 0 && (t2.maxWidth = measureToString(e2.maxW)), e2.minH > 0 && (t2.minHeight = measureToString(e2.minH)), e2.maxH > 0 && (t2.maxHeight = measureToString(e2.maxH)));
}
function layoutText(e2, t2, i2, a2, n2, s2) {
  const r2 = new TextMeasure(t2, i2, a2, n2);
  return "string" == typeof e2 ? r2.addString(e2) : e2[Nr](r2), r2.compute(s2);
}
function layoutNode(e2, t2) {
  let i2 = null, a2 = null, n2 = false;
  if ((!e2.w || !e2.h) && e2.value) {
    let s2 = 0, r2 = 0;
    e2.margin && (s2 = e2.margin.leftInset + e2.margin.rightInset, r2 = e2.margin.topInset + e2.margin.bottomInset);
    let o2 = null, l3 = null;
    e2.para && (l3 = /* @__PURE__ */ Object.create(null), o2 = "" === e2.para.lineHeight ? null : e2.para.lineHeight, l3.top = "" === e2.para.spaceAbove ? 0 : e2.para.spaceAbove, l3.bottom = "" === e2.para.spaceBelow ? 0 : e2.para.spaceBelow, l3.left = "" === e2.para.marginLeft ? 0 : e2.para.marginLeft, l3.right = "" === e2.para.marginRight ? 0 : e2.para.marginRight);
    let c2 = e2.font;
    if (!c2) {
      const t3 = e2[pr]();
      let i3 = e2[gr]();
      for (; i3 && i3 !== t3; ) {
        if (i3.font) {
          c2 = i3.font;
          break;
        }
        i3 = i3[gr]();
      }
    }
    const h2 = (e2.w || t2.width) - s2, d2 = e2[fr].fontFinder;
    if (e2.value.exData && e2.value.exData[Vs] && "text/html" === e2.value.exData.contentType) {
      const t3 = layoutText(e2.value.exData[Vs], c2, l3, o2, d2, h2);
      a2 = t3.width, i2 = t3.height, n2 = t3.isBroken;
    } else {
      const t3 = e2.value[Vr]();
      if (t3) {
        const e3 = layoutText(t3, c2, l3, o2, d2, h2);
        a2 = e3.width, i2 = e3.height, n2 = e3.isBroken;
      }
    }
    null === a2 || e2.w || (a2 += s2), null === i2 || e2.h || (i2 += r2);
  }
  return { w: a2, h: i2, isBroken: n2 };
}
function computeBbox(e2, t2, i2) {
  let a2;
  if ("" !== e2.w && "" !== e2.h)
    a2 = [e2.x, e2.y, e2.w, e2.h];
  else {
    if (!i2)
      return null;
    let n2 = e2.w;
    if ("" === n2) {
      if (0 === e2.maxW) {
        const t3 = e2[ur]();
        n2 = "position" === t3.layout && "" !== t3.w ? 0 : e2.minW;
      } else
        n2 = Math.min(e2.maxW, i2.width);
      t2.attributes.style.width = measureToString(n2);
    }
    let s2 = e2.h;
    if ("" === s2) {
      if (0 === e2.maxH) {
        const t3 = e2[ur]();
        s2 = "position" === t3.layout && "" !== t3.h ? 0 : e2.minH;
      } else
        s2 = Math.min(e2.maxH, i2.height);
      t2.attributes.style.height = measureToString(s2);
    }
    a2 = [e2.x, e2.y, n2, s2];
  }
  return a2;
}
function fixDimensions(e2) {
  const t2 = e2[ur]();
  if (t2.layout?.includes("row")) {
    const i2 = t2[Js], a2 = e2.colSpan;
    let n2;
    n2 = -1 === a2 ? Math.sumPrecise(i2.columnWidths.slice(i2.currentColumn)) : Math.sumPrecise(i2.columnWidths.slice(i2.currentColumn, i2.currentColumn + a2)), isNaN(n2) || (e2.w = n2);
  }
  t2.layout && "position" !== t2.layout && (e2.x = e2.y = 0), "table" === e2.layout && "" === e2.w && Array.isArray(e2.columnWidths) && (e2.w = Math.sumPrecise(e2.columnWidths));
}
function layoutClass(e2) {
  switch (e2.layout) {
    case "position":
    default:
      return "xfaPosition";
    case "lr-tb":
      return "xfaLrTb";
    case "rl-row":
      return "xfaRlRow";
    case "rl-tb":
      return "xfaRlTb";
    case "row":
      return "xfaRow";
    case "table":
      return "xfaTable";
    case "tb":
      return "xfaTb";
  }
}
function toStyle(e2, ...t2) {
  const i2 = /* @__PURE__ */ Object.create(null);
  for (const a2 of t2) {
    const t3 = e2[a2];
    if (null !== t3) {
      if (Po.hasOwnProperty(a2))
        Po[a2](e2, i2);
      else if (t3 instanceof XFAObject) {
        const e3 = t3[Zr]();
        e3 ? Object.assign(i2, e3) : warn$1(`(DEBUG) - XFA - style for ${a2} not implemented yet`);
      }
    }
  }
  return i2;
}
function createWrapper(e2, t2) {
  const { attributes: i2 } = t2, { style: a2 } = i2, n2 = { name: "div", attributes: { class: ["xfaWrapper"], style: /* @__PURE__ */ Object.create(null) }, children: [] };
  if (i2.class.push("xfaWrapped"), e2.border) {
    const { widths: i3, insets: s2 } = e2.border[Js];
    let r2, o2, l3 = s2[0], c2 = s2[3];
    const h2 = s2[0] + s2[2], d2 = s2[1] + s2[3];
    switch (e2.border.hand) {
      case "even":
        l3 -= i3[0] / 2, c2 -= i3[3] / 2, r2 = `calc(100% + ${(i3[1] + i3[3]) / 2 - d2}px)`, o2 = `calc(100% + ${(i3[0] + i3[2]) / 2 - h2}px)`;
        break;
      case "left":
        l3 -= i3[0], c2 -= i3[3], r2 = `calc(100% + ${i3[1] + i3[3] - d2}px)`, o2 = `calc(100% + ${i3[0] + i3[2] - h2}px)`;
        break;
      case "right":
        r2 = d2 ? `calc(100% - ${d2}px)` : "100%", o2 = h2 ? `calc(100% - ${h2}px)` : "100%";
    }
    const u2 = ["xfaBorder"];
    isPrintOnly(e2.border) && u2.push("xfaPrintOnly");
    const g2 = { name: "div", attributes: { class: u2, style: { top: `${l3}px`, left: `${c2}px`, width: r2, height: o2 } }, children: [] };
    for (const e3 of ["border", "borderWidth", "borderColor", "borderRadius", "borderStyle"])
      void 0 !== a2[e3] && (g2.attributes.style[e3] = a2[e3], delete a2[e3]);
    n2.children.push(g2, t2);
  } else
    n2.children.push(t2);
  for (const e3 of ["background", "backgroundClip", "top", "left", "width", "height", "minWidth", "minHeight", "maxWidth", "maxHeight", "transform", "transformOrigin", "visibility"])
    void 0 !== a2[e3] && (n2.attributes.style[e3] = a2[e3], delete a2[e3]);
  return n2.attributes.style.position = "absolute" === a2.position ? "absolute" : "relative", delete a2.position, a2.alignSelf && (n2.attributes.style.alignSelf = a2.alignSelf, delete a2.alignSelf), n2;
}
function fixTextIndent(e2) {
  const t2 = getMeasurement(e2.textIndent, "0px");
  if (t2 >= 0)
    return;
  const i2 = "padding" + ("left" === ("right" === e2.textAlign ? "right" : "left") ? "Left" : "Right"), a2 = getMeasurement(e2[i2], "0px");
  e2[i2] = a2 - t2 + "px";
}
function setAccess(e2, t2) {
  switch (e2.access) {
    case "nonInteractive":
      t2.push("xfaNonInteractive");
      break;
    case "readOnly":
      t2.push("xfaReadOnly");
      break;
    case "protected":
      t2.push("xfaDisabled");
  }
}
function isPrintOnly(e2) {
  return e2.relevant.length > 0 && !e2.relevant[0].excluded && "print" === e2.relevant[0].viewname;
}
function getCurrentPara(e2) {
  const t2 = e2[pr]()[Js].paraStack;
  return t2.length ? t2.at(-1) : null;
}
function setPara(e2, t2, i2) {
  if (i2.attributes.class?.includes("xfaRich")) {
    t2 && ("" === e2.h && (t2.height = "auto"), "" === e2.w && (t2.width = "auto"));
    const a2 = getCurrentPara(e2);
    if (a2) {
      const e3 = i2.attributes.style;
      switch (e3.display = "flex", e3.flexDirection = "column", a2.vAlign) {
        case "top":
          e3.justifyContent = "start";
          break;
        case "bottom":
          e3.justifyContent = "end";
          break;
        case "middle":
          e3.justifyContent = "center";
      }
      const t3 = a2[Zr]();
      for (const [i3, a3] of Object.entries(t3))
        i3 in e3 || (e3[i3] = a3);
    }
  }
}
function setFontFamily(e2, t2, i2, a2) {
  if (!i2)
    return void delete a2.fontFamily;
  const n2 = stripQuotes(e2.typeface);
  a2.fontFamily = `"${n2}"`;
  const s2 = i2.find(n2);
  if (s2) {
    const { fontFamily: i3 } = s2.regular.cssFontInfo;
    i3 !== n2 && (a2.fontFamily = `"${i3}"`);
    const r2 = getCurrentPara(t2);
    if (r2 && "" !== r2.lineHeight)
      return;
    if (a2.lineHeight)
      return;
    const o2 = selectFont(e2, s2);
    o2 && (a2.lineHeight = Math.max(1.2, o2.lineHeight));
  }
}
function fixURL(e2) {
  const t2 = createValidAbsoluteUrl$1(e2, null, { addDefaultProtocol: true, tryConvertEncoding: true });
  return t2 ? t2.href : null;
}
function createLine(e2, t2) {
  return { name: "div", attributes: { class: ["lr-tb" === e2.layout ? "xfaLr" : "xfaRl"] }, children: t2 };
}
function flushHTML(e2) {
  if (!e2[Js])
    return null;
  const t2 = { name: "div", attributes: e2[Js].attributes, children: e2[Js].children };
  if (e2[Js].failingNode) {
    const i2 = e2[Js].failingNode[Qs]();
    i2 && (e2.layout.endsWith("-tb") ? t2.children.push(createLine(e2, [i2])) : t2.children.push(i2));
  }
  return 0 === t2.children.length ? null : t2;
}
function addHTML(e2, t2, i2) {
  const a2 = e2[Js], n2 = a2.availableSpace, [s2, r2, o2, l3] = i2;
  switch (e2.layout) {
    case "position":
      a2.width = Math.max(a2.width, s2 + o2), a2.height = Math.max(a2.height, r2 + l3), a2.children.push(t2);
      break;
    case "lr-tb":
    case "rl-tb":
      a2.line && 1 !== a2.attempt || (a2.line = createLine(e2, []), a2.children.push(a2.line), a2.numberInLine = 0), a2.numberInLine += 1, a2.line.children.push(t2), 0 === a2.attempt ? (a2.currentWidth += o2, a2.height = Math.max(a2.height, a2.prevHeight + l3)) : (a2.currentWidth = o2, a2.prevHeight = a2.height, a2.height += l3, a2.attempt = 0), a2.width = Math.max(a2.width, a2.currentWidth);
      break;
    case "rl-row":
    case "row": {
      a2.children.push(t2), a2.width += o2, a2.height = Math.max(a2.height, l3);
      const e3 = measureToString(a2.height);
      for (const t3 of a2.children)
        t3.attributes.style.height = e3;
      break;
    }
    case "table":
    case "tb":
      a2.width = MathClamp$1(o2, a2.width, n2.width), a2.height += l3, a2.children.push(t2);
  }
}
function getAvailableSpace(e2) {
  const t2 = e2[Js].availableSpace, i2 = e2.margin ? e2.margin.topInset + e2.margin.bottomInset : 0, a2 = e2.margin ? e2.margin.leftInset + e2.margin.rightInset : 0;
  switch (e2.layout) {
    case "lr-tb":
    case "rl-tb":
      return 0 === e2[Js].attempt ? { width: t2.width - a2 - e2[Js].currentWidth, height: t2.height - i2 - e2[Js].prevHeight } : { width: t2.width - a2, height: t2.height - i2 - e2[Js].height };
    case "rl-row":
    case "row":
      return { width: Math.sumPrecise(e2[Js].columnWidths.slice(e2[Js].currentColumn)), height: t2.height - a2 };
    case "table":
    case "tb":
      return { width: t2.width - a2, height: t2.height - i2 - e2[Js].height };
    default:
      return t2;
  }
}
function checkDimensions(e2, t2) {
  if (null === e2[pr]()[Js].firstUnsplittable)
    return true;
  if (0 === e2.w || 0 === e2.h)
    return true;
  const i2 = e2[ur](), a2 = i2[Js]?.attempt || 0, [, n2, s2, r2] = function(e3) {
    let t3, i3, a3 = "" === e3.w ? NaN : e3.w, n3 = "" === e3.h ? NaN : e3.h, [s3, r3] = [0, 0];
    switch (e3.anchorType || "") {
      case "bottomCenter":
        [s3, r3] = [a3 / 2, n3];
        break;
      case "bottomLeft":
        [s3, r3] = [0, n3];
        break;
      case "bottomRight":
        [s3, r3] = [a3, n3];
        break;
      case "middleCenter":
        [s3, r3] = [a3 / 2, n3 / 2];
        break;
      case "middleLeft":
        [s3, r3] = [0, n3 / 2];
        break;
      case "middleRight":
        [s3, r3] = [a3, n3 / 2];
        break;
      case "topCenter":
        [s3, r3] = [a3 / 2, 0];
        break;
      case "topRight":
        [s3, r3] = [a3, 0];
    }
    switch (e3.rotate || 0) {
      case 0:
        [t3, i3] = [-s3, -r3];
        break;
      case 90:
        [t3, i3] = [-r3, s3], [a3, n3] = [n3, -a3];
        break;
      case 180:
        [t3, i3] = [s3, r3], [a3, n3] = [-a3, -n3];
        break;
      case 270:
        [t3, i3] = [r3, -s3], [a3, n3] = [-n3, a3];
    }
    return [e3.x + t3 + Math.min(0, a3), e3.y + i3 + Math.min(0, n3), Math.abs(a3), Math.abs(n3)];
  }(e2);
  switch (i2.layout) {
    case "lr-tb":
    case "rl-tb":
      return 0 === a2 ? e2[pr]()[Js].noLayoutFailure ? "" !== e2.w ? Math.round(s2 - t2.width) <= 2 : t2.width > 2 : !("" !== e2.h && Math.round(r2 - t2.height) > 2) && ("" !== e2.w ? Math.round(s2 - t2.width) <= 2 || 0 === i2[Js].numberInLine && t2.height > 2 : t2.width > 2) : !!e2[pr]()[Js].noLayoutFailure || !("" !== e2.h && Math.round(r2 - t2.height) > 2) && (("" === e2.w || Math.round(s2 - t2.width) <= 2 || !i2[Tr]()) && t2.height > 2);
    case "table":
    case "tb":
      return !!e2[pr]()[Js].noLayoutFailure || ("" === e2.h || e2[kr]() ? ("" === e2.w || Math.round(s2 - t2.width) <= 2 || !i2[Tr]()) && t2.height > 2 : Math.round(r2 - t2.height) <= 2);
    case "position":
      if (e2[pr]()[Js].noLayoutFailure)
        return true;
      if ("" === e2.h || Math.round(r2 + n2 - t2.height) <= 2)
        return true;
      return r2 + n2 > e2[pr]()[Js].currentContentArea.h;
    case "rl-row":
    case "row":
      return !!e2[pr]()[Js].noLayoutFailure || ("" === e2.h || Math.round(r2 - t2.height) <= 2);
    default:
      return true;
  }
}
function getBorderDims(e2) {
  if (!e2 || !e2.border)
    return { w: 0, h: 0 };
  const t2 = e2.border[or]();
  return t2 ? { w: t2.widths[0] + t2.widths[2] + t2.insets[0] + t2.insets[2], h: t2.widths[1] + t2.widths[3] + t2.insets[1] + t2.insets[3] } : { w: 0, h: 0 };
}
function hasMargin(e2) {
  return e2.margin && (e2.margin.topInset || e2.margin.rightInset || e2.margin.bottomInset || e2.margin.leftInset);
}
function _setValue(e2, t2) {
  if (!e2.value) {
    const t3 = new Value({});
    e2[$s](t3), e2.value = t3;
  }
  e2.value[Wr](t2);
}
function* getContainedChildren(e2) {
  for (const t2 of e2[cr]())
    t2 instanceof SubformSet ? yield* t2[hr]() : yield t2;
}
function isRequired(e2) {
  return "error" === e2.validate?.nullTest;
}
function setTabIndex(e2) {
  for (; e2; ) {
    if (!e2.traversal)
      return void (e2[Gr] = e2[gr]()[Gr]);
    if (e2[Gr])
      return;
    let t2 = null;
    for (const i3 of e2.traversal[cr]())
      if ("next" === i3.operation) {
        t2 = i3;
        break;
      }
    if (!t2 || !t2.ref)
      return void (e2[Gr] = e2[gr]()[Gr]);
    const i2 = e2[pr]();
    e2[Gr] = ++i2[Gr];
    const a2 = i2[qr](t2.ref, e2);
    if (!a2)
      return;
    e2 = a2[0];
  }
}
function applyAssist(e2, t2) {
  const i2 = e2.assist;
  if (i2) {
    const e3 = i2[Yr]();
    e3 && (t2.title = e3);
    const a2 = i2.role.match(No);
    if (a2) {
      const e4 = "heading", i3 = a2[1];
      t2.role = e4, t2["aria-level"] = i3;
    }
  }
  if ("table" === e2.layout)
    t2.role = "table";
  else if ("row" === e2.layout)
    t2.role = "row";
  else {
    const i3 = e2[gr]();
    "row" === i3.layout && (t2.role = "TH" === i3.assist?.role ? "columnheader" : "cell");
  }
}
function ariaLabel(e2) {
  if (!e2.assist)
    return null;
  const t2 = e2.assist;
  return t2.speak && "" !== t2.speak[Vs] ? t2.speak[Vs] : t2.toolTip ? t2.toolTip[Vs] : null;
}
function valueToHtml(e2) {
  return HTMLResult.success({ name: "div", attributes: { class: ["xfaRich"], style: /* @__PURE__ */ Object.create(null) }, children: [{ name: "span", attributes: { style: /* @__PURE__ */ Object.create(null) }, value: e2 }] });
}
function setFirstUnsplittable(e2) {
  const t2 = e2[pr]();
  null === t2[Js].firstUnsplittable && (t2[Js].firstUnsplittable = e2, t2[Js].noLayoutFailure = true);
}
function unsetFirstUnsplittable(e2) {
  const t2 = e2[pr]();
  t2[Js].firstUnsplittable === e2 && (t2[Js].noLayoutFailure = false);
}
function handleBreak(e2) {
  if (e2[Js])
    return false;
  if (e2[Js] = /* @__PURE__ */ Object.create(null), "auto" === e2.targetType)
    return false;
  const t2 = e2[pr]();
  let i2 = null;
  if (e2.target) {
    if (i2 = t2[qr](e2.target, e2[gr]()), !i2)
      return false;
    i2 = i2[0];
  }
  const { currentPageArea: a2, currentContentArea: n2 } = t2[Js];
  if ("pageArea" === e2.targetType)
    return i2 instanceof PageArea || (i2 = null), e2.startNew ? (e2[Js].target = i2 || a2, true) : !(!i2 || i2 === a2) && (e2[Js].target = i2, true);
  i2 instanceof ContentArea || (i2 = null);
  const s2 = i2 && i2[gr]();
  let r2, o2 = s2;
  if (e2.startNew)
    if (i2) {
      const e3 = s2.contentArea.children, t3 = e3.indexOf(n2), a3 = e3.indexOf(i2);
      -1 !== t3 && t3 < a3 && (o2 = null), r2 = a3 - 1;
    } else
      r2 = a2.contentArea.children.indexOf(n2);
  else {
    if (!i2 || i2 === n2)
      return false;
    r2 = s2.contentArea.children.indexOf(i2) - 1, o2 = s2 === a2 ? null : s2;
  }
  return e2[Js].target = o2, e2[Js].index = r2, true;
}
function handleOverflow(e2, t2, i2) {
  const a2 = e2[pr](), n2 = a2[Js].noLayoutFailure, s2 = t2[ur];
  t2[ur] = () => e2, a2[Js].noLayoutFailure = true;
  const r2 = t2[Yr](i2);
  e2[js](r2.html, r2.bbox), a2[Js].noLayoutFailure = n2, t2[ur] = s2;
}
function createText(e2) {
  const t2 = new Text({});
  return t2[Vs] = e2, t2;
}
function mapStyle(e2, t2, i2) {
  const a2 = /* @__PURE__ */ Object.create(null);
  if (!e2)
    return a2;
  const n2 = /* @__PURE__ */ Object.create(null);
  for (const [t3, i3] of e2.split(";").map((e3) => e3.split(":", 2))) {
    const e3 = el.get(t3);
    if ("" === e3)
      continue;
    let s2 = i3;
    e3 && (s2 = "string" == typeof e3 ? e3 : e3(i3, n2)), t3.endsWith("scale") ? a2.transform = a2.transform ? `${a2[t3]} ${s2}` : s2 : a2[t3.replaceAll(/-([a-zA-Z])/g, (e4, t4) => t4.toUpperCase())] = s2;
  }
  if (a2.fontFamily && setFontFamily({ typeface: a2.fontFamily, weight: a2.fontWeight || "normal", posture: a2.fontStyle || "normal", size: n2.fontSize || 0 }, t2, t2[fr].fontFinder, a2), i2 && a2.verticalAlign && "0px" !== a2.verticalAlign && a2.fontSize) {
    const e3 = 0.583, t3 = 0.333, i3 = getMeasurement(a2.fontSize);
    a2.fontSize = measureToString(i3 * e3), a2.verticalAlign = measureToString(Math.sign(getMeasurement(a2.verticalAlign)) * i3 * t3);
  }
  return i2 && a2.fontSize && (a2.fontSize = `calc(${a2.fontSize} * var(--total-scale-factor))`), fixTextIndent(a2), a2;
}
function getRgbColor(e2, t2 = new Uint8ClampedArray(3)) {
  if (!Array.isArray(e2))
    return t2;
  const i2 = t2 || new Uint8ClampedArray(3);
  switch (e2.length) {
    case 0:
      return null;
    case 1:
      return ColorSpaceUtils.gray.getRgbItem(e2, 0, i2, 0), i2;
    case 3:
      return ColorSpaceUtils.rgb.getRgbItem(e2, 0, i2, 0), i2;
    case 4:
      return ColorSpaceUtils.cmyk.getRgbItem(e2, 0, i2, 0), i2;
    default:
      return t2;
  }
}
function getPdfColorArray(e2, t2 = null) {
  return e2 && Array.from(e2, (e3) => e3 / 255) || t2;
}
function getQuadPoints(e2, t2) {
  const i2 = e2.getArray("QuadPoints");
  if (!isNumberArray(i2, null) || 0 === i2.length || i2.length % 8 > 0)
    return null;
  const a2 = new Float32Array(i2.length);
  for (let e3 = 0, n2 = i2.length; e3 < n2; e3 += 8) {
    const [n3, s2, r2, o2, l3, c2, h2, d2] = i2.slice(e3, e3 + 8), u2 = Math.min(n3, r2, l3, h2), g2 = Math.max(n3, r2, l3, h2), p2 = Math.min(s2, o2, c2, d2), f2 = Math.max(s2, o2, c2, d2);
    if (null !== t2 && (u2 < t2[0] || g2 > t2[2] || p2 < t2[1] || f2 > t2[3]))
      return null;
    a2.set([u2, f2, g2, f2, u2, p2, g2, p2], e3);
  }
  return a2;
}
function getTransformMatrix(e2, t2, i2) {
  const a2 = new Float32Array([1 / 0, 1 / 0, -1 / 0, -1 / 0]);
  ni.axialAlignedBoundingBox(t2, i2, a2);
  const [n2, s2, r2, o2] = a2;
  if (n2 === r2 || s2 === o2)
    return [1, 0, 0, 1, e2[0], e2[1]];
  const l3 = (e2[2] - e2[0]) / (r2 - n2), c2 = (e2[3] - e2[1]) / (o2 - s2);
  return [l3, 0, 0, c2, e2[0] - n2 * l3, e2[1] - s2 * c2];
}
function calculateMD5(e2, t2, i2) {
  let a2 = 1732584193, n2 = -271733879, s2 = -1732584194, r2 = 271733878;
  const o2 = i2 + 72 & -64, l3 = new Uint8Array(o2);
  let c2, h2;
  for (c2 = 0; c2 < i2; ++c2)
    l3[c2] = e2[t2++];
  l3[c2++] = 128;
  const d2 = o2 - 8;
  c2 < d2 && (c2 = d2), l3[c2++] = i2 << 3 & 255, l3[c2++] = i2 >> 5 & 255, l3[c2++] = i2 >> 13 & 255, l3[c2++] = i2 >> 21 & 255, l3[c2++] = i2 >>> 29 & 255, c2 += 3;
  const u2 = new Int32Array(16), { k: g2, r: p2 } = rl;
  for (c2 = 0; c2 < o2; ) {
    for (h2 = 0; h2 < 16; ++h2, c2 += 4)
      u2[h2] = l3[c2] | l3[c2 + 1] << 8 | l3[c2 + 2] << 16 | l3[c2 + 3] << 24;
    let e3, t3, i3 = a2, o3 = n2, d3 = s2, f2 = r2;
    for (h2 = 0; h2 < 64; ++h2) {
      h2 < 16 ? (e3 = o3 & d3 | ~o3 & f2, t3 = h2) : h2 < 32 ? (e3 = f2 & o3 | ~f2 & d3, t3 = 5 * h2 + 1 & 15) : h2 < 48 ? (e3 = o3 ^ d3 ^ f2, t3 = 3 * h2 + 5 & 15) : (e3 = d3 ^ (o3 | ~f2), t3 = 7 * h2 & 15);
      const a3 = f2, n3 = i3 + e3 + g2[h2] + u2[t3] | 0, s3 = p2[h2];
      f2 = d3, d3 = o3, o3 = o3 + (n3 << s3 | n3 >>> 32 - s3) | 0, i3 = a3;
    }
    a2 = a2 + i3 | 0, n2 = n2 + o3 | 0, s2 = s2 + d3 | 0, r2 = r2 + f2 | 0;
  }
  return new Uint8Array([255 & a2, a2 >> 8 & 255, a2 >> 16 & 255, a2 >>> 24 & 255, 255 & n2, n2 >> 8 & 255, n2 >> 16 & 255, n2 >>> 24 & 255, 255 & s2, s2 >> 8 & 255, s2 >> 16 & 255, s2 >>> 24 & 255, 255 & r2, r2 >> 8 & 255, r2 >> 16 & 255, r2 >>> 24 & 255]);
}
function decodeString(e2) {
  try {
    return stringToUTF8String$1(e2);
  } catch (t2) {
    return warn$1(`UTF-8 decoding failed: "${t2}".`), e2;
  }
}
function ch(e2, t2, i2, a2, n2) {
  e2.assign(t2), e2.and(i2), n2.assign(t2), n2.not(), n2.and(a2), e2.xor(n2);
}
function maj(e2, t2, i2, a2, n2) {
  e2.assign(t2), e2.and(i2), n2.assign(t2), n2.and(a2), e2.xor(n2), n2.assign(i2), n2.and(a2), e2.xor(n2);
}
function sigma(e2, t2, i2) {
  e2.assign(t2), e2.rotateRight(28), i2.assign(t2), i2.rotateRight(34), e2.xor(i2), i2.assign(t2), i2.rotateRight(39), e2.xor(i2);
}
function sigmaPrime(e2, t2, i2) {
  e2.assign(t2), e2.rotateRight(14), i2.assign(t2), i2.rotateRight(18), e2.xor(i2), i2.assign(t2), i2.rotateRight(41), e2.xor(i2);
}
function littleSigma(e2, t2, i2) {
  e2.assign(t2), e2.rotateRight(1), i2.assign(t2), i2.rotateRight(8), e2.xor(i2), i2.assign(t2), i2.shiftRight(7), e2.xor(i2);
}
function littleSigmaPrime(e2, t2, i2) {
  e2.assign(t2), e2.rotateRight(19), i2.assign(t2), i2.rotateRight(61), e2.xor(i2), i2.assign(t2), i2.shiftRight(6), e2.xor(i2);
}
function calculateSHA512(e2, t2, i2, a2 = false) {
  let n2, s2, r2, o2, l3, c2, h2, d2;
  a2 ? (n2 = new Word64(3418070365, 3238371032), s2 = new Word64(1654270250, 914150663), r2 = new Word64(2438529370, 812702999), o2 = new Word64(355462360, 4144912697), l3 = new Word64(1731405415, 4290775857), c2 = new Word64(2394180231, 1750603025), h2 = new Word64(3675008525, 1694076839), d2 = new Word64(1203062813, 3204075428)) : (n2 = new Word64(1779033703, 4089235720), s2 = new Word64(3144134277, 2227873595), r2 = new Word64(1013904242, 4271175723), o2 = new Word64(2773480762, 1595750129), l3 = new Word64(1359893119, 2917565137), c2 = new Word64(2600822924, 725511199), h2 = new Word64(528734635, 4215389547), d2 = new Word64(1541459225, 327033209));
  const u2 = 128 * Math.ceil((i2 + 17) / 128), g2 = new Uint8Array(u2);
  let p2, f2;
  for (p2 = 0; p2 < i2; ++p2)
    g2[p2] = e2[t2++];
  g2[p2++] = 128;
  const m2 = u2 - 16;
  p2 < m2 && (p2 = m2), p2 += 11, g2[p2++] = i2 >>> 29 & 255, g2[p2++] = i2 >> 21 & 255, g2[p2++] = i2 >> 13 & 255, g2[p2++] = i2 >> 5 & 255, g2[p2++] = i2 << 3 & 255;
  const b2 = new Array(80);
  for (p2 = 0; p2 < 80; p2++)
    b2[p2] = new Word64(0, 0);
  const { k: y2 } = ol;
  let w2 = new Word64(0, 0), x2 = new Word64(0, 0), S2 = new Word64(0, 0), v2 = new Word64(0, 0), C2 = new Word64(0, 0), k2 = new Word64(0, 0), T2 = new Word64(0, 0), F2 = new Word64(0, 0);
  const M2 = new Word64(0, 0), D2 = new Word64(0, 0), E2 = new Word64(0, 0), O2 = new Word64(0, 0);
  let _2, R2;
  for (p2 = 0; p2 < u2; ) {
    for (f2 = 0; f2 < 16; ++f2)
      b2[f2].high = g2[p2] << 24 | g2[p2 + 1] << 16 | g2[p2 + 2] << 8 | g2[p2 + 3], b2[f2].low = g2[p2 + 4] << 24 | g2[p2 + 5] << 16 | g2[p2 + 6] << 8 | g2[p2 + 7], p2 += 8;
    for (f2 = 16; f2 < 80; ++f2)
      _2 = b2[f2], littleSigmaPrime(_2, b2[f2 - 2], O2), _2.add(b2[f2 - 7]), littleSigma(E2, b2[f2 - 15], O2), _2.add(E2), _2.add(b2[f2 - 16]);
    for (w2.assign(n2), x2.assign(s2), S2.assign(r2), v2.assign(o2), C2.assign(l3), k2.assign(c2), T2.assign(h2), F2.assign(d2), f2 = 0; f2 < 80; ++f2)
      M2.assign(F2), sigmaPrime(E2, C2, O2), M2.add(E2), ch(E2, C2, k2, T2, O2), M2.add(E2), M2.add(y2[f2]), M2.add(b2[f2]), sigma(D2, w2, O2), maj(E2, w2, x2, S2, O2), D2.add(E2), _2 = F2, F2 = T2, T2 = k2, k2 = C2, v2.add(M2), C2 = v2, v2 = S2, S2 = x2, x2 = w2, _2.assign(M2), _2.add(D2), w2 = _2;
    n2.add(w2), s2.add(x2), r2.add(S2), o2.add(v2), l3.add(C2), c2.add(k2), h2.add(T2), d2.add(F2);
  }
  return a2 ? (R2 = new Uint8Array(48), n2.copyTo(R2, 0), s2.copyTo(R2, 8), r2.copyTo(R2, 16), o2.copyTo(R2, 24), l3.copyTo(R2, 32), c2.copyTo(R2, 40)) : (R2 = new Uint8Array(64), n2.copyTo(R2, 0), s2.copyTo(R2, 8), r2.copyTo(R2, 16), o2.copyTo(R2, 24), l3.copyTo(R2, 32), c2.copyTo(R2, 40), h2.copyTo(R2, 48), d2.copyTo(R2, 56)), R2;
}
function calculateSHA384(e2, t2, i2) {
  return calculateSHA512(e2, t2, i2, true);
}
function rotr(e2, t2) {
  return e2 >>> t2 | e2 << 32 - t2;
}
function calculate_sha256_ch(e2, t2, i2) {
  return e2 & t2 ^ ~e2 & i2;
}
function calculate_sha256_maj(e2, t2, i2) {
  return e2 & t2 ^ e2 & i2 ^ t2 & i2;
}
function calculate_sha256_sigma(e2) {
  return rotr(e2, 2) ^ rotr(e2, 13) ^ rotr(e2, 22);
}
function calculate_sha256_sigmaPrime(e2) {
  return rotr(e2, 6) ^ rotr(e2, 11) ^ rotr(e2, 25);
}
function calculate_sha256_littleSigma(e2) {
  return rotr(e2, 7) ^ rotr(e2, 18) ^ e2 >>> 3;
}
function calculate_sha256_littleSigmaPrime(e2) {
  return rotr(e2, 17) ^ rotr(e2, 19) ^ e2 >>> 10;
}
function calculateSHA256(e2, t2, i2) {
  let a2 = 1779033703, n2 = 3144134277, s2 = 1013904242, r2 = 2773480762, o2 = 1359893119, l3 = 2600822924, c2 = 528734635, h2 = 1541459225;
  const d2 = 64 * Math.ceil((i2 + 9) / 64), u2 = new Uint8Array(d2);
  let g2, p2;
  for (g2 = 0; g2 < i2; ++g2)
    u2[g2] = e2[t2++];
  u2[g2++] = 128;
  const f2 = d2 - 8;
  g2 < f2 && (g2 = f2), g2 += 3, u2[g2++] = i2 >>> 29 & 255, u2[g2++] = i2 >> 21 & 255, u2[g2++] = i2 >> 13 & 255, u2[g2++] = i2 >> 5 & 255, u2[g2++] = i2 << 3 & 255;
  const m2 = new Uint32Array(64), { k: b2 } = ll;
  for (g2 = 0; g2 < d2; ) {
    for (p2 = 0; p2 < 16; ++p2)
      m2[p2] = u2[g2] << 24 | u2[g2 + 1] << 16 | u2[g2 + 2] << 8 | u2[g2 + 3], g2 += 4;
    for (p2 = 16; p2 < 64; ++p2)
      m2[p2] = calculate_sha256_littleSigmaPrime(m2[p2 - 2]) + m2[p2 - 7] + calculate_sha256_littleSigma(m2[p2 - 15]) + m2[p2 - 16] | 0;
    let e3, t3, i3 = a2, d3 = n2, f3 = s2, y2 = r2, w2 = o2, x2 = l3, S2 = c2, v2 = h2;
    for (p2 = 0; p2 < 64; ++p2)
      e3 = v2 + calculate_sha256_sigmaPrime(w2) + calculate_sha256_ch(w2, x2, S2) + b2[p2] + m2[p2], t3 = calculate_sha256_sigma(i3) + calculate_sha256_maj(i3, d3, f3), v2 = S2, S2 = x2, x2 = w2, w2 = y2 + e3 | 0, y2 = f3, f3 = d3, d3 = i3, i3 = e3 + t3 | 0;
    a2 = a2 + i3 | 0, n2 = n2 + d3 | 0, s2 = s2 + f3 | 0, r2 = r2 + y2 | 0, o2 = o2 + w2 | 0, l3 = l3 + x2 | 0, c2 = c2 + S2 | 0, h2 = h2 + v2 | 0;
  }
  return new Uint8Array([a2 >> 24 & 255, a2 >> 16 & 255, a2 >> 8 & 255, 255 & a2, n2 >> 24 & 255, n2 >> 16 & 255, n2 >> 8 & 255, 255 & n2, s2 >> 24 & 255, s2 >> 16 & 255, s2 >> 8 & 255, 255 & s2, r2 >> 24 & 255, r2 >> 16 & 255, r2 >> 8 & 255, 255 & r2, o2 >> 24 & 255, o2 >> 16 & 255, o2 >> 8 & 255, 255 & o2, l3 >> 24 & 255, l3 >> 16 & 255, l3 >> 8 & 255, 255 & l3, c2 >> 24 & 255, c2 >> 16 & 255, c2 >> 8 & 255, 255 & c2, h2 >> 24 & 255, h2 >> 16 & 255, h2 >> 8 & 255, 255 & h2]);
}
function find(e2, t2, i2 = 1024, a2 = false) {
  const n2 = t2.length, s2 = e2.peekBytes(i2), r2 = s2.length - n2;
  if (r2 <= 0)
    return false;
  if (a2) {
    const i3 = n2 - 1;
    let a3 = s2.length - 1;
    for (; a3 >= i3; ) {
      let r3 = 0;
      for (; r3 < n2 && s2[a3 - r3] === t2[i3 - r3]; )
        r3++;
      if (r3 >= n2)
        return e2.pos += a3 - i3, true;
      a3--;
    }
  } else {
    let i3 = 0;
    for (; i3 <= r2; ) {
      let a3 = 0;
      for (; a3 < n2 && s2[i3 + a3] === t2[a3]; )
        a3++;
      if (a3 >= n2)
        return e2.pos += i3, true;
      i3++;
    }
  }
  return false;
}
function onFn$1() {
}
function wrapReason$1(e2) {
  if (e2 instanceof ii || e2 instanceof Qt || e2 instanceof Jt || e2 instanceof ei || e2 instanceof Zt)
    return e2;
  switch (e2 instanceof Error || "object" == typeof e2 && null !== e2 || unreachable$1('wrapReason: Expected "reason" to be a (possibly cloned) Error.'), e2.name) {
    case "AbortException":
      return new ii(e2.message);
    case "InvalidPDFException":
      return new Qt(e2.message);
    case "PasswordException":
      return new Jt(e2.message, e2.code);
    case "ResponseException":
      return new ei(e2.message, e2.status, e2.missing);
    case "UnknownErrorException":
      return new Zt(e2.message, e2.details);
  }
  return new Zt(e2.message, e2.toString());
}
async function writeObject(e2, t2, i2, { encrypt: a2 = null }) {
  const n2 = a2?.createCipherTransform(e2.num, e2.gen);
  i2.push(`${e2.num} ${e2.gen} obj
`), t2 instanceof Dict ? await writeDict(t2, i2, n2) : t2 instanceof BaseStream ? await writeStream(t2, i2, n2) : (Array.isArray(t2) || ArrayBuffer.isView(t2)) && await writeArray(t2, i2, n2), i2.push("\nendobj\n");
}
async function writeDict(e2, t2, i2) {
  t2.push("<<");
  for (const a2 of e2.getKeys())
    t2.push(` /${escapePDFName(a2)} `), await writeValue(e2.getRaw(a2), t2, i2);
  t2.push(">>");
}
async function writeStream(e2, t2, i2) {
  let a2 = e2.getBytes();
  const { dict: n2 } = e2, [s2, r2] = await Promise.all([n2.getAsync("Filter"), n2.getAsync("DecodeParms")]), o2 = isName(Array.isArray(s2) ? await n2.xref.fetchIfRefAsync(s2[0]) : s2, "FlateDecode");
  if (a2.length >= 256 || o2)
    try {
      const e3 = new CompressionStream("deflate"), t3 = e3.writable.getWriter();
      await t3.ready, t3.write(a2).then(async () => {
        await t3.ready, await t3.close();
      }).catch(() => {
      });
      const i3 = await new Response(e3.readable).arrayBuffer();
      let l4, c2;
      a2 = new Uint8Array(i3), s2 ? o2 || (l4 = Array.isArray(s2) ? [Name.get("FlateDecode"), ...s2] : [Name.get("FlateDecode"), s2], r2 && (c2 = Array.isArray(r2) ? [null, ...r2] : [null, r2])) : l4 = Name.get("FlateDecode"), l4 && n2.set("Filter", l4), c2 && n2.set("DecodeParms", c2);
    } catch (e3) {
      info$1(`writeStream - cannot compress data: "${e3}".`);
    }
  let l3 = bytesToString$1(a2);
  i2 && (l3 = i2.encryptString(l3)), n2.set("Length", l3.length), await writeDict(n2, t2, i2), t2.push(" stream\n", l3, "\nendstream");
}
async function writeArray(e2, t2, i2) {
  t2.push("[");
  let a2 = true;
  for (const n2 of e2)
    a2 ? a2 = false : t2.push(" "), await writeValue(n2, t2, i2);
  t2.push("]");
}
async function writeValue(e2, t2, i2) {
  e2 instanceof Name ? t2.push(`/${escapePDFName(e2.name)}`) : e2 instanceof Ref ? t2.push(`${e2.num} ${e2.gen} R`) : Array.isArray(e2) || ArrayBuffer.isView(e2) ? await writeArray(e2, t2, i2) : "string" == typeof e2 ? (i2 && (e2 = i2.encryptString(e2)), t2.push(`(${escapeString(e2)})`)) : "number" == typeof e2 ? t2.push(numberToString(e2)) : "boolean" == typeof e2 ? t2.push(e2.toString()) : e2 instanceof Dict ? await writeDict(e2, t2, i2) : e2 instanceof BaseStream ? await writeStream(e2, t2, i2) : null === e2 ? t2.push("null") : warn$1(`Unhandled value in writer: ${typeof e2}, please file a bug.`);
}
function writeInt(e2, t2, i2, a2) {
  for (let n2 = t2 + i2 - 1; n2 > i2 - 1; n2--)
    a2[n2] = 255 & e2, e2 >>= 8;
  return i2 + t2;
}
function writeString(e2, t2, i2) {
  const a2 = e2.length;
  for (let n2 = 0; n2 < a2; n2++)
    i2[t2 + n2] = 255 & e2.charCodeAt(n2);
  return t2 + a2;
}
function updateXFA({ xfaData: e2, xfaDatasetsRef: t2, changes: i2, xref: a2 }) {
  if (null === e2) {
    e2 = function(e3, t3) {
      const i3 = new SimpleXMLParser({ hasAttributes: true }).parseFromString(e3);
      for (const { xfa: e4 } of t3) {
        if (!e4)
          continue;
        const { path: t4, value: a4 } = e4;
        if (!t4)
          continue;
        const n3 = parseXFAPath(t4);
        let s2 = i3.documentElement.searchNode(n3, 0);
        !s2 && n3.length > 1 && (s2 = i3.documentElement.searchNode([n3.at(-1)], 0)), s2 ? s2.childNodes = Array.isArray(a4) ? a4.map((e5) => new SimpleDOMNode("value", e5)) : [new SimpleDOMNode("#text", a4)] : warn$1(`Node not found for path: ${t4}`);
      }
      const a3 = [];
      return i3.documentElement.dump(a3), a3.join("");
    }(a2.fetchIfRef(t2).getString(), i2);
  }
  const n2 = new StringStream(e2);
  n2.dict = new Dict(a2), n2.dict.setIfName("Type", "EmbeddedFile"), i2.put(t2, { data: n2 });
}
function getIndexes(e2) {
  const t2 = [];
  for (const { ref: i2 } of e2)
    i2.num === t2.at(-2) + t2.at(-1) ? t2[t2.length - 1] += 1 : t2.push(i2.num, 1);
  return t2;
}
function computeIDs(e2, t2, i2) {
  if (Array.isArray(t2.fileIds) && t2.fileIds.length > 0) {
    const a2 = function(e3, t3) {
      const i3 = Math.floor(Date.now() / 1e3), a3 = t3.filename || "", n2 = [i3.toString(), a3, e3.toString(), ...t3.infoMap.values()], s2 = Math.sumPrecise(n2.map((e4) => e4.length)), r2 = new Uint8Array(s2);
      let o2 = 0;
      for (const e4 of n2)
        o2 = writeString(e4, o2, r2);
      return bytesToString$1(calculateMD5(r2, 0, r2.length));
    }(e2, t2);
    i2.set("ID", [t2.fileIds[0], a2]);
  }
}
async function incrementalUpdate({ originalData: e2, xrefInfo: t2, changes: i2, xref: a2 = null, hasXfa: n2 = false, xfaDatasetsRef: s2 = null, hasXfaDatasetsEntry: r2 = false, needAppearances: o2, acroFormRef: l3 = null, acroForm: c2 = null, xfaData: h2 = null, useXrefStream: d2 = false }) {
  await async function({ xref: e3, acroForm: t3, acroFormRef: i3, hasXfa: a3, hasXfaDatasetsEntry: n3, xfaDatasetsRef: s3, needAppearances: r3, changes: o3 }) {
    if (!a3 || n3 || s3 || warn$1("XFA - Cannot save it"), !r3 && (!a3 || !s3 || n3))
      return;
    const l4 = t3.clone();
    if (a3 && !n3) {
      const e4 = t3.get("XFA").slice();
      e4.splice(2, 0, "datasets"), e4.splice(3, 0, s3), l4.set("XFA", e4);
    }
    r3 && l4.set("NeedAppearances", true), o3.put(i3, { data: l4 });
  }({ xref: a2, acroForm: c2, acroFormRef: l3, hasXfa: n2, hasXfaDatasetsEntry: r2, xfaDatasetsRef: s2, needAppearances: o2, changes: i2 }), n2 && updateXFA({ xfaData: h2, xfaDatasetsRef: s2, changes: i2, xref: a2 });
  const u2 = function(e3, t3, i3) {
    const a3 = new Dict(null);
    a3.set("Prev", e3.startXRef);
    const n3 = e3.newRef;
    return i3 ? (t3.put(n3, { data: "" }), a3.set("Size", n3.num + 1), a3.setIfName("Type", "XRef")) : a3.set("Size", n3.num), null !== e3.rootRef && a3.set("Root", e3.rootRef), null !== e3.infoRef && a3.set("Info", e3.infoRef), null !== e3.encryptRef && a3.set("Encrypt", e3.encryptRef), a3;
  }(t2, i2, d2), g2 = [], p2 = await async function(e3, t3, i3 = []) {
    const a3 = [];
    for (const [n3, { data: s3 }] of e3.items())
      null !== s3 && "string" != typeof s3 ? (await writeObject(n3, s3, i3, t3), a3.push({ ref: n3, data: i3.join("") }), i3.length = 0) : a3.push({ ref: n3, data: s3 });
    return a3.sort((e4, t4) => e4.ref.num - t4.ref.num);
  }(i2, a2, g2);
  let f2 = e2.length;
  const m2 = e2.at(-1);
  10 !== m2 && 13 !== m2 && (g2.push("\n"), f2 += 1);
  for (const { data: e3 } of p2)
    null !== e3 && g2.push(e3);
  await (d2 ? async function(e3, t3, i3, a3, n3) {
    const s3 = [];
    let r3 = 0, o3 = 0;
    for (const { ref: e4, data: a4 } of i3) {
      let i4;
      r3 = Math.max(r3, t3), null !== a4 ? (i4 = Math.min(e4.gen, 65535), s3.push([1, t3, i4]), t3 += a4.length) : (i4 = Math.min(e4.gen + 1, 65535), s3.push([0, 0, i4])), o3 = Math.max(o3, i4);
    }
    a3.set("Index", getIndexes(i3));
    const l4 = [1, getSizeInBytes(r3), getSizeInBytes(o3)];
    a3.set("W", l4), computeIDs(t3, e3, a3);
    const c3 = Math.sumPrecise(l4), h3 = new Uint8Array(c3 * s3.length), d3 = new Stream(h3);
    d3.dict = a3;
    let u3 = 0;
    for (const [e4, t4, i4] of s3)
      u3 = writeInt(e4, l4[0], u3, h3), u3 = writeInt(t4, l4[1], u3, h3), u3 = writeInt(i4, l4[2], u3, h3);
    await writeObject(e3.newRef, d3, n3, {}), n3.push("startxref\n", t3.toString(), "\n%%EOF\n");
  }(t2, f2, p2, u2, g2) : async function(e3, t3, i3, a3, n3) {
    n3.push("xref\n");
    const s3 = getIndexes(i3);
    let r3 = 0;
    for (const { ref: e4, data: a4 } of i3)
      e4.num === s3[r3] && (n3.push(`${s3[r3]} ${s3[r3 + 1]}
`), r3 += 2), null !== a4 ? (n3.push(`${t3.toString().padStart(10, "0")} ${Math.min(e4.gen, 65535).toString().padStart(5, "0")} n\r
`), t3 += a4.length) : n3.push(`0000000000 ${Math.min(e4.gen + 1, 65535).toString().padStart(5, "0")} f\r
`);
    computeIDs(t3, e3, a3), n3.push("trailer\n"), await writeDict(a3, n3), n3.push("\nstartxref\n", t3.toString(), "\n%%EOF\n");
  }(t2, f2, p2, u2, g2));
  const b2 = e2.length + Math.sumPrecise(g2.map((e3) => e3.length)), y2 = new Uint8Array(b2);
  y2.set(e2);
  let w2 = e2.length;
  for (const e3 of g2)
    w2 = writeString(e3, w2, y2);
  return y2;
}
function setVerbosityLevel(e2) {
  Number.isInteger(e2) && (lc = e2);
}
function getVerbosityLevel() {
  return lc;
}
function info3(e2) {
  lc >= tc.INFOS && console.log(`Info: ${e2}`);
}
function warn3(e2) {
  lc >= tc.WARNINGS && console.log(`Warning: ${e2}`);
}
function unreachable(e2) {
  throw new Error(e2);
}
function assert3(e2, t2) {
  e2 || unreachable(t2);
}
function createValidAbsoluteUrl(e2, t2 = null, i2 = null) {
  if (!e2)
    return null;
  if (i2 && "string" == typeof e2) {
    if (i2.addDefaultProtocol && e2.startsWith("www.")) {
      const t3 = e2.match(/\./g);
      t3?.length >= 2 && (e2 = `http://${e2}`);
    }
    if (i2.tryConvertEncoding)
      try {
        e2 = decodeURIComponent(escape(e2));
      } catch {
      }
  }
  const a2 = t2 ? URL.parse(e2, t2) : URL.parse(e2);
  return function(e3) {
    switch (e3?.protocol) {
      case "http:":
      case "https:":
      case "ftp:":
      case "mailto:":
      case "tel:":
        return true;
      default:
        return false;
    }
  }(a2) ? a2 : null;
}
function updateUrlHash(e2, t2, i2 = false) {
  const a2 = URL.parse(e2);
  return a2 ? (a2.hash = t2, a2.href) : i2 && createValidAbsoluteUrl(e2, "http://example.com") ? e2.split("#", 1)[0] + (t2 ? `#${t2}` : "") : "";
}
function shadow(e2, t2, i2, a2 = false) {
  return Object.defineProperty(e2, t2, { value: i2, enumerable: !a2, configurable: true, writable: false }), i2;
}
function bytesToString(e2) {
  "object" == typeof e2 && void 0 !== e2?.length || unreachable("Invalid argument for bytesToString");
  const t2 = e2.length, i2 = 8192;
  if (t2 < i2)
    return String.fromCharCode.apply(null, e2);
  const a2 = [];
  for (let n2 = 0; n2 < t2; n2 += i2) {
    const s2 = Math.min(n2 + i2, t2), r2 = e2.subarray(n2, s2);
    a2.push(String.fromCharCode.apply(null, r2));
  }
  return a2.join("");
}
function stringToBytes(e2) {
  "string" != typeof e2 && unreachable("Invalid argument for stringToBytes");
  const t2 = e2.length, i2 = new Uint8Array(t2);
  for (let a2 = 0; a2 < t2; ++a2)
    i2[a2] = 255 & e2.charCodeAt(a2);
  return i2;
}
function normalizeUnicode(e2) {
  return dc || (dc = /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu, uc = /* @__PURE__ */ new Map([["\uFB05", "\u017Ft"]])), e2.replaceAll(dc, (e3, t2, i2) => t2 ? t2.normalize("NFKC") : uc.get(i2));
}
function getUuid() {
  if ("function" == typeof crypto.randomUUID)
    return crypto.randomUUID();
  const e2 = new Uint8Array(32);
  return crypto.getRandomValues(e2), bytesToString(e2);
}
function MathClamp(e2, t2, i2) {
  return Math.min(Math.max(e2, t2), i2);
}
function toBase64Util(e2) {
  return Uint8Array.prototype.toBase64 ? e2.toBase64() : btoa(bytesToString(e2));
}
async function fetchData(e2, t2 = "text") {
  if (isValidFetchUrl(e2, document.baseURI)) {
    const i2 = await fetch(e2);
    if (!i2.ok)
      throw new Error(i2.statusText);
    switch (t2) {
      case "arraybuffer":
        return i2.arrayBuffer();
      case "blob":
        return i2.blob();
      case "json":
        return i2.json();
    }
    return i2.text();
  }
  return new Promise((i2, a2) => {
    const n2 = new XMLHttpRequest();
    n2.open("GET", e2, true), n2.responseType = t2, n2.onreadystatechange = () => {
      if (n2.readyState === XMLHttpRequest.DONE)
        if (200 !== n2.status && 0 !== n2.status)
          a2(new Error(n2.statusText));
        else {
          switch (t2) {
            case "arraybuffer":
            case "blob":
            case "json":
              return void i2(n2.response);
          }
          i2(n2.responseText);
        }
    }, n2.send(null);
  });
}
function isDataScheme(e2) {
  const t2 = e2.length;
  let i2 = 0;
  for (; i2 < t2 && "" === e2[i2].trim(); )
    i2++;
  return "data:" === e2.substring(i2, i2 + 5).toLowerCase();
}
function isPdfFile(e2) {
  return "string" == typeof e2 && /\.pdf$/i.test(e2);
}
function getFilenameFromUrl(e2) {
  return [e2] = e2.split(/[#?]/, 1), e2.substring(e2.lastIndexOf("/") + 1);
}
function getPdfFilenameFromUrl(e2, t2 = "document.pdf") {
  if ("string" != typeof e2)
    return t2;
  if (isDataScheme(e2))
    return warn3('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.'), t2;
  const i2 = ((e3) => {
    try {
      return new URL(e3);
    } catch {
      try {
        return new URL(decodeURIComponent(e3));
      } catch {
        try {
          return new URL(e3, "https://foo.bar");
        } catch {
          try {
            return new URL(decodeURIComponent(e3), "https://foo.bar");
          } catch {
            return null;
          }
        }
      }
    }
  })(e2);
  if (!i2)
    return t2;
  const decode = /* @__PURE__ */ __name((e3) => {
    try {
      let t3 = decodeURIComponent(e3);
      return t3.includes("/") ? (t3 = t3.split("/").at(-1), t3.test(/^\.pdf$/i) ? t3 : e3) : t3;
    } catch {
      return e3;
    }
  }, "decode"), a2 = /\.pdf$/i, n2 = i2.pathname.split("/").at(-1);
  if (a2.test(n2))
    return decode(n2);
  if (i2.searchParams.size > 0) {
    const e3 = Array.from(i2.searchParams.values()).reverse();
    for (const t4 of e3)
      if (a2.test(t4))
        return decode(t4);
    const t3 = Array.from(i2.searchParams.keys()).reverse();
    for (const e4 of t3)
      if (a2.test(e4))
        return decode(e4);
  }
  if (i2.hash) {
    const e3 = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i.exec(i2.hash);
    if (e3)
      return decode(e3[0]);
  }
  return t2;
}
function isValidFetchUrl(e2, t2) {
  const i2 = t2 ? URL.parse(e2, t2) : URL.parse(e2);
  return "http:" === i2?.protocol || "https:" === i2?.protocol;
}
function noContextMenu(e2) {
  e2.preventDefault();
}
function stopEvent(e2) {
  e2.preventDefault(), e2.stopPropagation();
}
function getXfaPageViewport(e2, { scale: t2 = 1, rotation: i2 = 0 }) {
  const { width: a2, height: n2 } = e2.attributes.style, s2 = [0, 0, parseInt(a2), parseInt(n2)];
  return new PageViewport({ viewBox: s2, userUnit: 1, scale: t2, rotation: i2 });
}
function getRGB(e2) {
  if (e2.startsWith("#")) {
    const t2 = parseInt(e2.slice(1), 16);
    return [(16711680 & t2) >> 16, (65280 & t2) >> 8, 255 & t2];
  }
  return e2.startsWith("rgb(") ? e2.slice(4, -1).split(",").map((e3) => parseInt(e3)) : e2.startsWith("rgba(") ? e2.slice(5, -1).split(",").map((e3) => parseInt(e3)).slice(0, 3) : (warn3(`Not a valid color format: "${e2}"`), [0, 0, 0]);
}
function getCurrentTransform(e2) {
  const { a: t2, b: i2, c: a2, d: n2, e: s2, f: r2 } = e2.getTransform();
  return [t2, i2, a2, n2, s2, r2];
}
function getCurrentTransformInverse(e2) {
  const { a: t2, b: i2, c: a2, d: n2, e: s2, f: r2 } = e2.getTransform().invertSelf();
  return [t2, i2, a2, n2, s2, r2];
}
function setLayerDimensions(e2, t2, i2 = false, a2 = true) {
  if (t2 instanceof PageViewport) {
    const { pageWidth: a3, pageHeight: n2 } = t2.rawDims, { style: s2 } = e2, r2 = util_FeatureTest.isCSSRoundSupported, o2 = `var(--total-scale-factor) * ${a3}px`, l3 = `var(--total-scale-factor) * ${n2}px`, c2 = r2 ? `round(down, ${o2}, var(--scale-round-x))` : `calc(${o2})`, h2 = r2 ? `round(down, ${l3}, var(--scale-round-y))` : `calc(${l3})`;
    i2 && t2.rotation % 180 != 0 ? (s2.width = h2, s2.height = c2) : (s2.width = c2, s2.height = h2);
  }
  a2 && e2.setAttribute("data-main-rotation", t2.rotation);
}
function bindEvents(e2, t2, i2) {
  for (const a2 of i2)
    t2.addEventListener(a2, e2[a2].bind(e2));
}
function getFactoryUrlProp(e2) {
  if ("string" != typeof e2)
    return null;
  if (e2.endsWith("/"))
    return e2;
  throw new Error(`Invalid factory url: "${e2}" must include trailing slash.`);
}
function onFn() {
}
function wrapReason(e2) {
  if (e2 instanceof AbortException || e2 instanceof InvalidPDFException || e2 instanceof PasswordException || e2 instanceof ResponseException || e2 instanceof UnknownErrorException)
    return e2;
  switch (e2 instanceof Error || "object" == typeof e2 && null !== e2 || unreachable('wrapReason: Expected "reason" to be a (possibly cloned) Error.'), e2.name) {
    case "AbortException":
      return new AbortException(e2.message);
    case "InvalidPDFException":
      return new InvalidPDFException(e2.message);
    case "PasswordException":
      return new PasswordException(e2.message, e2.code);
    case "ResponseException":
      return new ResponseException(e2.message, e2.status, e2.missing);
    case "UnknownErrorException":
      return new UnknownErrorException(e2.message, e2.details);
  }
  return new UnknownErrorException(e2.message, e2.toString());
}
async function node_utils_fetchData(e2) {
  const t2 = process.getBuiltinModule("fs"), i2 = await t2.promises.readFile(e2);
  return new Uint8Array(i2);
}
function applyBoundingBox(e2, t2) {
  if (!t2)
    return;
  const i2 = t2[2] - t2[0], a2 = t2[3] - t2[1], n2 = new Path2D();
  n2.rect(t2[0], t2[1], i2, a2), e2.clip(n2);
}
function drawTriangle(e2, t2, i2, a2, n2, s2, r2, o2) {
  const l3 = t2.coords, c2 = t2.colors, h2 = e2.data, d2 = 4 * e2.width;
  let u2;
  l3[i2 + 1] > l3[a2 + 1] && (u2 = i2, i2 = a2, a2 = u2, u2 = s2, s2 = r2, r2 = u2), l3[a2 + 1] > l3[n2 + 1] && (u2 = a2, a2 = n2, n2 = u2, u2 = r2, r2 = o2, o2 = u2), l3[i2 + 1] > l3[a2 + 1] && (u2 = i2, i2 = a2, a2 = u2, u2 = s2, s2 = r2, r2 = u2);
  const g2 = (l3[i2] + t2.offsetX) * t2.scaleX, p2 = (l3[i2 + 1] + t2.offsetY) * t2.scaleY, f2 = (l3[a2] + t2.offsetX) * t2.scaleX, m2 = (l3[a2 + 1] + t2.offsetY) * t2.scaleY, b2 = (l3[n2] + t2.offsetX) * t2.scaleX, y2 = (l3[n2 + 1] + t2.offsetY) * t2.scaleY;
  if (p2 >= y2)
    return;
  const w2 = c2[s2], x2 = c2[s2 + 1], S2 = c2[s2 + 2], v2 = c2[r2], C2 = c2[r2 + 1], k2 = c2[r2 + 2], T2 = c2[o2], F2 = c2[o2 + 1], M2 = c2[o2 + 2], D2 = Math.round(p2), E2 = Math.round(y2);
  let O2, _2, R2, N2, L2, U2, j2, $2;
  for (let e3 = D2; e3 <= E2; e3++) {
    if (e3 < m2) {
      const t4 = e3 < p2 ? 0 : (p2 - e3) / (p2 - m2);
      O2 = g2 - (g2 - f2) * t4, _2 = w2 - (w2 - v2) * t4, R2 = x2 - (x2 - C2) * t4, N2 = S2 - (S2 - k2) * t4;
    } else {
      let t4;
      t4 = e3 > y2 ? 1 : m2 === y2 ? 0 : (m2 - e3) / (m2 - y2), O2 = f2 - (f2 - b2) * t4, _2 = v2 - (v2 - T2) * t4, R2 = C2 - (C2 - F2) * t4, N2 = k2 - (k2 - M2) * t4;
    }
    let t3;
    t3 = e3 < p2 ? 0 : e3 > y2 ? 1 : (p2 - e3) / (p2 - y2), L2 = g2 - (g2 - b2) * t3, U2 = w2 - (w2 - T2) * t3, j2 = x2 - (x2 - F2) * t3, $2 = S2 - (S2 - M2) * t3;
    const i3 = Math.round(Math.min(O2, L2)), a3 = Math.round(Math.max(O2, L2));
    let n3 = d2 * e3 + 4 * i3;
    for (let e4 = i3; e4 <= a3; e4++)
      t3 = (O2 - e4) / (O2 - L2), t3 < 0 ? t3 = 0 : t3 > 1 && (t3 = 1), h2[n3++] = _2 - (_2 - U2) * t3 | 0, h2[n3++] = R2 - (R2 - j2) * t3 | 0, h2[n3++] = N2 - (N2 - $2) * t3 | 0, h2[n3++] = 255;
  }
}
function drawFigure(e2, t2, i2) {
  const a2 = t2.coords, n2 = t2.colors;
  let s2, r2;
  switch (t2.type) {
    case "lattice":
      const o2 = t2.verticesPerRow, l3 = Math.floor(a2.length / o2) - 1, c2 = o2 - 1;
      for (s2 = 0; s2 < l3; s2++) {
        let t3 = s2 * o2;
        for (let s3 = 0; s3 < c2; s3++, t3++)
          drawTriangle(e2, i2, a2[t3], a2[t3 + 1], a2[t3 + o2], n2[t3], n2[t3 + 1], n2[t3 + o2]), drawTriangle(e2, i2, a2[t3 + o2 + 1], a2[t3 + 1], a2[t3 + o2], n2[t3 + o2 + 1], n2[t3 + 1], n2[t3 + o2]);
      }
      break;
    case "triangles":
      for (s2 = 0, r2 = a2.length; s2 < r2; s2 += 3)
        drawTriangle(e2, i2, a2[s2], a2[s2 + 1], a2[s2 + 2], n2[s2], n2[s2 + 1], n2[s2 + 2]);
      break;
    default:
      throw new Error("illegal figure");
  }
}
function convertBlackAndWhiteToRGBA({ src: e2, srcPos: t2 = 0, dest: i2, width: a2, height: n2, nonBlackColor: s2 = 4294967295, inverseDecode: r2 = false }) {
  const o2 = util_FeatureTest.isLittleEndian ? 4278190080 : 255, [l3, c2] = r2 ? [s2, o2] : [o2, s2], h2 = a2 >> 3, d2 = 7 & a2, u2 = e2.length;
  i2 = new Uint32Array(i2.buffer);
  let g2 = 0;
  for (let a3 = 0; a3 < n2; a3++) {
    for (const a5 = t2 + h2; t2 < a5; t2++) {
      const a6 = t2 < u2 ? e2[t2] : 255;
      i2[g2++] = 128 & a6 ? c2 : l3, i2[g2++] = 64 & a6 ? c2 : l3, i2[g2++] = 32 & a6 ? c2 : l3, i2[g2++] = 16 & a6 ? c2 : l3, i2[g2++] = 8 & a6 ? c2 : l3, i2[g2++] = 4 & a6 ? c2 : l3, i2[g2++] = 2 & a6 ? c2 : l3, i2[g2++] = 1 & a6 ? c2 : l3;
    }
    if (0 === d2)
      continue;
    const a4 = t2 < u2 ? e2[t2++] : 255;
    for (let e3 = 0; e3 < d2; e3++)
      i2[g2++] = a4 & 1 << 7 - e3 ? c2 : l3;
  }
  return { srcPos: t2, destPos: g2 };
}
function drawImageAtIntegerCoords(e2, t2, i2, a2, n2, s2, r2, o2, l3, c2) {
  const [h2, d2, u2, g2, p2, f2] = getCurrentTransform(e2);
  if (0 === d2 && 0 === u2) {
    const m2 = r2 * h2 + p2, b2 = Math.round(m2), y2 = o2 * g2 + f2, w2 = Math.round(y2), x2 = (r2 + l3) * h2 + p2, S2 = Math.abs(Math.round(x2) - b2) || 1, v2 = (o2 + c2) * g2 + f2, C2 = Math.abs(Math.round(v2) - w2) || 1;
    return e2.setTransform(Math.sign(h2), 0, 0, Math.sign(g2), b2, w2), e2.drawImage(t2, i2, a2, n2, s2, 0, 0, S2, C2), e2.setTransform(h2, d2, u2, g2, p2, f2), [S2, C2];
  }
  if (0 === h2 && 0 === g2) {
    const m2 = o2 * u2 + p2, b2 = Math.round(m2), y2 = r2 * d2 + f2, w2 = Math.round(y2), x2 = (o2 + c2) * u2 + p2, S2 = Math.abs(Math.round(x2) - b2) || 1, v2 = (r2 + l3) * d2 + f2, C2 = Math.abs(Math.round(v2) - w2) || 1;
    return e2.setTransform(0, Math.sign(d2), Math.sign(u2), 0, b2, w2), e2.drawImage(t2, i2, a2, n2, s2, 0, 0, C2, S2), e2.setTransform(h2, d2, u2, g2, p2, f2), [C2, S2];
  }
  e2.drawImage(t2, i2, a2, n2, s2, r2, o2, l3, c2);
  return [Math.hypot(h2, d2) * l3, Math.hypot(u2, g2) * c2];
}
function putBinaryImageData(e2, t2) {
  if (t2 instanceof ImageData)
    return void e2.putImageData(t2, 0, 0);
  const i2 = t2.height, a2 = t2.width, n2 = i2 % Xc, s2 = (i2 - n2) / Xc, r2 = 0 === n2 ? s2 : s2 + 1, o2 = e2.createImageData(a2, Xc);
  let l3, c2 = 0;
  const h2 = t2.data, d2 = o2.data;
  let u2, g2, p2, f2;
  if (t2.kind === Vl.GRAYSCALE_1BPP) {
    const t3 = h2.byteLength, i3 = new Uint32Array(d2.buffer, 0, d2.byteLength >> 2), f3 = i3.length, m2 = a2 + 7 >> 3, b2 = 4294967295, y2 = util_FeatureTest.isLittleEndian ? 4278190080 : 255;
    for (u2 = 0; u2 < r2; u2++) {
      for (p2 = u2 < s2 ? Xc : n2, l3 = 0, g2 = 0; g2 < p2; g2++) {
        const e3 = t3 - c2;
        let n3 = 0;
        const s3 = e3 > m2 ? a2 : 8 * e3 - 7, r3 = -8 & s3;
        let o3 = 0, d3 = 0;
        for (; n3 < r3; n3 += 8)
          d3 = h2[c2++], i3[l3++] = 128 & d3 ? b2 : y2, i3[l3++] = 64 & d3 ? b2 : y2, i3[l3++] = 32 & d3 ? b2 : y2, i3[l3++] = 16 & d3 ? b2 : y2, i3[l3++] = 8 & d3 ? b2 : y2, i3[l3++] = 4 & d3 ? b2 : y2, i3[l3++] = 2 & d3 ? b2 : y2, i3[l3++] = 1 & d3 ? b2 : y2;
        for (; n3 < s3; n3++)
          0 === o3 && (d3 = h2[c2++], o3 = 128), i3[l3++] = d3 & o3 ? b2 : y2, o3 >>= 1;
      }
      for (; l3 < f3; )
        i3[l3++] = 0;
      e2.putImageData(o2, 0, u2 * Xc);
    }
  } else if (t2.kind === Vl.RGBA_32BPP) {
    for (g2 = 0, f2 = a2 * Xc * 4, u2 = 0; u2 < s2; u2++)
      d2.set(h2.subarray(c2, c2 + f2)), c2 += f2, e2.putImageData(o2, 0, g2), g2 += Xc;
    u2 < r2 && (f2 = a2 * n2 * 4, d2.set(h2.subarray(c2, c2 + f2)), e2.putImageData(o2, 0, g2));
  } else {
    if (t2.kind !== Vl.RGB_24BPP)
      throw new Error(`bad image kind: ${t2.kind}`);
    for (p2 = Xc, f2 = a2 * p2, u2 = 0; u2 < r2; u2++) {
      for (u2 >= s2 && (p2 = n2, f2 = a2 * p2), l3 = 0, g2 = f2; g2--; )
        d2[l3++] = h2[c2++], d2[l3++] = h2[c2++], d2[l3++] = h2[c2++], d2[l3++] = 255;
      e2.putImageData(o2, 0, u2 * Xc);
    }
  }
}
function putBinaryImageMask(e2, t2) {
  if (t2.bitmap)
    return void e2.drawImage(t2.bitmap, 0, 0);
  const i2 = t2.height, a2 = t2.width, n2 = i2 % Xc, s2 = (i2 - n2) / Xc, r2 = 0 === n2 ? s2 : s2 + 1, o2 = e2.createImageData(a2, Xc);
  let l3 = 0;
  const c2 = t2.data, h2 = o2.data;
  for (let t3 = 0; t3 < r2; t3++) {
    const i3 = t3 < s2 ? Xc : n2;
    ({ srcPos: l3 } = convertBlackAndWhiteToRGBA({ src: c2, srcPos: l3, dest: h2, width: a2, height: i3, nonBlackColor: 0 })), e2.putImageData(o2, 0, t3 * Xc);
  }
}
function copyCtxState(e2, t2) {
  const i2 = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font", "filter"];
  for (const a2 of i2)
    void 0 !== e2[a2] && (t2[a2] = e2[a2]);
  void 0 !== e2.setLineDash && (t2.setLineDash(e2.getLineDash()), t2.lineDashOffset = e2.lineDashOffset);
}
function resetCtxToDefault(e2) {
  e2.strokeStyle = e2.fillStyle = "#000000", e2.fillRule = "nonzero", e2.globalAlpha = 1, e2.lineWidth = 1, e2.lineCap = "butt", e2.lineJoin = "miter", e2.miterLimit = 10, e2.globalCompositeOperation = "source-over", e2.font = "10px sans-serif", void 0 !== e2.setLineDash && (e2.setLineDash([]), e2.lineDashOffset = 0);
  const { filter: t2 } = e2;
  "none" !== t2 && "" !== t2 && (e2.filter = "none");
}
function getImageSmoothingEnabled(e2, t2) {
  if (t2)
    return true;
  Util.singularValueDecompose2dScale(e2, Wc);
  const i2 = Math.fround(OutputScale.pixelRatio * PixelsPerInch.PDF_TO_CSS_UNITS);
  return Wc[0] <= i2 && Wc[1] <= i2;
}
function createHeaders(e2, t2) {
  const i2 = new Headers();
  if (!e2 || !t2 || "object" != typeof t2)
    return i2;
  for (const e3 in t2) {
    const a2 = t2[e3];
    void 0 !== a2 && i2.append(e3, a2);
  }
  return i2;
}
function getResponseOrigin(e2) {
  return URL.parse(e2)?.origin ?? null;
}
function validateRangeRequestCapabilities({ responseHeaders: e2, isHttp: t2, rangeChunkSize: i2, disableRange: a2 }) {
  const n2 = { allowRangeRequests: false, suggestedLength: void 0 }, s2 = parseInt(e2.get("Content-Length"), 10);
  if (!Number.isInteger(s2))
    return n2;
  if (n2.suggestedLength = s2, s2 <= 2 * i2)
    return n2;
  if (a2 || !t2)
    return n2;
  if ("bytes" !== e2.get("Accept-Ranges"))
    return n2;
  return "identity" !== (e2.get("Content-Encoding") || "identity") || (n2.allowRangeRequests = true), n2;
}
function extractFilenameFromHeader(e2) {
  const t2 = e2.get("Content-Disposition");
  if (t2) {
    let e3 = function(e4) {
      let t3 = true, i2 = toParamRegExp("filename\\*", "i").exec(e4);
      if (i2) {
        i2 = i2[1];
        let e5 = rfc2616unquote(i2);
        return e5 = unescape(e5), e5 = rfc5987decode(e5), e5 = rfc2047decode(e5), fixupEncoding(e5);
      }
      if (i2 = function(e5) {
        const t4 = [];
        let i3;
        const a2 = toParamRegExp("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
        for (; null !== (i3 = a2.exec(e5)); ) {
          let [, e6, a3, n3] = i3;
          if (e6 = parseInt(e6, 10), e6 in t4) {
            if (0 === e6)
              break;
          } else
            t4[e6] = [a3, n3];
        }
        const n2 = [];
        for (let e6 = 0; e6 < t4.length && e6 in t4; ++e6) {
          let [i4, a3] = t4[e6];
          a3 = rfc2616unquote(a3), i4 && (a3 = unescape(a3), 0 === e6 && (a3 = rfc5987decode(a3))), n2.push(a3);
        }
        return n2.join("");
      }(e4), i2)
        return fixupEncoding(rfc2047decode(i2));
      if (i2 = toParamRegExp("filename", "i").exec(e4), i2) {
        i2 = i2[1];
        let e5 = rfc2616unquote(i2);
        return e5 = rfc2047decode(e5), fixupEncoding(e5);
      }
      function toParamRegExp(e5, t4) {
        return new RegExp("(?:^|;)\\s*" + e5 + '\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)', t4);
      }
      __name(toParamRegExp, "toParamRegExp");
      function textdecode(e5, i3) {
        if (e5) {
          if (!/^[\x00-\xFF]+$/.test(i3))
            return i3;
          try {
            const a2 = new TextDecoder(e5, { fatal: true }), n2 = stringToBytes(i3);
            i3 = a2.decode(n2), t3 = false;
          } catch {
          }
        }
        return i3;
      }
      __name(textdecode, "textdecode");
      function fixupEncoding(e5) {
        return t3 && /[\x80-\xff]/.test(e5) && (e5 = textdecode("utf-8", e5), t3 && (e5 = textdecode("iso-8859-1", e5))), e5;
      }
      __name(fixupEncoding, "fixupEncoding");
      function rfc2616unquote(e5) {
        if (e5.startsWith('"')) {
          const t4 = e5.slice(1).split('\\"');
          for (let e6 = 0; e6 < t4.length; ++e6) {
            const i3 = t4[e6].indexOf('"');
            -1 !== i3 && (t4[e6] = t4[e6].slice(0, i3), t4.length = e6 + 1), t4[e6] = t4[e6].replaceAll(/\\(.)/g, "$1");
          }
          e5 = t4.join('"');
        }
        return e5;
      }
      __name(rfc2616unquote, "rfc2616unquote");
      function rfc5987decode(e5) {
        const t4 = e5.indexOf("'");
        return -1 === t4 ? e5 : textdecode(e5.slice(0, t4), e5.slice(t4 + 1).replace(/^[^']*'/, ""));
      }
      __name(rfc5987decode, "rfc5987decode");
      function rfc2047decode(e5) {
        return !e5.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(e5) ? e5 : e5.replaceAll(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function(e6, t4, i3, a2) {
          if ("q" === i3 || "Q" === i3)
            return textdecode(t4, a2 = (a2 = a2.replaceAll("_", " ")).replaceAll(/=([0-9a-fA-F]{2})/g, function(e7, t5) {
              return String.fromCharCode(parseInt(t5, 16));
            }));
          try {
            a2 = atob(a2);
          } catch {
          }
          return textdecode(t4, a2);
        });
      }
      __name(rfc2047decode, "rfc2047decode");
      return "";
    }(t2);
    if (e3.includes("%"))
      try {
        e3 = decodeURIComponent(e3);
      } catch {
      }
    if (isPdfFile(e3))
      return e3;
  }
  return null;
}
function createResponseError(e2, t2) {
  return new ResponseException(`Unexpected server response (${e2}) while retrieving PDF "${t2}".`, e2, 404 === e2 || 0 === e2 && t2.startsWith("file:"));
}
function validateResponseStatus(e2) {
  return 200 === e2 || 206 === e2;
}
function createFetchOptions(e2, t2, i2) {
  return { method: "GET", headers: e2, signal: i2.signal, mode: "cors", credentials: t2 ? "include" : "same-origin", redirect: "follow" };
}
function getArrayBuffer(e2) {
  return e2 instanceof Uint8Array ? e2.buffer : e2 instanceof ArrayBuffer ? e2 : (warn3(`getArrayBuffer - unexpected data format: ${e2}`), new Uint8Array(e2).buffer);
}
function getDocument(e2 = {}) {
  "string" == typeof e2 || e2 instanceof URL ? e2 = { url: e2 } : (e2 instanceof ArrayBuffer || ArrayBuffer.isView(e2)) && (e2 = { data: e2 });
  const t2 = new PDFDocumentLoadingTask(), { docId: i2 } = t2, a2 = e2.url ? function(e3) {
    if (e3 instanceof URL)
      return e3.href;
    if ("string" == typeof e3) {
      if (Cl)
        return e3;
      const t3 = URL.parse(e3, window.location);
      if (t3)
        return t3.href;
    }
    throw new Error("Invalid PDF url data: either string or URL-object is expected in the url property.");
  }(e2.url) : null, n2 = e2.data ? function(e3) {
    if (Cl && "undefined" != typeof Buffer && e3 instanceof Buffer)
      throw new Error("Please provide binary data as `Uint8Array`, rather than `Buffer`.");
    if (e3 instanceof Uint8Array && e3.byteLength === e3.buffer.byteLength)
      return e3;
    if ("string" == typeof e3)
      return stringToBytes(e3);
    if (e3 instanceof ArrayBuffer || ArrayBuffer.isView(e3) || "object" == typeof e3 && !isNaN(e3?.length))
      return new Uint8Array(e3);
    throw new Error("Invalid PDF binary data: either TypedArray, string, or array-like object is expected in the data property.");
  }(e2.data) : null, s2 = e2.httpHeaders || null, r2 = true === e2.withCredentials, o2 = e2.password ?? null, l3 = e2.range instanceof PDFDataRangeTransport ? e2.range : null, c2 = Number.isInteger(e2.rangeChunkSize) && e2.rangeChunkSize > 0 ? e2.rangeChunkSize : 65536;
  let h2 = e2.worker instanceof PDFWorker ? e2.worker : null;
  const d2 = e2.verbosity, u2 = "string" != typeof e2.docBaseUrl || isDataScheme(e2.docBaseUrl) ? null : e2.docBaseUrl, g2 = getFactoryUrlProp(e2.cMapUrl), p2 = false !== e2.cMapPacked, f2 = e2.CMapReaderFactory || (Cl ? NodeCMapReaderFactory : DOMCMapReaderFactory), m2 = getFactoryUrlProp(e2.iccUrl), b2 = getFactoryUrlProp(e2.standardFontDataUrl), y2 = e2.StandardFontDataFactory || (Cl ? NodeStandardFontDataFactory : DOMStandardFontDataFactory), w2 = getFactoryUrlProp(e2.wasmUrl), x2 = e2.WasmFactory || (Cl ? NodeWasmFactory : DOMWasmFactory), S2 = true !== e2.stopAtErrors, v2 = Number.isInteger(e2.maxImageSize) && e2.maxImageSize > -1 ? e2.maxImageSize : -1, C2 = false !== e2.isEvalSupported, k2 = "boolean" == typeof e2.isOffscreenCanvasSupported ? e2.isOffscreenCanvasSupported : !Cl, T2 = "boolean" == typeof e2.isImageDecoderSupported ? e2.isImageDecoderSupported : !Cl && (util_FeatureTest.platform.isFirefox || !globalThis.chrome), F2 = Number.isInteger(e2.canvasMaxAreaInBytes) ? e2.canvasMaxAreaInBytes : -1, M2 = "boolean" == typeof e2.disableFontFace ? e2.disableFontFace : Cl, D2 = true === e2.fontExtraProperties, E2 = true === e2.enableXfa, O2 = e2.ownerDocument || globalThis.document, _2 = true === e2.disableRange, R2 = true === e2.disableStream, N2 = true === e2.disableAutoFetch, L2 = true === e2.pdfBug, U2 = e2.CanvasFactory || (Cl ? NodeCanvasFactory : DOMCanvasFactory), j2 = e2.FilterFactory || (Cl ? NodeFilterFactory : DOMFilterFactory), $2 = true === e2.enableHWA, H2 = false !== e2.useWasm, q2 = l3 ? l3.length : e2.length ?? NaN, X2 = "boolean" == typeof e2.useSystemFonts ? e2.useSystemFonts : !Cl && !M2, z2 = "boolean" == typeof e2.useWorkerFetch ? e2.useWorkerFetch : !!(f2 === DOMCMapReaderFactory && y2 === DOMStandardFontDataFactory && x2 === DOMWasmFactory && g2 && b2 && w2 && isValidFetchUrl(g2, document.baseURI) && isValidFetchUrl(b2, document.baseURI) && isValidFetchUrl(w2, document.baseURI));
  setVerbosityLevel(d2);
  const W2 = { canvasFactory: new U2({ ownerDocument: O2, enableHWA: $2 }), filterFactory: new j2({ docId: i2, ownerDocument: O2 }), cMapReaderFactory: z2 ? null : new f2({ baseUrl: g2, isCompressed: p2 }), standardFontDataFactory: z2 ? null : new y2({ baseUrl: b2 }), wasmFactory: z2 ? null : new x2({ baseUrl: w2 }) };
  h2 || (h2 = PDFWorker.create({ verbosity: d2, port: GlobalWorkerOptions.workerPort }), t2._worker = h2);
  const G2 = { docId: i2, apiVersion: "5.4.149", data: n2, password: o2, disableAutoFetch: N2, rangeChunkSize: c2, length: q2, docBaseUrl: u2, enableXfa: E2, evaluatorOptions: { maxImageSize: v2, disableFontFace: M2, ignoreErrors: S2, isEvalSupported: C2, isOffscreenCanvasSupported: k2, isImageDecoderSupported: T2, canvasMaxAreaInBytes: F2, fontExtraProperties: D2, useSystemFonts: X2, useWasm: H2, useWorkerFetch: z2, cMapUrl: g2, iccUrl: m2, standardFontDataUrl: b2, wasmUrl: w2 } }, V2 = { ownerDocument: O2, pdfBug: L2, styleElement: null, loadingParams: { disableAutoFetch: N2, enableXfa: E2 } };
  return h2.promise.then(function() {
    if (t2.destroyed)
      throw new Error("Loading aborted");
    if (h2.destroyed)
      throw new Error("Worker was destroyed");
    const e3 = h2.messageHandler.sendWithPromise("GetDocRequest", G2, n2 ? [n2.buffer] : null);
    let o3;
    if (l3)
      o3 = new PDFDataTransportStream(l3, { disableRange: _2, disableStream: R2 });
    else if (!n2) {
      if (!a2)
        throw new Error("getDocument - no `url` parameter provided.");
      const e4 = isValidFetchUrl(a2) ? PDFFetchStream : Cl ? PDFNodeStream : PDFNetworkStream;
      o3 = new e4({ url: a2, length: q2, httpHeaders: s2, withCredentials: r2, rangeChunkSize: c2, disableRange: _2, disableStream: R2 });
    }
    return e3.then((e4) => {
      if (t2.destroyed)
        throw new Error("Loading aborted");
      if (h2.destroyed)
        throw new Error("Worker was destroyed");
      const a3 = new MessageHandler(i2, e4, h2.port), n3 = new WorkerTransport(a3, t2, o3, V2, W2, $2);
      t2._transport = n3, a3.send("Ready", null);
    });
  }).catch(t2._capability.reject), t2;
}
function makeColorComp(e2) {
  return Math.floor(255 * Math.max(0, Math.min(1, e2))).toString(16).padStart(2, "0");
}
function scaleAndClamp(e2) {
  return Math.max(0, Math.min(255, 255 * e2));
}
var e, t, i, a, n, s, r, o, l2, c, h, d, u, g, p, f, m, b, y, w, x, S, v, C, k, T, F, M, D, E, O, _, R, N, L, U, j, $, H, q, X, z, W, G, V, K, Y, J, Z, Q, ee, te, ie, ae, ne, se, re, oe, le, ce, he, de, ue, ge, pe, fe, me, be, ye, we, Ae, xe, Se, ve, Ce, ke, Te, Ie, Fe, Me, De, Ee, Oe, _e, Pe, Re, Be, Ne, Le, Ue, je, $e, He, qe, Xe, ze, We, Ge, Ve, Ke, Ye, Je, Ze, Qe, et, tt, it, at, nt, st, rt, ot, lt, ct, ht, dt, ut, gt, pt, ft, mt, bt, yt, wt, At, xt, St, vt, Ct, kt, Tt, It, Ft, Mt, Dt, Et, Ot, _t, Pt, Rt, Bt, Nt, Lt, Ut, jt, $t, Ht, qt, Xt, zt, Wt, Gt, Vt, Kt, Yt, Jt, Zt, Qt, ei, ti, ii, FeatureTest, ai, _e2, _a, e_fn, _t2, t_fn, ni, si, ri, oi, li, ci, hi, di, ui, Name, Cmd, nonSerializable, Dict, Ref, RefSet, RefSetCache, BaseStream, gi, pi, fi, mi, bi, MissingDataException, ParserEOFException, XRefEntryException, XRefParseException, yi, wi, _i, QCMS, Ai, xi, Si, vi, Ci, ki, _a2, _ColorSpace, ColorSpace, AlternateCS, PatternCS, IndexedCS, DeviceGrayCS, DeviceRgbCS, DeviceRgbaCS, DeviceCmykCS, CalGrayCS, _s, _r, _o, _l, _c, _h, _d, _u, _g, g_fn, _p, p_fn, _f, f_fn, _m, m_fn, _b, b_fn, _y, y_fn, _w, w_fn, _A, A_fn, _n, n_fn, _CalRGBCS, CalRGBCS, LabCS, _v, _C, _k, _T, _I, _IccColorSpace, IccColorSpace, _F, _CmykICCBasedCS, CmykICCBasedCS, Stream, StringStream, NullStream, ChunkedStream, ChunkedStreamManager, _M, _D, _E, E_fn, _ImageResizer, ImageResizer, Ti, DecodeStream, StreamsSequenceStream, __, __fn, _O, O_fn, ColorSpaceUtils, JpegError, DNLMarkerError, EOIMarkerError, Ii, Fi, Mi, Di, Ei, Oi, _i2, Pi, Ri, JpegImage, _D2, _P, P_fn, _JpegStream, JpegStream, JpxError, _R, _B, _N, _k2, _L, _T2, _U, U_fn, _j, j_fn, JpxImage, Bi, NullOptimizer, QueueOptimizer, _OperatorList, OperatorList, Ni, BinaryCMapStream, BinaryCMapReader, Ascii85Stream, AsciiHexStream, ji, $i, Hi, qi, Xi, zi, Wi, CCITTFaxDecoder, CCITTFaxStream, Gi, Vi, Ki, Yi, Ji, FlateStream, Zi, ArithmeticDecoder, Jbig2Error, ContextCache, DecodingContext, Qi, ea, ta, ia, aa, SimpleSegmentVisitor, HuffmanLine, HuffmanTreeNode, HuffmanTable, na, Reader, Jbig2Image, Jbig2Stream, JpxStream, LZWStream, PredictorStream, RunLengthStream, Parser, sa, Lexer, Linearization, ra, oa, CMap, IdentityCMap, CMapFactory, la, ca, ha, da, ua, ga, pa, fa, ma, ba, ya, wa, Aa, xa, Sa, va, Ca, ka, Ta, Ia, Fa, Ma, Da, Ea, Oa, _a3, Pa, CFFParser, CFF, CFFHeader, CFFStrings, CFFIndex, CFFDict, Ra, CFFTopDict, Ba, CFFPrivateDict, Na, CFFCharset, CFFEncoding, CFFFDSelect, CFFOffsetTracker, CFFCompiler, La, Ua, ja, $a, Ha, qa, Xa, za, ToUnicodeMap, IdentityToUnicodeMap, CFFFont, Commands, CompiledFont, TrueTypeCompiled, Type2Compiled, FontRendererFactory, Wa, Ga, GlyfTable, Glyph, GlyphHeader, Contour, SimpleGlyph, CompositeGlyph, OpenTypeFileBuilder, Va, Ka, Ya, Ja, Za, Qa, en, tn, an, nn, sn, Type1CharString, Type1Parser, Type1Font, rn, on2, ln, cn, fonts_Glyph, Font, ErrorFont, hn, dn, un, gn, pn, fn, Pattern, BaseShading, RadialAxialShading, MeshStreamReader, mn, _MeshShading, MeshShading, DummyShading, bn, yn, wn, An, xn, Sn, vn, Cn, kn, Tn, In, Fn, Mn, Dn, En, On, _n2, Pn, Rn, Bn, Nn, Ln, Un, jn, $n, Hn, qn, Xn, zn, Wn, Gn, Vn, Kn, Yn, Jn, Zn, Qn, es, ts, is, as, PostScriptParser, ns, PostScriptToken, PostScriptLexer, BaseLocalCache, LocalImageCache, LocalColorSpaceCache, LocalFunctionCache, LocalGStateCache, LocalTilingPatternCache, RegionalImageCache, GlobalColorSpaceCache, _q, _X, X_get, _z, z_get, _GlobalImageCache, GlobalImageCache, PDFFunctionFactory, PDFFunction, _PostScriptStack, PostScriptStack, PostScriptEvaluator, AstNode, AstArgument, AstLiteral, AstBinaryOperation, AstMin, AstVariable, AstVariableDefinition, ExpressionBuilderVisitor, PostScriptCompiler, ss, rs, os, ls, cs, hs, ds, us, gs, ps, fs, ms, bs, ys, PDFImage, ws, As, xs, Ss, _TimeSlotManager, TimeSlotManager, PartialEvaluator, TranslatedFont, StateManager, TextState, EvalState, _EvaluatorPreprocessor, EvaluatorPreprocessor, DefaultAppearanceEvaluator, AppearanceStreamEvaluator, FakeUnicodeFont, vs, Cs, NameOrNumberTree, NameTree, NumberTree, FileSpec, ks, Ts, Is, Fs, Ms, Ds, Es, XMLParserBase, SimpleDOMNode, SimpleXMLParser, MetadataParser, Os, _s2, Rs, Bs, Ns, _Z, Z_fn, _Q, Q_fn, _te, te_fn, _ee, ee_fn, _ie, ie_fn, _StructTreeRoot, StructTreeRoot, StructElementNode, StructElement, StructTreePage, Ls, Catalog, ObjectLoader, Us, js, $s, Hs, qs, Xs, zs, Ws, Gs, Vs, Ks, Ys, Js, Zs, Qs, er, tr, ir, ar, nr, sr, rr, or, lr, cr, hr, dr, ur, gr, pr, fr, mr, br, yr, wr, Ar, xr, Sr, vr, Cr, kr, Tr, Ir, Fr, Mr, Dr, Er, Or, _r2, Pr, Rr, Nr, Lr, Ur, jr, $r, Hr, qr, Xr, zr, Wr, Gr, Vr, Kr, Yr, Jr, Zr, Qr, eo, to, io, ao, HTMLResult, FontFinder, FontInfo, FontSelector, TextMeasure, no, so, ro, oo, lo, co, ho, uo, go, po, fo, mo, bo, yo, wo, Ao, xo, So, vo, Co, ko, Io, Fo, Mo, Do, Eo, Oo, _o2, XFAObject, XFAObjectArray, XFAAttribute, XmlObject, ContentObject, OptionObject, StringObject, IntegerObject, Option01, Option10, Po, Ro, Bo, No, Lo, Uo, AppearanceFilter, Arc, Area, Assist, Barcode, Bind, BindItems, Bookend, BooleanElement, Border, Break, BreakAfter, BreakBefore, Button, Calculate, Caption, Certificate, Certificates, CheckButton, ChoiceList, Color, Comb, Connect, ContentArea, Corner, DateElement, DateTime, DateTimeEdit, Decimal, DefaultUi, Desc, DigestMethod, DigestMethods, Draw, Edge, Encoding, Encodings, Encrypt, EncryptData, Encryption, EncryptionMethod, EncryptionMethods, jo, ExData, ExObject, ExclGroup, Execute, Extras, Field, Fill, Filter, Float, template_Font, Format, Handler, Hyphenation, $o, ImageEdit, Integer, Issuers, Items, Keep, KeyUsage, Line, Linear, LockDocument, Manifest, Margin, Mdp, Medium, Message, NumericEdit, Occur, Oid, Oids, Overflow, PageArea, PageSet, Para, PasswordEdit, template_Pattern, Picture, Proto, Radial, Reason, Reasons, Rectangle, RefElement, Script, SetProperty, SignData, Signature, Signing, Solid, Speak, Stipple, Subform, SubformSet, SubjectDN, SubjectDNs, Submit, Template, Text, TextEdit, Time, TimeStamp, ToolTip, Traversal, Traverse, Ui, Validate, Value, Variables, TemplateNamespace, Ho, Binder, DataHandler, qo, Acrobat, Acrobat7, ADBE_JSConsole, ADBE_JSDebugger, AddSilentPrint, AddViewerPreferences, AdjustData, AdobeExtensionLevel, Agent, AlwaysEmbed, Amd, config_Area, Attributes, AutoSave, Base, BatchOutput, BehaviorOverride, Cache, Change, Common, Compress, CompressLogicalStructure, CompressObjectStream, Compression, Config, Conformance, ContentCopy, Copies, Creator, CurrentPage, Data, Debug, DefaultTypeface, Destination, DocumentAssembly, Driver, DuplexOption, DynamicRender, Embed, config_Encrypt, config_Encryption, EncryptionLevel, Enforce, Equate, EquateRange, Exclude, ExcludeNS, FlipLabel, config_FontInfo, FormFieldFilling, GroupParent, IfEmpty, IncludeXDPContent, IncrementalLoad, IncrementalMerge, Interactive, Jog, LabelPrinter, Layout, Level, Linearized, Locale, LocaleSet, Log, MapElement, MediumInfo, config_Message, Messaging, Mode, ModifyAnnots, MsgId, NameAttr, NeverEmbed, NumberOfCopies, OpenAction, Output, OutputBin, OutputXSL, Overprint, Packets, PageOffset, PageRange, Pagination, PaginationOverride, Part, Pcl, Pdf, Pdfa, Permissions, PickTrayByPDFSize, config_Picture, PlaintextMetadata, Presence, Present, Print, PrintHighQuality, PrintScaling, PrinterName, Producer, Ps, Xo, Record, Relevant, Rename, RenderPolicy, RunScripts, config_Script, ScriptModel, Severity, SilentPrint, Staple, StartNode, StartPage, SubmitFormat, SubmitUrl, SubsetBelow, SuppressBanner, Tagged, config_Template, Threshold, To, TemplateCache, Trace, Transform, Type, Uri, config_Validate, ValidateApprovalSignatures, ValidationMessaging, Version, VersionControl, ViewerPreferences, WebClient, Whitespace, Window, Xdc, Xdp, Xsl, Zpl, ConfigNamespace, zo, ConnectionSet, EffectiveInputPolicy, EffectiveOutputPolicy, Operation, RootElement, SoapAction, SoapAddress, connection_set_Uri, WsdlAddress, WsdlConnection, XmlConnection, XsdConnection, ConnectionSetNamespace, Wo, datasets_Data, Datasets, DatasetsNamespace, Go, CalendarSymbols, CurrencySymbol, CurrencySymbols, DatePattern, DatePatterns, DateTimeSymbols, Day, DayNames, Era, EraNames, locale_set_Locale, locale_set_LocaleSet, Meridiem, MeridiemNames, Month, MonthNames, NumberPattern, NumberPatterns, NumberSymbol, NumberSymbols, TimePattern, TimePatterns, TypeFace, TypeFaces, LocaleSetNamespace, Vo, signature_Signature, SignatureNamespace, Ko, Stylesheet, StylesheetNamespace, Yo, xdp_Xdp, XdpNamespace, Jo, Zo, Qo, el, tl, il, al, nl, XhtmlObject, A, B, Body, Br, Html, I, Li, Ol, P, Span, Sub, Sup, Ul, XhtmlNamespace, sl, UnknownNamespace, Root, Empty, Builder, XFAParser, XFAFactory, AnnotationFactory, Annotation, AnnotationBorderStyle, MarkupAnnotation, WidgetAnnotation, TextWidgetAnnotation, ButtonWidgetAnnotation, ChoiceWidgetAnnotation, SignatureWidgetAnnotation, TextAnnotation, LinkAnnotation, PopupAnnotation, FreeTextAnnotation, LineAnnotation, SquareAnnotation, CircleAnnotation, PolylineAnnotation, PolygonAnnotation, CaretAnnotation, InkAnnotation, HighlightAnnotation, UnderlineAnnotation, SquigglyAnnotation, StrikeOutAnnotation, _fe, _me, me_fn, StampAnnotation, FileAttachmentAnnotation, rl, DatasetXMLParser, DatasetReader, SingleIntersector, Intersector, Word64, ol, ll, DecryptStream, ARCFourCipher, NullCipher, AESBaseCipher, AES128Cipher, AES256Cipher, PDFBase, PDF17, PDF20, CipherTransform, CipherTransformFactory, XRef, cl, Page, hl, dl, ul, PDFDocument, BasePdfManager, LocalPdfManager, NetworkPdfManager, gl, pl, fl, ml, bl, yl, wl, Al, xl, Sl, vl, PDFWorkerStream, PDFWorkerStreamReader, PDFWorkerStreamRangeReader, WorkerTask, WorkerMessageHandler, Cl, kl, Tl, Il, Fl, Ml, Dl, El, _l2, Pl, Rl, Bl, Nl, Ll, jl, $l, Hl, ql, Xl, zl, Wl, Gl, Vl, Kl, Yl, Jl, Zl, Ql, ec, tc, ic, ac, nc, sc, rc, oc, lc, cc, PasswordException, UnknownErrorException, InvalidPDFException, ResponseException, FormatError, AbortException, util_FeatureTest, hc, _e3, e_fn2, _t3, t_fn2, Util, dc, uc, gc, pc, _PixelsPerInch, PixelsPerInch, PageViewport, RenderingCancelledException, StatTimer, _it, PDFDateString, OutputScale, fc, _at, _nt, _st, _rt, _ot, _lt, _ct, _ht, _dt, dt_fn, _ut, ut_fn, _gt, gt_fn, _pt, pt_fn, _ft, ft_get, _EditorToolbar, EditorToolbar, FloatingToolbar, IdManager, ImageManager, CommandManager, KeyboardManager, _ColorManager, ColorManager, _Mt, _Dt, _Et, _Ot, __t, _Pt, _Rt, _Bt, _Nt, _Lt, _Ut, _jt, _$t, _Ht, _qt, _Xt, _zt, _Wt, _Gt, _Vt, _Kt, _Yt, _Jt, _Zt, _Qt, _ei, _ti, _ii, _ai, _ni, _si, _ri, _oi, _li, _ci, _hi, _di, _ui, _gi, _pi, _fi, _mi, _bi, _yi, _wi, _Ai, _xi, _Si, _vi, _Ii, Ii_fn, _Fi, Fi_fn, _Mi, Mi_fn, _Di, Di_fn, _Oi, Oi_fn, _Ci, Ci_fn, __i, _i_fn, _Pi, Pi_fn, _Ti, Ti_fn, _Ri, Ri_fn, _Bi, Bi_fn, _Ni, Ni_fn, _ki, ki_fn, _Ei, Ei_fn, _ji, ji_fn, _qi, qi_fn, _Hi, Hi_fn, _Li, Li_fn, _Xi, Xi_get, _$i, $i_fn, _Ui, Ui_fn, _AnnotationEditorUIManager, AnnotationEditorUIManager, _ot2, _zi, _Wi, _Gi, _Vi, _Ki, _Yi, _Ji, _st2, _Zi, _Qi, _ea, _ta, _ia, ia_get, _aa, aa_fn, _AltText, AltText, Comment, TouchManager, _va, _Ca, _ot3, _lt2, _ka, _Ta, _Ia, _Fa, _Ma, _Da, _Ea, _Oa, __a, _Pa, _Ra, _Ba, _Na, _La, _Ua, _ja, _$a, _Ha, _qa, _Xa, _za, _Ga, Ga_fn, _Va, Va_fn, _Ka, Ka_fn, _Ya, Ya_fn, _Ja, Ja_fn, _en, en_fn, _Qa, Qa_fn, _Za, Za_fn, _in, in_fn, _an, an_fn, _nn, nn_fn, _rn, rn_fn, _sn, sn_fn, _tn, tn_fn, _on, on_fn, _ln, ln_fn, _cn, cn_fn, _hn, hn_fn, _Wa, Wa_fn, _AnnotationEditor, AnnotationEditor, FakeEditor, mc, bc, yc, MurmurHash3_64, wc, AnnotationStorage, PrintAnnotationStorage, FontLoader, FontFaceObject, isRefProxy, Ac, LoopbackPort, xc, Sc, vc, Cc, kc, Tc, Ic, Fc, Mc, Dc, MessageHandler, BaseCanvasFactory, DOMCanvasFactory, BaseCMapReaderFactory, DOMCMapReaderFactory, BaseFilterFactory, DOMFilterFactory, BaseStandardFontDataFactory, DOMStandardFontDataFactory, BaseWasmFactory, DOMWasmFactory, NodeFilterFactory, NodeCanvasFactory, NodeCMapReaderFactory, NodeStandardFontDataFactory, NodeWasmFactory, Ec, CanvasDependencyTracker, CanvasNestedDependencyTracker, Oc, _c2, Pc, Rc, Bc, Nc, Lc, Uc, jc, $c, BaseShadingPattern, RadialAxialShadingPattern, MeshShadingPattern, DummyShadingPattern, Hc, qc, _TilingPattern, TilingPattern, Xc, zc, Wc, Gc, CachedCanvases, CanvasExtraState, Vc, Kc, Yc, Jc, CanvasGraphics, _ss, _rs, GlobalWorkerOptions, Metadata, Zc, OptionalContentGroup, OptionalContentConfig, PDFDataTransportStream, PDFDataTransportStreamReader, PDFDataTransportStreamRangeReader, PDFFetchStream, PDFFetchStreamReader, PDFFetchStreamRangeReader, NetworkManager, PDFNetworkStream, PDFNetworkStreamFullRequestReader, PDFNetworkStreamRangeRequestReader, Qc, PDFNodeStream, PDFNodeStreamFsFullReader, PDFNodeStreamFsRangeReader, eh, PDFObjects, _As, _Ai2, _xs, _Ss, _vs, _Cs, _ks, _Ts, _Is, _Fs, _Ms, _Ds, _Es, _Os, __s, _Ps, _Rs, _Bs, _Ns, _Ls, _Us, _js, _$s, _qs, qs_fn, _Ws, Ws_fn, _zs, zs_fn, _Xs, Xs_fn, _Vs, Vs_fn, _Hs, Hs_fn, _Gs, Gs_fn, _TextLayer, TextLayer, XfaText, _vn, _PDFDocumentLoadingTask, PDFDocumentLoadingTask, PDFDataRangeTransport, PDFDocumentProxy, PDFPageProxy, _As2, _tr, _ss2, _ir, _ar, _nr, _sr, _lr, lr_fn, _rr, rr_fn, _or, or_fn, _hr, hr_fn, _cr, cr_get, _PDFWorker, PDFWorker, WorkerTransport, RenderTask, _br, _yr, _InternalRenderTask, InternalRenderTask, th, ih, _wr, _Ar, _xr, _Sr, _vr, _Cr, _st3, _kr, _Tr, _mt, _Ir, _Dr, Dr_fn, _Er, Er_fn, _Mr, Mr_fn, _Fr, Fr_fn, _dt2, dt_fn2, _Or, Or_get, _ColorPicker, ColorPicker, __r, _st4, _mt2, _Ir2, _BasicColorPicker, BasicColorPicker, ColorConverters, BaseSVGFactory, DOMSVGFactory, XfaLayer, ah, nh, AnnotationElementFactory, AnnotationElement, LinkAnnotationElement, TextAnnotationElement, WidgetAnnotationElement, TextWidgetAnnotationElement, SignatureWidgetAnnotationElement, CheckboxWidgetAnnotationElement, RadioButtonWidgetAnnotationElement, PushButtonWidgetAnnotationElement, ChoiceWidgetAnnotationElement, PopupAnnotationElement, PopupElement, FreeTextAnnotationElement, LineAnnotationElement, SquareAnnotationElement, CircleAnnotationElement, PolylineAnnotationElement, PolygonAnnotationElement, CaretAnnotationElement, InkAnnotationElement, HighlightAnnotationElement, UnderlineAnnotationElement, SquigglyAnnotationElement, StrikeOutAnnotationElement, StampAnnotationElement, FileAttachmentAnnotationElement, AnnotationLayer, sh, _Kr, __o, _Po, _Ro, _po, _Bo, Bo_fn, _No, No_fn, _Uo, Uo_fn, _Lo, Lo_fn, _jo, jo_fn, _$o, $o_fn, _qo, qo_fn, _Ho, Ho_fn, _Xo, Xo_fn, _FreeTextEditor, FreeTextEditor, Outline, _zo, _Wo, _Go, _Vo, _Ko, _Yo, _Jo, _Zo, _Qo, _el, _tl, _il, _al, _nl, _sl, _rl, _ol, ol_fn, _ll, ll_fn, _hl, hl_fn, _cl, cl_fn, _dl, dl_fn, _gl, gl_fn, _ul, ul_fn, _FreeDrawOutliner, FreeDrawOutliner, FreeDrawOutline, HighlightOutliner, HighlightOutline, FreeHighlightOutliner, FreeHighlightOutline, _Tl, _Il, _Fl, _Ml, _nt2, _Dl, _El, _Ol, __l, _Pl, _At, _Rl, _bl, _Bl, _Nl, _ve, _il2, _Ll, _$l, $l_fn, _Ul, Ul_fn, _No2, No_fn2, _ql, ql_fn, _Xl, Xl_fn, _Wl, Wl_fn, _jl, jl_fn, _Hl, Hl_fn, _Gl, Gl_fn, _Vl, Vl_fn, _zl, zl_fn, _Kl, Kl_fn, _Yl, Yl_fn, _Zl, Zl_fn, _Jl, Jl_fn, _Xo2, Xo_fn2, _HighlightEditor, HighlightEditor, DrawingOptions, _ec, _tc, _ic, _ac, _nc, _sc, _rc, _oc, _lc, _cc, cc_fn, _hc, hc_fn, _Wl2, Wl_fn2, _jl2, jl_fn2, _pc, pc_fn, _uc, uc_fn, _dc, dc_fn, _gc, gc_fn, _DrawingEditor, DrawingEditor, InkDrawOutliner, InkDrawOutline, InkDrawingOptions, _Xo3, Xo_fn3, _InkEditor, InkEditor, ContourDrawOutline, _Tc, _Ic, Ic_fn, _Fc, _Mc, Mc_fn, _Dc, Dc_fn, _Ec, Ec_fn, _Oc, Oc_fn, __c, _c_fn, _Pc, Pc_fn, _Rc, Rc_fn, _Bc, Bc_fn, _Nc, Nc_fn, _Lc, Lc_fn, SignatureExtractor, SignatureOptions, DrawnSignatureOptions, _Uc, _jc, _$c, _Hc, _SignatureEditor, SignatureEditor, _qc, _Xc, _zc, _Wc, _Gc, _Vc, _Kc, _Yc, _Jc, _Zc, _Qc, _eh, eh_fn, _ih, ih_fn, _ah, ah_fn, _th, th_fn, _sh, sh_fn, _nh, nh_fn, _rh, rh_fn, _Xo4, Xo_fn4, StampEditor, _Io, _oh, _lh, _ch, _hh, _dh, _uh, _gh, _ph, _fh, _mh, _bh, _yh, _wh, _Ah, _mt3, _Xt2, _Sh, Sh_fn, _vh, vh_get, _Ch, Ch_fn, _kh, kh_fn, _xh, xh_fn, _AnnotationEditorLayer, AnnotationEditorLayer, _Qr, _Th, _Ih, _At2, _Fh, Fh_fn, _Mh, Mh_fn, _Dh, Dh_fn, _Eh, Eh_fn, _DrawLayer, DrawLayer;
var init_pdfjs = __esm({
  "node_modules/unpdf/dist/pdfjs.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    void 0 === globalThis.DOMMatrix && (globalThis.DOMMatrix = class {
    }), void 0 === globalThis.FinalizationRegistry && (globalThis.FinalizationRegistry = class {
      register() {
      }
      unregister() {
      }
    }), globalThis.navigator ??= {}, globalThis.navigator.platform ??= "", globalThis.navigator.userAgent ??= "", void 0 === Promise.withResolvers && (Promise.withResolvers = function() {
      let e2, t2;
      return { promise: new Promise((i2, a2) => {
        e2 = i2, t2 = a2;
      }), resolve: e2, reject: t2 };
    });
    e = !("object" != typeof process || process + "" != "[object process]" || process.versions.nw || process.versions.electron && process.type && "browser" !== process.type);
    t = [1e-3, 0, 0, 1e-3, 0, 0];
    i = 1.35;
    a = 0.35;
    n = 0.25925925925925924;
    s = 1;
    r = 2;
    o = 4;
    l2 = 8;
    c = 16;
    h = 64;
    d = 128;
    u = 256;
    g = "pdfjs_internal_editor_";
    p = 3;
    f = 9;
    m = 13;
    b = 15;
    y = 101;
    w = { PRINT: 4, MODIFY_CONTENTS: 8, COPY: 16, MODIFY_ANNOTATIONS: 32, FILL_INTERACTIVE_FORMS: 256, COPY_FOR_ACCESSIBILITY: 512, ASSEMBLE: 1024, PRINT_HIGH_QUALITY: 2048 };
    x = 0;
    S = 4;
    v = 1;
    C = 2;
    k = 3;
    T = { TEXT: 1, LINK: 2, FREETEXT: 3, LINE: 4, SQUARE: 5, CIRCLE: 6, POLYGON: 7, POLYLINE: 8, HIGHLIGHT: 9, UNDERLINE: 10, SQUIGGLY: 11, STRIKEOUT: 12, STAMP: 13, CARET: 14, INK: 15, POPUP: 16, FILEATTACHMENT: 17, SOUND: 18, MOVIE: 19, WIDGET: 20, SCREEN: 21, PRINTERMARK: 22, TRAPNET: 23, WATERMARK: 24, THREED: 25, REDACT: 26 };
    F = "Group";
    M = "R";
    D = 1;
    E = 2;
    O = 4;
    _ = 16;
    R = 32;
    N = 128;
    L = 512;
    U = 1;
    j = 2;
    $ = 4096;
    H = 8192;
    q = 32768;
    X = 65536;
    z = 131072;
    W = 1048576;
    G = 2097152;
    V = 8388608;
    K = 16777216;
    Y = 1;
    J = 2;
    Z = 3;
    Q = 4;
    ee = 5;
    te = { E: "Mouse Enter", X: "Mouse Exit", D: "Mouse Down", U: "Mouse Up", Fo: "Focus", Bl: "Blur", PO: "PageOpen", PC: "PageClose", PV: "PageVisible", PI: "PageInvisible", K: "Keystroke", F: "Format", V: "Validate", C: "Calculate" };
    ie = { WC: "WillClose", WS: "WillSave", DS: "DidSave", WP: "WillPrint", DP: "DidPrint" };
    ae = { O: "PageOpen", C: "PageClose" };
    ne = 1;
    se = 5;
    re = 1;
    oe = 2;
    le = 3;
    ce = 4;
    he = 5;
    de = 6;
    ue = 7;
    ge = 8;
    pe = 9;
    fe = 10;
    me = 11;
    be = 12;
    ye = 13;
    we = 14;
    Ae = 15;
    xe = 16;
    Se = 17;
    ve = 18;
    Ce = 19;
    ke = 20;
    Te = 21;
    Ie = 22;
    Fe = 23;
    Me = 24;
    De = 25;
    Ee = 26;
    Oe = 27;
    _e = 28;
    Pe = 29;
    Re = 30;
    Be = 31;
    Ne = 32;
    Le = 33;
    Ue = 34;
    je = 35;
    $e = 36;
    He = 37;
    qe = 38;
    Xe = 39;
    ze = 40;
    We = 41;
    Ge = 42;
    Ve = 43;
    Ke = 44;
    Ye = 45;
    Je = 46;
    Ze = 47;
    Qe = 48;
    et = 49;
    tt = 50;
    it = 51;
    at = 52;
    nt = 53;
    st = 54;
    rt = 55;
    ot = 56;
    lt = 57;
    ct = 58;
    ht = 59;
    dt = 60;
    ut = 61;
    gt = 62;
    pt = 63;
    ft = 64;
    mt = 65;
    bt = 66;
    yt = 67;
    wt = 68;
    At = 69;
    xt = 70;
    St = 71;
    vt = 72;
    Ct = 73;
    kt = 74;
    Tt = 75;
    It = 76;
    Ft = 77;
    Mt = 80;
    Dt = 81;
    Et = 83;
    Ot = 84;
    _t = 85;
    Pt = 86;
    Rt = 87;
    Bt = 88;
    Nt = 89;
    Lt = 90;
    Ut = 91;
    jt = 92;
    $t = 93;
    Ht = 94;
    qt = 0;
    Xt = 1;
    zt = 2;
    Wt = 3;
    Gt = 1;
    Vt = 2;
    Kt = ne;
    __name(info$1, "info$1");
    __name(warn$1, "warn$1");
    __name(unreachable$1, "unreachable$1");
    __name(assert$1, "assert$1");
    __name(createValidAbsoluteUrl$1, "createValidAbsoluteUrl$1");
    __name(shadow$1, "shadow$1");
    Yt = function() {
      function BaseException(e2, t2) {
        this.message = e2, this.name = t2;
      }
      __name(BaseException, "BaseException");
      return BaseException.prototype = new Error(), BaseException.constructor = BaseException, BaseException;
    }();
    Jt = /* @__PURE__ */ __name(class extends Yt {
      constructor(e2, t2) {
        super(e2, "PasswordException"), this.code = t2;
      }
    }, "Jt");
    Zt = /* @__PURE__ */ __name(class extends Yt {
      constructor(e2, t2) {
        super(e2, "UnknownErrorException"), this.details = t2;
      }
    }, "Zt");
    Qt = /* @__PURE__ */ __name(class extends Yt {
      constructor(e2) {
        super(e2, "InvalidPDFException");
      }
    }, "Qt");
    ei = /* @__PURE__ */ __name(class extends Yt {
      constructor(e2, t2, i2) {
        super(e2, "ResponseException"), this.status = t2, this.missing = i2;
      }
    }, "ei");
    ti = /* @__PURE__ */ __name(class extends Yt {
      constructor(e2) {
        super(e2, "FormatError");
      }
    }, "ti");
    ii = /* @__PURE__ */ __name(class extends Yt {
      constructor(e2) {
        super(e2, "AbortException");
      }
    }, "ii");
    __name(bytesToString$1, "bytesToString$1");
    __name(stringToBytes$1, "stringToBytes$1");
    __name(string32$1, "string32$1");
    __name(objectSize, "objectSize");
    FeatureTest = class {
      static get isLittleEndian() {
        return shadow$1(this, "isLittleEndian", function() {
          const e2 = new Uint8Array(4);
          return e2[0] = 1, 1 === new Uint32Array(e2.buffer, 0, 1)[0];
        }());
      }
      static get isEvalSupported() {
        return shadow$1(this, "isEvalSupported", function() {
          try {
            return new Function(""), true;
          } catch {
            return false;
          }
        }());
      }
      static get isOffscreenCanvasSupported() {
        return shadow$1(this, "isOffscreenCanvasSupported", "undefined" != typeof OffscreenCanvas);
      }
      static get isImageDecoderSupported() {
        return shadow$1(this, "isImageDecoderSupported", "undefined" != typeof ImageDecoder);
      }
      static get platform() {
        const { platform: e2, userAgent: t2 } = navigator;
        return shadow$1(this, "platform", { isAndroid: t2.includes("Android"), isLinux: e2.includes("Linux"), isMac: e2.includes("Mac"), isWindows: e2.includes("Win"), isFirefox: t2.includes("Firefox") });
      }
      static get isCSSRoundSupported() {
        return shadow$1(this, "isCSSRoundSupported", globalThis.CSS?.supports?.("width: round(1.5px, 1px)"));
      }
    };
    __name(FeatureTest, "FeatureTest");
    ai = Array.from(Array(256).keys(), (e2) => e2.toString(16).padStart(2, "0"));
    ni = /* @__PURE__ */ __name((_a = class {
      static makeHexColor(e2, t2, i2) {
        return `#${ai[e2]}${ai[t2]}${ai[i2]}`;
      }
      static domMatrixToTransform(e2) {
        return [e2.a, e2.b, e2.c, e2.d, e2.e, e2.f];
      }
      static scaleMinMax(e2, t2) {
        let i2;
        e2[0] ? (e2[0] < 0 && (i2 = t2[0], t2[0] = t2[2], t2[2] = i2), t2[0] *= e2[0], t2[2] *= e2[0], e2[3] < 0 && (i2 = t2[1], t2[1] = t2[3], t2[3] = i2), t2[1] *= e2[3], t2[3] *= e2[3]) : (i2 = t2[0], t2[0] = t2[1], t2[1] = i2, i2 = t2[2], t2[2] = t2[3], t2[3] = i2, e2[1] < 0 && (i2 = t2[1], t2[1] = t2[3], t2[3] = i2), t2[1] *= e2[1], t2[3] *= e2[1], e2[2] < 0 && (i2 = t2[0], t2[0] = t2[2], t2[2] = i2), t2[0] *= e2[2], t2[2] *= e2[2]), t2[0] += e2[4], t2[1] += e2[5], t2[2] += e2[4], t2[3] += e2[5];
      }
      static transform(e2, t2) {
        return [e2[0] * t2[0] + e2[2] * t2[1], e2[1] * t2[0] + e2[3] * t2[1], e2[0] * t2[2] + e2[2] * t2[3], e2[1] * t2[2] + e2[3] * t2[3], e2[0] * t2[4] + e2[2] * t2[5] + e2[4], e2[1] * t2[4] + e2[3] * t2[5] + e2[5]];
      }
      static multiplyByDOMMatrix(e2, t2) {
        return [e2[0] * t2.a + e2[2] * t2.b, e2[1] * t2.a + e2[3] * t2.b, e2[0] * t2.c + e2[2] * t2.d, e2[1] * t2.c + e2[3] * t2.d, e2[0] * t2.e + e2[2] * t2.f + e2[4], e2[1] * t2.e + e2[3] * t2.f + e2[5]];
      }
      static applyTransform(e2, t2, i2 = 0) {
        const a2 = e2[i2], n2 = e2[i2 + 1];
        e2[i2] = a2 * t2[0] + n2 * t2[2] + t2[4], e2[i2 + 1] = a2 * t2[1] + n2 * t2[3] + t2[5];
      }
      static applyTransformToBezier(e2, t2, i2 = 0) {
        const a2 = t2[0], n2 = t2[1], s2 = t2[2], r2 = t2[3], o2 = t2[4], l3 = t2[5];
        for (let t3 = 0; t3 < 6; t3 += 2) {
          const c2 = e2[i2 + t3], h2 = e2[i2 + t3 + 1];
          e2[i2 + t3] = c2 * a2 + h2 * s2 + o2, e2[i2 + t3 + 1] = c2 * n2 + h2 * r2 + l3;
        }
      }
      static applyInverseTransform(e2, t2) {
        const i2 = e2[0], a2 = e2[1], n2 = t2[0] * t2[3] - t2[1] * t2[2];
        e2[0] = (i2 * t2[3] - a2 * t2[2] + t2[2] * t2[5] - t2[4] * t2[3]) / n2, e2[1] = (-i2 * t2[1] + a2 * t2[0] + t2[4] * t2[1] - t2[5] * t2[0]) / n2;
      }
      static axialAlignedBoundingBox(e2, t2, i2) {
        const a2 = t2[0], n2 = t2[1], s2 = t2[2], r2 = t2[3], o2 = t2[4], l3 = t2[5], c2 = e2[0], h2 = e2[1], d2 = e2[2], u2 = e2[3];
        let g2 = a2 * c2 + o2, p2 = g2, f2 = a2 * d2 + o2, m2 = f2, b2 = r2 * h2 + l3, y2 = b2, w2 = r2 * u2 + l3, x2 = w2;
        if (0 !== n2 || 0 !== s2) {
          const e3 = n2 * c2, t3 = n2 * d2, i3 = s2 * h2, a3 = s2 * u2;
          g2 += i3, m2 += i3, f2 += a3, p2 += a3, b2 += e3, x2 += e3, w2 += t3, y2 += t3;
        }
        i2[0] = Math.min(i2[0], g2, f2, p2, m2), i2[1] = Math.min(i2[1], b2, w2, y2, x2), i2[2] = Math.max(i2[2], g2, f2, p2, m2), i2[3] = Math.max(i2[3], b2, w2, y2, x2);
      }
      static inverseTransform(e2) {
        const t2 = e2[0] * e2[3] - e2[1] * e2[2];
        return [e2[3] / t2, -e2[1] / t2, -e2[2] / t2, e2[0] / t2, (e2[2] * e2[5] - e2[4] * e2[3]) / t2, (e2[4] * e2[1] - e2[5] * e2[0]) / t2];
      }
      static singularValueDecompose2dScale(e2, t2) {
        const i2 = e2[0], a2 = e2[1], n2 = e2[2], s2 = e2[3], r2 = i2 ** 2 + a2 ** 2, o2 = i2 * n2 + a2 * s2, l3 = n2 ** 2 + s2 ** 2, c2 = (r2 + l3) / 2, h2 = Math.sqrt(c2 ** 2 - (r2 * l3 - o2 ** 2));
        t2[0] = Math.sqrt(c2 + h2 || 1), t2[1] = Math.sqrt(c2 - h2 || 1);
      }
      static normalizeRect(e2) {
        const t2 = e2.slice(0);
        return e2[0] > e2[2] && (t2[0] = e2[2], t2[2] = e2[0]), e2[1] > e2[3] && (t2[1] = e2[3], t2[3] = e2[1]), t2;
      }
      static intersect(e2, t2) {
        const i2 = Math.max(Math.min(e2[0], e2[2]), Math.min(t2[0], t2[2])), a2 = Math.min(Math.max(e2[0], e2[2]), Math.max(t2[0], t2[2]));
        if (i2 > a2)
          return null;
        const n2 = Math.max(Math.min(e2[1], e2[3]), Math.min(t2[1], t2[3])), s2 = Math.min(Math.max(e2[1], e2[3]), Math.max(t2[1], t2[3]));
        return n2 > s2 ? null : [i2, n2, a2, s2];
      }
      static pointBoundingBox(e2, t2, i2) {
        i2[0] = Math.min(i2[0], e2), i2[1] = Math.min(i2[1], t2), i2[2] = Math.max(i2[2], e2), i2[3] = Math.max(i2[3], t2);
      }
      static rectBoundingBox(e2, t2, i2, a2, n2) {
        n2[0] = Math.min(n2[0], e2, i2), n2[1] = Math.min(n2[1], t2, a2), n2[2] = Math.max(n2[2], e2, i2), n2[3] = Math.max(n2[3], t2, a2);
      }
      static bezierBoundingBox(e2, t2, i2, a2, n2, s2, r2, o2, l3) {
        l3[0] = Math.min(l3[0], e2, r2), l3[1] = Math.min(l3[1], t2, o2), l3[2] = Math.max(l3[2], e2, r2), l3[3] = Math.max(l3[3], t2, o2), __privateMethod(this, _t2, t_fn).call(this, e2, i2, n2, r2, t2, a2, s2, o2, 3 * (3 * (i2 - n2) - e2 + r2), 6 * (e2 - 2 * i2 + n2), 3 * (i2 - e2), l3), __privateMethod(this, _t2, t_fn).call(this, e2, i2, n2, r2, t2, a2, s2, o2, 3 * (3 * (a2 - s2) - t2 + o2), 6 * (t2 - 2 * a2 + s2), 3 * (a2 - t2), l3);
      }
    }, _e2 = new WeakSet(), e_fn = /* @__PURE__ */ __name(function(e2, t2, i2, a2, n2, s2, r2, o2, l3, c2) {
      if (l3 <= 0 || l3 >= 1)
        return;
      const h2 = 1 - l3, d2 = l3 * l3, u2 = d2 * l3, g2 = h2 * (h2 * (h2 * e2 + 3 * l3 * t2) + 3 * d2 * i2) + u2 * a2, p2 = h2 * (h2 * (h2 * n2 + 3 * l3 * s2) + 3 * d2 * r2) + u2 * o2;
      c2[0] = Math.min(c2[0], g2), c2[1] = Math.min(c2[1], p2), c2[2] = Math.max(c2[2], g2), c2[3] = Math.max(c2[3], p2);
    }, "#e"), _t2 = new WeakSet(), t_fn = /* @__PURE__ */ __name(function(e2, t2, i2, a2, n2, s2, r2, o2, l3, c2, h2, d2) {
      if (Math.abs(l3) < 1e-12)
        return void (Math.abs(c2) >= 1e-12 && __privateMethod(this, _e2, e_fn).call(this, e2, t2, i2, a2, n2, s2, r2, o2, -h2 / c2, d2));
      const u2 = c2 ** 2 - 4 * h2 * l3;
      if (u2 < 0)
        return;
      const g2 = Math.sqrt(u2), p2 = 2 * l3;
      __privateMethod(this, _e2, e_fn).call(this, e2, t2, i2, a2, n2, s2, r2, o2, (-c2 + g2) / p2, d2), __privateMethod(this, _e2, e_fn).call(this, e2, t2, i2, a2, n2, s2, r2, o2, (-c2 - g2) / p2, d2);
    }, "#t"), __privateAdd(_a, _e2), __privateAdd(_a, _t2), _a), "ni");
    si = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 711, 710, 729, 733, 731, 730, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225, 8230, 8212, 8211, 402, 8260, 8249, 8250, 8722, 8240, 8222, 8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338, 352, 376, 381, 305, 322, 339, 353, 382, 0, 8364];
    __name(stringToPDFString, "stringToPDFString");
    __name(stringToUTF8String$1, "stringToUTF8String$1");
    __name(utf8StringToString, "utf8StringToString");
    __name(isArrayEqual, "isArrayEqual");
    __name(getModificationDate, "getModificationDate");
    ri = null;
    oi = null;
    __name(MathClamp$1, "MathClamp$1");
    __name(toHexUtil, "toHexUtil");
    "function" != typeof Promise.try && (Promise.try = function(e2, ...t2) {
      return new Promise((i2) => {
        i2(e2(...t2));
      });
    }), "function" != typeof Math.sumPrecise && (Math.sumPrecise = function(e2) {
      return e2.reduce((e3, t2) => e3 + t2, 0);
    });
    li = Symbol("CIRCULAR_REF");
    ci = Symbol("EOF");
    hi = /* @__PURE__ */ Object.create(null);
    di = /* @__PURE__ */ Object.create(null);
    ui = /* @__PURE__ */ Object.create(null);
    Name = class {
      constructor(e2) {
        this.name = e2;
      }
      static get(e2) {
        return di[e2] ||= new Name(e2);
      }
    };
    __name(Name, "Name");
    Cmd = class {
      constructor(e2) {
        this.cmd = e2;
      }
      static get(e2) {
        return hi[e2] ||= new Cmd(e2);
      }
    };
    __name(Cmd, "Cmd");
    nonSerializable = /* @__PURE__ */ __name(function() {
      return nonSerializable;
    }, "nonSerializable");
    Dict = class {
      constructor(e2 = null) {
        this._map = /* @__PURE__ */ new Map(), this.xref = e2, this.objId = null, this.suppressEncryption = false, this.__nonSerializable__ = nonSerializable;
      }
      assignXref(e2) {
        this.xref = e2;
      }
      get size() {
        return this._map.size;
      }
      get(e2, t2, i2) {
        let a2 = this._map.get(e2);
        return void 0 === a2 && void 0 !== t2 && (a2 = this._map.get(t2), void 0 === a2 && void 0 !== i2 && (a2 = this._map.get(i2))), a2 instanceof Ref && this.xref ? this.xref.fetch(a2, this.suppressEncryption) : a2;
      }
      async getAsync(e2, t2, i2) {
        let a2 = this._map.get(e2);
        return void 0 === a2 && void 0 !== t2 && (a2 = this._map.get(t2), void 0 === a2 && void 0 !== i2 && (a2 = this._map.get(i2))), a2 instanceof Ref && this.xref ? this.xref.fetchAsync(a2, this.suppressEncryption) : a2;
      }
      getArray(e2, t2, i2) {
        let a2 = this._map.get(e2);
        if (void 0 === a2 && void 0 !== t2 && (a2 = this._map.get(t2), void 0 === a2 && void 0 !== i2 && (a2 = this._map.get(i2))), a2 instanceof Ref && this.xref && (a2 = this.xref.fetch(a2, this.suppressEncryption)), Array.isArray(a2)) {
          a2 = a2.slice();
          for (let e3 = 0, t3 = a2.length; e3 < t3; e3++)
            a2[e3] instanceof Ref && this.xref && (a2[e3] = this.xref.fetch(a2[e3], this.suppressEncryption));
        }
        return a2;
      }
      getRaw(e2) {
        return this._map.get(e2);
      }
      getKeys() {
        return [...this._map.keys()];
      }
      getRawValues() {
        return [...this._map.values()];
      }
      set(e2, t2) {
        this._map.set(e2, t2);
      }
      setIfNotExists(e2, t2) {
        this.has(e2) || this.set(e2, t2);
      }
      setIfNumber(e2, t2) {
        "number" == typeof t2 && this.set(e2, t2);
      }
      setIfArray(e2, t2) {
        (Array.isArray(t2) || ArrayBuffer.isView(t2)) && this.set(e2, t2);
      }
      setIfDefined(e2, t2) {
        null != t2 && this.set(e2, t2);
      }
      setIfName(e2, t2) {
        "string" == typeof t2 ? this.set(e2, Name.get(t2)) : t2 instanceof Name && this.set(e2, t2);
      }
      has(e2) {
        return this._map.has(e2);
      }
      *[Symbol.iterator]() {
        for (const [e2, t2] of this._map)
          yield [e2, t2 instanceof Ref && this.xref ? this.xref.fetch(t2, this.suppressEncryption) : t2];
      }
      static get empty() {
        const e2 = new Dict(null);
        return e2.set = (e3, t2) => {
          unreachable$1("Should not call `set` on the empty dictionary.");
        }, shadow$1(this, "empty", e2);
      }
      static merge({ xref: e2, dictArray: t2, mergeSubDicts: i2 = false }) {
        const a2 = new Dict(e2), n2 = /* @__PURE__ */ new Map();
        for (const e3 of t2)
          if (e3 instanceof Dict)
            for (const [t3, a3] of e3._map) {
              let e4 = n2.get(t3);
              if (void 0 === e4)
                e4 = [], n2.set(t3, e4);
              else if (!(i2 && a3 instanceof Dict))
                continue;
              e4.push(a3);
            }
        for (const [t3, i3] of n2) {
          if (1 === i3.length || !(i3[0] instanceof Dict)) {
            a2._map.set(t3, i3[0]);
            continue;
          }
          const n3 = new Dict(e2);
          for (const e3 of i3)
            for (const [t4, i4] of e3._map)
              n3._map.has(t4) || n3._map.set(t4, i4);
          n3.size > 0 && a2._map.set(t3, n3);
        }
        return n2.clear(), a2.size > 0 ? a2 : Dict.empty;
      }
      clone() {
        const e2 = new Dict(this.xref);
        for (const t2 of this.getKeys())
          e2.set(t2, this.getRaw(t2));
        return e2;
      }
      delete(e2) {
        delete this._map[e2];
      }
    };
    __name(Dict, "Dict");
    Ref = class {
      constructor(e2, t2) {
        this.num = e2, this.gen = t2;
      }
      toString() {
        return 0 === this.gen ? `${this.num}R` : `${this.num}R${this.gen}`;
      }
      static fromString(e2) {
        const t2 = ui[e2];
        if (t2)
          return t2;
        const i2 = /^(\d+)R(\d*)$/.exec(e2);
        return i2 && "0" !== i2[1] ? ui[e2] = new Ref(parseInt(i2[1]), i2[2] ? parseInt(i2[2]) : 0) : null;
      }
      static get(e2, t2) {
        const i2 = 0 === t2 ? `${e2}R` : `${e2}R${t2}`;
        return ui[i2] ||= new Ref(e2, t2);
      }
    };
    __name(Ref, "Ref");
    RefSet = class {
      constructor(e2 = null) {
        this._set = new Set(e2?._set);
      }
      has(e2) {
        return this._set.has(e2.toString());
      }
      put(e2) {
        this._set.add(e2.toString());
      }
      remove(e2) {
        this._set.delete(e2.toString());
      }
      [Symbol.iterator]() {
        return this._set.values();
      }
      clear() {
        this._set.clear();
      }
    };
    __name(RefSet, "RefSet");
    RefSetCache = class {
      constructor() {
        this._map = /* @__PURE__ */ new Map();
      }
      get size() {
        return this._map.size;
      }
      get(e2) {
        return this._map.get(e2.toString());
      }
      has(e2) {
        return this._map.has(e2.toString());
      }
      put(e2, t2) {
        this._map.set(e2.toString(), t2);
      }
      putAlias(e2, t2) {
        this._map.set(e2.toString(), this.get(t2));
      }
      [Symbol.iterator]() {
        return this._map.values();
      }
      clear() {
        this._map.clear();
      }
      *values() {
        yield* this._map.values();
      }
      *items() {
        for (const [e2, t2] of this._map)
          yield [Ref.fromString(e2), t2];
      }
    };
    __name(RefSetCache, "RefSetCache");
    __name(isName, "isName");
    __name(isCmd, "isCmd");
    __name(isDict, "isDict");
    __name(isRefsEqual, "isRefsEqual");
    BaseStream = class {
      get length() {
        unreachable$1("Abstract getter `length` accessed");
      }
      get isEmpty() {
        unreachable$1("Abstract getter `isEmpty` accessed");
      }
      get isDataLoaded() {
        return shadow$1(this, "isDataLoaded", true);
      }
      getByte() {
        unreachable$1("Abstract method `getByte` called");
      }
      getBytes(e2) {
        unreachable$1("Abstract method `getBytes` called");
      }
      async getImageData(e2, t2) {
        return this.getBytes(e2, t2);
      }
      async asyncGetBytes() {
        unreachable$1("Abstract method `asyncGetBytes` called");
      }
      get isAsync() {
        return false;
      }
      get isAsyncDecoder() {
        return false;
      }
      get canAsyncDecodeImageFromBuffer() {
        return false;
      }
      async getTransferableImage() {
        return null;
      }
      peekByte() {
        const e2 = this.getByte();
        return -1 !== e2 && this.pos--, e2;
      }
      peekBytes(e2) {
        const t2 = this.getBytes(e2);
        return this.pos -= t2.length, t2;
      }
      getUint16() {
        const e2 = this.getByte(), t2 = this.getByte();
        return -1 === e2 || -1 === t2 ? -1 : (e2 << 8) + t2;
      }
      getInt32() {
        return (this.getByte() << 24) + (this.getByte() << 16) + (this.getByte() << 8) + this.getByte();
      }
      getByteRange(e2, t2) {
        unreachable$1("Abstract method `getByteRange` called");
      }
      getString(e2) {
        return bytesToString$1(this.getBytes(e2));
      }
      skip(e2) {
        this.pos += e2 || 1;
      }
      reset() {
        unreachable$1("Abstract method `reset` called");
      }
      moveStart() {
        unreachable$1("Abstract method `moveStart` called");
      }
      makeSubStream(e2, t2, i2 = null) {
        unreachable$1("Abstract method `makeSubStream` called");
      }
      getBaseStreams() {
        return null;
      }
    };
    __name(BaseStream, "BaseStream");
    gi = /^[1-9]\.\d$/;
    pi = 2 ** 31 - 1;
    fi = [1, 0, 0, 1, 0, 0];
    mi = ["ColorSpace", "ExtGState", "Font", "Pattern", "Properties", "Shading", "XObject"];
    bi = ["ExtGState", "Font", "Properties", "XObject"];
    __name(getLookupTableFactory, "getLookupTableFactory");
    MissingDataException = class extends Yt {
      constructor(e2, t2) {
        super(`Missing data [${e2}, ${t2})`, "MissingDataException"), this.begin = e2, this.end = t2;
      }
    };
    __name(MissingDataException, "MissingDataException");
    ParserEOFException = class extends Yt {
      constructor(e2) {
        super(e2, "ParserEOFException");
      }
    };
    __name(ParserEOFException, "ParserEOFException");
    XRefEntryException = class extends Yt {
      constructor(e2) {
        super(e2, "XRefEntryException");
      }
    };
    __name(XRefEntryException, "XRefEntryException");
    XRefParseException = class extends Yt {
      constructor(e2) {
        super(e2, "XRefParseException");
      }
    };
    __name(XRefParseException, "XRefParseException");
    __name(arrayBuffersToBytes, "arrayBuffersToBytes");
    __name(fetchBinaryData, "fetchBinaryData");
    __name(getInheritableProperty, "getInheritableProperty");
    yi = ["", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM", "", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC", "", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"];
    __name(toRomanNumerals, "toRomanNumerals");
    __name(log22, "log2");
    __name(readInt8, "readInt8");
    __name(readInt16, "readInt16");
    __name(readUint16, "readUint16");
    __name(readUint32, "readUint32");
    __name(isWhiteSpace, "isWhiteSpace");
    __name(isNumberArray, "isNumberArray");
    __name(lookupMatrix, "lookupMatrix");
    __name(lookupRect, "lookupRect");
    __name(lookupNormalRect, "lookupNormalRect");
    __name(parseXFAPath, "parseXFAPath");
    __name(escapePDFName, "escapePDFName");
    __name(escapeString, "escapeString");
    __name(_collectJS, "_collectJS");
    __name(collectActions, "collectActions");
    wi = { 60: "&lt;", 62: "&gt;", 38: "&amp;", 34: "&quot;", 39: "&apos;" };
    __name(codePointIter, "codePointIter");
    __name(encodeToXmlString, "encodeToXmlString");
    __name(validateFontName, "validateFontName");
    __name(validateCSSFont, "validateCSSFont");
    __name(recoverJsURL, "recoverJsURL");
    __name(numberToString, "numberToString");
    __name(getNewAnnotationsMap, "getNewAnnotationsMap");
    __name(stringToAsciiOrUTF16BE, "stringToAsciiOrUTF16BE");
    __name(stringToUTF16HexString, "stringToUTF16HexString");
    __name(stringToUTF16String, "stringToUTF16String");
    __name(getRotationMatrix, "getRotationMatrix");
    __name(getSizeInBytes, "getSizeInBytes");
    QCMS = class {
      static get _memoryArray() {
        const e2 = __privateGet(this, _i);
        return e2?.byteLength ? e2 : __privateSet(this, _i, new Uint8Array(this._memory.buffer));
      }
    };
    __name(QCMS, "QCMS");
    _i = new WeakMap();
    __privateAdd(QCMS, _i, null);
    __publicField(QCMS, "_memory", null);
    __publicField(QCMS, "_mustAddAlpha", false);
    __publicField(QCMS, "_destBuffer", null);
    __publicField(QCMS, "_destOffset", 0);
    __publicField(QCMS, "_destLength", 0);
    __publicField(QCMS, "_cssColor", "");
    __publicField(QCMS, "_makeHexColor", null);
    xi = "undefined" != typeof TextDecoder ? new TextDecoder("utf-8", { ignoreBOM: true, fatal: true }) : { decode: () => {
      throw Error("TextDecoder not available");
    } };
    "undefined" != typeof TextDecoder && xi.decode();
    Si = null;
    __name(getUint8ArrayMemory0, "getUint8ArrayMemory0");
    vi = 0;
    __name(passArray8ToWasm0, "passArray8ToWasm0");
    Ci = Object.freeze({ RGB8: 0, 0: "RGB8", RGBA8: 1, 1: "RGBA8", BGRA8: 2, 2: "BGRA8", Gray8: 3, 3: "Gray8", GrayA8: 4, 4: "GrayA8", CMYK: 5, 5: "CMYK" });
    ki = Object.freeze({ Perceptual: 0, 0: "Perceptual", RelativeColorimetric: 1, 1: "RelativeColorimetric", Saturation: 2, 2: "Saturation", AbsoluteColorimetric: 3, 3: "AbsoluteColorimetric" });
    __name(__wbg_get_imports, "__wbg_get_imports");
    __name(initSync, "initSync");
    _ColorSpace = class {
      constructor(e2, t2) {
        this.name = e2, this.numComps = t2;
      }
      getRgb(e2, t2, i2 = new Uint8ClampedArray(3)) {
        return this.getRgbItem(e2, t2, i2, 0), i2;
      }
      getRgbHex(e2, t2) {
        const i2 = this.getRgb(e2, t2, __privateGet(_ColorSpace, _a2));
        return ni.makeHexColor(i2[0], i2[1], i2[2]);
      }
      getRgbItem(e2, t2, i2, a2) {
        unreachable$1("Should not call ColorSpace.getRgbItem");
      }
      getRgbBuffer(e2, t2, i2, a2, n2, s2, r2) {
        unreachable$1("Should not call ColorSpace.getRgbBuffer");
      }
      getOutputLength(e2, t2) {
        unreachable$1("Should not call ColorSpace.getOutputLength");
      }
      isPassthrough(e2) {
        return false;
      }
      isDefaultDecode(e2, t2) {
        return _ColorSpace.isDefaultDecode(e2, this.numComps);
      }
      fillRgb(e2, t2, i2, a2, n2, s2, r2, o2, l3) {
        const c2 = t2 * i2;
        let h2 = null;
        const d2 = 1 << r2, u2 = i2 !== n2 || t2 !== a2;
        if (this.isPassthrough(r2))
          h2 = o2;
        else if (1 === this.numComps && c2 > d2 && "DeviceGray" !== this.name && "DeviceRGB" !== this.name) {
          const t3 = r2 <= 8 ? new Uint8Array(d2) : new Uint16Array(d2);
          for (let e3 = 0; e3 < d2; e3++)
            t3[e3] = e3;
          const i3 = new Uint8ClampedArray(3 * d2);
          if (this.getRgbBuffer(t3, 0, d2, i3, 0, r2, 0), u2) {
            h2 = new Uint8Array(3 * c2);
            let e3 = 0;
            for (let t4 = 0; t4 < c2; ++t4) {
              const a3 = 3 * o2[t4];
              h2[e3++] = i3[a3], h2[e3++] = i3[a3 + 1], h2[e3++] = i3[a3 + 2];
            }
          } else {
            let t4 = 0;
            for (let a3 = 0; a3 < c2; ++a3) {
              const n3 = 3 * o2[a3];
              e2[t4++] = i3[n3], e2[t4++] = i3[n3 + 1], e2[t4++] = i3[n3 + 2], t4 += l3;
            }
          }
        } else
          u2 ? (h2 = new Uint8ClampedArray(3 * c2), this.getRgbBuffer(o2, 0, c2, h2, 0, r2, 0)) : this.getRgbBuffer(o2, 0, a2 * s2, e2, 0, r2, l3);
        if (h2)
          if (u2)
            !function(e3, t3, i3, a3, n3, s3, r3) {
              r3 = 1 !== r3 ? 0 : r3;
              const o3 = i3 / n3, l4 = a3 / s3;
              let c3, h3 = 0;
              const d3 = new Uint16Array(n3), u3 = 3 * i3;
              for (let e4 = 0; e4 < n3; e4++)
                d3[e4] = 3 * Math.floor(e4 * o3);
              for (let i4 = 0; i4 < s3; i4++) {
                const a4 = Math.floor(i4 * l4) * u3;
                for (let i5 = 0; i5 < n3; i5++)
                  c3 = a4 + d3[i5], t3[h3++] = e3[c3++], t3[h3++] = e3[c3++], t3[h3++] = e3[c3++], h3 += r3;
              }
            }(h2, e2, t2, i2, a2, n2, l3);
          else {
            let t3 = 0, i3 = 0;
            for (let n3 = 0, r3 = a2 * s2; n3 < r3; n3++)
              e2[t3++] = h2[i3++], e2[t3++] = h2[i3++], e2[t3++] = h2[i3++], t3 += l3;
          }
      }
      get usesZeroToOneRange() {
        return shadow$1(this, "usesZeroToOneRange", true);
      }
      static isDefaultDecode(e2, t2) {
        if (!Array.isArray(e2))
          return true;
        if (2 * t2 !== e2.length)
          return warn$1("The decode map is not the correct length"), true;
        for (let t3 = 0, i2 = e2.length; t3 < i2; t3 += 2)
          if (0 !== e2[t3] || 1 !== e2[t3 + 1])
            return false;
        return true;
      }
    };
    ColorSpace = _ColorSpace;
    __name(ColorSpace, "ColorSpace");
    _a2 = new WeakMap();
    __privateAdd(ColorSpace, _a2, new Uint8ClampedArray(3));
    AlternateCS = class extends ColorSpace {
      constructor(e2, t2, i2) {
        super("Alternate", e2), this.base = t2, this.tintFn = i2, this.tmpBuf = new Float32Array(t2.numComps);
      }
      getRgbItem(e2, t2, i2, a2) {
        const n2 = this.tmpBuf;
        this.tintFn(e2, t2, n2, 0), this.base.getRgbItem(n2, 0, i2, a2);
      }
      getRgbBuffer(e2, t2, i2, a2, n2, s2, r2) {
        const o2 = this.tintFn, l3 = this.base, c2 = 1 / ((1 << s2) - 1), h2 = l3.numComps, d2 = l3.usesZeroToOneRange, u2 = (l3.isPassthrough(8) || !d2) && 0 === r2;
        let g2 = u2 ? n2 : 0;
        const p2 = u2 ? a2 : new Uint8ClampedArray(h2 * i2), f2 = this.numComps, m2 = new Float32Array(f2), b2 = new Float32Array(h2);
        let y2, w2;
        for (y2 = 0; y2 < i2; y2++) {
          for (w2 = 0; w2 < f2; w2++)
            m2[w2] = e2[t2++] * c2;
          if (o2(m2, 0, b2, 0), d2)
            for (w2 = 0; w2 < h2; w2++)
              p2[g2++] = 255 * b2[w2];
          else
            l3.getRgbItem(b2, 0, p2, g2), g2 += h2;
        }
        u2 || l3.getRgbBuffer(p2, 0, i2, a2, n2, 8, r2);
      }
      getOutputLength(e2, t2) {
        return this.base.getOutputLength(e2 * this.base.numComps / this.numComps, t2);
      }
    };
    __name(AlternateCS, "AlternateCS");
    PatternCS = class extends ColorSpace {
      constructor(e2) {
        super("Pattern", null), this.base = e2;
      }
      isDefaultDecode(e2, t2) {
        unreachable$1("Should not call PatternCS.isDefaultDecode");
      }
    };
    __name(PatternCS, "PatternCS");
    IndexedCS = class extends ColorSpace {
      constructor(e2, t2, i2) {
        super("Indexed", 1), this.base = e2, this.highVal = t2;
        const a2 = e2.numComps * (t2 + 1);
        if (this.lookup = new Uint8Array(a2), i2 instanceof BaseStream) {
          const e3 = i2.getBytes(a2);
          this.lookup.set(e3);
        } else {
          if ("string" != typeof i2)
            throw new ti(`IndexedCS - unrecognized lookup table: ${i2}`);
          for (let e3 = 0; e3 < a2; ++e3)
            this.lookup[e3] = 255 & i2.charCodeAt(e3);
        }
      }
      getRgbItem(e2, t2, i2, a2) {
        const { base: n2, highVal: s2, lookup: r2 } = this, o2 = MathClamp$1(Math.round(e2[t2]), 0, s2) * n2.numComps;
        n2.getRgbBuffer(r2, o2, 1, i2, a2, 8, 0);
      }
      getRgbBuffer(e2, t2, i2, a2, n2, s2, r2) {
        const { base: o2, highVal: l3, lookup: c2 } = this, { numComps: h2 } = o2, d2 = o2.getOutputLength(h2, r2);
        for (let s3 = 0; s3 < i2; ++s3) {
          const i3 = MathClamp$1(Math.round(e2[t2++]), 0, l3) * h2;
          o2.getRgbBuffer(c2, i3, 1, a2, n2, 8, r2), n2 += d2;
        }
      }
      getOutputLength(e2, t2) {
        return this.base.getOutputLength(e2 * this.base.numComps, t2);
      }
      isDefaultDecode(e2, t2) {
        return !Array.isArray(e2) || (2 !== e2.length ? (warn$1("Decode map length is not correct"), true) : !Number.isInteger(t2) || t2 < 1 ? (warn$1("Bits per component is not correct"), true) : 0 === e2[0] && e2[1] === (1 << t2) - 1);
      }
    };
    __name(IndexedCS, "IndexedCS");
    DeviceGrayCS = class extends ColorSpace {
      constructor() {
        super("DeviceGray", 1);
      }
      getRgbItem(e2, t2, i2, a2) {
        const n2 = 255 * e2[t2];
        i2[a2] = i2[a2 + 1] = i2[a2 + 2] = n2;
      }
      getRgbBuffer(e2, t2, i2, a2, n2, s2, r2) {
        const o2 = 255 / ((1 << s2) - 1);
        let l3 = t2, c2 = n2;
        for (let t3 = 0; t3 < i2; ++t3) {
          const t4 = o2 * e2[l3++];
          a2[c2++] = t4, a2[c2++] = t4, a2[c2++] = t4, c2 += r2;
        }
      }
      getOutputLength(e2, t2) {
        return e2 * (3 + t2);
      }
    };
    __name(DeviceGrayCS, "DeviceGrayCS");
    DeviceRgbCS = class extends ColorSpace {
      constructor() {
        super("DeviceRGB", 3);
      }
      getRgbItem(e2, t2, i2, a2) {
        i2[a2] = 255 * e2[t2], i2[a2 + 1] = 255 * e2[t2 + 1], i2[a2 + 2] = 255 * e2[t2 + 2];
      }
      getRgbBuffer(e2, t2, i2, a2, n2, s2, r2) {
        if (8 === s2 && 0 === r2)
          return void a2.set(e2.subarray(t2, t2 + 3 * i2), n2);
        const o2 = 255 / ((1 << s2) - 1);
        let l3 = t2, c2 = n2;
        for (let t3 = 0; t3 < i2; ++t3)
          a2[c2++] = o2 * e2[l3++], a2[c2++] = o2 * e2[l3++], a2[c2++] = o2 * e2[l3++], c2 += r2;
      }
      getOutputLength(e2, t2) {
        return e2 * (3 + t2) / 3 | 0;
      }
      isPassthrough(e2) {
        return 8 === e2;
      }
    };
    __name(DeviceRgbCS, "DeviceRgbCS");
    DeviceRgbaCS = class extends ColorSpace {
      constructor() {
        super("DeviceRGBA", 4);
      }
      getOutputLength(e2, t2) {
        return 4 * e2;
      }
      isPassthrough(e2) {
        return 8 === e2;
      }
      fillRgb(e2, t2, i2, a2, n2, s2, r2, o2, l3) {
        i2 !== n2 || t2 !== a2 ? function(e3, t3, i3, a3, n3, s3, r3) {
          const o3 = i3 / n3, l4 = a3 / s3;
          let c2 = 0;
          const h2 = new Uint16Array(n3);
          if (1 === r3) {
            for (let e4 = 0; e4 < n3; e4++)
              h2[e4] = Math.floor(e4 * o3);
            const a4 = new Uint32Array(e3.buffer), r4 = new Uint32Array(t3.buffer), d2 = FeatureTest.isLittleEndian ? 16777215 : 4294967040;
            for (let e4 = 0; e4 < s3; e4++) {
              const t4 = a4.subarray(Math.floor(e4 * l4) * i3);
              for (let e5 = 0; e5 < n3; e5++)
                r4[c2++] |= t4[h2[e5]] & d2;
            }
          } else {
            const a4 = 4, r4 = i3 * a4;
            for (let e4 = 0; e4 < n3; e4++)
              h2[e4] = Math.floor(e4 * o3) * a4;
            for (let i4 = 0; i4 < s3; i4++) {
              const a5 = e3.subarray(Math.floor(i4 * l4) * r4);
              for (let e4 = 0; e4 < n3; e4++) {
                const i5 = h2[e4];
                t3[c2++] = a5[i5], t3[c2++] = a5[i5 + 1], t3[c2++] = a5[i5 + 2];
              }
            }
          }
        }(o2, e2, t2, i2, a2, n2, l3) : function(e3, t3, i3) {
          if (1 === i3) {
            const i4 = new Uint32Array(e3.buffer), a3 = new Uint32Array(t3.buffer), n3 = FeatureTest.isLittleEndian ? 16777215 : 4294967040;
            for (let e4 = 0, t4 = i4.length; e4 < t4; e4++)
              a3[e4] |= i4[e4] & n3;
          } else {
            let i4 = 0;
            for (let a3 = 0, n3 = e3.length; a3 < n3; a3 += 4)
              t3[i4++] = e3[a3], t3[i4++] = e3[a3 + 1], t3[i4++] = e3[a3 + 2];
          }
        }(o2, e2, l3);
      }
    };
    __name(DeviceRgbaCS, "DeviceRgbaCS");
    DeviceCmykCS = class extends ColorSpace {
      constructor() {
        super("DeviceCMYK", 4);
      }
      #n(e2, t2, i2, a2, n2) {
        const s2 = e2[t2] * i2, r2 = e2[t2 + 1] * i2, o2 = e2[t2 + 2] * i2, l3 = e2[t2 + 3] * i2;
        a2[n2] = 255 + s2 * (-4.387332384609988 * s2 + 54.48615194189176 * r2 + 18.82290502165302 * o2 + 212.25662451639585 * l3 - 285.2331026137004) + r2 * (1.7149763477362134 * r2 - 5.6096736904047315 * o2 + -17.873870861415444 * l3 - 5.497006427196366) + o2 * (-2.5217340131683033 * o2 - 21.248923337353073 * l3 + 17.5119270841813) + l3 * (-21.86122147463605 * l3 - 189.48180835922747), a2[n2 + 1] = 255 + s2 * (8.841041422036149 * s2 + 60.118027045597366 * r2 + 6.871425592049007 * o2 + 31.159100130055922 * l3 - 79.2970844816548) + r2 * (-15.310361306967817 * r2 + 17.575251261109482 * o2 + 131.35250912493976 * l3 - 190.9453302588951) + o2 * (4.444339102852739 * o2 + 9.8632861493405 * l3 - 24.86741582555878) + l3 * (-20.737325471181034 * l3 - 187.80453709719578), a2[n2 + 2] = 255 + s2 * (0.8842522430003296 * s2 + 8.078677503112928 * r2 + 30.89978309703729 * o2 - 0.23883238689178934 * l3 - 14.183576799673286) + r2 * (10.49593273432072 * r2 + 63.02378494754052 * o2 + 50.606957656360734 * l3 - 112.23884253719248) + o2 * (0.03296041114873217 * o2 + 115.60384449646641 * l3 - 193.58209356861505) + l3 * (-22.33816807309886 * l3 - 180.12613974708367);
      }
      getRgbItem(e2, t2, i2, a2) {
        this.#n(e2, t2, 1, i2, a2);
      }
      getRgbBuffer(e2, t2, i2, a2, n2, s2, r2) {
        const o2 = 1 / ((1 << s2) - 1);
        for (let s3 = 0; s3 < i2; s3++)
          this.#n(e2, t2, o2, a2, n2), t2 += 4, n2 += 3 + r2;
      }
      getOutputLength(e2, t2) {
        return e2 / 4 * (3 + t2) | 0;
      }
    };
    __name(DeviceCmykCS, "DeviceCmykCS");
    CalGrayCS = class extends ColorSpace {
      constructor(e2, t2, i2) {
        if (super("CalGray", 1), !e2)
          throw new ti("WhitePoint missing - required for color space CalGray");
        if ([this.XW, this.YW, this.ZW] = e2, [this.XB, this.YB, this.ZB] = t2 || [0, 0, 0], this.G = i2 || 1, this.XW < 0 || this.ZW < 0 || 1 !== this.YW)
          throw new ti(`Invalid WhitePoint components for ${this.name}, no fallback available`);
        (this.XB < 0 || this.YB < 0 || this.ZB < 0) && (info$1(`Invalid BlackPoint for ${this.name}, falling back to default.`), this.XB = this.YB = this.ZB = 0), 0 === this.XB && 0 === this.YB && 0 === this.ZB || warn$1(`${this.name}, BlackPoint: XB: ${this.XB}, YB: ${this.YB}, ZB: ${this.ZB}, only default values are supported.`), this.G < 1 && (info$1(`Invalid Gamma: ${this.G} for ${this.name}, falling back to default.`), this.G = 1);
      }
      #n(e2, t2, i2, a2, n2) {
        const s2 = (e2[t2] * n2) ** this.G, r2 = this.YW * s2, o2 = Math.max(295.8 * r2 ** 0.3333333333333333 - 40.8, 0);
        i2[a2] = o2, i2[a2 + 1] = o2, i2[a2 + 2] = o2;
      }
      getRgbItem(e2, t2, i2, a2) {
        this.#n(e2, t2, i2, a2, 1);
      }
      getRgbBuffer(e2, t2, i2, a2, n2, s2, r2) {
        const o2 = 1 / ((1 << s2) - 1);
        for (let s3 = 0; s3 < i2; ++s3)
          this.#n(e2, t2, a2, n2, o2), t2 += 1, n2 += 3 + r2;
      }
      getOutputLength(e2, t2) {
        return e2 * (3 + t2);
      }
    };
    __name(CalGrayCS, "CalGrayCS");
    _CalRGBCS = class extends ColorSpace {
      constructor(e2, t2, i2, a2) {
        super("CalRGB", 3);
        __privateAdd(this, _g);
        __privateAdd(this, _p);
        __privateAdd(this, _f);
        __privateAdd(this, _m);
        __privateAdd(this, _b);
        __privateAdd(this, _y);
        __privateAdd(this, _w);
        __privateAdd(this, _A);
        __privateAdd(this, _n);
        if (!e2)
          throw new ti("WhitePoint missing - required for color space CalRGB");
        const [n2, s2, r2] = this.whitePoint = e2, [o2, l3, c2] = this.blackPoint = t2 || new Float32Array(3);
        if ([this.GR, this.GG, this.GB] = i2 || new Float32Array([1, 1, 1]), [this.MXA, this.MYA, this.MZA, this.MXB, this.MYB, this.MZB, this.MXC, this.MYC, this.MZC] = a2 || new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]), n2 < 0 || r2 < 0 || 1 !== s2)
          throw new ti(`Invalid WhitePoint components for ${this.name}, no fallback available`);
        (o2 < 0 || l3 < 0 || c2 < 0) && (info$1(`Invalid BlackPoint for ${this.name} [${o2}, ${l3}, ${c2}], falling back to default.`), this.blackPoint = new Float32Array(3)), (this.GR < 0 || this.GG < 0 || this.GB < 0) && (info$1(`Invalid Gamma [${this.GR}, ${this.GG}, ${this.GB}] for ${this.name}, falling back to default.`), this.GR = this.GG = this.GB = 1);
      }
      getRgbItem(e2, t2, i2, a2) {
        __privateMethod(this, _n, n_fn).call(this, e2, t2, i2, a2, 1);
      }
      getRgbBuffer(e2, t2, i2, a2, n2, s2, r2) {
        const o2 = 1 / ((1 << s2) - 1);
        for (let s3 = 0; s3 < i2; ++s3)
          __privateMethod(this, _n, n_fn).call(this, e2, t2, a2, n2, o2), t2 += 3, n2 += 3 + r2;
      }
      getOutputLength(e2, t2) {
        return e2 * (3 + t2) / 3 | 0;
      }
    };
    CalRGBCS = _CalRGBCS;
    __name(CalRGBCS, "CalRGBCS");
    _s = new WeakMap();
    _r = new WeakMap();
    _o = new WeakMap();
    _l = new WeakMap();
    _c = new WeakMap();
    _h = new WeakMap();
    _d = new WeakMap();
    _u = new WeakMap();
    _g = new WeakSet();
    g_fn = /* @__PURE__ */ __name(function(e2, t2, i2) {
      i2[0] = e2[0] * t2[0] + e2[1] * t2[1] + e2[2] * t2[2], i2[1] = e2[3] * t2[0] + e2[4] * t2[1] + e2[5] * t2[2], i2[2] = e2[6] * t2[0] + e2[7] * t2[1] + e2[8] * t2[2];
    }, "#g");
    _p = new WeakSet();
    p_fn = /* @__PURE__ */ __name(function(e2, t2, i2) {
      i2[0] = 1 * t2[0] / e2[0], i2[1] = 1 * t2[1] / e2[1], i2[2] = 1 * t2[2] / e2[2];
    }, "#p");
    _f = new WeakSet();
    f_fn = /* @__PURE__ */ __name(function(e2, t2, i2) {
      i2[0] = 0.95047 * t2[0] / e2[0], i2[1] = 1 * t2[1] / e2[1], i2[2] = 1.08883 * t2[2] / e2[2];
    }, "#f");
    _m = new WeakSet();
    m_fn = /* @__PURE__ */ __name(function(e2) {
      return e2 <= 31308e-7 ? MathClamp$1(12.92 * e2, 0, 1) : e2 >= 0.99554525 ? 1 : MathClamp$1(1.055 * e2 ** (1 / 2.4) - 0.055, 0, 1);
    }, "#m");
    _b = new WeakSet();
    b_fn = /* @__PURE__ */ __name(function(e2) {
      return e2 < 0 ? -__privateMethod(this, _b, b_fn).call(this, -e2) : e2 > 8 ? ((e2 + 16) / 116) ** 3 : e2 * __privateGet(_CalRGBCS, _u);
    }, "#b");
    _y = new WeakSet();
    y_fn = /* @__PURE__ */ __name(function(e2, t2, i2) {
      if (0 === e2[0] && 0 === e2[1] && 0 === e2[2])
        return i2[0] = t2[0], i2[1] = t2[1], void (i2[2] = t2[2]);
      const a2 = __privateMethod(this, _b, b_fn).call(this, 0), n2 = (1 - a2) / (1 - __privateMethod(this, _b, b_fn).call(this, e2[0])), s2 = 1 - n2, r2 = (1 - a2) / (1 - __privateMethod(this, _b, b_fn).call(this, e2[1])), o2 = 1 - r2, l3 = (1 - a2) / (1 - __privateMethod(this, _b, b_fn).call(this, e2[2])), c2 = 1 - l3;
      i2[0] = t2[0] * n2 + s2, i2[1] = t2[1] * r2 + o2, i2[2] = t2[2] * l3 + c2;
    }, "#y");
    _w = new WeakSet();
    w_fn = /* @__PURE__ */ __name(function(e2, t2, i2) {
      if (1 === e2[0] && 1 === e2[2])
        return i2[0] = t2[0], i2[1] = t2[1], void (i2[2] = t2[2]);
      const a2 = i2;
      __privateMethod(this, _g, g_fn).call(this, __privateGet(_CalRGBCS, _s), t2, a2);
      const n2 = __privateGet(_CalRGBCS, _c);
      __privateMethod(this, _p, p_fn).call(this, e2, a2, n2), __privateMethod(this, _g, g_fn).call(this, __privateGet(_CalRGBCS, _r), n2, i2);
    }, "#w");
    _A = new WeakSet();
    A_fn = /* @__PURE__ */ __name(function(e2, t2, i2) {
      const a2 = i2;
      __privateMethod(this, _g, g_fn).call(this, __privateGet(_CalRGBCS, _s), t2, a2);
      const n2 = __privateGet(_CalRGBCS, _c);
      __privateMethod(this, _f, f_fn).call(this, e2, a2, n2), __privateMethod(this, _g, g_fn).call(this, __privateGet(_CalRGBCS, _r), n2, i2);
    }, "#A");
    _n = new WeakSet();
    n_fn = /* @__PURE__ */ __name(function(e2, t2, i2, a2, n2) {
      const s2 = MathClamp$1(e2[t2] * n2, 0, 1), r2 = MathClamp$1(e2[t2 + 1] * n2, 0, 1), o2 = MathClamp$1(e2[t2 + 2] * n2, 0, 1), l3 = 1 === s2 ? 1 : s2 ** this.GR, c2 = 1 === r2 ? 1 : r2 ** this.GG, h2 = 1 === o2 ? 1 : o2 ** this.GB, d2 = this.MXA * l3 + this.MXB * c2 + this.MXC * h2, u2 = this.MYA * l3 + this.MYB * c2 + this.MYC * h2, g2 = this.MZA * l3 + this.MZB * c2 + this.MZC * h2, p2 = __privateGet(_CalRGBCS, _h);
      p2[0] = d2, p2[1] = u2, p2[2] = g2;
      const f2 = __privateGet(_CalRGBCS, _d);
      __privateMethod(this, _w, w_fn).call(this, this.whitePoint, p2, f2);
      const m2 = __privateGet(_CalRGBCS, _h);
      __privateMethod(this, _y, y_fn).call(this, this.blackPoint, f2, m2);
      const b2 = __privateGet(_CalRGBCS, _d);
      __privateMethod(this, _A, A_fn).call(this, __privateGet(_CalRGBCS, _l), m2, b2);
      const y2 = __privateGet(_CalRGBCS, _h);
      __privateMethod(this, _g, g_fn).call(this, __privateGet(_CalRGBCS, _o), b2, y2), i2[a2] = 255 * __privateMethod(this, _m, m_fn).call(this, y2[0]), i2[a2 + 1] = 255 * __privateMethod(this, _m, m_fn).call(this, y2[1]), i2[a2 + 2] = 255 * __privateMethod(this, _m, m_fn).call(this, y2[2]);
    }, "#n");
    __privateAdd(CalRGBCS, _s, new Float32Array([0.8951, 0.2664, -0.1614, -0.7502, 1.7135, 0.0367, 0.0389, -0.0685, 1.0296]));
    __privateAdd(CalRGBCS, _r, new Float32Array([0.9869929, -0.1470543, 0.1599627, 0.4323053, 0.5183603, 0.0492912, -85287e-7, 0.0400428, 0.9684867]));
    __privateAdd(CalRGBCS, _o, new Float32Array([3.2404542, -1.5371385, -0.4985314, -0.969266, 1.8760108, 0.041556, 0.0556434, -0.2040259, 1.0572252]));
    __privateAdd(CalRGBCS, _l, new Float32Array([1, 1, 1]));
    __privateAdd(CalRGBCS, _c, new Float32Array(3));
    __privateAdd(CalRGBCS, _h, new Float32Array(3));
    __privateAdd(CalRGBCS, _d, new Float32Array(3));
    __privateAdd(CalRGBCS, _u, (24 / 116) ** 3 / 8);
    LabCS = class extends ColorSpace {
      constructor(e2, t2, i2) {
        if (super("Lab", 3), !e2)
          throw new ti("WhitePoint missing - required for color space Lab");
        if ([this.XW, this.YW, this.ZW] = e2, [this.amin, this.amax, this.bmin, this.bmax] = i2 || [-100, 100, -100, 100], [this.XB, this.YB, this.ZB] = t2 || [0, 0, 0], this.XW < 0 || this.ZW < 0 || 1 !== this.YW)
          throw new ti("Invalid WhitePoint components, no fallback available");
        (this.XB < 0 || this.YB < 0 || this.ZB < 0) && (info$1("Invalid BlackPoint, falling back to default"), this.XB = this.YB = this.ZB = 0), (this.amin > this.amax || this.bmin > this.bmax) && (info$1("Invalid Range, falling back to defaults"), this.amin = -100, this.amax = 100, this.bmin = -100, this.bmax = 100);
      }
      #x(e2) {
        return e2 >= 6 / 29 ? e2 ** 3 : 108 / 841 * (e2 - 4 / 29);
      }
      #S(e2, t2, i2, a2) {
        return i2 + e2 * (a2 - i2) / t2;
      }
      #n(e2, t2, i2, a2, n2) {
        let s2 = e2[t2], r2 = e2[t2 + 1], o2 = e2[t2 + 2];
        false !== i2 && (s2 = this.#S(s2, i2, 0, 100), r2 = this.#S(r2, i2, this.amin, this.amax), o2 = this.#S(o2, i2, this.bmin, this.bmax)), r2 > this.amax ? r2 = this.amax : r2 < this.amin && (r2 = this.amin), o2 > this.bmax ? o2 = this.bmax : o2 < this.bmin && (o2 = this.bmin);
        const l3 = (s2 + 16) / 116, c2 = l3 + r2 / 500, h2 = l3 - o2 / 200, d2 = this.XW * this.#x(c2), u2 = this.YW * this.#x(l3), g2 = this.ZW * this.#x(h2);
        let p2, f2, m2;
        this.ZW < 1 ? (p2 = 3.1339 * d2 + -1.617 * u2 + -0.4906 * g2, f2 = -0.9785 * d2 + 1.916 * u2 + 0.0333 * g2, m2 = 0.072 * d2 + -0.229 * u2 + 1.4057 * g2) : (p2 = 3.2406 * d2 + -1.5372 * u2 + -0.4986 * g2, f2 = -0.9689 * d2 + 1.8758 * u2 + 0.0415 * g2, m2 = 0.0557 * d2 + -0.204 * u2 + 1.057 * g2), a2[n2] = 255 * Math.sqrt(p2), a2[n2 + 1] = 255 * Math.sqrt(f2), a2[n2 + 2] = 255 * Math.sqrt(m2);
      }
      getRgbItem(e2, t2, i2, a2) {
        this.#n(e2, t2, false, i2, a2);
      }
      getRgbBuffer(e2, t2, i2, a2, n2, s2, r2) {
        const o2 = (1 << s2) - 1;
        for (let s3 = 0; s3 < i2; s3++)
          this.#n(e2, t2, o2, a2, n2), t2 += 3, n2 += 3 + r2;
      }
      getOutputLength(e2, t2) {
        return e2 * (3 + t2) / 3 | 0;
      }
      isDefaultDecode(e2, t2) {
        return true;
      }
      get usesZeroToOneRange() {
        return shadow$1(this, "usesZeroToOneRange", false);
      }
    };
    __name(LabCS, "LabCS");
    __name(fetchSync, "fetchSync");
    _IccColorSpace = class extends ColorSpace {
      constructor(e2, t2, i2) {
        if (!_IccColorSpace.isUsable)
          throw new Error("No ICC color space support");
        let a2;
        super(t2, i2);
        __privateAdd(this, _v, void 0);
        __privateAdd(this, _C, void 0);
        switch (i2) {
          case 1:
            a2 = Ci.Gray8, __privateSet(this, _C, (e3, t3, i3) => function(e4, t4, i4) {
              Ai.qcms_convert_one(e4, t4, i4);
            }(__privateGet(this, _v), 255 * e3[t3], i3));
            break;
          case 3:
            a2 = Ci.RGB8, __privateSet(this, _C, (e3, t3, i3) => function(e4, t4, i4, a3, n2) {
              Ai.qcms_convert_three(e4, t4, i4, a3, n2);
            }(__privateGet(this, _v), 255 * e3[t3], 255 * e3[t3 + 1], 255 * e3[t3 + 2], i3));
            break;
          case 4:
            a2 = Ci.CMYK, __privateSet(this, _C, (e3, t3, i3) => function(e4, t4, i4, a3, n2, s2) {
              Ai.qcms_convert_four(e4, t4, i4, a3, n2, s2);
            }(__privateGet(this, _v), 255 * e3[t3], 255 * e3[t3 + 1], 255 * e3[t3 + 2], 255 * e3[t3 + 3], i3));
            break;
          default:
            throw new Error(`Unsupported number of components: ${i2}`);
        }
        if (__privateSet(this, _v, function(e3, t3, i3) {
          const a3 = passArray8ToWasm0(e3, Ai.__wbindgen_malloc), n2 = vi;
          return Ai.qcms_transformer_from_memory(a3, n2, t3, i3) >>> 0;
        }(e2, a2, ki.Perceptual)), !__privateGet(this, _v))
          throw new Error("Failed to create ICC color space");
        __privateGet(_IccColorSpace, _I) || __privateSet(_IccColorSpace, _I, new FinalizationRegistry((e3) => {
          !function(e4) {
            Ai.qcms_drop_transformer(e4);
          }(e3);
        })), __privateGet(_IccColorSpace, _I).register(this, __privateGet(this, _v));
      }
      getRgbHex(e2, t2) {
        return __privateGet(this, _C).call(this, e2, t2, true), QCMS._cssColor;
      }
      getRgbItem(e2, t2, i2, a2) {
        QCMS._destBuffer = i2, QCMS._destOffset = a2, QCMS._destLength = 3, __privateGet(this, _C).call(this, e2, t2, false), QCMS._destBuffer = null;
      }
      getRgbBuffer(e2, t2, i2, a2, n2, s2, r2) {
        if (e2 = e2.subarray(t2, t2 + i2 * this.numComps), 8 !== s2) {
          const t3 = 255 / ((1 << s2) - 1);
          for (let i3 = 0, a3 = e2.length; i3 < a3; i3++)
            e2[i3] *= t3;
        }
        QCMS._mustAddAlpha = r2 && a2.buffer === e2.buffer, QCMS._destBuffer = a2, QCMS._destOffset = n2, QCMS._destLength = i2 * (3 + r2), function(e3, t3) {
          const i3 = passArray8ToWasm0(t3, Ai.__wbindgen_malloc), a3 = vi;
          Ai.qcms_convert_array(e3, i3, a3);
        }(__privateGet(this, _v), e2), QCMS._mustAddAlpha = false, QCMS._destBuffer = null;
      }
      getOutputLength(e2, t2) {
        return e2 / this.numComps * (3 + t2) | 0;
      }
      static setOptions({ useWasm: e2, useWorkerFetch: t2, wasmUrl: i2 }) {
        t2 ? (__privateSet(this, _k, e2), __privateSet(this, _T, i2)) : __privateSet(this, _k, false);
      }
      static get isUsable() {
        let e2 = false;
        if (__privateGet(this, _k))
          if (__privateGet(this, _T))
            try {
              this._module = initSync({ module: fetchSync(`${__privateGet(this, _T)}qcms_bg.wasm`) }), e2 = !!this._module, QCMS._memory = this._module.memory, QCMS._makeHexColor = ni.makeHexColor;
            } catch (e3) {
              warn$1(`ICCBased color space: "${e3}".`);
            }
          else
            warn$1("No ICC color space support due to missing `wasmUrl` API option");
        return shadow$1(this, "isUsable", e2);
      }
    };
    IccColorSpace = _IccColorSpace;
    __name(IccColorSpace, "IccColorSpace");
    _v = new WeakMap();
    _C = new WeakMap();
    _k = new WeakMap();
    _T = new WeakMap();
    _I = new WeakMap();
    __privateAdd(IccColorSpace, _k, true);
    __privateAdd(IccColorSpace, _T, null);
    __privateAdd(IccColorSpace, _I, null);
    _CmykICCBasedCS = class extends IccColorSpace {
      constructor() {
        super(new Uint8Array(fetchSync(`${__privateGet(_CmykICCBasedCS, _F)}CGATS001Compat-v2-micro.icc`)), "DeviceCMYK", 4);
      }
      static setOptions({ iccUrl: e2 }) {
        __privateSet(this, _F, e2);
      }
      static get isUsable() {
        let e2 = false;
        return IccColorSpace.isUsable && (__privateGet(this, _F) ? e2 = true : warn$1("No CMYK ICC profile support due to missing `iccUrl` API option")), shadow$1(this, "isUsable", e2);
      }
    };
    CmykICCBasedCS = _CmykICCBasedCS;
    __name(CmykICCBasedCS, "CmykICCBasedCS");
    _F = new WeakMap();
    __privateAdd(CmykICCBasedCS, _F, void 0);
    Stream = class extends BaseStream {
      constructor(e2, t2, i2, a2) {
        super(), this.bytes = e2 instanceof Uint8Array ? e2 : new Uint8Array(e2), this.start = t2 || 0, this.pos = this.start, this.end = t2 + i2 || this.bytes.length, this.dict = a2;
      }
      get length() {
        return this.end - this.start;
      }
      get isEmpty() {
        return 0 === this.length;
      }
      getByte() {
        return this.pos >= this.end ? -1 : this.bytes[this.pos++];
      }
      getBytes(e2) {
        const t2 = this.bytes, i2 = this.pos, a2 = this.end;
        if (!e2)
          return t2.subarray(i2, a2);
        let n2 = i2 + e2;
        return n2 > a2 && (n2 = a2), this.pos = n2, t2.subarray(i2, n2);
      }
      getByteRange(e2, t2) {
        return e2 < 0 && (e2 = 0), t2 > this.end && (t2 = this.end), this.bytes.subarray(e2, t2);
      }
      reset() {
        this.pos = this.start;
      }
      moveStart() {
        this.start = this.pos;
      }
      makeSubStream(e2, t2, i2 = null) {
        return new Stream(this.bytes.buffer, e2, t2, i2);
      }
    };
    __name(Stream, "Stream");
    StringStream = class extends Stream {
      constructor(e2) {
        super(stringToBytes$1(e2));
      }
    };
    __name(StringStream, "StringStream");
    NullStream = class extends Stream {
      constructor() {
        super(new Uint8Array(0));
      }
    };
    __name(NullStream, "NullStream");
    ChunkedStream = class extends Stream {
      constructor(e2, t2, i2) {
        super(new Uint8Array(e2), 0, e2, null), this.chunkSize = t2, this._loadedChunks = /* @__PURE__ */ new Set(), this.numChunks = Math.ceil(e2 / t2), this.manager = i2, this.progressiveDataLength = 0, this.lastSuccessfulEnsureByteChunk = -1;
      }
      getMissingChunks() {
        const e2 = [];
        for (let t2 = 0, i2 = this.numChunks; t2 < i2; ++t2)
          this._loadedChunks.has(t2) || e2.push(t2);
        return e2;
      }
      get numChunksLoaded() {
        return this._loadedChunks.size;
      }
      get isDataLoaded() {
        return this.numChunksLoaded === this.numChunks;
      }
      onReceiveData(e2, t2) {
        const i2 = this.chunkSize;
        if (e2 % i2 !== 0)
          throw new Error(`Bad begin offset: ${e2}`);
        const a2 = e2 + t2.byteLength;
        if (a2 % i2 !== 0 && a2 !== this.bytes.length)
          throw new Error(`Bad end offset: ${a2}`);
        this.bytes.set(new Uint8Array(t2), e2);
        const n2 = Math.floor(e2 / i2), s2 = Math.floor((a2 - 1) / i2) + 1;
        for (let e3 = n2; e3 < s2; ++e3)
          this._loadedChunks.add(e3);
      }
      onReceiveProgressiveData(e2) {
        let t2 = this.progressiveDataLength;
        const i2 = Math.floor(t2 / this.chunkSize);
        this.bytes.set(new Uint8Array(e2), t2), t2 += e2.byteLength, this.progressiveDataLength = t2;
        const a2 = t2 >= this.end ? this.numChunks : Math.floor(t2 / this.chunkSize);
        for (let e3 = i2; e3 < a2; ++e3)
          this._loadedChunks.add(e3);
      }
      ensureByte(e2) {
        if (e2 < this.progressiveDataLength)
          return;
        const t2 = Math.floor(e2 / this.chunkSize);
        if (!(t2 > this.numChunks) && t2 !== this.lastSuccessfulEnsureByteChunk) {
          if (!this._loadedChunks.has(t2))
            throw new MissingDataException(e2, e2 + 1);
          this.lastSuccessfulEnsureByteChunk = t2;
        }
      }
      ensureRange(e2, t2) {
        if (e2 >= t2)
          return;
        if (t2 <= this.progressiveDataLength)
          return;
        const i2 = Math.floor(e2 / this.chunkSize);
        if (i2 > this.numChunks)
          return;
        const a2 = Math.min(Math.floor((t2 - 1) / this.chunkSize) + 1, this.numChunks);
        for (let n2 = i2; n2 < a2; ++n2)
          if (!this._loadedChunks.has(n2))
            throw new MissingDataException(e2, t2);
      }
      nextEmptyChunk(e2) {
        const t2 = this.numChunks;
        for (let i2 = 0; i2 < t2; ++i2) {
          const a2 = (e2 + i2) % t2;
          if (!this._loadedChunks.has(a2))
            return a2;
        }
        return null;
      }
      hasChunk(e2) {
        return this._loadedChunks.has(e2);
      }
      getByte() {
        const e2 = this.pos;
        return e2 >= this.end ? -1 : (e2 >= this.progressiveDataLength && this.ensureByte(e2), this.bytes[this.pos++]);
      }
      getBytes(e2) {
        const t2 = this.bytes, i2 = this.pos, a2 = this.end;
        if (!e2)
          return a2 > this.progressiveDataLength && this.ensureRange(i2, a2), t2.subarray(i2, a2);
        let n2 = i2 + e2;
        return n2 > a2 && (n2 = a2), n2 > this.progressiveDataLength && this.ensureRange(i2, n2), this.pos = n2, t2.subarray(i2, n2);
      }
      getByteRange(e2, t2) {
        return e2 < 0 && (e2 = 0), t2 > this.end && (t2 = this.end), t2 > this.progressiveDataLength && this.ensureRange(e2, t2), this.bytes.subarray(e2, t2);
      }
      makeSubStream(e2, t2, i2 = null) {
        function ChunkedStreamSubstream() {
        }
        __name(ChunkedStreamSubstream, "ChunkedStreamSubstream");
        t2 ? e2 + t2 > this.progressiveDataLength && this.ensureRange(e2, e2 + t2) : e2 >= this.progressiveDataLength && this.ensureByte(e2), ChunkedStreamSubstream.prototype = Object.create(this), ChunkedStreamSubstream.prototype.getMissingChunks = function() {
          const e3 = this.chunkSize, t3 = Math.floor(this.start / e3), i3 = Math.floor((this.end - 1) / e3) + 1, a3 = [];
          for (let e4 = t3; e4 < i3; ++e4)
            this._loadedChunks.has(e4) || a3.push(e4);
          return a3;
        }, Object.defineProperty(ChunkedStreamSubstream.prototype, "isDataLoaded", { get() {
          return this.numChunksLoaded === this.numChunks || 0 === this.getMissingChunks().length;
        }, configurable: true });
        const a2 = new ChunkedStreamSubstream();
        return a2.pos = a2.start = e2, a2.end = e2 + t2 || this.end, a2.dict = i2, a2;
      }
      getBaseStreams() {
        return [this];
      }
    };
    __name(ChunkedStream, "ChunkedStream");
    ChunkedStreamManager = class {
      constructor(e2, t2) {
        this.length = t2.length, this.chunkSize = t2.rangeChunkSize, this.stream = new ChunkedStream(this.length, this.chunkSize, this), this.pdfNetworkStream = e2, this.disableAutoFetch = t2.disableAutoFetch, this.msgHandler = t2.msgHandler, this.currRequestId = 0, this._chunksNeededByRequest = /* @__PURE__ */ new Map(), this._requestsByChunk = /* @__PURE__ */ new Map(), this._promisesByRequest = /* @__PURE__ */ new Map(), this.progressiveDataLength = 0, this.aborted = false, this._loadedStreamCapability = Promise.withResolvers();
      }
      sendRequest(e2, t2) {
        const i2 = this.pdfNetworkStream.getRangeReader(e2, t2);
        i2.isStreamingSupported || (i2.onProgress = this.onProgress.bind(this));
        let a2 = [], n2 = 0;
        return new Promise((e3, t3) => {
          const readChunk = /* @__PURE__ */ __name(({ value: s2, done: r2 }) => {
            try {
              if (r2) {
                const t4 = arrayBuffersToBytes(a2);
                return a2 = null, void e3(t4);
              }
              n2 += s2.byteLength, i2.isStreamingSupported && this.onProgress({ loaded: n2 }), a2.push(s2), i2.read().then(readChunk, t3);
            } catch (e4) {
              t3(e4);
            }
          }, "readChunk");
          i2.read().then(readChunk, t3);
        }).then((t3) => {
          this.aborted || this.onReceiveData({ chunk: t3, begin: e2 });
        });
      }
      requestAllChunks(e2 = false) {
        if (!e2) {
          const e3 = this.stream.getMissingChunks();
          this._requestChunks(e3);
        }
        return this._loadedStreamCapability.promise;
      }
      _requestChunks(e2) {
        const t2 = this.currRequestId++, i2 = /* @__PURE__ */ new Set();
        this._chunksNeededByRequest.set(t2, i2);
        for (const t3 of e2)
          this.stream.hasChunk(t3) || i2.add(t3);
        if (0 === i2.size)
          return Promise.resolve();
        const a2 = Promise.withResolvers();
        this._promisesByRequest.set(t2, a2);
        const n2 = [];
        for (const e3 of i2) {
          let i3 = this._requestsByChunk.get(e3);
          i3 || (i3 = [], this._requestsByChunk.set(e3, i3), n2.push(e3)), i3.push(t2);
        }
        if (n2.length > 0) {
          const e3 = this.groupChunks(n2);
          for (const t3 of e3) {
            const e4 = t3.beginChunk * this.chunkSize, i3 = Math.min(t3.endChunk * this.chunkSize, this.length);
            this.sendRequest(e4, i3).catch(a2.reject);
          }
        }
        return a2.promise.catch((e3) => {
          if (!this.aborted)
            throw e3;
        });
      }
      getStream() {
        return this.stream;
      }
      requestRange(e2, t2) {
        t2 = Math.min(t2, this.length);
        const i2 = this.getBeginChunk(e2), a2 = this.getEndChunk(t2), n2 = [];
        for (let e3 = i2; e3 < a2; ++e3)
          n2.push(e3);
        return this._requestChunks(n2);
      }
      requestRanges(e2 = []) {
        const t2 = [];
        for (const i2 of e2) {
          const e3 = this.getBeginChunk(i2.begin), a2 = this.getEndChunk(i2.end);
          for (let i3 = e3; i3 < a2; ++i3)
            t2.includes(i3) || t2.push(i3);
        }
        return t2.sort((e3, t3) => e3 - t3), this._requestChunks(t2);
      }
      groupChunks(e2) {
        const t2 = [];
        let i2 = -1, a2 = -1;
        for (let n2 = 0, s2 = e2.length; n2 < s2; ++n2) {
          const s3 = e2[n2];
          i2 < 0 && (i2 = s3), a2 >= 0 && a2 + 1 !== s3 && (t2.push({ beginChunk: i2, endChunk: a2 + 1 }), i2 = s3), n2 + 1 === e2.length && t2.push({ beginChunk: i2, endChunk: s3 + 1 }), a2 = s3;
        }
        return t2;
      }
      onProgress(e2) {
        this.msgHandler.send("DocProgress", { loaded: this.stream.numChunksLoaded * this.chunkSize + e2.loaded, total: this.length });
      }
      onReceiveData(e2) {
        const t2 = e2.chunk, i2 = void 0 === e2.begin, a2 = i2 ? this.progressiveDataLength : e2.begin, n2 = a2 + t2.byteLength, s2 = Math.floor(a2 / this.chunkSize), r2 = n2 < this.length ? Math.floor(n2 / this.chunkSize) : Math.ceil(n2 / this.chunkSize);
        i2 ? (this.stream.onReceiveProgressiveData(t2), this.progressiveDataLength = n2) : this.stream.onReceiveData(a2, t2), this.stream.isDataLoaded && this._loadedStreamCapability.resolve(this.stream);
        const o2 = [];
        for (let e3 = s2; e3 < r2; ++e3) {
          const t3 = this._requestsByChunk.get(e3);
          if (t3) {
            this._requestsByChunk.delete(e3);
            for (const i3 of t3) {
              const t4 = this._chunksNeededByRequest.get(i3);
              t4.has(e3) && t4.delete(e3), t4.size > 0 || o2.push(i3);
            }
          }
        }
        if (!this.disableAutoFetch && 0 === this._requestsByChunk.size) {
          let e3;
          if (1 === this.stream.numChunksLoaded) {
            const t3 = this.stream.numChunks - 1;
            this.stream.hasChunk(t3) || (e3 = t3);
          } else
            e3 = this.stream.nextEmptyChunk(r2);
          Number.isInteger(e3) && this._requestChunks([e3]);
        }
        for (const e3 of o2) {
          const t3 = this._promisesByRequest.get(e3);
          this._promisesByRequest.delete(e3), t3.resolve();
        }
        this.msgHandler.send("DocProgress", { loaded: this.stream.numChunksLoaded * this.chunkSize, total: this.length });
      }
      onError(e2) {
        this._loadedStreamCapability.reject(e2);
      }
      getBeginChunk(e2) {
        return Math.floor(e2 / this.chunkSize);
      }
      getEndChunk(e2) {
        return Math.floor((e2 - 1) / this.chunkSize) + 1;
      }
      abort(e2) {
        this.aborted = true, this.pdfNetworkStream?.cancelAllRequests(e2);
        for (const t2 of this._promisesByRequest.values())
          t2.reject(e2);
      }
    };
    __name(ChunkedStreamManager, "ChunkedStreamManager");
    __name(convertToRGBA, "convertToRGBA");
    __name(convertBlackAndWhiteToRGBA$1, "convertBlackAndWhiteToRGBA$1");
    _ImageResizer = class {
      constructor(e2, t2) {
        __privateAdd(this, _E);
        this._imgData = e2, this._isMask = t2;
      }
      static get canUseImageDecoder() {
        return shadow$1(this, "canUseImageDecoder", __privateGet(this, _D) ? ImageDecoder.isTypeSupported("image/bmp") : Promise.resolve(false));
      }
      static needsToBeResized(e2, t2) {
        if (e2 <= __privateGet(this, _M) && t2 <= __privateGet(this, _M))
          return false;
        const { MAX_DIM: i2 } = this;
        if (e2 > i2 || t2 > i2)
          return true;
        const a2 = e2 * t2;
        if (this._hasMaxArea)
          return a2 > this.MAX_AREA;
        if (a2 < __privateGet(this, _M) ** 2)
          return false;
        if (this._areGoodDims(e2, t2))
          return __privateSet(this, _M, Math.max(__privateGet(this, _M), Math.floor(Math.sqrt(e2 * t2)))), false;
        __privateSet(this, _M, this._guessMax(__privateGet(this, _M), i2, 128, 0));
        return a2 > (this.MAX_AREA = __privateGet(this, _M) ** 2);
      }
      static getReducePowerForJPX(e2, t2, i2) {
        const a2 = e2 * t2, n2 = 2 ** 30 / (4 * i2);
        if (!this.needsToBeResized(e2, t2))
          return a2 > n2 ? Math.ceil(Math.log2(a2 / n2)) : 0;
        const { MAX_DIM: s2, MAX_AREA: r2 } = this, o2 = Math.max(e2 / s2, t2 / s2, Math.sqrt(a2 / Math.min(n2, r2)));
        return Math.ceil(Math.log2(o2));
      }
      static get MAX_DIM() {
        return shadow$1(this, "MAX_DIM", this._guessMax(2048, 65537, 0, 1));
      }
      static get MAX_AREA() {
        return this._hasMaxArea = true, shadow$1(this, "MAX_AREA", this._guessMax(__privateGet(this, _M), this.MAX_DIM, 128, 0) ** 2);
      }
      static set MAX_AREA(e2) {
        e2 >= 0 && (this._hasMaxArea = true, shadow$1(this, "MAX_AREA", e2));
      }
      static setOptions({ canvasMaxAreaInBytes: e2 = -1, isImageDecoderSupported: t2 = false }) {
        this._hasMaxArea || (this.MAX_AREA = e2 >> 2), __privateSet(this, _D, t2);
      }
      static _areGoodDims(e2, t2) {
        try {
          const i2 = new OffscreenCanvas(e2, t2), a2 = i2.getContext("2d");
          a2.fillRect(0, 0, 1, 1);
          const n2 = a2.getImageData(0, 0, 1, 1).data[3];
          return i2.width = i2.height = 1, 0 !== n2;
        } catch {
          return false;
        }
      }
      static _guessMax(e2, t2, i2, a2) {
        for (; e2 + i2 + 1 < t2; ) {
          const i3 = Math.floor((e2 + t2) / 2), n2 = a2 || i3;
          this._areGoodDims(i3, n2) ? e2 = i3 : t2 = i3;
        }
        return e2;
      }
      static async createImage(e2, t2 = false) {
        return new _ImageResizer(e2, t2)._createImage();
      }
      async _createImage() {
        const { _imgData: e2 } = this, { width: t2, height: i2 } = e2;
        if (t2 * i2 * 4 > pi) {
          const e3 = __privateMethod(this, _E, E_fn).call(this);
          if (e3)
            return e3;
        }
        const a2 = this._encodeBMP();
        let n2, s2;
        await _ImageResizer.canUseImageDecoder ? (n2 = new ImageDecoder({ data: a2, type: "image/bmp", preferAnimation: false, transfer: [a2.buffer] }), s2 = n2.decode().catch((e3) => (warn$1(`BMP image decoding failed: ${e3}`), createImageBitmap(new Blob([this._encodeBMP().buffer], { type: "image/bmp" })))).finally(() => {
          n2.close();
        })) : s2 = createImageBitmap(new Blob([a2.buffer], { type: "image/bmp" }));
        const { MAX_AREA: r2, MAX_DIM: o2 } = _ImageResizer, l3 = Math.max(t2 / o2, i2 / o2, Math.sqrt(t2 * i2 / r2)), c2 = Math.max(l3, 2), h2 = Math.round(10 * (l3 + 1.25)) / 10 / c2, d2 = Math.floor(Math.log2(h2)), u2 = new Array(d2 + 2).fill(2);
        u2[0] = c2, u2.splice(-1, 1, h2 / (1 << d2));
        let g2 = t2, p2 = i2;
        const f2 = await s2;
        let m2 = f2.image || f2;
        for (const e3 of u2) {
          const t3 = g2, i3 = p2;
          g2 = Math.floor(g2 / e3) - 1, p2 = Math.floor(p2 / e3) - 1;
          const a3 = new OffscreenCanvas(g2, p2);
          a3.getContext("2d").drawImage(m2, 0, 0, t3, i3, 0, 0, g2, p2), m2.close(), m2 = a3.transferToImageBitmap();
        }
        return e2.data = null, e2.bitmap = m2, e2.width = g2, e2.height = p2, e2;
      }
      _encodeBMP() {
        const { width: e2, height: t2, kind: i2 } = this._imgData;
        let a2, n2 = this._imgData.data, s2 = new Uint8Array(0), r2 = s2, o2 = 0;
        switch (i2) {
          case v: {
            a2 = 1, s2 = new Uint8Array(this._isMask ? [255, 255, 255, 255, 0, 0, 0, 0] : [0, 0, 0, 0, 255, 255, 255, 255]);
            const i4 = e2 + 7 >> 3, r3 = i4 + 3 & -4;
            if (i4 !== r3) {
              const e3 = new Uint8Array(r3 * t2);
              let a3 = 0;
              for (let s3 = 0, o3 = t2 * i4; s3 < o3; s3 += i4, a3 += r3)
                e3.set(n2.subarray(s3, s3 + i4), a3);
              n2 = e3;
            }
            break;
          }
          case C:
            if (a2 = 24, 3 & e2) {
              const i4 = 3 * e2, a3 = i4 + 3 & -4, s3 = a3 - i4, r3 = new Uint8Array(a3 * t2);
              let o3 = 0;
              for (let e3 = 0, a4 = t2 * i4; e3 < a4; e3 += i4) {
                const t3 = n2.subarray(e3, e3 + i4);
                for (let e4 = 0; e4 < i4; e4 += 3)
                  r3[o3++] = t3[e4 + 2], r3[o3++] = t3[e4 + 1], r3[o3++] = t3[e4];
                o3 += s3;
              }
              n2 = r3;
            } else
              for (let e3 = 0, t3 = n2.length; e3 < t3; e3 += 3) {
                const t4 = n2[e3];
                n2[e3] = n2[e3 + 2], n2[e3 + 2] = t4;
              }
            break;
          case k:
            a2 = 32, o2 = 3, r2 = new Uint8Array(68);
            const i3 = new DataView(r2.buffer);
            FeatureTest.isLittleEndian ? (i3.setUint32(0, 255, true), i3.setUint32(4, 65280, true), i3.setUint32(8, 16711680, true), i3.setUint32(12, 4278190080, true)) : (i3.setUint32(0, 4278190080, true), i3.setUint32(4, 16711680, true), i3.setUint32(8, 65280, true), i3.setUint32(12, 255, true));
            break;
          default:
            throw new Error("invalid format");
        }
        let l3 = 0;
        const c2 = 40 + r2.length, h2 = 14 + c2 + s2.length + n2.length, d2 = new Uint8Array(h2), u2 = new DataView(d2.buffer);
        return u2.setUint16(l3, 19778, true), l3 += 2, u2.setUint32(l3, h2, true), l3 += 4, u2.setUint32(l3, 0, true), l3 += 4, u2.setUint32(l3, 14 + c2 + s2.length, true), l3 += 4, u2.setUint32(l3, c2, true), l3 += 4, u2.setInt32(l3, e2, true), l3 += 4, u2.setInt32(l3, -t2, true), l3 += 4, u2.setUint16(l3, 1, true), l3 += 2, u2.setUint16(l3, a2, true), l3 += 2, u2.setUint32(l3, o2, true), l3 += 4, u2.setUint32(l3, 0, true), l3 += 4, u2.setInt32(l3, 0, true), l3 += 4, u2.setInt32(l3, 0, true), l3 += 4, u2.setUint32(l3, s2.length / 4, true), l3 += 4, u2.setUint32(l3, 0, true), l3 += 4, d2.set(r2, l3), l3 += r2.length, d2.set(s2, l3), l3 += s2.length, d2.set(n2, l3), d2;
      }
    };
    ImageResizer = _ImageResizer;
    __name(ImageResizer, "ImageResizer");
    _M = new WeakMap();
    _D = new WeakMap();
    _E = new WeakSet();
    E_fn = /* @__PURE__ */ __name(function() {
      const { _imgData: e2 } = this, { data: t2, width: i2, height: a2, kind: n2 } = e2, s2 = i2 * a2 * 4, r2 = Math.ceil(Math.log2(s2 / pi)), o2 = i2 >> r2, l3 = a2 >> r2;
      let c2, h2 = a2;
      try {
        c2 = new Uint8Array(s2);
      } catch {
        let e3 = Math.floor(Math.log2(s2 + 1));
        for (; ; )
          try {
            c2 = new Uint8Array(2 ** e3 - 1);
            break;
          } catch {
            e3 -= 1;
          }
        h2 = Math.floor((2 ** e3 - 1) / (4 * i2));
        const t3 = i2 * h2 * 4;
        t3 < c2.length && (c2 = new Uint8Array(t3));
      }
      const d2 = new Uint32Array(c2.buffer), u2 = new Uint32Array(o2 * l3);
      let g2 = 0, p2 = 0;
      const f2 = Math.ceil(a2 / h2), m2 = a2 % h2 === 0 ? a2 : a2 % h2;
      for (let e3 = 0; e3 < f2; e3++) {
        const a3 = e3 < f2 - 1 ? h2 : m2;
        ({ srcPos: g2 } = convertToRGBA({ kind: n2, src: t2, dest: d2, width: i2, height: a3, inverseDecode: this._isMask, srcPos: g2 }));
        for (let e4 = 0, t3 = a3 >> r2; e4 < t3; e4++) {
          const t4 = d2.subarray((e4 << r2) * i2);
          for (let e5 = 0; e5 < o2; e5++)
            u2[p2++] = t4[e5 << r2];
        }
      }
      if (_ImageResizer.needsToBeResized(o2, l3))
        return e2.data = u2, e2.width = o2, e2.height = l3, e2.kind = k, null;
      const b2 = new OffscreenCanvas(o2, l3);
      return b2.getContext("2d", { willReadFrequently: true }).putImageData(new ImageData(new Uint8ClampedArray(u2.buffer), o2, l3), 0, 0), e2.data = null, e2.bitmap = b2.transferToImageBitmap(), e2.width = o2, e2.height = l3, e2;
    }, "#E");
    __privateAdd(ImageResizer, _M, 2048);
    __privateAdd(ImageResizer, _D, FeatureTest.isImageDecoderSupported);
    Ti = new Uint8Array(0);
    DecodeStream = class extends BaseStream {
      constructor(e2) {
        if (super(), this._rawMinBufferLength = e2 || 0, this.pos = 0, this.bufferLength = 0, this.eof = false, this.buffer = Ti, this.minBufferLength = 512, e2)
          for (; this.minBufferLength < e2; )
            this.minBufferLength *= 2;
      }
      get isEmpty() {
        for (; !this.eof && 0 === this.bufferLength; )
          this.readBlock();
        return 0 === this.bufferLength;
      }
      ensureBuffer(e2) {
        const t2 = this.buffer;
        if (e2 <= t2.byteLength)
          return t2;
        let i2 = this.minBufferLength;
        for (; i2 < e2; )
          i2 *= 2;
        const a2 = new Uint8Array(i2);
        return a2.set(t2), this.buffer = a2;
      }
      getByte() {
        const e2 = this.pos;
        for (; this.bufferLength <= e2; ) {
          if (this.eof)
            return -1;
          this.readBlock();
        }
        return this.buffer[this.pos++];
      }
      getBytes(e2, t2 = null) {
        const i2 = this.pos;
        let a2;
        if (e2) {
          for (this.ensureBuffer(i2 + e2), a2 = i2 + e2; !this.eof && this.bufferLength < a2; )
            this.readBlock(t2);
          const n2 = this.bufferLength;
          a2 > n2 && (a2 = n2);
        } else {
          for (; !this.eof; )
            this.readBlock(t2);
          a2 = this.bufferLength;
        }
        return this.pos = a2, this.buffer.subarray(i2, a2);
      }
      async getImageData(e2, t2) {
        if (!this.canAsyncDecodeImageFromBuffer)
          return this.isAsyncDecoder ? this.decodeImage(null, t2) : this.getBytes(e2, t2);
        const i2 = await this.stream.asyncGetBytes();
        return this.decodeImage(i2, t2);
      }
      reset() {
        this.pos = 0;
      }
      makeSubStream(e2, t2, i2 = null) {
        if (void 0 === t2)
          for (; !this.eof; )
            this.readBlock();
        else {
          const i3 = e2 + t2;
          for (; this.bufferLength <= i3 && !this.eof; )
            this.readBlock();
        }
        return new Stream(this.buffer, e2, t2, i2);
      }
      getBaseStreams() {
        return this.str ? this.str.getBaseStreams() : null;
      }
    };
    __name(DecodeStream, "DecodeStream");
    StreamsSequenceStream = class extends DecodeStream {
      constructor(e2, t2 = null) {
        e2 = e2.filter((e3) => e3 instanceof BaseStream);
        let i2 = 0;
        for (const t3 of e2)
          i2 += t3 instanceof DecodeStream ? t3._rawMinBufferLength : t3.length;
        super(i2), this.streams = e2, this._onError = t2;
      }
      readBlock() {
        const e2 = this.streams;
        if (0 === e2.length)
          return void (this.eof = true);
        const t2 = e2.shift();
        let i2;
        try {
          i2 = t2.getBytes();
        } catch (e3) {
          if (this._onError)
            return void this._onError(e3, t2.dict?.objId);
          throw e3;
        }
        const a2 = this.bufferLength, n2 = a2 + i2.length;
        this.ensureBuffer(n2).set(i2, a2), this.bufferLength = n2;
      }
      getBaseStreams() {
        const e2 = [];
        for (const t2 of this.streams) {
          const i2 = t2.getBaseStreams();
          i2 && e2.push(...i2);
        }
        return e2.length > 0 ? e2 : null;
      }
    };
    __name(StreamsSequenceStream, "StreamsSequenceStream");
    ColorSpaceUtils = class {
      static parse({ cs: e2, xref: t2, resources: i2 = null, pdfFunctionFactory: a2, globalColorSpaceCache: n2, localColorSpaceCache: s2, asyncIfNotCached: r2 = false }) {
        const o2 = { xref: t2, resources: i2, pdfFunctionFactory: a2, globalColorSpaceCache: n2, localColorSpaceCache: s2 };
        let l3, c2, h2;
        if (e2 instanceof Ref) {
          c2 = e2;
          const i3 = n2.getByRef(c2) || s2.getByRef(c2);
          if (i3)
            return i3;
          e2 = t2.fetch(e2);
        }
        if (e2 instanceof Name) {
          l3 = e2.name;
          const t3 = s2.getByName(l3);
          if (t3)
            return t3;
        }
        try {
          h2 = __privateMethod(this, _O, O_fn).call(this, e2, o2);
        } catch (e3) {
          if (r2 && !(e3 instanceof MissingDataException))
            return Promise.reject(e3);
          throw e3;
        }
        return (l3 || c2) && (s2.set(l3, c2, h2), c2 && n2.set(null, c2, h2)), r2 ? Promise.resolve(h2) : h2;
      }
      static get gray() {
        return shadow$1(this, "gray", new DeviceGrayCS());
      }
      static get rgb() {
        return shadow$1(this, "rgb", new DeviceRgbCS());
      }
      static get rgba() {
        return shadow$1(this, "rgba", new DeviceRgbaCS());
      }
      static get cmyk() {
        if (CmykICCBasedCS.isUsable)
          try {
            return shadow$1(this, "cmyk", new CmykICCBasedCS());
          } catch {
            warn$1("CMYK fallback: DeviceCMYK");
          }
        return shadow$1(this, "cmyk", new DeviceCmykCS());
      }
    };
    __name(ColorSpaceUtils, "ColorSpaceUtils");
    __ = new WeakSet();
    __fn = /* @__PURE__ */ __name(function(e2, t2) {
      const { globalColorSpaceCache: i2 } = t2;
      let a2;
      if (e2 instanceof Ref) {
        a2 = e2;
        const t3 = i2.getByRef(a2);
        if (t3)
          return t3;
      }
      const n2 = __privateMethod(this, _O, O_fn).call(this, e2, t2);
      return a2 && i2.set(null, a2, n2), n2;
    }, "#_");
    _O = new WeakSet();
    O_fn = /* @__PURE__ */ __name(function(e2, t2) {
      const { xref: i2, resources: a2, pdfFunctionFactory: n2, globalColorSpaceCache: s2 } = t2;
      if ((e2 = i2.fetchIfRef(e2)) instanceof Name)
        switch (e2.name) {
          case "G":
          case "DeviceGray":
            return this.gray;
          case "RGB":
          case "DeviceRGB":
            return this.rgb;
          case "DeviceRGBA":
            return this.rgba;
          case "CMYK":
          case "DeviceCMYK":
            return this.cmyk;
          case "Pattern":
            return new PatternCS(null);
          default:
            if (a2 instanceof Dict) {
              const i3 = a2.get("ColorSpace");
              if (i3 instanceof Dict) {
                const a3 = i3.get(e2.name);
                if (a3) {
                  if (a3 instanceof Name)
                    return __privateMethod(this, _O, O_fn).call(this, a3, t2);
                  e2 = a3;
                  break;
                }
              }
            }
            return warn$1(`Unrecognized ColorSpace: ${e2.name}`), this.gray;
        }
      if (Array.isArray(e2)) {
        const a3 = i2.fetchIfRef(e2[0]).name;
        let r2, o2, l3, c2, h2, d2;
        switch (a3) {
          case "G":
          case "DeviceGray":
            return this.gray;
          case "RGB":
          case "DeviceRGB":
            return this.rgb;
          case "CMYK":
          case "DeviceCMYK":
            return this.cmyk;
          case "CalGray":
            return r2 = i2.fetchIfRef(e2[1]), c2 = r2.getArray("WhitePoint"), h2 = r2.getArray("BlackPoint"), d2 = r2.get("Gamma"), new CalGrayCS(c2, h2, d2);
          case "CalRGB":
            r2 = i2.fetchIfRef(e2[1]), c2 = r2.getArray("WhitePoint"), h2 = r2.getArray("BlackPoint"), d2 = r2.getArray("Gamma");
            const u2 = r2.getArray("Matrix");
            return new CalRGBCS(c2, h2, d2, u2);
          case "ICCBased":
            const g2 = e2[1] instanceof Ref;
            if (g2) {
              const t3 = s2.getByRef(e2[1]);
              if (t3)
                return t3;
            }
            const p2 = i2.fetchIfRef(e2[1]), f2 = p2.dict;
            if (o2 = f2.get("N"), IccColorSpace.isUsable)
              try {
                const t3 = new IccColorSpace(p2.getBytes(), "ICCBased", o2);
                return g2 && s2.set(null, e2[1], t3), t3;
              } catch (t3) {
                if (t3 instanceof MissingDataException)
                  throw t3;
                warn$1(`ICCBased color space (${e2[1]}): "${t3}".`);
              }
            const m2 = f2.getRaw("Alternate");
            if (m2) {
              const e3 = __privateMethod(this, __, __fn).call(this, m2, t2);
              if (e3.numComps === o2)
                return e3;
              warn$1("ICCBased color space: Ignoring incorrect /Alternate entry.");
            }
            if (1 === o2)
              return this.gray;
            if (3 === o2)
              return this.rgb;
            if (4 === o2)
              return this.cmyk;
            break;
          case "Pattern":
            return l3 = e2[1] || null, l3 && (l3 = __privateMethod(this, __, __fn).call(this, l3, t2)), new PatternCS(l3);
          case "I":
          case "Indexed":
            l3 = __privateMethod(this, __, __fn).call(this, e2[1], t2);
            const b2 = MathClamp$1(i2.fetchIfRef(e2[2]), 0, 255), y2 = i2.fetchIfRef(e2[3]);
            return new IndexedCS(l3, b2, y2);
          case "Separation":
          case "DeviceN":
            const w2 = i2.fetchIfRef(e2[1]);
            o2 = Array.isArray(w2) ? w2.length : 1, l3 = __privateMethod(this, __, __fn).call(this, e2[2], t2);
            const x2 = n2.create(e2[3]);
            return new AlternateCS(o2, l3, x2);
          case "Lab":
            r2 = i2.fetchIfRef(e2[1]), c2 = r2.getArray("WhitePoint"), h2 = r2.getArray("BlackPoint");
            const S2 = r2.getArray("Range");
            return new LabCS(c2, h2, S2);
          default:
            return warn$1(`Unimplemented ColorSpace object: ${a3}`), this.gray;
        }
      }
      return warn$1(`Unrecognized ColorSpace object: ${e2}`), this.gray;
    }, "#O");
    __privateAdd(ColorSpaceUtils, __);
    __privateAdd(ColorSpaceUtils, _O);
    JpegError = class extends Yt {
      constructor(e2) {
        super(e2, "JpegError");
      }
    };
    __name(JpegError, "JpegError");
    DNLMarkerError = class extends Yt {
      constructor(e2, t2) {
        super(e2, "DNLMarkerError"), this.scanLines = t2;
      }
    };
    __name(DNLMarkerError, "DNLMarkerError");
    EOIMarkerError = class extends Yt {
      constructor(e2) {
        super(e2, "EOIMarkerError");
      }
    };
    __name(EOIMarkerError, "EOIMarkerError");
    Ii = new Uint8Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]);
    Fi = 4017;
    Mi = 799;
    Di = 3406;
    Ei = 2276;
    Oi = 1567;
    _i2 = 3784;
    Pi = 5793;
    Ri = 2896;
    __name(buildHuffmanTable, "buildHuffmanTable");
    __name(getBlockBufferOffset, "getBlockBufferOffset");
    __name(decodeScan, "decodeScan");
    __name(quantizeAndInverse, "quantizeAndInverse");
    __name(buildComponentData, "buildComponentData");
    __name(findNextFileMarker, "findNextFileMarker");
    __name(prepareComponents, "prepareComponents");
    __name(readDataBlock, "readDataBlock");
    __name(skipData, "skipData");
    JpegImage = class {
      constructor({ decodeTransform: e2 = null, colorTransform: t2 = -1 } = {}) {
        this._decodeTransform = e2, this._colorTransform = t2;
      }
      static canUseImageDecoder(e2, t2 = -1) {
        let i2 = null, a2 = 0, n2 = null, s2 = readUint16(e2, a2);
        if (a2 += 2, 65496 !== s2)
          throw new JpegError("SOI not found");
        s2 = readUint16(e2, a2), a2 += 2;
        e:
          for (; 65497 !== s2; ) {
            switch (s2) {
              case 65505:
                const { appData: t3, oldOffset: r2, newOffset: o2 } = readDataBlock(e2, a2);
                if (a2 = o2, 69 === t3[0] && 120 === t3[1] && 105 === t3[2] && 102 === t3[3] && 0 === t3[4] && 0 === t3[5]) {
                  if (i2)
                    throw new JpegError("Duplicate EXIF-blocks found.");
                  i2 = { exifStart: r2 + 6, exifEnd: o2 };
                }
                s2 = readUint16(e2, a2), a2 += 2;
                continue;
              case 65472:
              case 65473:
              case 65474:
                n2 = e2[a2 + 7];
                break e;
              case 65535:
                255 !== e2[a2] && a2--;
            }
            a2 = skipData(e2, a2), s2 = readUint16(e2, a2), a2 += 2;
          }
        return 4 === n2 || 3 === n2 && 0 === t2 ? null : i2 || {};
      }
      parse(e2, { dnlScanLines: t2 = null } = {}) {
        let i2, a2, n2 = 0, s2 = null, r2 = null, o2 = 0;
        const l3 = [], c2 = [], h2 = [];
        let d2 = readUint16(e2, n2);
        if (n2 += 2, 65496 !== d2)
          throw new JpegError("SOI not found");
        d2 = readUint16(e2, n2), n2 += 2;
        e:
          for (; 65497 !== d2; ) {
            let u2, g2, p2;
            switch (d2) {
              case 65504:
              case 65505:
              case 65506:
              case 65507:
              case 65508:
              case 65509:
              case 65510:
              case 65511:
              case 65512:
              case 65513:
              case 65514:
              case 65515:
              case 65516:
              case 65517:
              case 65518:
              case 65519:
              case 65534:
                const { appData: f2, newOffset: m2 } = readDataBlock(e2, n2);
                n2 = m2, 65504 === d2 && 74 === f2[0] && 70 === f2[1] && 73 === f2[2] && 70 === f2[3] && 0 === f2[4] && (s2 = { version: { major: f2[5], minor: f2[6] }, densityUnits: f2[7], xDensity: f2[8] << 8 | f2[9], yDensity: f2[10] << 8 | f2[11], thumbWidth: f2[12], thumbHeight: f2[13], thumbData: f2.subarray(14, 14 + 3 * f2[12] * f2[13]) }), 65518 === d2 && 65 === f2[0] && 100 === f2[1] && 111 === f2[2] && 98 === f2[3] && 101 === f2[4] && (r2 = { version: f2[5] << 8 | f2[6], flags0: f2[7] << 8 | f2[8], flags1: f2[9] << 8 | f2[10], transformCode: f2[11] });
                break;
              case 65499:
                const b2 = readUint16(e2, n2);
                n2 += 2;
                const y2 = b2 + n2 - 2;
                let w2;
                for (; n2 < y2; ) {
                  const t3 = e2[n2++], i3 = new Uint16Array(64);
                  if (t3 >> 4) {
                    if (t3 >> 4 != 1)
                      throw new JpegError("DQT - invalid table spec");
                    for (g2 = 0; g2 < 64; g2++)
                      w2 = Ii[g2], i3[w2] = readUint16(e2, n2), n2 += 2;
                  } else
                    for (g2 = 0; g2 < 64; g2++)
                      w2 = Ii[g2], i3[w2] = e2[n2++];
                  l3[15 & t3] = i3;
                }
                break;
              case 65472:
              case 65473:
              case 65474:
                if (i2)
                  throw new JpegError("Only single frame JPEGs supported");
                n2 += 2, i2 = {}, i2.extended = 65473 === d2, i2.progressive = 65474 === d2, i2.precision = e2[n2++];
                const x2 = readUint16(e2, n2);
                n2 += 2, i2.scanLines = t2 || x2, i2.samplesPerLine = readUint16(e2, n2), n2 += 2, i2.components = [], i2.componentIds = {};
                const S2 = e2[n2++];
                let v2 = 0, C2 = 0;
                for (u2 = 0; u2 < S2; u2++) {
                  const t3 = e2[n2], a3 = e2[n2 + 1] >> 4, s3 = 15 & e2[n2 + 1];
                  v2 < a3 && (v2 = a3), C2 < s3 && (C2 = s3);
                  const r3 = e2[n2 + 2];
                  p2 = i2.components.push({ h: a3, v: s3, quantizationId: r3, quantizationTable: null }), i2.componentIds[t3] = p2 - 1, n2 += 3;
                }
                i2.maxH = v2, i2.maxV = C2, prepareComponents(i2);
                break;
              case 65476:
                const k2 = readUint16(e2, n2);
                for (n2 += 2, u2 = 2; u2 < k2; ) {
                  const t3 = e2[n2++], i3 = new Uint8Array(16);
                  let a3 = 0;
                  for (g2 = 0; g2 < 16; g2++, n2++)
                    a3 += i3[g2] = e2[n2];
                  const s3 = new Uint8Array(a3);
                  for (g2 = 0; g2 < a3; g2++, n2++)
                    s3[g2] = e2[n2];
                  u2 += 17 + a3, (t3 >> 4 ? c2 : h2)[15 & t3] = buildHuffmanTable(i3, s3);
                }
                break;
              case 65501:
                n2 += 2, a2 = readUint16(e2, n2), n2 += 2;
                break;
              case 65498:
                const T2 = 1 === ++o2 && !t2;
                n2 += 2;
                const F2 = e2[n2++], M2 = [];
                for (u2 = 0; u2 < F2; u2++) {
                  const t3 = e2[n2++], a3 = i2.componentIds[t3], s3 = i2.components[a3];
                  s3.index = t3;
                  const r3 = e2[n2++];
                  s3.huffmanTableDC = h2[r3 >> 4], s3.huffmanTableAC = c2[15 & r3], M2.push(s3);
                }
                const D2 = e2[n2++], E2 = e2[n2++], O2 = e2[n2++];
                try {
                  n2 += decodeScan(e2, n2, i2, M2, a2, D2, E2, O2 >> 4, 15 & O2, T2);
                } catch (t3) {
                  if (t3 instanceof DNLMarkerError)
                    return warn$1(`${t3.message} -- attempting to re-parse the JPEG image.`), this.parse(e2, { dnlScanLines: t3.scanLines });
                  if (t3 instanceof EOIMarkerError) {
                    warn$1(`${t3.message} -- ignoring the rest of the image data.`);
                    break e;
                  }
                  throw t3;
                }
                break;
              case 65500:
                n2 += 4;
                break;
              case 65535:
                255 !== e2[n2] && n2--;
                break;
              default:
                const _2 = findNextFileMarker(e2, n2 - 2, n2 - 3);
                if (_2?.invalid) {
                  warn$1("JpegImage.parse - unexpected data, current marker is: " + _2.invalid), n2 = _2.offset;
                  break;
                }
                if (!_2 || n2 >= e2.length - 1) {
                  warn$1("JpegImage.parse - reached the end of the image data without finding an EOI marker (0xFFD9).");
                  break e;
                }
                throw new JpegError("JpegImage.parse - unknown marker: " + d2.toString(16));
            }
            d2 = readUint16(e2, n2), n2 += 2;
          }
        if (!i2)
          throw new JpegError("JpegImage.parse - no frame data found.");
        this.width = i2.samplesPerLine, this.height = i2.scanLines, this.jfif = s2, this.adobe = r2, this.components = [];
        for (const e3 of i2.components) {
          const t3 = l3[e3.quantizationId];
          t3 && (e3.quantizationTable = t3), this.components.push({ index: e3.index, output: buildComponentData(0, e3), scaleX: e3.h / i2.maxH, scaleY: e3.v / i2.maxV, blocksPerLine: e3.blocksPerLine, blocksPerColumn: e3.blocksPerColumn });
        }
        this.numComponents = this.components.length;
      }
      _getLinearizedBlockData(e2, t2, i2 = false) {
        const a2 = this.width / e2, n2 = this.height / t2;
        let s2, r2, o2, l3, c2, h2, d2, u2, g2, p2, f2, m2 = 0;
        const b2 = this.components.length, y2 = e2 * t2 * b2, w2 = new Uint8ClampedArray(y2), x2 = new Uint32Array(e2), S2 = 4294967288;
        let v2;
        for (d2 = 0; d2 < b2; d2++) {
          if (s2 = this.components[d2], r2 = s2.scaleX * a2, o2 = s2.scaleY * n2, m2 = d2, f2 = s2.output, l3 = s2.blocksPerLine + 1 << 3, r2 !== v2) {
            for (c2 = 0; c2 < e2; c2++)
              u2 = 0 | c2 * r2, x2[c2] = (u2 & S2) << 3 | 7 & u2;
            v2 = r2;
          }
          for (h2 = 0; h2 < t2; h2++)
            for (u2 = 0 | h2 * o2, p2 = l3 * (u2 & S2) | (7 & u2) << 3, c2 = 0; c2 < e2; c2++)
              w2[m2] = f2[p2 + x2[c2]], m2 += b2;
        }
        let C2 = this._decodeTransform;
        if (i2 || 4 !== b2 || C2 || (C2 = new Int32Array([-256, 255, -256, 255, -256, 255, -256, 255])), C2)
          for (d2 = 0; d2 < y2; )
            for (u2 = 0, g2 = 0; u2 < b2; u2++, d2++, g2 += 2)
              w2[d2] = (w2[d2] * C2[g2] >> 8) + C2[g2 + 1];
        return w2;
      }
      get _isColorConversionNeeded() {
        return this.adobe ? !!this.adobe.transformCode : 3 === this.numComponents ? 0 !== this._colorTransform && (82 !== this.components[0].index || 71 !== this.components[1].index || 66 !== this.components[2].index) : 1 === this._colorTransform;
      }
      _convertYccToRgb(e2) {
        let t2, i2, a2;
        for (let n2 = 0, s2 = e2.length; n2 < s2; n2 += 3)
          t2 = e2[n2], i2 = e2[n2 + 1], a2 = e2[n2 + 2], e2[n2] = t2 - 179.456 + 1.402 * a2, e2[n2 + 1] = t2 + 135.459 - 0.344 * i2 - 0.714 * a2, e2[n2 + 2] = t2 - 226.816 + 1.772 * i2;
        return e2;
      }
      _convertYccToRgba(e2, t2) {
        for (let i2 = 0, a2 = 0, n2 = e2.length; i2 < n2; i2 += 3, a2 += 4) {
          const n3 = e2[i2], s2 = e2[i2 + 1], r2 = e2[i2 + 2];
          t2[a2] = n3 - 179.456 + 1.402 * r2, t2[a2 + 1] = n3 + 135.459 - 0.344 * s2 - 0.714 * r2, t2[a2 + 2] = n3 - 226.816 + 1.772 * s2, t2[a2 + 3] = 255;
        }
        return t2;
      }
      _convertYcckToRgb(e2) {
        return this._convertYcckToCmyk(e2), this._convertCmykToRgb(e2);
      }
      _convertYcckToRgba(e2) {
        return this._convertYcckToCmyk(e2), this._convertCmykToRgba(e2);
      }
      _convertYcckToCmyk(e2) {
        let t2, i2, a2;
        for (let n2 = 0, s2 = e2.length; n2 < s2; n2 += 4)
          t2 = e2[n2], i2 = e2[n2 + 1], a2 = e2[n2 + 2], e2[n2] = 434.456 - t2 - 1.402 * a2, e2[n2 + 1] = 119.541 - t2 + 0.344 * i2 + 0.714 * a2, e2[n2 + 2] = 481.816 - t2 - 1.772 * i2;
        return e2;
      }
      _convertCmykToRgb(e2) {
        const t2 = e2.length / 4;
        return ColorSpaceUtils.cmyk.getRgbBuffer(e2, 0, t2, e2, 0, 8, 0), e2.subarray(0, 3 * t2);
      }
      _convertCmykToRgba(e2) {
        if (ColorSpaceUtils.cmyk.getRgbBuffer(e2, 0, e2.length / 4, e2, 0, 8, 1), ColorSpaceUtils.cmyk instanceof DeviceCmykCS)
          for (let t2 = 3, i2 = e2.length; t2 < i2; t2 += 4)
            e2[t2] = 255;
        return e2;
      }
      getData({ width: e2, height: t2, forceRGBA: i2 = false, forceRGB: a2 = false, isSourcePDF: n2 = false }) {
        if (this.numComponents > 4)
          throw new JpegError("Unsupported color mode");
        const s2 = this._getLinearizedBlockData(e2, t2, n2);
        if (1 === this.numComponents && (i2 || a2)) {
          const e3 = s2.length * (i2 ? 4 : 3), t3 = new Uint8ClampedArray(e3);
          let a3 = 0;
          if (i2)
            !function(e4, t4) {
              if (FeatureTest.isLittleEndian)
                for (let i3 = 0, a4 = e4.length; i3 < a4; i3++)
                  t4[i3] = 65793 * e4[i3] | 4278190080;
              else
                for (let i3 = 0, a4 = e4.length; i3 < a4; i3++)
                  t4[i3] = 16843008 * e4[i3] | 255;
            }(s2, new Uint32Array(t3.buffer));
          else
            for (const e4 of s2)
              t3[a3++] = e4, t3[a3++] = e4, t3[a3++] = e4;
          return t3;
        }
        if (3 === this.numComponents && this._isColorConversionNeeded) {
          if (i2) {
            const e3 = new Uint8ClampedArray(s2.length / 3 * 4);
            return this._convertYccToRgba(s2, e3);
          }
          return this._convertYccToRgb(s2);
        }
        if (4 === this.numComponents) {
          if (this._isColorConversionNeeded)
            return i2 ? this._convertYcckToRgba(s2) : a2 ? this._convertYcckToRgb(s2) : this._convertYcckToCmyk(s2);
          if (i2)
            return this._convertCmykToRgba(s2);
          if (a2)
            return this._convertCmykToRgb(s2);
        }
        return s2;
      }
    };
    __name(JpegImage, "JpegImage");
    _JpegStream = class extends DecodeStream {
      constructor(e2, t2, i2) {
        super(t2);
        __privateAdd(this, _P);
        this.stream = e2, this.dict = e2.dict, this.maybeLength = t2, this.params = i2;
      }
      static get canUseImageDecoder() {
        return shadow$1(this, "canUseImageDecoder", __privateGet(this, _D2) ? ImageDecoder.isTypeSupported("image/jpeg") : Promise.resolve(false));
      }
      static setOptions({ isImageDecoderSupported: e2 = false }) {
        __privateSet(this, _D2, e2);
      }
      get bytes() {
        return shadow$1(this, "bytes", this.stream.getBytes(this.maybeLength));
      }
      ensureBuffer(e2) {
      }
      readBlock() {
        this.decodeImage();
      }
      get jpegOptions() {
        const e2 = { decodeTransform: void 0, colorTransform: void 0 }, t2 = this.dict.getArray("D", "Decode");
        if ((this.forceRGBA || this.forceRGB) && Array.isArray(t2)) {
          const i2 = this.dict.get("BPC", "BitsPerComponent") || 8, a2 = t2.length, n2 = new Int32Array(a2);
          let s2 = false;
          const r2 = (1 << i2) - 1;
          for (let e3 = 0; e3 < a2; e3 += 2)
            n2[e3] = 256 * (t2[e3 + 1] - t2[e3]) | 0, n2[e3 + 1] = t2[e3] * r2 | 0, 256 === n2[e3] && 0 === n2[e3 + 1] || (s2 = true);
          s2 && (e2.decodeTransform = n2);
        }
        if (this.params instanceof Dict) {
          const t3 = this.params.get("ColorTransform");
          Number.isInteger(t3) && (e2.colorTransform = t3);
        }
        return shadow$1(this, "jpegOptions", e2);
      }
      decodeImage(e2) {
        if (this.eof)
          return this.buffer;
        e2 = __privateMethod(this, _P, P_fn).call(this, e2 || this.bytes);
        const t2 = new JpegImage(this.jpegOptions);
        t2.parse(e2);
        const i2 = t2.getData({ width: this.drawWidth, height: this.drawHeight, forceRGBA: this.forceRGBA, forceRGB: this.forceRGB, isSourcePDF: true });
        return this.buffer = i2, this.bufferLength = i2.length, this.eof = true, this.buffer;
      }
      get canAsyncDecodeImageFromBuffer() {
        return this.stream.isAsync;
      }
      async getTransferableImage() {
        if (!await _JpegStream.canUseImageDecoder)
          return null;
        const e2 = this.jpegOptions;
        if (e2.decodeTransform)
          return null;
        let t2;
        try {
          const i2 = this.canAsyncDecodeImageFromBuffer && await this.stream.asyncGetBytes() || this.bytes;
          if (!i2)
            return null;
          let a2 = __privateMethod(this, _P, P_fn).call(this, i2);
          const n2 = JpegImage.canUseImageDecoder(a2, e2.colorTransform);
          return n2 ? (n2.exifStart && (a2 = a2.slice(), a2.fill(0, n2.exifStart, n2.exifEnd)), t2 = new ImageDecoder({ data: a2, type: "image/jpeg", preferAnimation: false }), (await t2.decode()).image) : null;
        } catch (e3) {
          return warn$1(`getTransferableImage - failed: "${e3}".`), null;
        } finally {
          t2?.close();
        }
      }
    };
    JpegStream = _JpegStream;
    __name(JpegStream, "JpegStream");
    _D2 = new WeakMap();
    _P = new WeakSet();
    P_fn = /* @__PURE__ */ __name(function(e2) {
      for (let t2 = 0, i2 = e2.length - 1; t2 < i2; t2++)
        if (255 === e2[t2] && 216 === e2[t2 + 1]) {
          t2 > 0 && (e2 = e2.subarray(t2));
          break;
        }
      return e2;
    }, "#P");
    __privateAdd(JpegStream, _D2, FeatureTest.isImageDecoderSupported);
    JpxError = class extends Yt {
      constructor(e2) {
        super(e2, "JpxError");
      }
    };
    __name(JpxError, "JpxError");
    JpxImage = class {
      static setOptions({ handler: e2, useWasm: t2, useWorkerFetch: i2, wasmUrl: a2 }) {
        __privateSet(this, _k2, t2), __privateSet(this, _L, i2), __privateSet(this, _T2, a2), i2 || __privateSet(this, _B, e2);
      }
      static async decode(e2, { numComponents: t2 = 4, isIndexedColormap: i2 = false, smaskInData: a2 = false, reducePower: n2 = 0 } = {}) {
        const s2 = await __privateGet(this, _N);
        if (!s2)
          throw new JpxError("OpenJPEG failed to initialize");
        let r2;
        try {
          const o2 = e2.length;
          r2 = s2._malloc(o2), s2.writeArrayToMemory(e2, r2);
          if (s2._jp2_decode(r2, o2, t2 > 0 ? t2 : 0, !!i2, !!a2, n2)) {
            const { errorMessages: e3 } = s2;
            if (e3)
              throw delete s2.errorMessages, new JpxError(e3);
            throw new JpxError("Unknown error");
          }
          const { imageData: l3 } = s2;
          return s2.imageData = null, l3;
        } finally {
          r2 && s2._free(r2);
        }
      }
      static cleanup() {
        __privateSet(this, _N, null);
      }
      static parseImageProperties(e2) {
        let t2 = e2.getByte();
        for (; t2 >= 0; ) {
          const i2 = t2;
          t2 = e2.getByte();
          if (65361 === (i2 << 8 | t2)) {
            e2.skip(4);
            const t3 = e2.getInt32() >>> 0, i3 = e2.getInt32() >>> 0, a2 = e2.getInt32() >>> 0, n2 = e2.getInt32() >>> 0;
            e2.skip(16);
            return { width: t3 - a2, height: i3 - n2, bitsPerComponent: 8, componentsCount: e2.getUint16() };
          }
        }
        throw new JpxError("No size marker found in JPX stream");
      }
    };
    __name(JpxImage, "JpxImage");
    _R = new WeakMap();
    _B = new WeakMap();
    _N = new WeakMap();
    _k2 = new WeakMap();
    _L = new WeakMap();
    _T2 = new WeakMap();
    _U = new WeakSet();
    U_fn = /* @__PURE__ */ __name(async function(e2) {
    }, "#U");
    _j = new WeakSet();
    j_fn = /* @__PURE__ */ __name(async function(e2, t2, i2) {
    }, "#j");
    __privateAdd(JpxImage, _U);
    __privateAdd(JpxImage, _j);
    __privateAdd(JpxImage, _R, null);
    __privateAdd(JpxImage, _B, null);
    __privateAdd(JpxImage, _N, null);
    __privateAdd(JpxImage, _k2, true);
    __privateAdd(JpxImage, _L, true);
    __privateAdd(JpxImage, _T2, null);
    __name(addState, "addState");
    Bi = [];
    addState(Bi, [fe, be, Pt, me], null, function(e2, t2) {
      const i2 = e2.fnArray, a2 = (t2 - (e2.iCurr - 3)) % 4;
      switch (a2) {
        case 0:
          return i2[t2] === fe;
        case 1:
          return i2[t2] === be;
        case 2:
          return i2[t2] === Pt;
        case 3:
          return i2[t2] === me;
      }
      throw new Error(`iterateInlineImageGroup - invalid pos: ${a2}`);
    }, function(e2, t2) {
      const i2 = e2.fnArray, a2 = e2.argsArray, n2 = e2.iCurr, s2 = n2 - 3, r2 = n2 - 2, o2 = n2 - 1, l3 = Math.min(Math.floor((t2 - s2) / 4), 200);
      if (l3 < 10)
        return t2 - (t2 - s2) % 4;
      let c2 = 0;
      const h2 = [];
      let d2 = 0, u2 = 1, g2 = 1;
      for (let e3 = 0; e3 < l3; e3++) {
        const t3 = a2[r2 + (e3 << 2)], i3 = a2[o2 + (e3 << 2)][0];
        u2 + i3.width > 1e3 && (c2 = Math.max(c2, u2), g2 += d2 + 2, u2 = 0, d2 = 0), h2.push({ transform: t3, x: u2, y: g2, w: i3.width, h: i3.height }), u2 += i3.width + 2, d2 = Math.max(d2, i3.height);
      }
      const p2 = Math.max(c2, u2) + 1, f2 = g2 + d2 + 1, m2 = new Uint8Array(p2 * f2 * 4), b2 = p2 << 2;
      for (let e3 = 0; e3 < l3; e3++) {
        const t3 = a2[o2 + (e3 << 2)][0].data, i3 = h2[e3].w << 2;
        let n3 = 0, s3 = h2[e3].x + h2[e3].y * p2 << 2;
        m2.set(t3.subarray(0, i3), s3 - b2);
        for (let a3 = 0, r3 = h2[e3].h; a3 < r3; a3++)
          m2.set(t3.subarray(n3, n3 + i3), s3), n3 += i3, s3 += b2;
        for (m2.set(t3.subarray(n3 - i3, n3), s3); s3 >= 0; )
          t3[s3 - 4] = t3[s3], t3[s3 - 3] = t3[s3 + 1], t3[s3 - 2] = t3[s3 + 2], t3[s3 - 1] = t3[s3 + 3], t3[s3 + i3] = t3[s3 + i3 - 4], t3[s3 + i3 + 1] = t3[s3 + i3 - 3], t3[s3 + i3 + 2] = t3[s3 + i3 - 2], t3[s3 + i3 + 3] = t3[s3 + i3 - 1], s3 -= b2;
      }
      const y2 = { width: p2, height: f2 };
      if (e2.isOffscreenCanvasSupported) {
        const e3 = new OffscreenCanvas(p2, f2);
        e3.getContext("2d").putImageData(new ImageData(new Uint8ClampedArray(m2.buffer), p2, f2), 0, 0), y2.bitmap = e3.transferToImageBitmap(), y2.data = null;
      } else
        y2.kind = k, y2.data = m2;
      return i2.splice(s2, 4 * l3, Rt), a2.splice(s2, 4 * l3, [y2, h2]), s2 + 1;
    }), addState(Bi, [fe, be, Et, me], null, function(e2, t2) {
      const i2 = e2.fnArray, a2 = (t2 - (e2.iCurr - 3)) % 4;
      switch (a2) {
        case 0:
          return i2[t2] === fe;
        case 1:
          return i2[t2] === be;
        case 2:
          return i2[t2] === Et;
        case 3:
          return i2[t2] === me;
      }
      throw new Error(`iterateImageMaskGroup - invalid pos: ${a2}`);
    }, function(e2, t2) {
      const i2 = e2.fnArray, a2 = e2.argsArray, n2 = e2.iCurr, s2 = n2 - 3, r2 = n2 - 2, o2 = n2 - 1;
      let l3 = Math.floor((t2 - s2) / 4);
      if (l3 < 10)
        return t2 - (t2 - s2) % 4;
      let c2, h2, d2 = false;
      const u2 = a2[o2][0], g2 = a2[r2][0], p2 = a2[r2][1], f2 = a2[r2][2], m2 = a2[r2][3];
      if (p2 === f2) {
        d2 = true, c2 = r2 + 4;
        let e3 = o2 + 4;
        for (let t3 = 1; t3 < l3; t3++, c2 += 4, e3 += 4)
          if (h2 = a2[c2], a2[e3][0] !== u2 || h2[0] !== g2 || h2[1] !== p2 || h2[2] !== f2 || h2[3] !== m2) {
            t3 < 10 ? d2 = false : l3 = t3;
            break;
          }
      }
      if (d2) {
        l3 = Math.min(l3, 1e3);
        const e3 = new Float32Array(2 * l3);
        c2 = r2;
        for (let t3 = 0; t3 < l3; t3++, c2 += 4)
          h2 = a2[c2], e3[t3 << 1] = h2[4], e3[1 + (t3 << 1)] = h2[5];
        i2.splice(s2, 4 * l3, Nt), a2.splice(s2, 4 * l3, [u2, g2, p2, f2, m2, e3]);
      } else {
        l3 = Math.min(l3, 100);
        const e3 = [];
        for (let t3 = 0; t3 < l3; t3++) {
          h2 = a2[r2 + (t3 << 2)];
          const i3 = a2[o2 + (t3 << 2)][0];
          e3.push({ data: i3.data, width: i3.width, height: i3.height, interpolate: i3.interpolate, count: i3.count, transform: h2 });
        }
        i2.splice(s2, 4 * l3, Ot), a2.splice(s2, 4 * l3, [e3]);
      }
      return s2 + 1;
    }), addState(Bi, [fe, be, _t, me], function(e2) {
      const t2 = e2.argsArray, i2 = e2.iCurr - 2;
      return 0 === t2[i2][1] && 0 === t2[i2][2];
    }, function(e2, t2) {
      const i2 = e2.fnArray, a2 = e2.argsArray, n2 = (t2 - (e2.iCurr - 3)) % 4;
      switch (n2) {
        case 0:
          return i2[t2] === fe;
        case 1:
          if (i2[t2] !== be)
            return false;
          const n3 = e2.iCurr - 2, s2 = a2[n3][0], r2 = a2[n3][3];
          return a2[t2][0] === s2 && 0 === a2[t2][1] && 0 === a2[t2][2] && a2[t2][3] === r2;
        case 2:
          if (i2[t2] !== _t)
            return false;
          const o2 = a2[e2.iCurr - 1][0];
          return a2[t2][0] === o2;
        case 3:
          return i2[t2] === me;
      }
      throw new Error(`iterateImageGroup - invalid pos: ${n2}`);
    }, function(e2, t2) {
      const i2 = e2.fnArray, a2 = e2.argsArray, n2 = e2.iCurr, s2 = n2 - 3, r2 = n2 - 2, o2 = a2[n2 - 1][0], l3 = a2[r2][0], c2 = a2[r2][3], h2 = Math.min(Math.floor((t2 - s2) / 4), 1e3);
      if (h2 < 3)
        return t2 - (t2 - s2) % 4;
      const d2 = new Float32Array(2 * h2);
      let u2 = r2;
      for (let e3 = 0; e3 < h2; e3++, u2 += 4) {
        const t3 = a2[u2];
        d2[e3 << 1] = t3[4], d2[1 + (e3 << 1)] = t3[5];
      }
      const g2 = [o2, l3, c2, d2];
      return i2.splice(s2, 4 * h2, Bt), a2.splice(s2, 4 * h2, g2), s2 + 1;
    }), addState(Bi, [Be, He, Ge, Ke, Ne], null, function(e2, t2) {
      const i2 = e2.fnArray, a2 = e2.argsArray, n2 = (t2 - (e2.iCurr - 4)) % 5;
      switch (n2) {
        case 0:
          return i2[t2] === Be;
        case 1:
          return i2[t2] === He;
        case 2:
          return i2[t2] === Ge;
        case 3:
          if (i2[t2] !== Ke)
            return false;
          const n3 = e2.iCurr - 3, s2 = a2[n3][0], r2 = a2[n3][1];
          return a2[t2][0] === s2 && a2[t2][1] === r2;
        case 4:
          return i2[t2] === Ne;
      }
      throw new Error(`iterateShowTextGroup - invalid pos: ${n2}`);
    }, function(e2, t2) {
      const i2 = e2.fnArray, a2 = e2.argsArray, n2 = e2.iCurr, s2 = n2 - 4, r2 = n2 - 3, o2 = n2 - 2, l3 = n2 - 1, c2 = n2, h2 = a2[r2][0], d2 = a2[r2][1];
      let u2 = Math.min(Math.floor((t2 - s2) / 5), 1e3);
      if (u2 < 3)
        return t2 - (t2 - s2) % 5;
      let g2 = s2;
      s2 >= 4 && i2[s2 - 4] === i2[r2] && i2[s2 - 3] === i2[o2] && i2[s2 - 2] === i2[l3] && i2[s2 - 1] === i2[c2] && a2[s2 - 4][0] === h2 && a2[s2 - 4][1] === d2 && (u2++, g2 -= 5);
      let p2 = g2 + 4;
      for (let e3 = 1; e3 < u2; e3++)
        i2.splice(p2, 3), a2.splice(p2, 3), p2 += 2;
      return p2 + 1;
    }), addState(Bi, [fe, be, Ut, me], (e2) => {
      const t2 = e2.argsArray, i2 = t2[e2.iCurr - 1][0];
      if (i2 !== ke && i2 !== Te && i2 !== Me && i2 !== De && i2 !== Ee && i2 !== Oe)
        return true;
      const a2 = t2[e2.iCurr - 2];
      return 1 === a2[0] && 0 === a2[1] && 0 === a2[2] && 1 === a2[3];
    }, () => false, (e2, t2) => {
      const { fnArray: i2, argsArray: a2 } = e2, n2 = e2.iCurr, s2 = n2 - 3, r2 = n2 - 2, o2 = a2[n2 - 1], l3 = a2[r2], [, [c2], h2] = o2;
      if (h2) {
        ni.scaleMinMax(l3, h2);
        for (let e3 = 0, t3 = c2.length; e3 < t3; )
          switch (c2[e3++]) {
            case qt:
            case Xt:
              ni.applyTransform(c2, l3, e3), e3 += 2;
              break;
            case zt:
              ni.applyTransformToBezier(c2, l3, e3), e3 += 6;
          }
      }
      return i2.splice(s2, 4, Ut), a2.splice(s2, 4, o2), s2 + 1;
    });
    NullOptimizer = class {
      constructor(e2) {
        this.queue = e2;
      }
      _optimize() {
      }
      push(e2, t2) {
        this.queue.fnArray.push(e2), this.queue.argsArray.push(t2), this._optimize();
      }
      flush() {
      }
      reset() {
      }
    };
    __name(NullOptimizer, "NullOptimizer");
    QueueOptimizer = class extends NullOptimizer {
      constructor(e2) {
        super(e2), this.state = null, this.context = { iCurr: 0, fnArray: e2.fnArray, argsArray: e2.argsArray, isOffscreenCanvasSupported: OperatorList.isOffscreenCanvasSupported }, this.match = null, this.lastProcessed = 0;
      }
      _optimize() {
        const e2 = this.queue.fnArray;
        let t2 = this.lastProcessed, i2 = e2.length, a2 = this.state, n2 = this.match;
        if (!a2 && !n2 && t2 + 1 === i2 && !Bi[e2[t2]])
          return void (this.lastProcessed = i2);
        const s2 = this.context;
        for (; t2 < i2; ) {
          if (n2) {
            if ((0, n2.iterateFn)(s2, t2)) {
              t2++;
              continue;
            }
            if (t2 = (0, n2.processFn)(s2, t2 + 1), i2 = e2.length, n2 = null, a2 = null, t2 >= i2)
              break;
          }
          a2 = (a2 || Bi)[e2[t2]], a2 && !Array.isArray(a2) ? (s2.iCurr = t2, t2++, !a2.checkFn || (0, a2.checkFn)(s2) ? (n2 = a2, a2 = null) : a2 = null) : t2++;
        }
        this.state = a2, this.match = n2, this.lastProcessed = t2;
      }
      flush() {
        for (; this.match; ) {
          const e2 = this.queue.fnArray.length;
          this.lastProcessed = (0, this.match.processFn)(this.context, e2), this.match = null, this.state = null, this._optimize();
        }
      }
      reset() {
        this.state = null, this.match = null, this.lastProcessed = 0;
      }
    };
    __name(QueueOptimizer, "QueueOptimizer");
    _OperatorList = class {
      constructor(e2 = 0, t2) {
        this._streamSink = t2, this.fnArray = [], this.argsArray = [], this.optimizer = !t2 || e2 & u ? new NullOptimizer(this) : new QueueOptimizer(this), this.dependencies = /* @__PURE__ */ new Set(), this._totalLength = 0, this.weight = 0, this._resolved = t2 ? null : Promise.resolve();
      }
      static setOptions({ isOffscreenCanvasSupported: e2 }) {
        this.isOffscreenCanvasSupported = e2;
      }
      get length() {
        return this.argsArray.length;
      }
      get ready() {
        return this._resolved || this._streamSink.ready;
      }
      get totalLength() {
        return this._totalLength + this.length;
      }
      addOp(e2, t2) {
        this.optimizer.push(e2, t2), this.weight++, this._streamSink && (this.weight >= _OperatorList.CHUNK_SIZE || this.weight >= _OperatorList.CHUNK_SIZE_ABOUT && (e2 === me || e2 === Ne)) && this.flush();
      }
      addImageOps(e2, t2, i2, a2 = false) {
        a2 && (this.addOp(fe), this.addOp(pe, [[["SMask", false]]])), void 0 !== i2 && this.addOp(xt, ["OC", i2]), this.addOp(e2, t2), void 0 !== i2 && this.addOp(St, []), a2 && this.addOp(me);
      }
      addDependency(e2) {
        this.dependencies.has(e2) || (this.dependencies.add(e2), this.addOp(re, [e2]));
      }
      addDependencies(e2) {
        for (const t2 of e2)
          this.addDependency(t2);
      }
      addOpList(e2) {
        if (e2 instanceof _OperatorList) {
          for (const t2 of e2.dependencies)
            this.dependencies.add(t2);
          for (let t2 = 0, i2 = e2.length; t2 < i2; t2++)
            this.addOp(e2.fnArray[t2], e2.argsArray[t2]);
        } else
          warn$1('addOpList - ignoring invalid "opList" parameter.');
      }
      getIR() {
        return { fnArray: this.fnArray, argsArray: this.argsArray, length: this.length };
      }
      get _transfers() {
        const e2 = [], { fnArray: t2, argsArray: i2, length: a2 } = this;
        for (let n2 = 0; n2 < a2; n2++)
          switch (t2[n2]) {
            case Pt:
            case Rt:
            case Et: {
              const { bitmap: t4, data: a4 } = i2[n2][0];
              (t4 || a4?.buffer) && e2.push(t4 || a4.buffer);
              break;
            }
            case Ut: {
              const [, [t4], a4] = i2[n2];
              t4 && e2.push(t4.buffer, a4.buffer);
              break;
            }
            case kt:
              const [t3, a3] = i2[n2];
              t3 && e2.push(t3.buffer), a3 && e2.push(a3.buffer);
              break;
            case Ge:
              e2.push(i2[n2][0].buffer);
          }
        return e2;
      }
      flush(e2 = false, t2 = null) {
        this.optimizer.flush();
        const i2 = this.length;
        this._totalLength += i2, this._streamSink.enqueue({ fnArray: this.fnArray, argsArray: this.argsArray, lastChunk: e2, separateAnnots: t2, length: i2 }, 1, this._transfers), this.dependencies.clear(), this.fnArray.length = 0, this.argsArray.length = 0, this.weight = 0, this.optimizer.reset();
      }
    };
    OperatorList = _OperatorList;
    __name(OperatorList, "OperatorList");
    __publicField(OperatorList, "CHUNK_SIZE", 1e3);
    __publicField(OperatorList, "CHUNK_SIZE_ABOUT", _OperatorList.CHUNK_SIZE - 5);
    __publicField(OperatorList, "isOffscreenCanvasSupported", false);
    __name(hexToInt, "hexToInt");
    __name(hexToStr, "hexToStr");
    __name(addHex, "addHex");
    __name(incHex, "incHex");
    Ni = 16;
    BinaryCMapStream = class {
      constructor(e2) {
        this.buffer = e2, this.pos = 0, this.end = e2.length, this.tmpBuf = new Uint8Array(19);
      }
      readByte() {
        return this.pos >= this.end ? -1 : this.buffer[this.pos++];
      }
      readNumber() {
        let e2, t2 = 0;
        do {
          const i2 = this.readByte();
          if (i2 < 0)
            throw new ti("unexpected EOF in bcmap");
          e2 = !(128 & i2), t2 = t2 << 7 | 127 & i2;
        } while (!e2);
        return t2;
      }
      readSigned() {
        const e2 = this.readNumber();
        return 1 & e2 ? ~(e2 >>> 1) : e2 >>> 1;
      }
      readHex(e2, t2) {
        e2.set(this.buffer.subarray(this.pos, this.pos + t2 + 1)), this.pos += t2 + 1;
      }
      readHexNumber(e2, t2) {
        let i2;
        const a2 = this.tmpBuf;
        let n2 = 0;
        do {
          const e3 = this.readByte();
          if (e3 < 0)
            throw new ti("unexpected EOF in bcmap");
          i2 = !(128 & e3), a2[n2++] = 127 & e3;
        } while (!i2);
        let s2 = t2, r2 = 0, o2 = 0;
        for (; s2 >= 0; ) {
          for (; o2 < 8 && a2.length > 0; )
            r2 |= a2[--n2] << o2, o2 += 7;
          e2[s2] = 255 & r2, s2--, r2 >>= 8, o2 -= 8;
        }
      }
      readHexSigned(e2, t2) {
        this.readHexNumber(e2, t2);
        const i2 = 1 & e2[t2] ? 255 : 0;
        let a2 = 0;
        for (let n2 = 0; n2 <= t2; n2++)
          a2 = (1 & a2) << 8 | e2[n2], e2[n2] = a2 >> 1 ^ i2;
      }
      readString() {
        const e2 = this.readNumber(), t2 = new Array(e2);
        for (let i2 = 0; i2 < e2; i2++)
          t2[i2] = this.readNumber();
        return String.fromCharCode(...t2);
      }
    };
    __name(BinaryCMapStream, "BinaryCMapStream");
    BinaryCMapReader = class {
      async process(e2, t2, i2) {
        const a2 = new BinaryCMapStream(e2), n2 = a2.readByte();
        t2.vertical = !!(1 & n2);
        let s2 = null;
        const r2 = new Uint8Array(Ni), o2 = new Uint8Array(Ni), l3 = new Uint8Array(Ni), c2 = new Uint8Array(Ni), h2 = new Uint8Array(Ni);
        let d2, u2;
        for (; (u2 = a2.readByte()) >= 0; ) {
          const e3 = u2 >> 5;
          if (7 === e3) {
            switch (31 & u2) {
              case 0:
                a2.readString();
                break;
              case 1:
                s2 = a2.readString();
            }
            continue;
          }
          const i3 = !!(16 & u2), n3 = 15 & u2;
          if (n3 + 1 > Ni)
            throw new Error("BinaryCMapReader.process: Invalid dataSize.");
          const g2 = 1, p2 = a2.readNumber();
          switch (e3) {
            case 0:
              a2.readHex(r2, n3), a2.readHexNumber(o2, n3), addHex(o2, r2, n3), t2.addCodespaceRange(n3 + 1, hexToInt(r2, n3), hexToInt(o2, n3));
              for (let e4 = 1; e4 < p2; e4++)
                incHex(o2, n3), a2.readHexNumber(r2, n3), addHex(r2, o2, n3), a2.readHexNumber(o2, n3), addHex(o2, r2, n3), t2.addCodespaceRange(n3 + 1, hexToInt(r2, n3), hexToInt(o2, n3));
              break;
            case 1:
              a2.readHex(r2, n3), a2.readHexNumber(o2, n3), addHex(o2, r2, n3), a2.readNumber();
              for (let e4 = 1; e4 < p2; e4++)
                incHex(o2, n3), a2.readHexNumber(r2, n3), addHex(r2, o2, n3), a2.readHexNumber(o2, n3), addHex(o2, r2, n3), a2.readNumber();
              break;
            case 2:
              a2.readHex(l3, n3), d2 = a2.readNumber(), t2.mapOne(hexToInt(l3, n3), d2);
              for (let e4 = 1; e4 < p2; e4++)
                incHex(l3, n3), i3 || (a2.readHexNumber(h2, n3), addHex(l3, h2, n3)), d2 = a2.readSigned() + (d2 + 1), t2.mapOne(hexToInt(l3, n3), d2);
              break;
            case 3:
              a2.readHex(r2, n3), a2.readHexNumber(o2, n3), addHex(o2, r2, n3), d2 = a2.readNumber(), t2.mapCidRange(hexToInt(r2, n3), hexToInt(o2, n3), d2);
              for (let e4 = 1; e4 < p2; e4++)
                incHex(o2, n3), i3 ? r2.set(o2) : (a2.readHexNumber(r2, n3), addHex(r2, o2, n3)), a2.readHexNumber(o2, n3), addHex(o2, r2, n3), d2 = a2.readNumber(), t2.mapCidRange(hexToInt(r2, n3), hexToInt(o2, n3), d2);
              break;
            case 4:
              a2.readHex(l3, g2), a2.readHex(c2, n3), t2.mapOne(hexToInt(l3, g2), hexToStr(c2, n3));
              for (let e4 = 1; e4 < p2; e4++)
                incHex(l3, g2), i3 || (a2.readHexNumber(h2, g2), addHex(l3, h2, g2)), incHex(c2, n3), a2.readHexSigned(h2, n3), addHex(c2, h2, n3), t2.mapOne(hexToInt(l3, g2), hexToStr(c2, n3));
              break;
            case 5:
              a2.readHex(r2, g2), a2.readHexNumber(o2, g2), addHex(o2, r2, g2), a2.readHex(c2, n3), t2.mapBfRange(hexToInt(r2, g2), hexToInt(o2, g2), hexToStr(c2, n3));
              for (let e4 = 1; e4 < p2; e4++)
                incHex(o2, g2), i3 ? r2.set(o2) : (a2.readHexNumber(r2, g2), addHex(r2, o2, g2)), a2.readHexNumber(o2, g2), addHex(o2, r2, g2), a2.readHex(c2, n3), t2.mapBfRange(hexToInt(r2, g2), hexToInt(o2, g2), hexToStr(c2, n3));
              break;
            default:
              throw new Error(`BinaryCMapReader.process - unknown type: ${e3}`);
          }
        }
        return s2 ? i2(s2) : t2;
      }
    };
    __name(BinaryCMapReader, "BinaryCMapReader");
    Ascii85Stream = class extends DecodeStream {
      constructor(e2, t2) {
        t2 && (t2 *= 0.8), super(t2), this.str = e2, this.dict = e2.dict, this.input = new Uint8Array(5);
      }
      readBlock() {
        const e2 = this.str;
        let t2 = e2.getByte();
        for (; isWhiteSpace(t2); )
          t2 = e2.getByte();
        if (-1 === t2 || 126 === t2)
          return void (this.eof = true);
        const i2 = this.bufferLength;
        let a2, n2;
        if (122 === t2) {
          for (a2 = this.ensureBuffer(i2 + 4), n2 = 0; n2 < 4; ++n2)
            a2[i2 + n2] = 0;
          this.bufferLength += 4;
        } else {
          const s2 = this.input;
          for (s2[0] = t2, n2 = 1; n2 < 5; ++n2) {
            for (t2 = e2.getByte(); isWhiteSpace(t2); )
              t2 = e2.getByte();
            if (s2[n2] = t2, -1 === t2 || 126 === t2)
              break;
          }
          if (a2 = this.ensureBuffer(i2 + n2 - 1), this.bufferLength += n2 - 1, n2 < 5) {
            for (; n2 < 5; ++n2)
              s2[n2] = 117;
            this.eof = true;
          }
          let r2 = 0;
          for (n2 = 0; n2 < 5; ++n2)
            r2 = 85 * r2 + (s2[n2] - 33);
          for (n2 = 3; n2 >= 0; --n2)
            a2[i2 + n2] = 255 & r2, r2 >>= 8;
        }
      }
    };
    __name(Ascii85Stream, "Ascii85Stream");
    AsciiHexStream = class extends DecodeStream {
      constructor(e2, t2) {
        t2 && (t2 *= 0.5), super(t2), this.str = e2, this.dict = e2.dict, this.firstDigit = -1;
      }
      readBlock() {
        const e2 = this.str.getBytes(8e3);
        if (!e2.length)
          return void (this.eof = true);
        const t2 = e2.length + 1 >> 1, i2 = this.ensureBuffer(this.bufferLength + t2);
        let a2 = this.bufferLength, n2 = this.firstDigit;
        for (const t3 of e2) {
          let e3;
          if (t3 >= 48 && t3 <= 57)
            e3 = 15 & t3;
          else {
            if (!(t3 >= 65 && t3 <= 70 || t3 >= 97 && t3 <= 102)) {
              if (62 === t3) {
                this.eof = true;
                break;
              }
              continue;
            }
            e3 = 9 + (15 & t3);
          }
          n2 < 0 ? n2 = e3 : (i2[a2++] = n2 << 4 | e3, n2 = -1);
        }
        n2 >= 0 && this.eof && (i2[a2++] = n2 << 4, n2 = -1), this.firstDigit = n2, this.bufferLength = a2;
      }
    };
    __name(AsciiHexStream, "AsciiHexStream");
    ji = -1;
    $i = [[-1, -1], [-1, -1], [7, 8], [7, 7], [6, 6], [6, 6], [6, 5], [6, 5], [4, 0], [4, 0], [4, 0], [4, 0], [4, 0], [4, 0], [4, 0], [4, 0], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2]];
    Hi = [[-1, -1], [12, -2], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [11, 1792], [11, 1792], [12, 1984], [12, 2048], [12, 2112], [12, 2176], [12, 2240], [12, 2304], [11, 1856], [11, 1856], [11, 1920], [11, 1920], [12, 2368], [12, 2432], [12, 2496], [12, 2560]];
    qi = [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [8, 29], [8, 29], [8, 30], [8, 30], [8, 45], [8, 45], [8, 46], [8, 46], [7, 22], [7, 22], [7, 22], [7, 22], [7, 23], [7, 23], [7, 23], [7, 23], [8, 47], [8, 47], [8, 48], [8, 48], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [7, 20], [7, 20], [7, 20], [7, 20], [8, 33], [8, 33], [8, 34], [8, 34], [8, 35], [8, 35], [8, 36], [8, 36], [8, 37], [8, 37], [8, 38], [8, 38], [7, 19], [7, 19], [7, 19], [7, 19], [8, 31], [8, 31], [8, 32], [8, 32], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [8, 53], [8, 53], [8, 54], [8, 54], [7, 26], [7, 26], [7, 26], [7, 26], [8, 39], [8, 39], [8, 40], [8, 40], [8, 41], [8, 41], [8, 42], [8, 42], [8, 43], [8, 43], [8, 44], [8, 44], [7, 21], [7, 21], [7, 21], [7, 21], [7, 28], [7, 28], [7, 28], [7, 28], [8, 61], [8, 61], [8, 62], [8, 62], [8, 63], [8, 63], [8, 0], [8, 0], [8, 320], [8, 320], [8, 384], [8, 384], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [7, 27], [7, 27], [7, 27], [7, 27], [8, 59], [8, 59], [8, 60], [8, 60], [9, 1472], [9, 1536], [9, 1600], [9, 1728], [7, 18], [7, 18], [7, 18], [7, 18], [7, 24], [7, 24], [7, 24], [7, 24], [8, 49], [8, 49], [8, 50], [8, 50], [8, 51], [8, 51], [8, 52], [8, 52], [7, 25], [7, 25], [7, 25], [7, 25], [8, 55], [8, 55], [8, 56], [8, 56], [8, 57], [8, 57], [8, 58], [8, 58], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [8, 448], [8, 448], [8, 512], [8, 512], [9, 704], [9, 768], [8, 640], [8, 640], [8, 576], [8, 576], [9, 832], [9, 896], [9, 960], [9, 1024], [9, 1088], [9, 1152], [9, 1216], [9, 1280], [9, 1344], [9, 1408], [7, 256], [7, 256], [7, 256], [7, 256], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7]];
    Xi = [[-1, -1], [-1, -1], [12, -2], [12, -2], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [11, 1792], [11, 1792], [11, 1792], [11, 1792], [12, 1984], [12, 1984], [12, 2048], [12, 2048], [12, 2112], [12, 2112], [12, 2176], [12, 2176], [12, 2240], [12, 2240], [12, 2304], [12, 2304], [11, 1856], [11, 1856], [11, 1856], [11, 1856], [11, 1920], [11, 1920], [11, 1920], [11, 1920], [12, 2368], [12, 2368], [12, 2432], [12, 2432], [12, 2496], [12, 2496], [12, 2560], [12, 2560], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [12, 52], [12, 52], [13, 640], [13, 704], [13, 768], [13, 832], [12, 55], [12, 55], [12, 56], [12, 56], [13, 1280], [13, 1344], [13, 1408], [13, 1472], [12, 59], [12, 59], [12, 60], [12, 60], [13, 1536], [13, 1600], [11, 24], [11, 24], [11, 24], [11, 24], [11, 25], [11, 25], [11, 25], [11, 25], [13, 1664], [13, 1728], [12, 320], [12, 320], [12, 384], [12, 384], [12, 448], [12, 448], [13, 512], [13, 576], [12, 53], [12, 53], [12, 54], [12, 54], [13, 896], [13, 960], [13, 1024], [13, 1088], [13, 1152], [13, 1216], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64]];
    zi = [[8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [11, 23], [11, 23], [12, 50], [12, 51], [12, 44], [12, 45], [12, 46], [12, 47], [12, 57], [12, 58], [12, 61], [12, 256], [10, 16], [10, 16], [10, 16], [10, 16], [10, 17], [10, 17], [10, 17], [10, 17], [12, 48], [12, 49], [12, 62], [12, 63], [12, 30], [12, 31], [12, 32], [12, 33], [12, 40], [12, 41], [11, 22], [11, 22], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [12, 128], [12, 192], [12, 26], [12, 27], [12, 28], [12, 29], [11, 19], [11, 19], [11, 20], [11, 20], [12, 34], [12, 35], [12, 36], [12, 37], [12, 38], [12, 39], [11, 21], [11, 21], [12, 42], [12, 43], [10, 0], [10, 0], [10, 0], [10, 0], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12]];
    Wi = [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [6, 9], [6, 8], [5, 7], [5, 7], [4, 6], [4, 6], [4, 6], [4, 6], [4, 5], [4, 5], [4, 5], [4, 5], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2]];
    CCITTFaxDecoder = class {
      constructor(e2, t2 = {}) {
        if ("function" != typeof e2?.next)
          throw new Error('CCITTFaxDecoder - invalid "source" parameter.');
        let i2;
        for (this.source = e2, this.eof = false, this.encoding = t2.K || 0, this.eoline = t2.EndOfLine || false, this.byteAlign = t2.EncodedByteAlign || false, this.columns = t2.Columns || 1728, this.rows = t2.Rows || 0, this.eoblock = t2.EndOfBlock ?? true, this.black = t2.BlackIs1 || false, this.codingLine = new Uint32Array(this.columns + 1), this.refLine = new Uint32Array(this.columns + 2), this.codingLine[0] = this.columns, this.codingPos = 0, this.row = 0, this.nextLine2D = this.encoding < 0, this.inputBits = 0, this.inputBuf = 0, this.outputBits = 0, this.rowsDone = false; 0 === (i2 = this._lookBits(12)); )
          this._eatBits(1);
        1 === i2 && this._eatBits(12), this.encoding > 0 && (this.nextLine2D = !this._lookBits(1), this._eatBits(1));
      }
      readNextChar() {
        if (this.eof)
          return -1;
        const e2 = this.refLine, t2 = this.codingLine, i2 = this.columns;
        let a2, n2, s2, r2, o2;
        if (0 === this.outputBits) {
          if (this.rowsDone && (this.eof = true), this.eof)
            return -1;
          let s3, o3, l3;
          if (this.err = false, this.nextLine2D) {
            for (r2 = 0; t2[r2] < i2; ++r2)
              e2[r2] = t2[r2];
            for (e2[r2++] = i2, e2[r2] = i2, t2[0] = 0, this.codingPos = 0, a2 = 0, n2 = 0; t2[this.codingPos] < i2; )
              switch (s3 = this._getTwoDimCode(), s3) {
                case 0:
                  this._addPixels(e2[a2 + 1], n2), e2[a2 + 1] < i2 && (a2 += 2);
                  break;
                case 1:
                  if (s3 = o3 = 0, n2) {
                    do {
                      s3 += l3 = this._getBlackCode();
                    } while (l3 >= 64);
                    do {
                      o3 += l3 = this._getWhiteCode();
                    } while (l3 >= 64);
                  } else {
                    do {
                      s3 += l3 = this._getWhiteCode();
                    } while (l3 >= 64);
                    do {
                      o3 += l3 = this._getBlackCode();
                    } while (l3 >= 64);
                  }
                  for (this._addPixels(t2[this.codingPos] + s3, n2), t2[this.codingPos] < i2 && this._addPixels(t2[this.codingPos] + o3, 1 ^ n2); e2[a2] <= t2[this.codingPos] && e2[a2] < i2; )
                    a2 += 2;
                  break;
                case 7:
                  if (this._addPixels(e2[a2] + 3, n2), n2 ^= 1, t2[this.codingPos] < i2)
                    for (++a2; e2[a2] <= t2[this.codingPos] && e2[a2] < i2; )
                      a2 += 2;
                  break;
                case 5:
                  if (this._addPixels(e2[a2] + 2, n2), n2 ^= 1, t2[this.codingPos] < i2)
                    for (++a2; e2[a2] <= t2[this.codingPos] && e2[a2] < i2; )
                      a2 += 2;
                  break;
                case 3:
                  if (this._addPixels(e2[a2] + 1, n2), n2 ^= 1, t2[this.codingPos] < i2)
                    for (++a2; e2[a2] <= t2[this.codingPos] && e2[a2] < i2; )
                      a2 += 2;
                  break;
                case 2:
                  if (this._addPixels(e2[a2], n2), n2 ^= 1, t2[this.codingPos] < i2)
                    for (++a2; e2[a2] <= t2[this.codingPos] && e2[a2] < i2; )
                      a2 += 2;
                  break;
                case 8:
                  if (this._addPixelsNeg(e2[a2] - 3, n2), n2 ^= 1, t2[this.codingPos] < i2)
                    for (a2 > 0 ? --a2 : ++a2; e2[a2] <= t2[this.codingPos] && e2[a2] < i2; )
                      a2 += 2;
                  break;
                case 6:
                  if (this._addPixelsNeg(e2[a2] - 2, n2), n2 ^= 1, t2[this.codingPos] < i2)
                    for (a2 > 0 ? --a2 : ++a2; e2[a2] <= t2[this.codingPos] && e2[a2] < i2; )
                      a2 += 2;
                  break;
                case 4:
                  if (this._addPixelsNeg(e2[a2] - 1, n2), n2 ^= 1, t2[this.codingPos] < i2)
                    for (a2 > 0 ? --a2 : ++a2; e2[a2] <= t2[this.codingPos] && e2[a2] < i2; )
                      a2 += 2;
                  break;
                case ji:
                  this._addPixels(i2, 0), this.eof = true;
                  break;
                default:
                  info$1("bad 2d code"), this._addPixels(i2, 0), this.err = true;
              }
          } else
            for (t2[0] = 0, this.codingPos = 0, n2 = 0; t2[this.codingPos] < i2; ) {
              if (s3 = 0, n2)
                do {
                  s3 += l3 = this._getBlackCode();
                } while (l3 >= 64);
              else
                do {
                  s3 += l3 = this._getWhiteCode();
                } while (l3 >= 64);
              this._addPixels(t2[this.codingPos] + s3, n2), n2 ^= 1;
            }
          let c2 = false;
          if (this.byteAlign && (this.inputBits &= -8), this.eoblock || this.row !== this.rows - 1) {
            if (s3 = this._lookBits(12), this.eoline)
              for (; s3 !== ji && 1 !== s3; )
                this._eatBits(1), s3 = this._lookBits(12);
            else
              for (; 0 === s3; )
                this._eatBits(1), s3 = this._lookBits(12);
            1 === s3 ? (this._eatBits(12), c2 = true) : s3 === ji && (this.eof = true);
          } else
            this.rowsDone = true;
          if (!this.eof && this.encoding > 0 && !this.rowsDone && (this.nextLine2D = !this._lookBits(1), this._eatBits(1)), this.eoblock && c2 && this.byteAlign) {
            if (s3 = this._lookBits(12), 1 === s3) {
              if (this._eatBits(12), this.encoding > 0 && (this._lookBits(1), this._eatBits(1)), this.encoding >= 0)
                for (r2 = 0; r2 < 4; ++r2)
                  s3 = this._lookBits(12), 1 !== s3 && info$1("bad rtc code: " + s3), this._eatBits(12), this.encoding > 0 && (this._lookBits(1), this._eatBits(1));
              this.eof = true;
            }
          } else if (this.err && this.eoline) {
            for (; ; ) {
              if (s3 = this._lookBits(13), s3 === ji)
                return this.eof = true, -1;
              if (s3 >> 1 == 1)
                break;
              this._eatBits(1);
            }
            this._eatBits(12), this.encoding > 0 && (this._eatBits(1), this.nextLine2D = !(1 & s3));
          }
          this.outputBits = t2[0] > 0 ? t2[this.codingPos = 0] : t2[this.codingPos = 1], this.row++;
        }
        if (this.outputBits >= 8)
          o2 = 1 & this.codingPos ? 0 : 255, this.outputBits -= 8, 0 === this.outputBits && t2[this.codingPos] < i2 && (this.codingPos++, this.outputBits = t2[this.codingPos] - t2[this.codingPos - 1]);
        else {
          s2 = 8, o2 = 0;
          do {
            if ("number" != typeof this.outputBits)
              throw new ti('Invalid /CCITTFaxDecode data, "outputBits" must be a number.');
            this.outputBits > s2 ? (o2 <<= s2, 1 & this.codingPos || (o2 |= 255 >> 8 - s2), this.outputBits -= s2, s2 = 0) : (o2 <<= this.outputBits, 1 & this.codingPos || (o2 |= 255 >> 8 - this.outputBits), s2 -= this.outputBits, this.outputBits = 0, t2[this.codingPos] < i2 ? (this.codingPos++, this.outputBits = t2[this.codingPos] - t2[this.codingPos - 1]) : s2 > 0 && (o2 <<= s2, s2 = 0));
          } while (s2);
        }
        return this.black && (o2 ^= 255), o2;
      }
      _addPixels(e2, t2) {
        const i2 = this.codingLine;
        let a2 = this.codingPos;
        e2 > i2[a2] && (e2 > this.columns && (info$1("row is wrong length"), this.err = true, e2 = this.columns), 1 & a2 ^ t2 && ++a2, i2[a2] = e2), this.codingPos = a2;
      }
      _addPixelsNeg(e2, t2) {
        const i2 = this.codingLine;
        let a2 = this.codingPos;
        if (e2 > i2[a2])
          e2 > this.columns && (info$1("row is wrong length"), this.err = true, e2 = this.columns), 1 & a2 ^ t2 && ++a2, i2[a2] = e2;
        else if (e2 < i2[a2]) {
          for (e2 < 0 && (info$1("invalid code"), this.err = true, e2 = 0); a2 > 0 && e2 < i2[a2 - 1]; )
            --a2;
          i2[a2] = e2;
        }
        this.codingPos = a2;
      }
      _findTableCode(e2, t2, i2, a2) {
        const n2 = a2 || 0;
        for (let a3 = e2; a3 <= t2; ++a3) {
          let e3 = this._lookBits(a3);
          if (e3 === ji)
            return [true, 1, false];
          if (a3 < t2 && (e3 <<= t2 - a3), !n2 || e3 >= n2) {
            const t3 = i2[e3 - n2];
            if (t3[0] === a3)
              return this._eatBits(a3), [true, t3[1], true];
          }
        }
        return [false, 0, false];
      }
      _getTwoDimCode() {
        let e2, t2 = 0;
        if (this.eoblock) {
          if (t2 = this._lookBits(7), e2 = $i[t2], e2?.[0] > 0)
            return this._eatBits(e2[0]), e2[1];
        } else {
          const e3 = this._findTableCode(1, 7, $i);
          if (e3[0] && e3[2])
            return e3[1];
        }
        return info$1("Bad two dim code"), ji;
      }
      _getWhiteCode() {
        let e2, t2 = 0;
        if (this.eoblock) {
          if (t2 = this._lookBits(12), t2 === ji)
            return 1;
          if (e2 = t2 >> 5 ? qi[t2 >> 3] : Hi[t2], e2[0] > 0)
            return this._eatBits(e2[0]), e2[1];
        } else {
          let e3 = this._findTableCode(1, 9, qi);
          if (e3[0])
            return e3[1];
          if (e3 = this._findTableCode(11, 12, Hi), e3[0])
            return e3[1];
        }
        return info$1("bad white code"), this._eatBits(1), 1;
      }
      _getBlackCode() {
        let e2, t2;
        if (this.eoblock) {
          if (e2 = this._lookBits(13), e2 === ji)
            return 1;
          if (t2 = e2 >> 7 ? !(e2 >> 9) && e2 >> 7 ? zi[(e2 >> 1) - 64] : Wi[e2 >> 7] : Xi[e2], t2[0] > 0)
            return this._eatBits(t2[0]), t2[1];
        } else {
          let e3 = this._findTableCode(2, 6, Wi);
          if (e3[0])
            return e3[1];
          if (e3 = this._findTableCode(7, 12, zi, 64), e3[0])
            return e3[1];
          if (e3 = this._findTableCode(10, 13, Xi), e3[0])
            return e3[1];
        }
        return info$1("bad black code"), this._eatBits(1), 1;
      }
      _lookBits(e2) {
        let t2;
        for (; this.inputBits < e2; ) {
          if (-1 === (t2 = this.source.next()))
            return 0 === this.inputBits ? ji : this.inputBuf << e2 - this.inputBits & 65535 >> 16 - e2;
          this.inputBuf = this.inputBuf << 8 | t2, this.inputBits += 8;
        }
        return this.inputBuf >> this.inputBits - e2 & 65535 >> 16 - e2;
      }
      _eatBits(e2) {
        (this.inputBits -= e2) < 0 && (this.inputBits = 0);
      }
    };
    __name(CCITTFaxDecoder, "CCITTFaxDecoder");
    CCITTFaxStream = class extends DecodeStream {
      constructor(e2, t2, i2) {
        super(t2), this.str = e2, this.dict = e2.dict, i2 instanceof Dict || (i2 = Dict.empty);
        const a2 = { next: () => e2.getByte() };
        this.ccittFaxDecoder = new CCITTFaxDecoder(a2, { K: i2.get("K"), EndOfLine: i2.get("EndOfLine"), EncodedByteAlign: i2.get("EncodedByteAlign"), Columns: i2.get("Columns"), Rows: i2.get("Rows"), EndOfBlock: i2.get("EndOfBlock"), BlackIs1: i2.get("BlackIs1") });
      }
      readBlock() {
        for (; !this.eof; ) {
          const e2 = this.ccittFaxDecoder.readNextChar();
          if (-1 === e2)
            return void (this.eof = true);
          this.ensureBuffer(this.bufferLength + 1), this.buffer[this.bufferLength++] = e2;
        }
      }
    };
    __name(CCITTFaxStream, "CCITTFaxStream");
    Gi = new Int32Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
    Vi = new Int32Array([3, 4, 5, 6, 7, 8, 9, 10, 65547, 65549, 65551, 65553, 131091, 131095, 131099, 131103, 196643, 196651, 196659, 196667, 262211, 262227, 262243, 262259, 327811, 327843, 327875, 327907, 258, 258, 258]);
    Ki = new Int32Array([1, 2, 3, 4, 65541, 65543, 131081, 131085, 196625, 196633, 262177, 262193, 327745, 327777, 393345, 393409, 459009, 459137, 524801, 525057, 590849, 591361, 657409, 658433, 724993, 727041, 794625, 798721, 868353, 876545]);
    Yi = [new Int32Array([459008, 524368, 524304, 524568, 459024, 524400, 524336, 590016, 459016, 524384, 524320, 589984, 524288, 524416, 524352, 590048, 459012, 524376, 524312, 589968, 459028, 524408, 524344, 590032, 459020, 524392, 524328, 59e4, 524296, 524424, 524360, 590064, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590024, 459018, 524388, 524324, 589992, 524292, 524420, 524356, 590056, 459014, 524380, 524316, 589976, 459030, 524412, 524348, 590040, 459022, 524396, 524332, 590008, 524300, 524428, 524364, 590072, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590020, 459017, 524386, 524322, 589988, 524290, 524418, 524354, 590052, 459013, 524378, 524314, 589972, 459029, 524410, 524346, 590036, 459021, 524394, 524330, 590004, 524298, 524426, 524362, 590068, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590028, 459019, 524390, 524326, 589996, 524294, 524422, 524358, 590060, 459015, 524382, 524318, 589980, 459031, 524414, 524350, 590044, 459023, 524398, 524334, 590012, 524302, 524430, 524366, 590076, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590018, 459016, 524385, 524321, 589986, 524289, 524417, 524353, 590050, 459012, 524377, 524313, 589970, 459028, 524409, 524345, 590034, 459020, 524393, 524329, 590002, 524297, 524425, 524361, 590066, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590026, 459018, 524389, 524325, 589994, 524293, 524421, 524357, 590058, 459014, 524381, 524317, 589978, 459030, 524413, 524349, 590042, 459022, 524397, 524333, 590010, 524301, 524429, 524365, 590074, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590022, 459017, 524387, 524323, 589990, 524291, 524419, 524355, 590054, 459013, 524379, 524315, 589974, 459029, 524411, 524347, 590038, 459021, 524395, 524331, 590006, 524299, 524427, 524363, 590070, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590030, 459019, 524391, 524327, 589998, 524295, 524423, 524359, 590062, 459015, 524383, 524319, 589982, 459031, 524415, 524351, 590046, 459023, 524399, 524335, 590014, 524303, 524431, 524367, 590078, 459008, 524368, 524304, 524568, 459024, 524400, 524336, 590017, 459016, 524384, 524320, 589985, 524288, 524416, 524352, 590049, 459012, 524376, 524312, 589969, 459028, 524408, 524344, 590033, 459020, 524392, 524328, 590001, 524296, 524424, 524360, 590065, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590025, 459018, 524388, 524324, 589993, 524292, 524420, 524356, 590057, 459014, 524380, 524316, 589977, 459030, 524412, 524348, 590041, 459022, 524396, 524332, 590009, 524300, 524428, 524364, 590073, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590021, 459017, 524386, 524322, 589989, 524290, 524418, 524354, 590053, 459013, 524378, 524314, 589973, 459029, 524410, 524346, 590037, 459021, 524394, 524330, 590005, 524298, 524426, 524362, 590069, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590029, 459019, 524390, 524326, 589997, 524294, 524422, 524358, 590061, 459015, 524382, 524318, 589981, 459031, 524414, 524350, 590045, 459023, 524398, 524334, 590013, 524302, 524430, 524366, 590077, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590019, 459016, 524385, 524321, 589987, 524289, 524417, 524353, 590051, 459012, 524377, 524313, 589971, 459028, 524409, 524345, 590035, 459020, 524393, 524329, 590003, 524297, 524425, 524361, 590067, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590027, 459018, 524389, 524325, 589995, 524293, 524421, 524357, 590059, 459014, 524381, 524317, 589979, 459030, 524413, 524349, 590043, 459022, 524397, 524333, 590011, 524301, 524429, 524365, 590075, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590023, 459017, 524387, 524323, 589991, 524291, 524419, 524355, 590055, 459013, 524379, 524315, 589975, 459029, 524411, 524347, 590039, 459021, 524395, 524331, 590007, 524299, 524427, 524363, 590071, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590031, 459019, 524391, 524327, 589999, 524295, 524423, 524359, 590063, 459015, 524383, 524319, 589983, 459031, 524415, 524351, 590047, 459023, 524399, 524335, 590015, 524303, 524431, 524367, 590079]), 9];
    Ji = [new Int32Array([327680, 327696, 327688, 327704, 327684, 327700, 327692, 327708, 327682, 327698, 327690, 327706, 327686, 327702, 327694, 0, 327681, 327697, 327689, 327705, 327685, 327701, 327693, 327709, 327683, 327699, 327691, 327707, 327687, 327703, 327695, 0]), 5];
    FlateStream = class extends DecodeStream {
      constructor(e2, t2) {
        super(t2), this.str = e2, this.dict = e2.dict;
        const i2 = e2.getByte(), a2 = e2.getByte();
        if (-1 === i2 || -1 === a2)
          throw new ti(`Invalid header in flate stream: ${i2}, ${a2}`);
        if (8 != (15 & i2))
          throw new ti(`Unknown compression method in flate stream: ${i2}, ${a2}`);
        if (((i2 << 8) + a2) % 31 != 0)
          throw new ti(`Bad FCHECK in flate stream: ${i2}, ${a2}`);
        if (32 & a2)
          throw new ti(`FDICT bit set in flate stream: ${i2}, ${a2}`);
        this.codeSize = 0, this.codeBuf = 0;
      }
      async getImageData(e2, t2) {
        const i2 = await this.asyncGetBytes();
        return i2 ? i2.length <= e2 ? i2 : i2.subarray(0, e2) : this.getBytes(e2);
      }
      async asyncGetBytes() {
        this.str.reset();
        const e2 = this.str.getBytes();
        try {
          const { readable: t2, writable: i2 } = new DecompressionStream("deflate"), a2 = i2.getWriter();
          await a2.ready, a2.write(e2).then(async () => {
            await a2.ready, await a2.close();
          }).catch(() => {
          });
          const n2 = [];
          let s2 = 0;
          for await (const e3 of t2)
            n2.push(e3), s2 += e3.byteLength;
          const r2 = new Uint8Array(s2);
          let o2 = 0;
          for (const e3 of n2)
            r2.set(e3, o2), o2 += e3.byteLength;
          return r2;
        } catch {
          return this.str = new Stream(e2, 2, e2.length, this.str.dict), this.reset(), null;
        }
      }
      get isAsync() {
        return true;
      }
      getBits(e2) {
        const t2 = this.str;
        let i2, a2 = this.codeSize, n2 = this.codeBuf;
        for (; a2 < e2; ) {
          if (-1 === (i2 = t2.getByte()))
            throw new ti("Bad encoding in flate stream");
          n2 |= i2 << a2, a2 += 8;
        }
        return i2 = n2 & (1 << e2) - 1, this.codeBuf = n2 >> e2, this.codeSize = a2 -= e2, i2;
      }
      getCode(e2) {
        const t2 = this.str, i2 = e2[0], a2 = e2[1];
        let n2, s2 = this.codeSize, r2 = this.codeBuf;
        for (; s2 < a2 && -1 !== (n2 = t2.getByte()); )
          r2 |= n2 << s2, s2 += 8;
        const o2 = i2[r2 & (1 << a2) - 1], l3 = o2 >> 16, c2 = 65535 & o2;
        if (l3 < 1 || s2 < l3)
          throw new ti("Bad encoding in flate stream");
        return this.codeBuf = r2 >> l3, this.codeSize = s2 - l3, c2;
      }
      generateHuffmanTable(e2) {
        const t2 = e2.length;
        let i2, a2 = 0;
        for (i2 = 0; i2 < t2; ++i2)
          e2[i2] > a2 && (a2 = e2[i2]);
        const n2 = 1 << a2, s2 = new Int32Array(n2);
        for (let r2 = 1, o2 = 0, l3 = 2; r2 <= a2; ++r2, o2 <<= 1, l3 <<= 1)
          for (let a3 = 0; a3 < t2; ++a3)
            if (e2[a3] === r2) {
              let e3 = 0, t3 = o2;
              for (i2 = 0; i2 < r2; ++i2)
                e3 = e3 << 1 | 1 & t3, t3 >>= 1;
              for (i2 = e3; i2 < n2; i2 += l3)
                s2[i2] = r2 << 16 | a3;
              ++o2;
            }
        return [s2, a2];
      }
      #$(e2) {
        info$1(e2), this.eof = true;
      }
      readBlock() {
        let e2, t2, i2;
        const a2 = this.str;
        try {
          t2 = this.getBits(3);
        } catch (e3) {
          return void this.#$(e3.message);
        }
        if (1 & t2 && (this.eof = true), t2 >>= 1, 0 === t2) {
          let t3;
          if (-1 === (t3 = a2.getByte()))
            return void this.#$("Bad block header in flate stream");
          let i3 = t3;
          if (-1 === (t3 = a2.getByte()))
            return void this.#$("Bad block header in flate stream");
          if (i3 |= t3 << 8, -1 === (t3 = a2.getByte()))
            return void this.#$("Bad block header in flate stream");
          let n3 = t3;
          if (-1 === (t3 = a2.getByte()))
            return void this.#$("Bad block header in flate stream");
          if (n3 |= t3 << 8, n3 !== (65535 & ~i3) && (0 !== i3 || 0 !== n3))
            throw new ti("Bad uncompressed block length in flate stream");
          this.codeBuf = 0, this.codeSize = 0;
          const s3 = this.bufferLength, r3 = s3 + i3;
          if (e2 = this.ensureBuffer(r3), this.bufferLength = r3, 0 === i3)
            -1 === a2.peekByte() && (this.eof = true);
          else {
            const t4 = a2.getBytes(i3);
            e2.set(t4, s3), t4.length < i3 && (this.eof = true);
          }
          return;
        }
        let n2, s2;
        if (1 === t2)
          n2 = Yi, s2 = Ji;
        else {
          if (2 !== t2)
            throw new ti("Unknown block type in flate stream");
          {
            const e3 = this.getBits(5) + 257, t3 = this.getBits(5) + 1, a3 = this.getBits(4) + 4, r3 = new Uint8Array(Gi.length);
            let o3;
            for (o3 = 0; o3 < a3; ++o3)
              r3[Gi[o3]] = this.getBits(3);
            const l3 = this.generateHuffmanTable(r3);
            i2 = 0, o3 = 0;
            const c2 = e3 + t3, h2 = new Uint8Array(c2);
            let d2, u2, g2;
            for (; o3 < c2; ) {
              const e4 = this.getCode(l3);
              if (16 === e4)
                d2 = 2, u2 = 3, g2 = i2;
              else if (17 === e4)
                d2 = 3, u2 = 3, g2 = i2 = 0;
              else {
                if (18 !== e4) {
                  h2[o3++] = i2 = e4;
                  continue;
                }
                d2 = 7, u2 = 11, g2 = i2 = 0;
              }
              let t4 = this.getBits(d2) + u2;
              for (; t4-- > 0; )
                h2[o3++] = g2;
            }
            n2 = this.generateHuffmanTable(h2.subarray(0, e3)), s2 = this.generateHuffmanTable(h2.subarray(e3, c2));
          }
        }
        e2 = this.buffer;
        let r2 = e2 ? e2.length : 0, o2 = this.bufferLength;
        for (; ; ) {
          let t3 = this.getCode(n2);
          if (t3 < 256) {
            o2 + 1 >= r2 && (e2 = this.ensureBuffer(o2 + 1), r2 = e2.length), e2[o2++] = t3;
            continue;
          }
          if (256 === t3)
            return void (this.bufferLength = o2);
          t3 -= 257, t3 = Vi[t3];
          let a3 = t3 >> 16;
          a3 > 0 && (a3 = this.getBits(a3)), i2 = (65535 & t3) + a3, t3 = this.getCode(s2), t3 = Ki[t3], a3 = t3 >> 16, a3 > 0 && (a3 = this.getBits(a3));
          const l3 = (65535 & t3) + a3;
          o2 + i2 >= r2 && (e2 = this.ensureBuffer(o2 + i2), r2 = e2.length);
          for (let t4 = 0; t4 < i2; ++t4, ++o2)
            e2[o2] = e2[o2 - l3];
        }
      }
    };
    __name(FlateStream, "FlateStream");
    Zi = [{ qe: 22017, nmps: 1, nlps: 1, switchFlag: 1 }, { qe: 13313, nmps: 2, nlps: 6, switchFlag: 0 }, { qe: 6145, nmps: 3, nlps: 9, switchFlag: 0 }, { qe: 2753, nmps: 4, nlps: 12, switchFlag: 0 }, { qe: 1313, nmps: 5, nlps: 29, switchFlag: 0 }, { qe: 545, nmps: 38, nlps: 33, switchFlag: 0 }, { qe: 22017, nmps: 7, nlps: 6, switchFlag: 1 }, { qe: 21505, nmps: 8, nlps: 14, switchFlag: 0 }, { qe: 18433, nmps: 9, nlps: 14, switchFlag: 0 }, { qe: 14337, nmps: 10, nlps: 14, switchFlag: 0 }, { qe: 12289, nmps: 11, nlps: 17, switchFlag: 0 }, { qe: 9217, nmps: 12, nlps: 18, switchFlag: 0 }, { qe: 7169, nmps: 13, nlps: 20, switchFlag: 0 }, { qe: 5633, nmps: 29, nlps: 21, switchFlag: 0 }, { qe: 22017, nmps: 15, nlps: 14, switchFlag: 1 }, { qe: 21505, nmps: 16, nlps: 14, switchFlag: 0 }, { qe: 20737, nmps: 17, nlps: 15, switchFlag: 0 }, { qe: 18433, nmps: 18, nlps: 16, switchFlag: 0 }, { qe: 14337, nmps: 19, nlps: 17, switchFlag: 0 }, { qe: 13313, nmps: 20, nlps: 18, switchFlag: 0 }, { qe: 12289, nmps: 21, nlps: 19, switchFlag: 0 }, { qe: 10241, nmps: 22, nlps: 19, switchFlag: 0 }, { qe: 9217, nmps: 23, nlps: 20, switchFlag: 0 }, { qe: 8705, nmps: 24, nlps: 21, switchFlag: 0 }, { qe: 7169, nmps: 25, nlps: 22, switchFlag: 0 }, { qe: 6145, nmps: 26, nlps: 23, switchFlag: 0 }, { qe: 5633, nmps: 27, nlps: 24, switchFlag: 0 }, { qe: 5121, nmps: 28, nlps: 25, switchFlag: 0 }, { qe: 4609, nmps: 29, nlps: 26, switchFlag: 0 }, { qe: 4353, nmps: 30, nlps: 27, switchFlag: 0 }, { qe: 2753, nmps: 31, nlps: 28, switchFlag: 0 }, { qe: 2497, nmps: 32, nlps: 29, switchFlag: 0 }, { qe: 2209, nmps: 33, nlps: 30, switchFlag: 0 }, { qe: 1313, nmps: 34, nlps: 31, switchFlag: 0 }, { qe: 1089, nmps: 35, nlps: 32, switchFlag: 0 }, { qe: 673, nmps: 36, nlps: 33, switchFlag: 0 }, { qe: 545, nmps: 37, nlps: 34, switchFlag: 0 }, { qe: 321, nmps: 38, nlps: 35, switchFlag: 0 }, { qe: 273, nmps: 39, nlps: 36, switchFlag: 0 }, { qe: 133, nmps: 40, nlps: 37, switchFlag: 0 }, { qe: 73, nmps: 41, nlps: 38, switchFlag: 0 }, { qe: 37, nmps: 42, nlps: 39, switchFlag: 0 }, { qe: 21, nmps: 43, nlps: 40, switchFlag: 0 }, { qe: 9, nmps: 44, nlps: 41, switchFlag: 0 }, { qe: 5, nmps: 45, nlps: 42, switchFlag: 0 }, { qe: 1, nmps: 45, nlps: 43, switchFlag: 0 }, { qe: 22017, nmps: 46, nlps: 46, switchFlag: 0 }];
    ArithmeticDecoder = class {
      constructor(e2, t2, i2) {
        this.data = e2, this.bp = t2, this.dataEnd = i2, this.chigh = e2[t2], this.clow = 0, this.byteIn(), this.chigh = this.chigh << 7 & 65535 | this.clow >> 9 & 127, this.clow = this.clow << 7 & 65535, this.ct -= 7, this.a = 32768;
      }
      byteIn() {
        const e2 = this.data;
        let t2 = this.bp;
        255 === e2[t2] ? e2[t2 + 1] > 143 ? (this.clow += 65280, this.ct = 8) : (t2++, this.clow += e2[t2] << 9, this.ct = 7, this.bp = t2) : (t2++, this.clow += t2 < this.dataEnd ? e2[t2] << 8 : 65280, this.ct = 8, this.bp = t2), this.clow > 65535 && (this.chigh += this.clow >> 16, this.clow &= 65535);
      }
      readBit(e2, t2) {
        let i2 = e2[t2] >> 1, a2 = 1 & e2[t2];
        const n2 = Zi[i2], s2 = n2.qe;
        let r2, o2 = this.a - s2;
        if (this.chigh < s2)
          o2 < s2 ? (o2 = s2, r2 = a2, i2 = n2.nmps) : (o2 = s2, r2 = 1 ^ a2, 1 === n2.switchFlag && (a2 = r2), i2 = n2.nlps);
        else {
          if (this.chigh -= s2, 32768 & o2)
            return this.a = o2, a2;
          o2 < s2 ? (r2 = 1 ^ a2, 1 === n2.switchFlag && (a2 = r2), i2 = n2.nlps) : (r2 = a2, i2 = n2.nmps);
        }
        do {
          0 === this.ct && this.byteIn(), o2 <<= 1, this.chigh = this.chigh << 1 & 65535 | this.clow >> 15 & 1, this.clow = this.clow << 1 & 65535, this.ct--;
        } while (!(32768 & o2));
        return this.a = o2, e2[t2] = i2 << 1 | a2, r2;
      }
    };
    __name(ArithmeticDecoder, "ArithmeticDecoder");
    Jbig2Error = class extends Yt {
      constructor(e2) {
        super(e2, "Jbig2Error");
      }
    };
    __name(Jbig2Error, "Jbig2Error");
    ContextCache = class {
      getContexts(e2) {
        return e2 in this ? this[e2] : this[e2] = new Int8Array(65536);
      }
    };
    __name(ContextCache, "ContextCache");
    DecodingContext = class {
      constructor(e2, t2, i2) {
        this.data = e2, this.start = t2, this.end = i2;
      }
      get decoder() {
        return shadow$1(this, "decoder", new ArithmeticDecoder(this.data, this.start, this.end));
      }
      get contextCache() {
        return shadow$1(this, "contextCache", new ContextCache());
      }
    };
    __name(DecodingContext, "DecodingContext");
    __name(decodeInteger, "decodeInteger");
    __name(decodeIAID, "decodeIAID");
    Qi = ["SymbolDictionary", null, null, null, "IntermediateTextRegion", null, "ImmediateTextRegion", "ImmediateLosslessTextRegion", null, null, null, null, null, null, null, null, "PatternDictionary", null, null, null, "IntermediateHalftoneRegion", null, "ImmediateHalftoneRegion", "ImmediateLosslessHalftoneRegion", null, null, null, null, null, null, null, null, null, null, null, null, "IntermediateGenericRegion", null, "ImmediateGenericRegion", "ImmediateLosslessGenericRegion", "IntermediateGenericRefinementRegion", null, "ImmediateGenericRefinementRegion", "ImmediateLosslessGenericRefinementRegion", null, null, null, null, "PageInformation", "EndOfPage", "EndOfStripe", "EndOfFile", "Profiles", "Tables", null, null, null, null, null, null, null, null, "Extension"];
    ea = [[{ x: -1, y: -2 }, { x: 0, y: -2 }, { x: 1, y: -2 }, { x: -2, y: -1 }, { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: 2, y: -1 }, { x: -4, y: 0 }, { x: -3, y: 0 }, { x: -2, y: 0 }, { x: -1, y: 0 }], [{ x: -1, y: -2 }, { x: 0, y: -2 }, { x: 1, y: -2 }, { x: 2, y: -2 }, { x: -2, y: -1 }, { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: 2, y: -1 }, { x: -3, y: 0 }, { x: -2, y: 0 }, { x: -1, y: 0 }], [{ x: -1, y: -2 }, { x: 0, y: -2 }, { x: 1, y: -2 }, { x: -2, y: -1 }, { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: -2, y: 0 }, { x: -1, y: 0 }], [{ x: -3, y: -1 }, { x: -2, y: -1 }, { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: -4, y: 0 }, { x: -3, y: 0 }, { x: -2, y: 0 }, { x: -1, y: 0 }]];
    ta = [{ coding: [{ x: 0, y: -1 }, { x: 1, y: -1 }, { x: -1, y: 0 }], reference: [{ x: 0, y: -1 }, { x: 1, y: -1 }, { x: -1, y: 0 }, { x: 0, y: 0 }, { x: 1, y: 0 }, { x: -1, y: 1 }, { x: 0, y: 1 }, { x: 1, y: 1 }] }, { coding: [{ x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: -1, y: 0 }], reference: [{ x: 0, y: -1 }, { x: -1, y: 0 }, { x: 0, y: 0 }, { x: 1, y: 0 }, { x: 0, y: 1 }, { x: 1, y: 1 }] }];
    ia = [39717, 1941, 229, 405];
    __name(decodeBitmap, "decodeBitmap");
    __name(decodeRefinement, "decodeRefinement");
    __name(decodeTextRegion, "decodeTextRegion");
    __name(readSegmentHeader, "readSegmentHeader");
    __name(readSegments, "readSegments");
    __name(readRegionSegmentInformation, "readRegionSegmentInformation");
    aa = 17;
    __name(processSegment, "processSegment");
    __name(processSegments, "processSegments");
    SimpleSegmentVisitor = class {
      onPageInformation(e2) {
        this.currentPageInfo = e2;
        const t2 = e2.width + 7 >> 3, i2 = new Uint8ClampedArray(t2 * e2.height);
        e2.defaultPixelValue && i2.fill(255), this.buffer = i2;
      }
      drawBitmap(e2, t2) {
        const i2 = this.currentPageInfo, a2 = e2.width, n2 = e2.height, s2 = i2.width + 7 >> 3, r2 = i2.combinationOperatorOverride ? e2.combinationOperator : i2.combinationOperator, o2 = this.buffer, l3 = 128 >> (7 & e2.x);
        let c2, h2, d2, u2, g2 = e2.y * s2 + (e2.x >> 3);
        switch (r2) {
          case 0:
            for (c2 = 0; c2 < n2; c2++) {
              for (d2 = l3, u2 = g2, h2 = 0; h2 < a2; h2++)
                t2[c2][h2] && (o2[u2] |= d2), d2 >>= 1, d2 || (d2 = 128, u2++);
              g2 += s2;
            }
            break;
          case 2:
            for (c2 = 0; c2 < n2; c2++) {
              for (d2 = l3, u2 = g2, h2 = 0; h2 < a2; h2++)
                t2[c2][h2] && (o2[u2] ^= d2), d2 >>= 1, d2 || (d2 = 128, u2++);
              g2 += s2;
            }
            break;
          default:
            throw new Jbig2Error(`operator ${r2} is not supported`);
        }
      }
      onImmediateGenericRegion(e2, t2, i2, a2) {
        const n2 = e2.info, s2 = new DecodingContext(t2, i2, a2), r2 = decodeBitmap(e2.mmr, n2.width, n2.height, e2.template, e2.prediction, 0, e2.at, s2);
        this.drawBitmap(n2, r2);
      }
      onImmediateLosslessGenericRegion() {
        this.onImmediateGenericRegion(...arguments);
      }
      onSymbolDictionary(e2, t2, i2, a2, n2, s2) {
        let r2, o2;
        e2.huffman && (r2 = function(e3, t3, i3) {
          let a3, n3, s3, r3, o3 = 0;
          switch (e3.huffmanDHSelector) {
            case 0:
            case 1:
              a3 = getStandardTable(e3.huffmanDHSelector + 4);
              break;
            case 3:
              a3 = getCustomHuffmanTable(o3, t3, i3), o3++;
              break;
            default:
              throw new Jbig2Error("invalid Huffman DH selector");
          }
          switch (e3.huffmanDWSelector) {
            case 0:
            case 1:
              n3 = getStandardTable(e3.huffmanDWSelector + 2);
              break;
            case 3:
              n3 = getCustomHuffmanTable(o3, t3, i3), o3++;
              break;
            default:
              throw new Jbig2Error("invalid Huffman DW selector");
          }
          e3.bitmapSizeSelector ? (s3 = getCustomHuffmanTable(o3, t3, i3), o3++) : s3 = getStandardTable(1);
          r3 = e3.aggregationInstancesSelector ? getCustomHuffmanTable(o3, t3, i3) : getStandardTable(1);
          return { tableDeltaHeight: a3, tableDeltaWidth: n3, tableBitmapSize: s3, tableAggregateInstances: r3 };
        }(e2, i2, this.customTables), o2 = new Reader(a2, n2, s2));
        let l3 = this.symbols;
        l3 || (this.symbols = l3 = {});
        const c2 = [];
        for (const e3 of i2) {
          const t3 = l3[e3];
          t3 && c2.push(...t3);
        }
        const h2 = new DecodingContext(a2, n2, s2);
        l3[t2] = function(e3, t3, i3, a3, n3, s3, r3, o3, l4, c3, h3, d2) {
          if (e3 && t3)
            throw new Jbig2Error("symbol refinement with Huffman is not supported");
          const u2 = [];
          let g2 = 0, p2 = log22(i3.length + a3);
          const f2 = h3.decoder, m2 = h3.contextCache;
          let b2, y2;
          for (e3 && (b2 = getStandardTable(1), y2 = [], p2 = Math.max(p2, 1)); u2.length < a3; ) {
            g2 += e3 ? s3.tableDeltaHeight.decode(d2) : decodeInteger(m2, "IADH", f2);
            let a4 = 0, n4 = 0;
            const b3 = e3 ? y2.length : 0;
            for (; ; ) {
              const b4 = e3 ? s3.tableDeltaWidth.decode(d2) : decodeInteger(m2, "IADW", f2);
              if (null === b4)
                break;
              let w3;
              if (a4 += b4, n4 += a4, t3) {
                const n5 = decodeInteger(m2, "IAAI", f2);
                if (n5 > 1)
                  w3 = decodeTextRegion(e3, t3, a4, g2, 0, n5, 1, i3.concat(u2), p2, 0, 0, 1, 0, s3, l4, c3, h3, 0, d2);
                else {
                  const e4 = decodeIAID(m2, f2, p2), t4 = decodeInteger(m2, "IARDX", f2), n6 = decodeInteger(m2, "IARDY", f2);
                  w3 = decodeRefinement(a4, g2, l4, e4 < i3.length ? i3[e4] : u2[e4 - i3.length], t4, n6, 0, c3, h3);
                }
                u2.push(w3);
              } else
                e3 ? y2.push(a4) : (w3 = decodeBitmap(false, a4, g2, r3, false, 0, o3, h3), u2.push(w3));
            }
            if (e3 && !t3) {
              const e4 = s3.tableBitmapSize.decode(d2);
              let t4;
              if (d2.byteAlign(), 0 === e4)
                t4 = readUncompressedBitmap(d2, n4, g2);
              else {
                const i5 = d2.end, a5 = d2.position + e4;
                d2.end = a5, t4 = decodeMMRBitmap(d2, n4, g2, false), d2.end = i5, d2.position = a5;
              }
              const i4 = y2.length;
              if (b3 === i4 - 1)
                u2.push(t4);
              else {
                let e5, a5, n5, s4, r4, o4 = 0;
                for (e5 = b3; e5 < i4; e5++) {
                  for (s4 = y2[e5], n5 = o4 + s4, r4 = [], a5 = 0; a5 < g2; a5++)
                    r4.push(t4[a5].subarray(o4, n5));
                  u2.push(r4), o4 = n5;
                }
              }
            }
          }
          const w2 = [], x2 = [];
          let S2, v2, C2 = false;
          const k2 = i3.length + a3;
          for (; x2.length < k2; ) {
            let t4 = e3 ? b2.decode(d2) : decodeInteger(m2, "IAEX", f2);
            for (; t4--; )
              x2.push(C2);
            C2 = !C2;
          }
          for (S2 = 0, v2 = i3.length; S2 < v2; S2++)
            x2[S2] && w2.push(i3[S2]);
          for (let e4 = 0; e4 < a3; S2++, e4++)
            x2[S2] && w2.push(u2[e4]);
          return w2;
        }(e2.huffman, e2.refinement, c2, e2.numberOfNewSymbols, e2.numberOfExportedSymbols, r2, e2.template, e2.at, e2.refinementTemplate, e2.refinementAt, h2, o2);
      }
      onImmediateTextRegion(e2, t2, i2, a2, n2) {
        const s2 = e2.info;
        let r2, o2;
        const l3 = this.symbols, c2 = [];
        for (const e3 of t2) {
          const t3 = l3[e3];
          t3 && c2.push(...t3);
        }
        const h2 = log22(c2.length);
        e2.huffman && (o2 = new Reader(i2, a2, n2), r2 = function(e3, t3, i3, a3, n3) {
          const s3 = [];
          for (let e4 = 0; e4 <= 34; e4++) {
            const t4 = n3.readBits(4);
            s3.push(new HuffmanLine([e4, t4, 0, 0]));
          }
          const r3 = new HuffmanTable(s3, false);
          s3.length = 0;
          for (let e4 = 0; e4 < a3; ) {
            const t4 = r3.decode(n3);
            if (t4 >= 32) {
              let i4, a4, r4;
              switch (t4) {
                case 32:
                  if (0 === e4)
                    throw new Jbig2Error("no previous value in symbol ID table");
                  a4 = n3.readBits(2) + 3, i4 = s3[e4 - 1].prefixLength;
                  break;
                case 33:
                  a4 = n3.readBits(3) + 3, i4 = 0;
                  break;
                case 34:
                  a4 = n3.readBits(7) + 11, i4 = 0;
                  break;
                default:
                  throw new Jbig2Error("invalid code length in symbol ID table");
              }
              for (r4 = 0; r4 < a4; r4++)
                s3.push(new HuffmanLine([e4, i4, 0, 0])), e4++;
            } else
              s3.push(new HuffmanLine([e4, t4, 0, 0])), e4++;
          }
          n3.byteAlign();
          const o3 = new HuffmanTable(s3, false);
          let l4, c3, h3, d3 = 0;
          switch (e3.huffmanFS) {
            case 0:
            case 1:
              l4 = getStandardTable(e3.huffmanFS + 6);
              break;
            case 3:
              l4 = getCustomHuffmanTable(d3, t3, i3), d3++;
              break;
            default:
              throw new Jbig2Error("invalid Huffman FS selector");
          }
          switch (e3.huffmanDS) {
            case 0:
            case 1:
            case 2:
              c3 = getStandardTable(e3.huffmanDS + 8);
              break;
            case 3:
              c3 = getCustomHuffmanTable(d3, t3, i3), d3++;
              break;
            default:
              throw new Jbig2Error("invalid Huffman DS selector");
          }
          switch (e3.huffmanDT) {
            case 0:
            case 1:
            case 2:
              h3 = getStandardTable(e3.huffmanDT + 11);
              break;
            case 3:
              h3 = getCustomHuffmanTable(d3, t3, i3), d3++;
              break;
            default:
              throw new Jbig2Error("invalid Huffman DT selector");
          }
          if (e3.refinement)
            throw new Jbig2Error("refinement with Huffman is not supported");
          return { symbolIDTable: o3, tableFirstS: l4, tableDeltaS: c3, tableDeltaT: h3 };
        }(e2, t2, this.customTables, c2.length, o2));
        const d2 = new DecodingContext(i2, a2, n2), u2 = decodeTextRegion(e2.huffman, e2.refinement, s2.width, s2.height, e2.defaultPixelValue, e2.numberOfSymbolInstances, e2.stripSize, c2, h2, e2.transposed, e2.dsOffset, e2.referenceCorner, e2.combinationOperator, r2, e2.refinementTemplate, e2.refinementAt, d2, e2.logStripSize, o2);
        this.drawBitmap(s2, u2);
      }
      onImmediateLosslessTextRegion() {
        this.onImmediateTextRegion(...arguments);
      }
      onPatternDictionary(e2, t2, i2, a2, n2) {
        let s2 = this.patterns;
        s2 || (this.patterns = s2 = {});
        const r2 = new DecodingContext(i2, a2, n2);
        s2[t2] = function(e3, t3, i3, a3, n3, s3) {
          const r3 = [];
          e3 || (r3.push({ x: -t3, y: 0 }), 0 === n3 && r3.push({ x: -3, y: -1 }, { x: 2, y: -2 }, { x: -2, y: -2 }));
          const o2 = decodeBitmap(e3, (a3 + 1) * t3, i3, n3, false, 0, r3, s3), l3 = [];
          for (let e4 = 0; e4 <= a3; e4++) {
            const a4 = [], n4 = t3 * e4, s4 = n4 + t3;
            for (let e5 = 0; e5 < i3; e5++)
              a4.push(o2[e5].subarray(n4, s4));
            l3.push(a4);
          }
          return l3;
        }(e2.mmr, e2.patternWidth, e2.patternHeight, e2.maxPatternIndex, e2.template, r2);
      }
      onImmediateHalftoneRegion(e2, t2, i2, a2, n2) {
        const s2 = this.patterns[t2[0]], r2 = e2.info, o2 = new DecodingContext(i2, a2, n2), l3 = function(e3, t3, i3, a3, n3, s3, r3, o3, l4, c2, h2, d2, u2, g2, p2) {
          if (r3)
            throw new Jbig2Error("skip is not supported");
          if (0 !== o3)
            throw new Jbig2Error(`operator "${o3}" is not supported in halftone region`);
          const f2 = [];
          let m2, b2, y2;
          for (m2 = 0; m2 < n3; m2++)
            y2 = new Uint8Array(a3), s3 && y2.fill(s3), f2.push(y2);
          const w2 = t3.length, x2 = t3[0], S2 = x2[0].length, v2 = x2.length, C2 = log22(w2), k2 = [];
          e3 || (k2.push({ x: i3 <= 1 ? 3 : 2, y: -1 }), 0 === i3 && k2.push({ x: -3, y: -1 }, { x: 2, y: -2 }, { x: -2, y: -2 }));
          const T2 = [];
          let F2, M2, D2, E2, O2, _2, R2, N2, L2, U2, j2;
          for (e3 && (F2 = new Reader(p2.data, p2.start, p2.end)), m2 = C2 - 1; m2 >= 0; m2--)
            M2 = e3 ? decodeMMRBitmap(F2, l4, c2, true) : decodeBitmap(false, l4, c2, i3, false, 0, k2, p2), T2[m2] = M2;
          for (D2 = 0; D2 < c2; D2++)
            for (E2 = 0; E2 < l4; E2++) {
              for (O2 = 0, _2 = 0, b2 = C2 - 1; b2 >= 0; b2--)
                O2 ^= T2[b2][D2][E2], _2 |= O2 << b2;
              if (R2 = t3[_2], N2 = h2 + D2 * g2 + E2 * u2 >> 8, L2 = d2 + D2 * u2 - E2 * g2 >> 8, N2 >= 0 && N2 + S2 <= a3 && L2 >= 0 && L2 + v2 <= n3)
                for (m2 = 0; m2 < v2; m2++)
                  for (j2 = f2[L2 + m2], U2 = R2[m2], b2 = 0; b2 < S2; b2++)
                    j2[N2 + b2] |= U2[b2];
              else {
                let e4, t4;
                for (m2 = 0; m2 < v2; m2++)
                  if (t4 = L2 + m2, !(t4 < 0 || t4 >= n3))
                    for (j2 = f2[t4], U2 = R2[m2], b2 = 0; b2 < S2; b2++)
                      e4 = N2 + b2, e4 >= 0 && e4 < a3 && (j2[e4] |= U2[b2]);
              }
            }
          return f2;
        }(e2.mmr, s2, e2.template, r2.width, r2.height, e2.defaultPixelValue, e2.enableSkip, e2.combinationOperator, e2.gridWidth, e2.gridHeight, e2.gridOffsetX, e2.gridOffsetY, e2.gridVectorX, e2.gridVectorY, o2);
        this.drawBitmap(r2, l3);
      }
      onImmediateLosslessHalftoneRegion() {
        this.onImmediateHalftoneRegion(...arguments);
      }
      onTables(e2, t2, i2, a2) {
        let n2 = this.customTables;
        n2 || (this.customTables = n2 = {}), n2[e2] = function(e3, t3, i3) {
          const a3 = e3[t3], n3 = 4294967295 & readUint32(e3, t3 + 1), s2 = 4294967295 & readUint32(e3, t3 + 5), r2 = new Reader(e3, t3 + 9, i3), o2 = 1 + (a3 >> 1 & 7), l3 = 1 + (a3 >> 4 & 7), c2 = [];
          let h2, d2, u2 = n3;
          do {
            h2 = r2.readBits(o2), d2 = r2.readBits(l3), c2.push(new HuffmanLine([u2, h2, d2, 0])), u2 += 1 << d2;
          } while (u2 < s2);
          h2 = r2.readBits(o2), c2.push(new HuffmanLine([n3 - 1, h2, 32, 0, "lower"])), h2 = r2.readBits(o2), c2.push(new HuffmanLine([s2, h2, 32, 0])), 1 & a3 && (h2 = r2.readBits(o2), c2.push(new HuffmanLine([h2, 0])));
          return new HuffmanTable(c2, false);
        }(t2, i2, a2);
      }
    };
    __name(SimpleSegmentVisitor, "SimpleSegmentVisitor");
    HuffmanLine = class {
      constructor(e2) {
        2 === e2.length ? (this.isOOB = true, this.rangeLow = 0, this.prefixLength = e2[0], this.rangeLength = 0, this.prefixCode = e2[1], this.isLowerRange = false) : (this.isOOB = false, this.rangeLow = e2[0], this.prefixLength = e2[1], this.rangeLength = e2[2], this.prefixCode = e2[3], this.isLowerRange = "lower" === e2[4]);
      }
    };
    __name(HuffmanLine, "HuffmanLine");
    HuffmanTreeNode = class {
      constructor(e2) {
        this.children = [], e2 ? (this.isLeaf = true, this.rangeLength = e2.rangeLength, this.rangeLow = e2.rangeLow, this.isLowerRange = e2.isLowerRange, this.isOOB = e2.isOOB) : this.isLeaf = false;
      }
      buildTree(e2, t2) {
        const i2 = e2.prefixCode >> t2 & 1;
        if (t2 <= 0)
          this.children[i2] = new HuffmanTreeNode(e2);
        else {
          let a2 = this.children[i2];
          a2 || (this.children[i2] = a2 = new HuffmanTreeNode(null)), a2.buildTree(e2, t2 - 1);
        }
      }
      decodeNode(e2) {
        if (this.isLeaf) {
          if (this.isOOB)
            return null;
          const t3 = e2.readBits(this.rangeLength);
          return this.rangeLow + (this.isLowerRange ? -t3 : t3);
        }
        const t2 = this.children[e2.readBit()];
        if (!t2)
          throw new Jbig2Error("invalid Huffman data");
        return t2.decodeNode(e2);
      }
    };
    __name(HuffmanTreeNode, "HuffmanTreeNode");
    HuffmanTable = class {
      constructor(e2, t2) {
        t2 || this.assignPrefixCodes(e2), this.rootNode = new HuffmanTreeNode(null);
        for (let t3 = 0, i2 = e2.length; t3 < i2; t3++) {
          const i3 = e2[t3];
          i3.prefixLength > 0 && this.rootNode.buildTree(i3, i3.prefixLength - 1);
        }
      }
      decode(e2) {
        return this.rootNode.decodeNode(e2);
      }
      assignPrefixCodes(e2) {
        const t2 = e2.length;
        let i2 = 0;
        for (let a3 = 0; a3 < t2; a3++)
          i2 = Math.max(i2, e2[a3].prefixLength);
        const a2 = new Uint32Array(i2 + 1);
        for (let i3 = 0; i3 < t2; i3++)
          a2[e2[i3].prefixLength]++;
        let n2, s2, r2, o2 = 1, l3 = 0;
        for (a2[0] = 0; o2 <= i2; ) {
          for (l3 = l3 + a2[o2 - 1] << 1, n2 = l3, s2 = 0; s2 < t2; )
            r2 = e2[s2], r2.prefixLength === o2 && (r2.prefixCode = n2, n2++), s2++;
          o2++;
        }
      }
    };
    __name(HuffmanTable, "HuffmanTable");
    na = {};
    __name(getStandardTable, "getStandardTable");
    Reader = class {
      constructor(e2, t2, i2) {
        this.data = e2, this.start = t2, this.end = i2, this.position = t2, this.shift = -1, this.currentByte = 0;
      }
      readBit() {
        if (this.shift < 0) {
          if (this.position >= this.end)
            throw new Jbig2Error("end of data while reading bit");
          this.currentByte = this.data[this.position++], this.shift = 7;
        }
        const e2 = this.currentByte >> this.shift & 1;
        return this.shift--, e2;
      }
      readBits(e2) {
        let t2, i2 = 0;
        for (t2 = e2 - 1; t2 >= 0; t2--)
          i2 |= this.readBit() << t2;
        return i2;
      }
      byteAlign() {
        this.shift = -1;
      }
      next() {
        return this.position >= this.end ? -1 : this.data[this.position++];
      }
    };
    __name(Reader, "Reader");
    __name(getCustomHuffmanTable, "getCustomHuffmanTable");
    __name(readUncompressedBitmap, "readUncompressedBitmap");
    __name(decodeMMRBitmap, "decodeMMRBitmap");
    Jbig2Image = class {
      parseChunks(e2) {
        return function(e3) {
          const t2 = new SimpleSegmentVisitor();
          for (let i2 = 0, a2 = e3.length; i2 < a2; i2++) {
            const a3 = e3[i2];
            processSegments(readSegments({}, a3.data, a3.start, a3.end), t2);
          }
          return t2.buffer;
        }(e2);
      }
      parse(e2) {
        throw new Error("Not implemented: Jbig2Image.parse");
      }
    };
    __name(Jbig2Image, "Jbig2Image");
    Jbig2Stream = class extends DecodeStream {
      constructor(e2, t2, i2) {
        super(t2), this.stream = e2, this.dict = e2.dict, this.maybeLength = t2, this.params = i2;
      }
      get bytes() {
        return shadow$1(this, "bytes", this.stream.getBytes(this.maybeLength));
      }
      ensureBuffer(e2) {
      }
      readBlock() {
        this.decodeImage();
      }
      decodeImage(e2) {
        if (this.eof)
          return this.buffer;
        e2 ||= this.bytes;
        const t2 = new Jbig2Image(), i2 = [];
        if (this.params instanceof Dict) {
          const e3 = this.params.get("JBIG2Globals");
          if (e3 instanceof BaseStream) {
            const t3 = e3.getBytes();
            i2.push({ data: t3, start: 0, end: t3.length });
          }
        }
        i2.push({ data: e2, start: 0, end: e2.length });
        const a2 = t2.parseChunks(i2), n2 = a2.length;
        for (let e3 = 0; e3 < n2; e3++)
          a2[e3] ^= 255;
        return this.buffer = a2, this.bufferLength = n2, this.eof = true, this.buffer;
      }
      get canAsyncDecodeImageFromBuffer() {
        return this.stream.isAsync;
      }
    };
    __name(Jbig2Stream, "Jbig2Stream");
    JpxStream = class extends DecodeStream {
      constructor(e2, t2, i2) {
        super(t2), this.stream = e2, this.dict = e2.dict, this.maybeLength = t2, this.params = i2;
      }
      get bytes() {
        return shadow$1(this, "bytes", this.stream.getBytes(this.maybeLength));
      }
      ensureBuffer(e2) {
      }
      readBlock(e2) {
        unreachable$1("JpxStream.readBlock");
      }
      get isAsyncDecoder() {
        return true;
      }
      async decodeImage(e2, t2) {
        return this.eof || (e2 ||= this.bytes, this.buffer = await JpxImage.decode(e2, t2), this.bufferLength = this.buffer.length, this.eof = true), this.buffer;
      }
      get canAsyncDecodeImageFromBuffer() {
        return this.stream.isAsync;
      }
    };
    __name(JpxStream, "JpxStream");
    LZWStream = class extends DecodeStream {
      constructor(e2, t2, i2) {
        super(t2), this.str = e2, this.dict = e2.dict, this.cachedData = 0, this.bitsCached = 0;
        const a2 = 4096, n2 = { earlyChange: i2, codeLength: 9, nextCode: 258, dictionaryValues: new Uint8Array(a2), dictionaryLengths: new Uint16Array(a2), dictionaryPrevCodes: new Uint16Array(a2), currentSequence: new Uint8Array(a2), currentSequenceLength: 0 };
        for (let e3 = 0; e3 < 256; ++e3)
          n2.dictionaryValues[e3] = e3, n2.dictionaryLengths[e3] = 1;
        this.lzwState = n2;
      }
      readBits(e2) {
        let t2 = this.bitsCached, i2 = this.cachedData;
        for (; t2 < e2; ) {
          const e3 = this.str.getByte();
          if (-1 === e3)
            return this.eof = true, null;
          i2 = i2 << 8 | e3, t2 += 8;
        }
        return this.bitsCached = t2 -= e2, this.cachedData = i2, this.lastCode = null, i2 >>> t2 & (1 << e2) - 1;
      }
      readBlock() {
        let e2, t2, i2, a2 = 1024;
        const n2 = this.lzwState;
        if (!n2)
          return;
        const s2 = n2.earlyChange;
        let r2 = n2.nextCode;
        const o2 = n2.dictionaryValues, l3 = n2.dictionaryLengths, c2 = n2.dictionaryPrevCodes;
        let h2 = n2.codeLength, d2 = n2.prevCode;
        const u2 = n2.currentSequence;
        let g2 = n2.currentSequenceLength, p2 = 0, f2 = this.bufferLength, m2 = this.ensureBuffer(this.bufferLength + a2);
        for (e2 = 0; e2 < 512; e2++) {
          const e3 = this.readBits(h2), n3 = g2 > 0;
          if (e3 < 256)
            u2[0] = e3, g2 = 1;
          else {
            if (!(e3 >= 258)) {
              if (256 === e3) {
                h2 = 9, r2 = 258, g2 = 0;
                continue;
              }
              this.eof = true, delete this.lzwState;
              break;
            }
            if (e3 < r2)
              for (g2 = l3[e3], t2 = g2 - 1, i2 = e3; t2 >= 0; t2--)
                u2[t2] = o2[i2], i2 = c2[i2];
            else
              u2[g2++] = u2[0];
          }
          if (n3 && (c2[r2] = d2, l3[r2] = l3[d2] + 1, o2[r2] = u2[0], r2++, h2 = r2 + s2 & r2 + s2 - 1 ? h2 : 0 | Math.min(Math.log(r2 + s2) / 0.6931471805599453 + 1, 12)), d2 = e3, p2 += g2, a2 < p2) {
            do {
              a2 += 512;
            } while (a2 < p2);
            m2 = this.ensureBuffer(this.bufferLength + a2);
          }
          for (t2 = 0; t2 < g2; t2++)
            m2[f2++] = u2[t2];
        }
        n2.nextCode = r2, n2.codeLength = h2, n2.prevCode = d2, n2.currentSequenceLength = g2, this.bufferLength = f2;
      }
    };
    __name(LZWStream, "LZWStream");
    PredictorStream = class extends DecodeStream {
      constructor(e2, t2, i2) {
        if (super(t2), !(i2 instanceof Dict))
          return e2;
        const a2 = this.predictor = i2.get("Predictor") || 1;
        if (a2 <= 1)
          return e2;
        if (2 !== a2 && (a2 < 10 || a2 > 15))
          throw new ti(`Unsupported predictor: ${a2}`);
        this.readBlock = 2 === a2 ? this.readBlockTiff : this.readBlockPng, this.str = e2, this.dict = e2.dict;
        const n2 = this.colors = i2.get("Colors") || 1, s2 = this.bits = i2.get("BPC", "BitsPerComponent") || 8, r2 = this.columns = i2.get("Columns") || 1;
        return this.pixBytes = n2 * s2 + 7 >> 3, this.rowBytes = r2 * n2 * s2 + 7 >> 3, this;
      }
      readBlockTiff() {
        const e2 = this.rowBytes, t2 = this.bufferLength, i2 = this.ensureBuffer(t2 + e2), a2 = this.bits, n2 = this.colors, s2 = this.str.getBytes(e2);
        if (this.eof = !s2.length, this.eof)
          return;
        let r2, o2 = 0, l3 = 0, c2 = 0, h2 = 0, d2 = t2;
        if (1 === a2 && 1 === n2)
          for (r2 = 0; r2 < e2; ++r2) {
            let e3 = s2[r2] ^ o2;
            e3 ^= e3 >> 1, e3 ^= e3 >> 2, e3 ^= e3 >> 4, o2 = (1 & e3) << 7, i2[d2++] = e3;
          }
        else if (8 === a2) {
          for (r2 = 0; r2 < n2; ++r2)
            i2[d2++] = s2[r2];
          for (; r2 < e2; ++r2)
            i2[d2] = i2[d2 - n2] + s2[r2], d2++;
        } else if (16 === a2) {
          const t3 = 2 * n2;
          for (r2 = 0; r2 < t3; ++r2)
            i2[d2++] = s2[r2];
          for (; r2 < e2; r2 += 2) {
            const e3 = ((255 & s2[r2]) << 8) + (255 & s2[r2 + 1]) + ((255 & i2[d2 - t3]) << 8) + (255 & i2[d2 - t3 + 1]);
            i2[d2++] = e3 >> 8 & 255, i2[d2++] = 255 & e3;
          }
        } else {
          const e3 = new Uint8Array(n2 + 1), d3 = (1 << a2) - 1;
          let u2 = 0, g2 = t2;
          const p2 = this.columns;
          for (r2 = 0; r2 < p2; ++r2)
            for (let t3 = 0; t3 < n2; ++t3)
              c2 < a2 && (o2 = o2 << 8 | 255 & s2[u2++], c2 += 8), e3[t3] = e3[t3] + (o2 >> c2 - a2) & d3, c2 -= a2, l3 = l3 << a2 | e3[t3], h2 += a2, h2 >= 8 && (i2[g2++] = l3 >> h2 - 8 & 255, h2 -= 8);
          h2 > 0 && (i2[g2++] = (l3 << 8 - h2) + (o2 & (1 << 8 - h2) - 1));
        }
        this.bufferLength += e2;
      }
      readBlockPng() {
        const e2 = this.rowBytes, t2 = this.pixBytes, i2 = this.str.getByte(), a2 = this.str.getBytes(e2);
        if (this.eof = !a2.length, this.eof)
          return;
        const n2 = this.bufferLength, s2 = this.ensureBuffer(n2 + e2);
        let r2 = s2.subarray(n2 - e2, n2);
        0 === r2.length && (r2 = new Uint8Array(e2));
        let o2, l3, c2, h2 = n2;
        switch (i2) {
          case 0:
            for (o2 = 0; o2 < e2; ++o2)
              s2[h2++] = a2[o2];
            break;
          case 1:
            for (o2 = 0; o2 < t2; ++o2)
              s2[h2++] = a2[o2];
            for (; o2 < e2; ++o2)
              s2[h2] = s2[h2 - t2] + a2[o2] & 255, h2++;
            break;
          case 2:
            for (o2 = 0; o2 < e2; ++o2)
              s2[h2++] = r2[o2] + a2[o2] & 255;
            break;
          case 3:
            for (o2 = 0; o2 < t2; ++o2)
              s2[h2++] = (r2[o2] >> 1) + a2[o2];
            for (; o2 < e2; ++o2)
              s2[h2] = (r2[o2] + s2[h2 - t2] >> 1) + a2[o2] & 255, h2++;
            break;
          case 4:
            for (o2 = 0; o2 < t2; ++o2)
              l3 = r2[o2], c2 = a2[o2], s2[h2++] = l3 + c2;
            for (; o2 < e2; ++o2) {
              l3 = r2[o2];
              const e3 = r2[o2 - t2], i3 = s2[h2 - t2], n3 = i3 + l3 - e3;
              let d2 = n3 - i3;
              d2 < 0 && (d2 = -d2);
              let u2 = n3 - l3;
              u2 < 0 && (u2 = -u2);
              let g2 = n3 - e3;
              g2 < 0 && (g2 = -g2), c2 = a2[o2], s2[h2++] = d2 <= u2 && d2 <= g2 ? i3 + c2 : u2 <= g2 ? l3 + c2 : e3 + c2;
            }
            break;
          default:
            throw new ti(`Unsupported predictor: ${i2}`);
        }
        this.bufferLength += e2;
      }
    };
    __name(PredictorStream, "PredictorStream");
    RunLengthStream = class extends DecodeStream {
      constructor(e2, t2) {
        super(t2), this.str = e2, this.dict = e2.dict;
      }
      readBlock() {
        const e2 = this.str.getBytes(2);
        if (!e2 || e2.length < 2 || 128 === e2[0])
          return void (this.eof = true);
        let t2, i2 = this.bufferLength, a2 = e2[0];
        if (a2 < 128) {
          if (t2 = this.ensureBuffer(i2 + a2 + 1), t2[i2++] = e2[1], a2 > 0) {
            const e3 = this.str.getBytes(a2);
            t2.set(e3, i2), i2 += a2;
          }
        } else
          a2 = 257 - a2, t2 = this.ensureBuffer(i2 + a2 + 1), t2.fill(e2[1], i2, i2 + a2), i2 += a2;
        this.bufferLength = i2;
      }
    };
    __name(RunLengthStream, "RunLengthStream");
    Parser = class {
      constructor({ lexer: e2, xref: t2, allowStreams: i2 = false, recoveryMode: a2 = false }) {
        this.lexer = e2, this.xref = t2, this.allowStreams = i2, this.recoveryMode = a2, this.imageCache = /* @__PURE__ */ Object.create(null), this._imageId = 0, this.refill();
      }
      refill() {
        this.buf1 = this.lexer.getObj(), this.buf2 = this.lexer.getObj();
      }
      shift() {
        this.buf2 instanceof Cmd && "ID" === this.buf2.cmd ? (this.buf1 = this.buf2, this.buf2 = null) : (this.buf1 = this.buf2, this.buf2 = this.lexer.getObj());
      }
      tryShift() {
        try {
          return this.shift(), true;
        } catch (e2) {
          if (e2 instanceof MissingDataException)
            throw e2;
          return false;
        }
      }
      getObj(e2 = null) {
        const t2 = this.buf1;
        if (this.shift(), t2 instanceof Cmd)
          switch (t2.cmd) {
            case "BI":
              return this.makeInlineImage(e2);
            case "[":
              const i2 = [];
              for (; !isCmd(this.buf1, "]") && this.buf1 !== ci; )
                i2.push(this.getObj(e2));
              if (this.buf1 === ci) {
                if (this.recoveryMode)
                  return i2;
                throw new ParserEOFException("End of file inside array.");
              }
              return this.shift(), i2;
            case "<<":
              const a2 = new Dict(this.xref);
              for (; !isCmd(this.buf1, ">>") && this.buf1 !== ci; ) {
                if (!(this.buf1 instanceof Name)) {
                  info$1("Malformed dictionary: key must be a name object"), this.shift();
                  continue;
                }
                const t3 = this.buf1.name;
                if (this.shift(), this.buf1 === ci)
                  break;
                a2.set(t3, this.getObj(e2));
              }
              if (this.buf1 === ci) {
                if (this.recoveryMode)
                  return a2;
                throw new ParserEOFException("End of file inside dictionary.");
              }
              return isCmd(this.buf2, "stream") ? this.allowStreams ? this.makeStream(a2, e2) : a2 : (this.shift(), a2);
            default:
              return t2;
          }
        if (Number.isInteger(t2)) {
          if (Number.isInteger(this.buf1) && isCmd(this.buf2, "R")) {
            const e3 = Ref.get(t2, this.buf1);
            return this.shift(), this.shift(), e3;
          }
          return t2;
        }
        return "string" == typeof t2 && e2 ? e2.decryptString(t2) : t2;
      }
      findDefaultInlineStreamEnd(e2) {
        const { knownCommands: t2 } = this.lexer, i2 = e2.pos;
        let a2, n2, s2 = 0;
        for (; -1 !== (a2 = e2.getByte()); )
          if (0 === s2)
            s2 = 69 === a2 ? 1 : 0;
          else if (1 === s2)
            s2 = 73 === a2 ? 2 : 0;
          else if (32 === a2 || 10 === a2 || 13 === a2) {
            n2 = e2.pos;
            const i3 = e2.peekBytes(15), r3 = i3.length;
            if (0 === r3)
              break;
            for (let e3 = 0; e3 < r3; e3++)
              if (a2 = i3[e3], (0 !== a2 || 0 === i3[e3 + 1]) && 10 !== a2 && 13 !== a2 && (a2 < 32 || a2 > 127)) {
                s2 = 0;
                break;
              }
            if (2 !== s2)
              continue;
            if (!t2) {
              warn$1("findDefaultInlineStreamEnd - `lexer.knownCommands` is undefined.");
              continue;
            }
            const o2 = new Lexer(new Stream(e2.peekBytes(75)), t2);
            o2._hexStringWarn = () => {
            };
            let l3 = 0;
            for (; ; ) {
              const e3 = o2.getObj();
              if (e3 === ci) {
                s2 = 0;
                break;
              }
              if (e3 instanceof Cmd) {
                const i4 = t2[e3.cmd];
                if (!i4) {
                  s2 = 0;
                  break;
                }
                if (i4.variableArgs ? l3 <= i4.numArgs : l3 === i4.numArgs)
                  break;
                l3 = 0;
                continue;
              }
              l3++;
            }
            if (2 === s2)
              break;
          } else
            s2 = 0;
        -1 === a2 && (warn$1("findDefaultInlineStreamEnd: Reached the end of the stream without finding a valid EI marker"), n2 && (warn$1('... trying to recover by using the last "EI" occurrence.'), e2.skip(-(e2.pos - n2))));
        let r2 = 4;
        return e2.skip(-r2), a2 = e2.peekByte(), e2.skip(r2), isWhiteSpace(a2) || r2--, e2.pos - r2 - i2;
      }
      findDCTDecodeInlineStreamEnd(e2) {
        const t2 = e2.pos;
        let i2, a2, n2 = false;
        for (; -1 !== (i2 = e2.getByte()); )
          if (255 === i2) {
            switch (e2.getByte()) {
              case 0:
                break;
              case 255:
                e2.skip(-1);
                break;
              case 217:
                n2 = true;
                break;
              case 192:
              case 193:
              case 194:
              case 195:
              case 197:
              case 198:
              case 199:
              case 201:
              case 202:
              case 203:
              case 205:
              case 206:
              case 207:
              case 196:
              case 204:
              case 218:
              case 219:
              case 220:
              case 221:
              case 222:
              case 223:
              case 224:
              case 225:
              case 226:
              case 227:
              case 228:
              case 229:
              case 230:
              case 231:
              case 232:
              case 233:
              case 234:
              case 235:
              case 236:
              case 237:
              case 238:
              case 239:
              case 254:
                a2 = e2.getUint16(), a2 > 2 ? e2.skip(a2 - 2) : e2.skip(-2);
            }
            if (n2)
              break;
          }
        const s2 = e2.pos - t2;
        return -1 === i2 ? (warn$1("Inline DCTDecode image stream: EOI marker not found, searching for /EI/ instead."), e2.skip(-s2), this.findDefaultInlineStreamEnd(e2)) : (this.inlineStreamSkipEI(e2), s2);
      }
      findASCII85DecodeInlineStreamEnd(e2) {
        const t2 = e2.pos;
        let i2;
        for (; -1 !== (i2 = e2.getByte()); )
          if (126 === i2) {
            const t3 = e2.pos;
            for (i2 = e2.peekByte(); isWhiteSpace(i2); )
              e2.skip(), i2 = e2.peekByte();
            if (62 === i2) {
              e2.skip();
              break;
            }
            if (e2.pos > t3) {
              const t4 = e2.peekBytes(2);
              if (69 === t4[0] && 73 === t4[1])
                break;
            }
          }
        const a2 = e2.pos - t2;
        return -1 === i2 ? (warn$1("Inline ASCII85Decode image stream: EOD marker not found, searching for /EI/ instead."), e2.skip(-a2), this.findDefaultInlineStreamEnd(e2)) : (this.inlineStreamSkipEI(e2), a2);
      }
      findASCIIHexDecodeInlineStreamEnd(e2) {
        const t2 = e2.pos;
        let i2;
        for (; -1 !== (i2 = e2.getByte()) && 62 !== i2; )
          ;
        const a2 = e2.pos - t2;
        return -1 === i2 ? (warn$1("Inline ASCIIHexDecode image stream: EOD marker not found, searching for /EI/ instead."), e2.skip(-a2), this.findDefaultInlineStreamEnd(e2)) : (this.inlineStreamSkipEI(e2), a2);
      }
      inlineStreamSkipEI(e2) {
        let t2, i2 = 0;
        for (; -1 !== (t2 = e2.getByte()); )
          if (0 === i2)
            i2 = 69 === t2 ? 1 : 0;
          else if (1 === i2)
            i2 = 73 === t2 ? 2 : 0;
          else if (2 === i2)
            break;
      }
      makeInlineImage(e2) {
        const t2 = this.lexer, i2 = t2.stream, a2 = /* @__PURE__ */ Object.create(null);
        let n2;
        for (; !isCmd(this.buf1, "ID") && this.buf1 !== ci; ) {
          if (!(this.buf1 instanceof Name))
            throw new ti("Dictionary key must be a name object");
          const t3 = this.buf1.name;
          if (this.shift(), this.buf1 === ci)
            break;
          a2[t3] = this.getObj(e2);
        }
        -1 !== t2.beginInlineImagePos && (n2 = i2.pos - t2.beginInlineImagePos);
        const s2 = this.xref.fetchIfRef(a2.F || a2.Filter);
        let r2;
        if (s2 instanceof Name)
          r2 = s2.name;
        else if (Array.isArray(s2)) {
          const e3 = this.xref.fetchIfRef(s2[0]);
          e3 instanceof Name && (r2 = e3.name);
        }
        const o2 = i2.pos;
        let l3, c2;
        switch (r2) {
          case "DCT":
          case "DCTDecode":
            l3 = this.findDCTDecodeInlineStreamEnd(i2);
            break;
          case "A85":
          case "ASCII85Decode":
            l3 = this.findASCII85DecodeInlineStreamEnd(i2);
            break;
          case "AHx":
          case "ASCIIHexDecode":
            l3 = this.findASCIIHexDecodeInlineStreamEnd(i2);
            break;
          default:
            l3 = this.findDefaultInlineStreamEnd(i2);
        }
        if (l3 < 1e3 && n2 > 0) {
          const e3 = i2.pos;
          i2.pos = t2.beginInlineImagePos, c2 = function(e4) {
            const t3 = [], i3 = e4.length;
            let a4 = 0;
            for (; a4 < i3 - 1; )
              t3.push(e4[a4++] << 8 | e4[a4++]);
            return a4 < i3 && t3.push(e4[a4]), i3 + "_" + String.fromCharCode.apply(null, t3);
          }(i2.getBytes(n2 + l3)), i2.pos = e3;
          const a3 = this.imageCache[c2];
          if (void 0 !== a3)
            return this.buf2 = Cmd.get("EI"), this.shift(), a3.reset(), a3;
        }
        const h2 = new Dict(this.xref);
        for (const e3 in a2)
          h2.set(e3, a2[e3]);
        let d2 = i2.makeSubStream(o2, l3, h2);
        return e2 && (d2 = e2.createStream(d2, l3)), d2 = this.filter(d2, h2, l3), d2.dict = h2, void 0 !== c2 && (d2.cacheKey = "inline_img_" + ++this._imageId, this.imageCache[c2] = d2), this.buf2 = Cmd.get("EI"), this.shift(), d2;
      }
      #H(e2) {
        const { stream: t2 } = this.lexer;
        t2.pos = e2;
        const i2 = new Uint8Array([101, 110, 100]), a2 = i2.length, n2 = [new Uint8Array([115, 116, 114, 101, 97, 109]), new Uint8Array([115, 116, 101, 97, 109]), new Uint8Array([115, 116, 114, 101, 97])], s2 = 9 - a2;
        for (; t2.pos < t2.end; ) {
          const r2 = t2.peekBytes(2048), o2 = r2.length - 9;
          if (o2 <= 0)
            break;
          let l3 = 0;
          for (; l3 < o2; ) {
            let o3 = 0;
            for (; o3 < a2 && r2[l3 + o3] === i2[o3]; )
              o3++;
            if (o3 >= a2) {
              let a3 = false;
              for (const e3 of n2) {
                const t3 = e3.length;
                let n3 = 0;
                for (; n3 < t3 && r2[l3 + o3 + n3] === e3[n3]; )
                  n3++;
                if (n3 >= s2) {
                  a3 = true;
                  break;
                }
                if (n3 >= t3) {
                  isWhiteSpace(r2[l3 + o3 + n3]) && (info$1(`Found "${bytesToString$1([...i2, ...e3])}" when searching for endstream command.`), a3 = true);
                  break;
                }
              }
              if (a3)
                return t2.pos += l3, t2.pos - e2;
            }
            l3++;
          }
          t2.pos += o2;
        }
        return -1;
      }
      makeStream(e2, t2) {
        const i2 = this.lexer;
        let a2 = i2.stream;
        i2.skipToNextLine();
        const n2 = a2.pos - 1;
        let s2 = e2.get("Length");
        if (Number.isInteger(s2) || (info$1(`Bad length "${s2 && s2.toString()}" in stream.`), s2 = 0), a2.pos = n2 + s2, i2.nextChar(), this.tryShift() && isCmd(this.buf2, "endstream"))
          this.shift();
        else {
          if (s2 = this.#H(n2), s2 < 0)
            throw new ti("Missing endstream command.");
          i2.nextChar(), this.shift(), this.shift();
        }
        return this.shift(), a2 = a2.makeSubStream(n2, s2, e2), t2 && (a2 = t2.createStream(a2, s2)), a2 = this.filter(a2, e2, s2), a2.dict = e2, a2;
      }
      filter(e2, t2, i2) {
        let a2 = t2.get("F", "Filter"), n2 = t2.get("DP", "DecodeParms");
        if (a2 instanceof Name)
          return Array.isArray(n2) && warn$1("/DecodeParms should not be an Array, when /Filter is a Name."), this.makeFilter(e2, a2.name, i2, n2);
        let s2 = i2;
        if (Array.isArray(a2)) {
          const t3 = a2, i3 = n2;
          for (let r2 = 0, o2 = t3.length; r2 < o2; ++r2) {
            if (a2 = this.xref.fetchIfRef(t3[r2]), !(a2 instanceof Name))
              throw new ti(`Bad filter name "${a2}"`);
            n2 = null, Array.isArray(i3) && r2 in i3 && (n2 = this.xref.fetchIfRef(i3[r2])), e2 = this.makeFilter(e2, a2.name, s2, n2), s2 = null;
          }
        }
        return e2;
      }
      makeFilter(e2, t2, i2, a2) {
        if (0 === i2)
          return warn$1(`Empty "${t2}" stream.`), new NullStream();
        try {
          switch (t2) {
            case "Fl":
            case "FlateDecode":
              return a2 ? new PredictorStream(new FlateStream(e2, i2), i2, a2) : new FlateStream(e2, i2);
            case "LZW":
            case "LZWDecode":
              let t3 = 1;
              return a2 ? (a2.has("EarlyChange") && (t3 = a2.get("EarlyChange")), new PredictorStream(new LZWStream(e2, i2, t3), i2, a2)) : new LZWStream(e2, i2, t3);
            case "DCT":
            case "DCTDecode":
              return new JpegStream(e2, i2, a2);
            case "JPX":
            case "JPXDecode":
              return new JpxStream(e2, i2, a2);
            case "A85":
            case "ASCII85Decode":
              return new Ascii85Stream(e2, i2);
            case "AHx":
            case "ASCIIHexDecode":
              return new AsciiHexStream(e2, i2);
            case "CCF":
            case "CCITTFaxDecode":
              return new CCITTFaxStream(e2, i2, a2);
            case "RL":
            case "RunLengthDecode":
              return new RunLengthStream(e2, i2);
            case "JBIG2Decode":
              return new Jbig2Stream(e2, i2, a2);
          }
          return warn$1(`Filter "${t2}" is not supported.`), e2;
        } catch (e3) {
          if (e3 instanceof MissingDataException)
            throw e3;
          return warn$1(`Invalid stream: "${e3}"`), new NullStream();
        }
      }
    };
    __name(Parser, "Parser");
    sa = [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    __name(toHexDigit, "toHexDigit");
    Lexer = class {
      constructor(e2, t2 = null) {
        this.stream = e2, this.nextChar(), this.strBuf = [], this.knownCommands = t2, this._hexStringNumWarn = 0, this.beginInlineImagePos = -1;
      }
      nextChar() {
        return this.currentChar = this.stream.getByte();
      }
      peekChar() {
        return this.stream.peekByte();
      }
      getNumber() {
        let e2 = this.currentChar, t2 = false, i2 = 0, a2 = 1;
        if (45 === e2 ? (a2 = -1, e2 = this.nextChar(), 45 === e2 && (e2 = this.nextChar())) : 43 === e2 && (e2 = this.nextChar()), 10 === e2 || 13 === e2)
          do {
            e2 = this.nextChar();
          } while (10 === e2 || 13 === e2);
        if (46 === e2 && (i2 = 10, e2 = this.nextChar()), e2 < 48 || e2 > 57) {
          const t3 = `Invalid number: ${String.fromCharCode(e2)} (charCode ${e2})`;
          if (isWhiteSpace(e2) || 40 === e2 || 60 === e2 || -1 === e2)
            return info$1(`Lexer.getNumber - "${t3}".`), 0;
          throw new ti(t3);
        }
        let n2 = e2 - 48, s2 = 0, r2 = 1;
        for (; (e2 = this.nextChar()) >= 0; )
          if (e2 >= 48 && e2 <= 57) {
            const a3 = e2 - 48;
            t2 ? s2 = 10 * s2 + a3 : (0 !== i2 && (i2 *= 10), n2 = 10 * n2 + a3);
          } else if (46 === e2) {
            if (0 !== i2)
              break;
            i2 = 1;
          } else if (45 === e2)
            warn$1("Badly formatted number: minus sign in the middle");
          else {
            if (69 !== e2 && 101 !== e2)
              break;
            if (e2 = this.peekChar(), 43 === e2 || 45 === e2)
              r2 = 45 === e2 ? -1 : 1, this.nextChar();
            else if (e2 < 48 || e2 > 57)
              break;
            t2 = true;
          }
        return 0 !== i2 && (n2 /= i2), t2 && (n2 *= 10 ** (r2 * s2)), a2 * n2;
      }
      getString() {
        let e2 = 1, t2 = false;
        const i2 = this.strBuf;
        i2.length = 0;
        let a2 = this.nextChar();
        for (; ; ) {
          let n2 = false;
          switch (0 | a2) {
            case -1:
              warn$1("Unterminated string"), t2 = true;
              break;
            case 40:
              ++e2, i2.push("(");
              break;
            case 41:
              0 === --e2 ? (this.nextChar(), t2 = true) : i2.push(")");
              break;
            case 92:
              switch (a2 = this.nextChar(), a2) {
                case -1:
                  warn$1("Unterminated string"), t2 = true;
                  break;
                case 110:
                  i2.push("\n");
                  break;
                case 114:
                  i2.push("\r");
                  break;
                case 116:
                  i2.push("	");
                  break;
                case 98:
                  i2.push("\b");
                  break;
                case 102:
                  i2.push("\f");
                  break;
                case 92:
                case 40:
                case 41:
                  i2.push(String.fromCharCode(a2));
                  break;
                case 48:
                case 49:
                case 50:
                case 51:
                case 52:
                case 53:
                case 54:
                case 55:
                  let e3 = 15 & a2;
                  a2 = this.nextChar(), n2 = true, a2 >= 48 && a2 <= 55 && (e3 = (e3 << 3) + (15 & a2), a2 = this.nextChar(), a2 >= 48 && a2 <= 55 && (n2 = false, e3 = (e3 << 3) + (15 & a2))), i2.push(String.fromCharCode(e3));
                  break;
                case 13:
                  10 === this.peekChar() && this.nextChar();
                  break;
                case 10:
                  break;
                default:
                  i2.push(String.fromCharCode(a2));
              }
              break;
            default:
              i2.push(String.fromCharCode(a2));
          }
          if (t2)
            break;
          n2 || (a2 = this.nextChar());
        }
        return i2.join("");
      }
      getName() {
        let e2, t2;
        const i2 = this.strBuf;
        for (i2.length = 0; (e2 = this.nextChar()) >= 0 && !sa[e2]; )
          if (35 === e2) {
            if (e2 = this.nextChar(), sa[e2]) {
              warn$1("Lexer_getName: NUMBER SIGN (#) should be followed by a hexadecimal number."), i2.push("#");
              break;
            }
            const a2 = toHexDigit(e2);
            if (-1 !== a2) {
              t2 = e2, e2 = this.nextChar();
              const n2 = toHexDigit(e2);
              if (-1 === n2) {
                if (warn$1(`Lexer_getName: Illegal digit (${String.fromCharCode(e2)}) in hexadecimal number.`), i2.push("#", String.fromCharCode(t2)), sa[e2])
                  break;
                i2.push(String.fromCharCode(e2));
                continue;
              }
              i2.push(String.fromCharCode(a2 << 4 | n2));
            } else
              i2.push("#", String.fromCharCode(e2));
          } else
            i2.push(String.fromCharCode(e2));
        return i2.length > 127 && warn$1(`Name token is longer than allowed by the spec: ${i2.length}`), Name.get(i2.join(""));
      }
      _hexStringWarn(e2) {
        5 !== this._hexStringNumWarn++ ? this._hexStringNumWarn > 5 || warn$1(`getHexString - ignoring invalid character: ${e2}`) : warn$1("getHexString - ignoring additional invalid characters.");
      }
      getHexString() {
        const e2 = this.strBuf;
        e2.length = 0;
        let t2 = this.currentChar, i2 = -1, a2 = -1;
        for (this._hexStringNumWarn = 0; ; ) {
          if (t2 < 0) {
            warn$1("Unterminated hex string");
            break;
          }
          if (62 === t2) {
            this.nextChar();
            break;
          }
          1 !== sa[t2] ? (a2 = toHexDigit(t2), -1 === a2 ? this._hexStringWarn(t2) : -1 === i2 ? i2 = a2 : (e2.push(String.fromCharCode(i2 << 4 | a2)), i2 = -1), t2 = this.nextChar()) : t2 = this.nextChar();
        }
        return -1 !== i2 && e2.push(String.fromCharCode(i2 << 4)), e2.join("");
      }
      getObj() {
        let e2 = false, t2 = this.currentChar;
        for (; ; ) {
          if (t2 < 0)
            return ci;
          if (e2)
            10 !== t2 && 13 !== t2 || (e2 = false);
          else if (37 === t2)
            e2 = true;
          else if (1 !== sa[t2])
            break;
          t2 = this.nextChar();
        }
        switch (0 | t2) {
          case 48:
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
          case 43:
          case 45:
          case 46:
            return this.getNumber();
          case 40:
            return this.getString();
          case 47:
            return this.getName();
          case 91:
            return this.nextChar(), Cmd.get("[");
          case 93:
            return this.nextChar(), Cmd.get("]");
          case 60:
            return t2 = this.nextChar(), 60 === t2 ? (this.nextChar(), Cmd.get("<<")) : this.getHexString();
          case 62:
            return t2 = this.nextChar(), 62 === t2 ? (this.nextChar(), Cmd.get(">>")) : Cmd.get(">");
          case 123:
            return this.nextChar(), Cmd.get("{");
          case 125:
            return this.nextChar(), Cmd.get("}");
          case 41:
            throw this.nextChar(), new ti(`Illegal character: ${t2}`);
        }
        let i2 = String.fromCharCode(t2);
        if (t2 < 32 || t2 > 127) {
          const e3 = this.peekChar();
          if (e3 >= 32 && e3 <= 127)
            return this.nextChar(), Cmd.get(i2);
        }
        const a2 = this.knownCommands;
        let n2 = void 0 !== a2?.[i2];
        for (; (t2 = this.nextChar()) >= 0 && !sa[t2]; ) {
          const e3 = i2 + String.fromCharCode(t2);
          if (n2 && void 0 === a2[e3])
            break;
          if (128 === i2.length)
            throw new ti(`Command token too long: ${i2.length}`);
          i2 = e3, n2 = void 0 !== a2?.[i2];
        }
        return "true" === i2 || "false" !== i2 && ("null" === i2 ? null : ("BI" === i2 && (this.beginInlineImagePos = this.stream.pos), Cmd.get(i2)));
      }
      skipToNextLine() {
        let e2 = this.currentChar;
        for (; e2 >= 0; ) {
          if (13 === e2) {
            e2 = this.nextChar(), 10 === e2 && this.nextChar();
            break;
          }
          if (10 === e2) {
            this.nextChar();
            break;
          }
          e2 = this.nextChar();
        }
      }
    };
    __name(Lexer, "Lexer");
    Linearization = class {
      static create(e2) {
        function getInt(e3, t3, i3 = false) {
          const a3 = e3.get(t3);
          if (Number.isInteger(a3) && (i3 ? a3 >= 0 : a3 > 0))
            return a3;
          throw new Error(`The "${t3}" parameter in the linearization dictionary is invalid.`);
        }
        __name(getInt, "getInt");
        const t2 = new Parser({ lexer: new Lexer(e2), xref: null }), i2 = t2.getObj(), a2 = t2.getObj(), n2 = t2.getObj(), s2 = t2.getObj();
        let r2, o2;
        if (!(Number.isInteger(i2) && Number.isInteger(a2) && isCmd(n2, "obj") && s2 instanceof Dict && "number" == typeof (r2 = s2.get("Linearized")) && r2 > 0))
          return null;
        if ((o2 = getInt(s2, "L")) !== e2.length)
          throw new Error('The "L" parameter in the linearization dictionary does not equal the stream length.');
        return { length: o2, hints: function(e3) {
          const t3 = e3.get("H");
          let i3;
          if (Array.isArray(t3) && (2 === (i3 = t3.length) || 4 === i3)) {
            for (let e4 = 0; e4 < i3; e4++) {
              const i4 = t3[e4];
              if (!(Number.isInteger(i4) && i4 > 0))
                throw new Error(`Hint (${e4}) in the linearization dictionary is invalid.`);
            }
            return t3;
          }
          throw new Error("Hint array in the linearization dictionary is invalid.");
        }(s2), objectNumberFirst: getInt(s2, "O"), endFirst: getInt(s2, "E"), numPages: getInt(s2, "N"), mainXRefEntriesOffset: getInt(s2, "T"), pageFirst: s2.has("P") ? getInt(s2, "P", true) : 0 };
      }
    };
    __name(Linearization, "Linearization");
    ra = ["Adobe-GB1-UCS2", "Adobe-CNS1-UCS2", "Adobe-Japan1-UCS2", "Adobe-Korea1-UCS2", "78-EUC-H", "78-EUC-V", "78-H", "78-RKSJ-H", "78-RKSJ-V", "78-V", "78ms-RKSJ-H", "78ms-RKSJ-V", "83pv-RKSJ-H", "90ms-RKSJ-H", "90ms-RKSJ-V", "90msp-RKSJ-H", "90msp-RKSJ-V", "90pv-RKSJ-H", "90pv-RKSJ-V", "Add-H", "Add-RKSJ-H", "Add-RKSJ-V", "Add-V", "Adobe-CNS1-0", "Adobe-CNS1-1", "Adobe-CNS1-2", "Adobe-CNS1-3", "Adobe-CNS1-4", "Adobe-CNS1-5", "Adobe-CNS1-6", "Adobe-GB1-0", "Adobe-GB1-1", "Adobe-GB1-2", "Adobe-GB1-3", "Adobe-GB1-4", "Adobe-GB1-5", "Adobe-Japan1-0", "Adobe-Japan1-1", "Adobe-Japan1-2", "Adobe-Japan1-3", "Adobe-Japan1-4", "Adobe-Japan1-5", "Adobe-Japan1-6", "Adobe-Korea1-0", "Adobe-Korea1-1", "Adobe-Korea1-2", "B5-H", "B5-V", "B5pc-H", "B5pc-V", "CNS-EUC-H", "CNS-EUC-V", "CNS1-H", "CNS1-V", "CNS2-H", "CNS2-V", "ETHK-B5-H", "ETHK-B5-V", "ETen-B5-H", "ETen-B5-V", "ETenms-B5-H", "ETenms-B5-V", "EUC-H", "EUC-V", "Ext-H", "Ext-RKSJ-H", "Ext-RKSJ-V", "Ext-V", "GB-EUC-H", "GB-EUC-V", "GB-H", "GB-V", "GBK-EUC-H", "GBK-EUC-V", "GBK2K-H", "GBK2K-V", "GBKp-EUC-H", "GBKp-EUC-V", "GBT-EUC-H", "GBT-EUC-V", "GBT-H", "GBT-V", "GBTpc-EUC-H", "GBTpc-EUC-V", "GBpc-EUC-H", "GBpc-EUC-V", "H", "HKdla-B5-H", "HKdla-B5-V", "HKdlb-B5-H", "HKdlb-B5-V", "HKgccs-B5-H", "HKgccs-B5-V", "HKm314-B5-H", "HKm314-B5-V", "HKm471-B5-H", "HKm471-B5-V", "HKscs-B5-H", "HKscs-B5-V", "Hankaku", "Hiragana", "KSC-EUC-H", "KSC-EUC-V", "KSC-H", "KSC-Johab-H", "KSC-Johab-V", "KSC-V", "KSCms-UHC-H", "KSCms-UHC-HW-H", "KSCms-UHC-HW-V", "KSCms-UHC-V", "KSCpc-EUC-H", "KSCpc-EUC-V", "Katakana", "NWP-H", "NWP-V", "RKSJ-H", "RKSJ-V", "Roman", "UniCNS-UCS2-H", "UniCNS-UCS2-V", "UniCNS-UTF16-H", "UniCNS-UTF16-V", "UniCNS-UTF32-H", "UniCNS-UTF32-V", "UniCNS-UTF8-H", "UniCNS-UTF8-V", "UniGB-UCS2-H", "UniGB-UCS2-V", "UniGB-UTF16-H", "UniGB-UTF16-V", "UniGB-UTF32-H", "UniGB-UTF32-V", "UniGB-UTF8-H", "UniGB-UTF8-V", "UniJIS-UCS2-H", "UniJIS-UCS2-HW-H", "UniJIS-UCS2-HW-V", "UniJIS-UCS2-V", "UniJIS-UTF16-H", "UniJIS-UTF16-V", "UniJIS-UTF32-H", "UniJIS-UTF32-V", "UniJIS-UTF8-H", "UniJIS-UTF8-V", "UniJIS2004-UTF16-H", "UniJIS2004-UTF16-V", "UniJIS2004-UTF32-H", "UniJIS2004-UTF32-V", "UniJIS2004-UTF8-H", "UniJIS2004-UTF8-V", "UniJISPro-UCS2-HW-V", "UniJISPro-UCS2-V", "UniJISPro-UTF8-V", "UniJISX0213-UTF32-H", "UniJISX0213-UTF32-V", "UniJISX02132004-UTF32-H", "UniJISX02132004-UTF32-V", "UniKS-UCS2-H", "UniKS-UCS2-V", "UniKS-UTF16-H", "UniKS-UTF16-V", "UniKS-UTF32-H", "UniKS-UTF32-V", "UniKS-UTF8-H", "UniKS-UTF8-V", "V", "WP-Symbol"];
    oa = 2 ** 24 - 1;
    CMap = class {
      constructor(e2 = false) {
        this.codespaceRanges = [[], [], [], []], this.numCodespaceRanges = 0, this._map = [], this.name = "", this.vertical = false, this.useCMap = null, this.builtInCMap = e2;
      }
      addCodespaceRange(e2, t2, i2) {
        this.codespaceRanges[e2 - 1].push(t2, i2), this.numCodespaceRanges++;
      }
      mapCidRange(e2, t2, i2) {
        if (t2 - e2 > oa)
          throw new Error("mapCidRange - ignoring data above MAX_MAP_RANGE.");
        for (; e2 <= t2; )
          this._map[e2++] = i2++;
      }
      mapBfRange(e2, t2, i2) {
        if (t2 - e2 > oa)
          throw new Error("mapBfRange - ignoring data above MAX_MAP_RANGE.");
        const a2 = i2.length - 1;
        for (; e2 <= t2; ) {
          this._map[e2++] = i2;
          const t3 = i2.charCodeAt(a2) + 1;
          t3 > 255 ? i2 = i2.substring(0, a2 - 1) + String.fromCharCode(i2.charCodeAt(a2 - 1) + 1) + "\0" : i2 = i2.substring(0, a2) + String.fromCharCode(t3);
        }
      }
      mapBfRangeToArray(e2, t2, i2) {
        if (t2 - e2 > oa)
          throw new Error("mapBfRangeToArray - ignoring data above MAX_MAP_RANGE.");
        const a2 = i2.length;
        let n2 = 0;
        for (; e2 <= t2 && n2 < a2; )
          this._map[e2] = i2[n2++], ++e2;
      }
      mapOne(e2, t2) {
        this._map[e2] = t2;
      }
      lookup(e2) {
        return this._map[e2];
      }
      contains(e2) {
        return void 0 !== this._map[e2];
      }
      forEach(e2) {
        const t2 = this._map, i2 = t2.length;
        if (i2 <= 65536)
          for (let a2 = 0; a2 < i2; a2++)
            void 0 !== t2[a2] && e2(a2, t2[a2]);
        else
          for (const i3 in t2)
            e2(i3, t2[i3]);
      }
      charCodeOf(e2) {
        const t2 = this._map;
        if (t2.length <= 65536)
          return t2.indexOf(e2);
        for (const i2 in t2)
          if (t2[i2] === e2)
            return 0 | i2;
        return -1;
      }
      getMap() {
        return this._map;
      }
      readCharCode(e2, t2, i2) {
        let a2 = 0;
        const n2 = this.codespaceRanges;
        for (let s2 = 0, r2 = n2.length; s2 < r2; s2++) {
          a2 = (a2 << 8 | e2.charCodeAt(t2 + s2)) >>> 0;
          const r3 = n2[s2];
          for (let e3 = 0, t3 = r3.length; e3 < t3; ) {
            const t4 = r3[e3++], n3 = r3[e3++];
            if (a2 >= t4 && a2 <= n3)
              return i2.charcode = a2, void (i2.length = s2 + 1);
          }
        }
        i2.charcode = 0, i2.length = 1;
      }
      getCharCodeLength(e2) {
        const t2 = this.codespaceRanges;
        for (let i2 = 0, a2 = t2.length; i2 < a2; i2++) {
          const a3 = t2[i2];
          for (let t3 = 0, n2 = a3.length; t3 < n2; ) {
            const n3 = a3[t3++], s2 = a3[t3++];
            if (e2 >= n3 && e2 <= s2)
              return i2 + 1;
          }
        }
        return 1;
      }
      get length() {
        return this._map.length;
      }
      get isIdentityCMap() {
        if ("Identity-H" !== this.name && "Identity-V" !== this.name)
          return false;
        if (65536 !== this._map.length)
          return false;
        for (let e2 = 0; e2 < 65536; e2++)
          if (this._map[e2] !== e2)
            return false;
        return true;
      }
    };
    __name(CMap, "CMap");
    IdentityCMap = class extends CMap {
      constructor(e2, t2) {
        super(), this.vertical = e2, this.addCodespaceRange(t2, 0, 65535);
      }
      mapCidRange(e2, t2, i2) {
        unreachable$1("should not call mapCidRange");
      }
      mapBfRange(e2, t2, i2) {
        unreachable$1("should not call mapBfRange");
      }
      mapBfRangeToArray(e2, t2, i2) {
        unreachable$1("should not call mapBfRangeToArray");
      }
      mapOne(e2, t2) {
        unreachable$1("should not call mapCidOne");
      }
      lookup(e2) {
        return Number.isInteger(e2) && e2 <= 65535 ? e2 : void 0;
      }
      contains(e2) {
        return Number.isInteger(e2) && e2 <= 65535;
      }
      forEach(e2) {
        for (let t2 = 0; t2 <= 65535; t2++)
          e2(t2, t2);
      }
      charCodeOf(e2) {
        return Number.isInteger(e2) && e2 <= 65535 ? e2 : -1;
      }
      getMap() {
        const e2 = new Array(65536);
        for (let t2 = 0; t2 <= 65535; t2++)
          e2[t2] = t2;
        return e2;
      }
      get length() {
        return 65536;
      }
      get isIdentityCMap() {
        unreachable$1("should not access .isIdentityCMap");
      }
    };
    __name(IdentityCMap, "IdentityCMap");
    __name(strToInt, "strToInt");
    __name(expectString, "expectString");
    __name(expectInt, "expectInt");
    __name(parseBfChar, "parseBfChar");
    __name(parseBfRange, "parseBfRange");
    __name(parseCidChar, "parseCidChar");
    __name(parseCidRange, "parseCidRange");
    __name(parseCodespaceRange, "parseCodespaceRange");
    __name(parseWMode, "parseWMode");
    __name(parseCMapName, "parseCMapName");
    __name(parseCMap, "parseCMap");
    __name(extendCMap, "extendCMap");
    __name(createBuiltInCMap, "createBuiltInCMap");
    CMapFactory = class {
      static async create({ encoding: e2, fetchBuiltInCMap: t2, useCMap: i2 }) {
        if (e2 instanceof Name)
          return createBuiltInCMap(e2.name, t2);
        if (e2 instanceof BaseStream) {
          const a2 = await parseCMap(new CMap(), new Lexer(e2), t2, i2);
          return a2.isIdentityCMap ? createBuiltInCMap(a2.name, t2) : a2;
        }
        throw new Error("Encoding required.");
      }
    };
    __name(CMapFactory, "CMapFactory");
    la = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "", "", "", "isuperior", "", "", "lsuperior", "msuperior", "nsuperior", "osuperior", "", "", "rsuperior", "ssuperior", "tsuperior", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdownsmall", "centoldstyle", "Lslashsmall", "", "", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "", "Dotaccentsmall", "", "", "Macronsmall", "", "", "figuredash", "hypheninferior", "", "", "Ogoneksmall", "Ringsmall", "Cedillasmall", "", "", "", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"];
    ca = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "centoldstyle", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "", "threequartersemdash", "", "questionsmall", "", "", "", "", "Ethsmall", "", "", "onequarter", "onehalf", "threequarters", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "", "", "", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hypheninferior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "asuperior", "centsuperior", "", "", "", "", "Aacutesmall", "Agravesmall", "Acircumflexsmall", "Adieresissmall", "Atildesmall", "Aringsmall", "Ccedillasmall", "Eacutesmall", "Egravesmall", "Ecircumflexsmall", "Edieresissmall", "Iacutesmall", "Igravesmall", "Icircumflexsmall", "Idieresissmall", "Ntildesmall", "Oacutesmall", "Ogravesmall", "Ocircumflexsmall", "Odieresissmall", "Otildesmall", "Uacutesmall", "Ugravesmall", "Ucircumflexsmall", "Udieresissmall", "", "eightsuperior", "fourinferior", "threeinferior", "sixinferior", "eightinferior", "seveninferior", "Scaronsmall", "", "centinferior", "twoinferior", "", "Dieresissmall", "", "Caronsmall", "osuperior", "fiveinferior", "", "commainferior", "periodinferior", "Yacutesmall", "", "dollarinferior", "", "", "Thornsmall", "", "nineinferior", "zeroinferior", "Zcaronsmall", "AEsmall", "Oslashsmall", "questiondownsmall", "oneinferior", "Lslashsmall", "", "", "", "", "", "", "Cedillasmall", "", "", "", "", "", "OEsmall", "figuredash", "hyphensuperior", "", "", "", "", "exclamdownsmall", "", "Ydieresissmall", "", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "ninesuperior", "zerosuperior", "", "esuperior", "rsuperior", "tsuperior", "", "", "isuperior", "ssuperior", "dsuperior", "", "", "", "", "", "lsuperior", "Ogoneksmall", "Brevesmall", "Macronsmall", "bsuperior", "nsuperior", "msuperior", "commasuperior", "periodsuperior", "Dotaccentsmall", "Ringsmall", "", "", "", ""];
    ha = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "space", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron"];
    da = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "", "endash", "dagger", "daggerdbl", "periodcentered", "", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "", "questiondown", "", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "", "ring", "cedilla", "", "hungarumlaut", "ogonek", "caron", "emdash", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "AE", "", "ordfeminine", "", "", "", "", "Lslash", "Oslash", "OE", "ordmasculine", "", "", "", "", "", "ae", "", "", "", "dotlessi", "", "", "lslash", "oslash", "oe", "germandbls", "", "", "", ""];
    ua = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "bullet", "Euro", "bullet", "quotesinglbase", "florin", "quotedblbase", "ellipsis", "dagger", "daggerdbl", "circumflex", "perthousand", "Scaron", "guilsinglleft", "OE", "bullet", "Zcaron", "bullet", "bullet", "quoteleft", "quoteright", "quotedblleft", "quotedblright", "bullet", "endash", "emdash", "tilde", "trademark", "scaron", "guilsinglright", "oe", "bullet", "zcaron", "Ydieresis", "space", "exclamdown", "cent", "sterling", "currency", "yen", "brokenbar", "section", "dieresis", "copyright", "ordfeminine", "guillemotleft", "logicalnot", "hyphen", "registered", "macron", "degree", "plusminus", "twosuperior", "threesuperior", "acute", "mu", "paragraph", "periodcentered", "cedilla", "onesuperior", "ordmasculine", "guillemotright", "onequarter", "onehalf", "threequarters", "questiondown", "Agrave", "Aacute", "Acircumflex", "Atilde", "Adieresis", "Aring", "AE", "Ccedilla", "Egrave", "Eacute", "Ecircumflex", "Edieresis", "Igrave", "Iacute", "Icircumflex", "Idieresis", "Eth", "Ntilde", "Ograve", "Oacute", "Ocircumflex", "Otilde", "Odieresis", "multiply", "Oslash", "Ugrave", "Uacute", "Ucircumflex", "Udieresis", "Yacute", "Thorn", "germandbls", "agrave", "aacute", "acircumflex", "atilde", "adieresis", "aring", "ae", "ccedilla", "egrave", "eacute", "ecircumflex", "edieresis", "igrave", "iacute", "icircumflex", "idieresis", "eth", "ntilde", "ograve", "oacute", "ocircumflex", "otilde", "odieresis", "divide", "oslash", "ugrave", "uacute", "ucircumflex", "udieresis", "yacute", "thorn", "ydieresis"];
    ga = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "universal", "numbersign", "existential", "percent", "ampersand", "suchthat", "parenleft", "parenright", "asteriskmath", "plus", "comma", "minus", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "congruent", "Alpha", "Beta", "Chi", "Delta", "Epsilon", "Phi", "Gamma", "Eta", "Iota", "theta1", "Kappa", "Lambda", "Mu", "Nu", "Omicron", "Pi", "Theta", "Rho", "Sigma", "Tau", "Upsilon", "sigma1", "Omega", "Xi", "Psi", "Zeta", "bracketleft", "therefore", "bracketright", "perpendicular", "underscore", "radicalex", "alpha", "beta", "chi", "delta", "epsilon", "phi", "gamma", "eta", "iota", "phi1", "kappa", "lambda", "mu", "nu", "omicron", "pi", "theta", "rho", "sigma", "tau", "upsilon", "omega1", "omega", "xi", "psi", "zeta", "braceleft", "bar", "braceright", "similar", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "Euro", "Upsilon1", "minute", "lessequal", "fraction", "infinity", "florin", "club", "diamond", "heart", "spade", "arrowboth", "arrowleft", "arrowup", "arrowright", "arrowdown", "degree", "plusminus", "second", "greaterequal", "multiply", "proportional", "partialdiff", "bullet", "divide", "notequal", "equivalence", "approxequal", "ellipsis", "arrowvertex", "arrowhorizex", "carriagereturn", "aleph", "Ifraktur", "Rfraktur", "weierstrass", "circlemultiply", "circleplus", "emptyset", "intersection", "union", "propersuperset", "reflexsuperset", "notsubset", "propersubset", "reflexsubset", "element", "notelement", "angle", "gradient", "registerserif", "copyrightserif", "trademarkserif", "product", "radical", "dotmath", "logicalnot", "logicaland", "logicalor", "arrowdblboth", "arrowdblleft", "arrowdblup", "arrowdblright", "arrowdbldown", "lozenge", "angleleft", "registersans", "copyrightsans", "trademarksans", "summation", "parenlefttp", "parenleftex", "parenleftbt", "bracketlefttp", "bracketleftex", "bracketleftbt", "bracelefttp", "braceleftmid", "braceleftbt", "braceex", "", "angleright", "integral", "integraltp", "integralex", "integralbt", "parenrighttp", "parenrightex", "parenrightbt", "bracketrighttp", "bracketrightex", "bracketrightbt", "bracerighttp", "bracerightmid", "bracerightbt", ""];
    pa = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "a1", "a2", "a202", "a3", "a4", "a5", "a119", "a118", "a117", "a11", "a12", "a13", "a14", "a15", "a16", "a105", "a17", "a18", "a19", "a20", "a21", "a22", "a23", "a24", "a25", "a26", "a27", "a28", "a6", "a7", "a8", "a9", "a10", "a29", "a30", "a31", "a32", "a33", "a34", "a35", "a36", "a37", "a38", "a39", "a40", "a41", "a42", "a43", "a44", "a45", "a46", "a47", "a48", "a49", "a50", "a51", "a52", "a53", "a54", "a55", "a56", "a57", "a58", "a59", "a60", "a61", "a62", "a63", "a64", "a65", "a66", "a67", "a68", "a69", "a70", "a71", "a72", "a73", "a74", "a203", "a75", "a204", "a76", "a77", "a78", "a79", "a81", "a82", "a83", "a84", "a97", "a98", "a99", "a100", "", "a89", "a90", "a93", "a94", "a91", "a92", "a205", "a85", "a206", "a86", "a87", "a88", "a95", "a96", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "a101", "a102", "a103", "a104", "a106", "a107", "a108", "a112", "a111", "a110", "a109", "a120", "a121", "a122", "a123", "a124", "a125", "a126", "a127", "a128", "a129", "a130", "a131", "a132", "a133", "a134", "a135", "a136", "a137", "a138", "a139", "a140", "a141", "a142", "a143", "a144", "a145", "a146", "a147", "a148", "a149", "a150", "a151", "a152", "a153", "a154", "a155", "a156", "a157", "a158", "a159", "a160", "a161", "a163", "a164", "a196", "a165", "a192", "a166", "a167", "a168", "a169", "a170", "a171", "a172", "a173", "a162", "a174", "a175", "a176", "a177", "a178", "a179", "a193", "a180", "a199", "a181", "a200", "a182", "", "a201", "a183", "a184", "a197", "a185", "a194", "a198", "a186", "a195", "a187", "a188", "a189", "a190", "a191", ""];
    __name(getEncoding, "getEncoding");
    fa = getLookupTableFactory(function(e2) {
      e2.A = 65, e2.AE = 198, e2.AEacute = 508, e2.AEmacron = 482, e2.AEsmall = 63462, e2.Aacute = 193, e2.Aacutesmall = 63457, e2.Abreve = 258, e2.Abreveacute = 7854, e2.Abrevecyrillic = 1232, e2.Abrevedotbelow = 7862, e2.Abrevegrave = 7856, e2.Abrevehookabove = 7858, e2.Abrevetilde = 7860, e2.Acaron = 461, e2.Acircle = 9398, e2.Acircumflex = 194, e2.Acircumflexacute = 7844, e2.Acircumflexdotbelow = 7852, e2.Acircumflexgrave = 7846, e2.Acircumflexhookabove = 7848, e2.Acircumflexsmall = 63458, e2.Acircumflextilde = 7850, e2.Acute = 63177, e2.Acutesmall = 63412, e2.Acyrillic = 1040, e2.Adblgrave = 512, e2.Adieresis = 196, e2.Adieresiscyrillic = 1234, e2.Adieresismacron = 478, e2.Adieresissmall = 63460, e2.Adotbelow = 7840, e2.Adotmacron = 480, e2.Agrave = 192, e2.Agravesmall = 63456, e2.Ahookabove = 7842, e2.Aiecyrillic = 1236, e2.Ainvertedbreve = 514, e2.Alpha = 913, e2.Alphatonos = 902, e2.Amacron = 256, e2.Amonospace = 65313, e2.Aogonek = 260, e2.Aring = 197, e2.Aringacute = 506, e2.Aringbelow = 7680, e2.Aringsmall = 63461, e2.Asmall = 63329, e2.Atilde = 195, e2.Atildesmall = 63459, e2.Aybarmenian = 1329, e2.B = 66, e2.Bcircle = 9399, e2.Bdotaccent = 7682, e2.Bdotbelow = 7684, e2.Becyrillic = 1041, e2.Benarmenian = 1330, e2.Beta = 914, e2.Bhook = 385, e2.Blinebelow = 7686, e2.Bmonospace = 65314, e2.Brevesmall = 63220, e2.Bsmall = 63330, e2.Btopbar = 386, e2.C = 67, e2.Caarmenian = 1342, e2.Cacute = 262, e2.Caron = 63178, e2.Caronsmall = 63221, e2.Ccaron = 268, e2.Ccedilla = 199, e2.Ccedillaacute = 7688, e2.Ccedillasmall = 63463, e2.Ccircle = 9400, e2.Ccircumflex = 264, e2.Cdot = 266, e2.Cdotaccent = 266, e2.Cedillasmall = 63416, e2.Chaarmenian = 1353, e2.Cheabkhasiancyrillic = 1212, e2.Checyrillic = 1063, e2.Chedescenderabkhasiancyrillic = 1214, e2.Chedescendercyrillic = 1206, e2.Chedieresiscyrillic = 1268, e2.Cheharmenian = 1347, e2.Chekhakassiancyrillic = 1227, e2.Cheverticalstrokecyrillic = 1208, e2.Chi = 935, e2.Chook = 391, e2.Circumflexsmall = 63222, e2.Cmonospace = 65315, e2.Coarmenian = 1361, e2.Csmall = 63331, e2.D = 68, e2.DZ = 497, e2.DZcaron = 452, e2.Daarmenian = 1332, e2.Dafrican = 393, e2.Dcaron = 270, e2.Dcedilla = 7696, e2.Dcircle = 9401, e2.Dcircumflexbelow = 7698, e2.Dcroat = 272, e2.Ddotaccent = 7690, e2.Ddotbelow = 7692, e2.Decyrillic = 1044, e2.Deicoptic = 1006, e2.Delta = 8710, e2.Deltagreek = 916, e2.Dhook = 394, e2.Dieresis = 63179, e2.DieresisAcute = 63180, e2.DieresisGrave = 63181, e2.Dieresissmall = 63400, e2.Digammagreek = 988, e2.Djecyrillic = 1026, e2.Dlinebelow = 7694, e2.Dmonospace = 65316, e2.Dotaccentsmall = 63223, e2.Dslash = 272, e2.Dsmall = 63332, e2.Dtopbar = 395, e2.Dz = 498, e2.Dzcaron = 453, e2.Dzeabkhasiancyrillic = 1248, e2.Dzecyrillic = 1029, e2.Dzhecyrillic = 1039, e2.E = 69, e2.Eacute = 201, e2.Eacutesmall = 63465, e2.Ebreve = 276, e2.Ecaron = 282, e2.Ecedillabreve = 7708, e2.Echarmenian = 1333, e2.Ecircle = 9402, e2.Ecircumflex = 202, e2.Ecircumflexacute = 7870, e2.Ecircumflexbelow = 7704, e2.Ecircumflexdotbelow = 7878, e2.Ecircumflexgrave = 7872, e2.Ecircumflexhookabove = 7874, e2.Ecircumflexsmall = 63466, e2.Ecircumflextilde = 7876, e2.Ecyrillic = 1028, e2.Edblgrave = 516, e2.Edieresis = 203, e2.Edieresissmall = 63467, e2.Edot = 278, e2.Edotaccent = 278, e2.Edotbelow = 7864, e2.Efcyrillic = 1060, e2.Egrave = 200, e2.Egravesmall = 63464, e2.Eharmenian = 1335, e2.Ehookabove = 7866, e2.Eightroman = 8551, e2.Einvertedbreve = 518, e2.Eiotifiedcyrillic = 1124, e2.Elcyrillic = 1051, e2.Elevenroman = 8554, e2.Emacron = 274, e2.Emacronacute = 7702, e2.Emacrongrave = 7700, e2.Emcyrillic = 1052, e2.Emonospace = 65317, e2.Encyrillic = 1053, e2.Endescendercyrillic = 1186, e2.Eng = 330, e2.Enghecyrillic = 1188, e2.Enhookcyrillic = 1223, e2.Eogonek = 280, e2.Eopen = 400, e2.Epsilon = 917, e2.Epsilontonos = 904, e2.Ercyrillic = 1056, e2.Ereversed = 398, e2.Ereversedcyrillic = 1069, e2.Escyrillic = 1057, e2.Esdescendercyrillic = 1194, e2.Esh = 425, e2.Esmall = 63333, e2.Eta = 919, e2.Etarmenian = 1336, e2.Etatonos = 905, e2.Eth = 208, e2.Ethsmall = 63472, e2.Etilde = 7868, e2.Etildebelow = 7706, e2.Euro = 8364, e2.Ezh = 439, e2.Ezhcaron = 494, e2.Ezhreversed = 440, e2.F = 70, e2.Fcircle = 9403, e2.Fdotaccent = 7710, e2.Feharmenian = 1366, e2.Feicoptic = 996, e2.Fhook = 401, e2.Fitacyrillic = 1138, e2.Fiveroman = 8548, e2.Fmonospace = 65318, e2.Fourroman = 8547, e2.Fsmall = 63334, e2.G = 71, e2.GBsquare = 13191, e2.Gacute = 500, e2.Gamma = 915, e2.Gammaafrican = 404, e2.Gangiacoptic = 1002, e2.Gbreve = 286, e2.Gcaron = 486, e2.Gcedilla = 290, e2.Gcircle = 9404, e2.Gcircumflex = 284, e2.Gcommaaccent = 290, e2.Gdot = 288, e2.Gdotaccent = 288, e2.Gecyrillic = 1043, e2.Ghadarmenian = 1346, e2.Ghemiddlehookcyrillic = 1172, e2.Ghestrokecyrillic = 1170, e2.Gheupturncyrillic = 1168, e2.Ghook = 403, e2.Gimarmenian = 1331, e2.Gjecyrillic = 1027, e2.Gmacron = 7712, e2.Gmonospace = 65319, e2.Grave = 63182, e2.Gravesmall = 63328, e2.Gsmall = 63335, e2.Gsmallhook = 667, e2.Gstroke = 484, e2.H = 72, e2.H18533 = 9679, e2.H18543 = 9642, e2.H18551 = 9643, e2.H22073 = 9633, e2.HPsquare = 13259, e2.Haabkhasiancyrillic = 1192, e2.Hadescendercyrillic = 1202, e2.Hardsigncyrillic = 1066, e2.Hbar = 294, e2.Hbrevebelow = 7722, e2.Hcedilla = 7720, e2.Hcircle = 9405, e2.Hcircumflex = 292, e2.Hdieresis = 7718, e2.Hdotaccent = 7714, e2.Hdotbelow = 7716, e2.Hmonospace = 65320, e2.Hoarmenian = 1344, e2.Horicoptic = 1e3, e2.Hsmall = 63336, e2.Hungarumlaut = 63183, e2.Hungarumlautsmall = 63224, e2.Hzsquare = 13200, e2.I = 73, e2.IAcyrillic = 1071, e2.IJ = 306, e2.IUcyrillic = 1070, e2.Iacute = 205, e2.Iacutesmall = 63469, e2.Ibreve = 300, e2.Icaron = 463, e2.Icircle = 9406, e2.Icircumflex = 206, e2.Icircumflexsmall = 63470, e2.Icyrillic = 1030, e2.Idblgrave = 520, e2.Idieresis = 207, e2.Idieresisacute = 7726, e2.Idieresiscyrillic = 1252, e2.Idieresissmall = 63471, e2.Idot = 304, e2.Idotaccent = 304, e2.Idotbelow = 7882, e2.Iebrevecyrillic = 1238, e2.Iecyrillic = 1045, e2.Ifraktur = 8465, e2.Igrave = 204, e2.Igravesmall = 63468, e2.Ihookabove = 7880, e2.Iicyrillic = 1048, e2.Iinvertedbreve = 522, e2.Iishortcyrillic = 1049, e2.Imacron = 298, e2.Imacroncyrillic = 1250, e2.Imonospace = 65321, e2.Iniarmenian = 1339, e2.Iocyrillic = 1025, e2.Iogonek = 302, e2.Iota = 921, e2.Iotaafrican = 406, e2.Iotadieresis = 938, e2.Iotatonos = 906, e2.Ismall = 63337, e2.Istroke = 407, e2.Itilde = 296, e2.Itildebelow = 7724, e2.Izhitsacyrillic = 1140, e2.Izhitsadblgravecyrillic = 1142, e2.J = 74, e2.Jaarmenian = 1345, e2.Jcircle = 9407, e2.Jcircumflex = 308, e2.Jecyrillic = 1032, e2.Jheharmenian = 1355, e2.Jmonospace = 65322, e2.Jsmall = 63338, e2.K = 75, e2.KBsquare = 13189, e2.KKsquare = 13261, e2.Kabashkircyrillic = 1184, e2.Kacute = 7728, e2.Kacyrillic = 1050, e2.Kadescendercyrillic = 1178, e2.Kahookcyrillic = 1219, e2.Kappa = 922, e2.Kastrokecyrillic = 1182, e2.Kaverticalstrokecyrillic = 1180, e2.Kcaron = 488, e2.Kcedilla = 310, e2.Kcircle = 9408, e2.Kcommaaccent = 310, e2.Kdotbelow = 7730, e2.Keharmenian = 1364, e2.Kenarmenian = 1343, e2.Khacyrillic = 1061, e2.Kheicoptic = 998, e2.Khook = 408, e2.Kjecyrillic = 1036, e2.Klinebelow = 7732, e2.Kmonospace = 65323, e2.Koppacyrillic = 1152, e2.Koppagreek = 990, e2.Ksicyrillic = 1134, e2.Ksmall = 63339, e2.L = 76, e2.LJ = 455, e2.LL = 63167, e2.Lacute = 313, e2.Lambda = 923, e2.Lcaron = 317, e2.Lcedilla = 315, e2.Lcircle = 9409, e2.Lcircumflexbelow = 7740, e2.Lcommaaccent = 315, e2.Ldot = 319, e2.Ldotaccent = 319, e2.Ldotbelow = 7734, e2.Ldotbelowmacron = 7736, e2.Liwnarmenian = 1340, e2.Lj = 456, e2.Ljecyrillic = 1033, e2.Llinebelow = 7738, e2.Lmonospace = 65324, e2.Lslash = 321, e2.Lslashsmall = 63225, e2.Lsmall = 63340, e2.M = 77, e2.MBsquare = 13190, e2.Macron = 63184, e2.Macronsmall = 63407, e2.Macute = 7742, e2.Mcircle = 9410, e2.Mdotaccent = 7744, e2.Mdotbelow = 7746, e2.Menarmenian = 1348, e2.Mmonospace = 65325, e2.Msmall = 63341, e2.Mturned = 412, e2.Mu = 924, e2.N = 78, e2.NJ = 458, e2.Nacute = 323, e2.Ncaron = 327, e2.Ncedilla = 325, e2.Ncircle = 9411, e2.Ncircumflexbelow = 7754, e2.Ncommaaccent = 325, e2.Ndotaccent = 7748, e2.Ndotbelow = 7750, e2.Nhookleft = 413, e2.Nineroman = 8552, e2.Nj = 459, e2.Njecyrillic = 1034, e2.Nlinebelow = 7752, e2.Nmonospace = 65326, e2.Nowarmenian = 1350, e2.Nsmall = 63342, e2.Ntilde = 209, e2.Ntildesmall = 63473, e2.Nu = 925, e2.O = 79, e2.OE = 338, e2.OEsmall = 63226, e2.Oacute = 211, e2.Oacutesmall = 63475, e2.Obarredcyrillic = 1256, e2.Obarreddieresiscyrillic = 1258, e2.Obreve = 334, e2.Ocaron = 465, e2.Ocenteredtilde = 415, e2.Ocircle = 9412, e2.Ocircumflex = 212, e2.Ocircumflexacute = 7888, e2.Ocircumflexdotbelow = 7896, e2.Ocircumflexgrave = 7890, e2.Ocircumflexhookabove = 7892, e2.Ocircumflexsmall = 63476, e2.Ocircumflextilde = 7894, e2.Ocyrillic = 1054, e2.Odblacute = 336, e2.Odblgrave = 524, e2.Odieresis = 214, e2.Odieresiscyrillic = 1254, e2.Odieresissmall = 63478, e2.Odotbelow = 7884, e2.Ogoneksmall = 63227, e2.Ograve = 210, e2.Ogravesmall = 63474, e2.Oharmenian = 1365, e2.Ohm = 8486, e2.Ohookabove = 7886, e2.Ohorn = 416, e2.Ohornacute = 7898, e2.Ohorndotbelow = 7906, e2.Ohorngrave = 7900, e2.Ohornhookabove = 7902, e2.Ohorntilde = 7904, e2.Ohungarumlaut = 336, e2.Oi = 418, e2.Oinvertedbreve = 526, e2.Omacron = 332, e2.Omacronacute = 7762, e2.Omacrongrave = 7760, e2.Omega = 8486, e2.Omegacyrillic = 1120, e2.Omegagreek = 937, e2.Omegaroundcyrillic = 1146, e2.Omegatitlocyrillic = 1148, e2.Omegatonos = 911, e2.Omicron = 927, e2.Omicrontonos = 908, e2.Omonospace = 65327, e2.Oneroman = 8544, e2.Oogonek = 490, e2.Oogonekmacron = 492, e2.Oopen = 390, e2.Oslash = 216, e2.Oslashacute = 510, e2.Oslashsmall = 63480, e2.Osmall = 63343, e2.Ostrokeacute = 510, e2.Otcyrillic = 1150, e2.Otilde = 213, e2.Otildeacute = 7756, e2.Otildedieresis = 7758, e2.Otildesmall = 63477, e2.P = 80, e2.Pacute = 7764, e2.Pcircle = 9413, e2.Pdotaccent = 7766, e2.Pecyrillic = 1055, e2.Peharmenian = 1354, e2.Pemiddlehookcyrillic = 1190, e2.Phi = 934, e2.Phook = 420, e2.Pi = 928, e2.Piwrarmenian = 1363, e2.Pmonospace = 65328, e2.Psi = 936, e2.Psicyrillic = 1136, e2.Psmall = 63344, e2.Q = 81, e2.Qcircle = 9414, e2.Qmonospace = 65329, e2.Qsmall = 63345, e2.R = 82, e2.Raarmenian = 1356, e2.Racute = 340, e2.Rcaron = 344, e2.Rcedilla = 342, e2.Rcircle = 9415, e2.Rcommaaccent = 342, e2.Rdblgrave = 528, e2.Rdotaccent = 7768, e2.Rdotbelow = 7770, e2.Rdotbelowmacron = 7772, e2.Reharmenian = 1360, e2.Rfraktur = 8476, e2.Rho = 929, e2.Ringsmall = 63228, e2.Rinvertedbreve = 530, e2.Rlinebelow = 7774, e2.Rmonospace = 65330, e2.Rsmall = 63346, e2.Rsmallinverted = 641, e2.Rsmallinvertedsuperior = 694, e2.S = 83, e2.SF010000 = 9484, e2.SF020000 = 9492, e2.SF030000 = 9488, e2.SF040000 = 9496, e2.SF050000 = 9532, e2.SF060000 = 9516, e2.SF070000 = 9524, e2.SF080000 = 9500, e2.SF090000 = 9508, e2.SF100000 = 9472, e2.SF110000 = 9474, e2.SF190000 = 9569, e2.SF200000 = 9570, e2.SF210000 = 9558, e2.SF220000 = 9557, e2.SF230000 = 9571, e2.SF240000 = 9553, e2.SF250000 = 9559, e2.SF260000 = 9565, e2.SF270000 = 9564, e2.SF280000 = 9563, e2.SF360000 = 9566, e2.SF370000 = 9567, e2.SF380000 = 9562, e2.SF390000 = 9556, e2.SF400000 = 9577, e2.SF410000 = 9574, e2.SF420000 = 9568, e2.SF430000 = 9552, e2.SF440000 = 9580, e2.SF450000 = 9575, e2.SF460000 = 9576, e2.SF470000 = 9572, e2.SF480000 = 9573, e2.SF490000 = 9561, e2.SF500000 = 9560, e2.SF510000 = 9554, e2.SF520000 = 9555, e2.SF530000 = 9579, e2.SF540000 = 9578, e2.Sacute = 346, e2.Sacutedotaccent = 7780, e2.Sampigreek = 992, e2.Scaron = 352, e2.Scarondotaccent = 7782, e2.Scaronsmall = 63229, e2.Scedilla = 350, e2.Schwa = 399, e2.Schwacyrillic = 1240, e2.Schwadieresiscyrillic = 1242, e2.Scircle = 9416, e2.Scircumflex = 348, e2.Scommaaccent = 536, e2.Sdotaccent = 7776, e2.Sdotbelow = 7778, e2.Sdotbelowdotaccent = 7784, e2.Seharmenian = 1357, e2.Sevenroman = 8550, e2.Shaarmenian = 1351, e2.Shacyrillic = 1064, e2.Shchacyrillic = 1065, e2.Sheicoptic = 994, e2.Shhacyrillic = 1210, e2.Shimacoptic = 1004, e2.Sigma = 931, e2.Sixroman = 8549, e2.Smonospace = 65331, e2.Softsigncyrillic = 1068, e2.Ssmall = 63347, e2.Stigmagreek = 986, e2.T = 84, e2.Tau = 932, e2.Tbar = 358, e2.Tcaron = 356, e2.Tcedilla = 354, e2.Tcircle = 9417, e2.Tcircumflexbelow = 7792, e2.Tcommaaccent = 354, e2.Tdotaccent = 7786, e2.Tdotbelow = 7788, e2.Tecyrillic = 1058, e2.Tedescendercyrillic = 1196, e2.Tenroman = 8553, e2.Tetsecyrillic = 1204, e2.Theta = 920, e2.Thook = 428, e2.Thorn = 222, e2.Thornsmall = 63486, e2.Threeroman = 8546, e2.Tildesmall = 63230, e2.Tiwnarmenian = 1359, e2.Tlinebelow = 7790, e2.Tmonospace = 65332, e2.Toarmenian = 1337, e2.Tonefive = 444, e2.Tonesix = 388, e2.Tonetwo = 423, e2.Tretroflexhook = 430, e2.Tsecyrillic = 1062, e2.Tshecyrillic = 1035, e2.Tsmall = 63348, e2.Twelveroman = 8555, e2.Tworoman = 8545, e2.U = 85, e2.Uacute = 218, e2.Uacutesmall = 63482, e2.Ubreve = 364, e2.Ucaron = 467, e2.Ucircle = 9418, e2.Ucircumflex = 219, e2.Ucircumflexbelow = 7798, e2.Ucircumflexsmall = 63483, e2.Ucyrillic = 1059, e2.Udblacute = 368, e2.Udblgrave = 532, e2.Udieresis = 220, e2.Udieresisacute = 471, e2.Udieresisbelow = 7794, e2.Udieresiscaron = 473, e2.Udieresiscyrillic = 1264, e2.Udieresisgrave = 475, e2.Udieresismacron = 469, e2.Udieresissmall = 63484, e2.Udotbelow = 7908, e2.Ugrave = 217, e2.Ugravesmall = 63481, e2.Uhookabove = 7910, e2.Uhorn = 431, e2.Uhornacute = 7912, e2.Uhorndotbelow = 7920, e2.Uhorngrave = 7914, e2.Uhornhookabove = 7916, e2.Uhorntilde = 7918, e2.Uhungarumlaut = 368, e2.Uhungarumlautcyrillic = 1266, e2.Uinvertedbreve = 534, e2.Ukcyrillic = 1144, e2.Umacron = 362, e2.Umacroncyrillic = 1262, e2.Umacrondieresis = 7802, e2.Umonospace = 65333, e2.Uogonek = 370, e2.Upsilon = 933, e2.Upsilon1 = 978, e2.Upsilonacutehooksymbolgreek = 979, e2.Upsilonafrican = 433, e2.Upsilondieresis = 939, e2.Upsilondieresishooksymbolgreek = 980, e2.Upsilonhooksymbol = 978, e2.Upsilontonos = 910, e2.Uring = 366, e2.Ushortcyrillic = 1038, e2.Usmall = 63349, e2.Ustraightcyrillic = 1198, e2.Ustraightstrokecyrillic = 1200, e2.Utilde = 360, e2.Utildeacute = 7800, e2.Utildebelow = 7796, e2.V = 86, e2.Vcircle = 9419, e2.Vdotbelow = 7806, e2.Vecyrillic = 1042, e2.Vewarmenian = 1358, e2.Vhook = 434, e2.Vmonospace = 65334, e2.Voarmenian = 1352, e2.Vsmall = 63350, e2.Vtilde = 7804, e2.W = 87, e2.Wacute = 7810, e2.Wcircle = 9420, e2.Wcircumflex = 372, e2.Wdieresis = 7812, e2.Wdotaccent = 7814, e2.Wdotbelow = 7816, e2.Wgrave = 7808, e2.Wmonospace = 65335, e2.Wsmall = 63351, e2.X = 88, e2.Xcircle = 9421, e2.Xdieresis = 7820, e2.Xdotaccent = 7818, e2.Xeharmenian = 1341, e2.Xi = 926, e2.Xmonospace = 65336, e2.Xsmall = 63352, e2.Y = 89, e2.Yacute = 221, e2.Yacutesmall = 63485, e2.Yatcyrillic = 1122, e2.Ycircle = 9422, e2.Ycircumflex = 374, e2.Ydieresis = 376, e2.Ydieresissmall = 63487, e2.Ydotaccent = 7822, e2.Ydotbelow = 7924, e2.Yericyrillic = 1067, e2.Yerudieresiscyrillic = 1272, e2.Ygrave = 7922, e2.Yhook = 435, e2.Yhookabove = 7926, e2.Yiarmenian = 1349, e2.Yicyrillic = 1031, e2.Yiwnarmenian = 1362, e2.Ymonospace = 65337, e2.Ysmall = 63353, e2.Ytilde = 7928, e2.Yusbigcyrillic = 1130, e2.Yusbigiotifiedcyrillic = 1132, e2.Yuslittlecyrillic = 1126, e2.Yuslittleiotifiedcyrillic = 1128, e2.Z = 90, e2.Zaarmenian = 1334, e2.Zacute = 377, e2.Zcaron = 381, e2.Zcaronsmall = 63231, e2.Zcircle = 9423, e2.Zcircumflex = 7824, e2.Zdot = 379, e2.Zdotaccent = 379, e2.Zdotbelow = 7826, e2.Zecyrillic = 1047, e2.Zedescendercyrillic = 1176, e2.Zedieresiscyrillic = 1246, e2.Zeta = 918, e2.Zhearmenian = 1338, e2.Zhebrevecyrillic = 1217, e2.Zhecyrillic = 1046, e2.Zhedescendercyrillic = 1174, e2.Zhedieresiscyrillic = 1244, e2.Zlinebelow = 7828, e2.Zmonospace = 65338, e2.Zsmall = 63354, e2.Zstroke = 437, e2.a = 97, e2.aabengali = 2438, e2.aacute = 225, e2.aadeva = 2310, e2.aagujarati = 2694, e2.aagurmukhi = 2566, e2.aamatragurmukhi = 2622, e2.aarusquare = 13059, e2.aavowelsignbengali = 2494, e2.aavowelsigndeva = 2366, e2.aavowelsigngujarati = 2750, e2.abbreviationmarkarmenian = 1375, e2.abbreviationsigndeva = 2416, e2.abengali = 2437, e2.abopomofo = 12570, e2.abreve = 259, e2.abreveacute = 7855, e2.abrevecyrillic = 1233, e2.abrevedotbelow = 7863, e2.abrevegrave = 7857, e2.abrevehookabove = 7859, e2.abrevetilde = 7861, e2.acaron = 462, e2.acircle = 9424, e2.acircumflex = 226, e2.acircumflexacute = 7845, e2.acircumflexdotbelow = 7853, e2.acircumflexgrave = 7847, e2.acircumflexhookabove = 7849, e2.acircumflextilde = 7851, e2.acute = 180, e2.acutebelowcmb = 791, e2.acutecmb = 769, e2.acutecomb = 769, e2.acutedeva = 2388, e2.acutelowmod = 719, e2.acutetonecmb = 833, e2.acyrillic = 1072, e2.adblgrave = 513, e2.addakgurmukhi = 2673, e2.adeva = 2309, e2.adieresis = 228, e2.adieresiscyrillic = 1235, e2.adieresismacron = 479, e2.adotbelow = 7841, e2.adotmacron = 481, e2.ae = 230, e2.aeacute = 509, e2.aekorean = 12624, e2.aemacron = 483, e2.afii00208 = 8213, e2.afii08941 = 8356, e2.afii10017 = 1040, e2.afii10018 = 1041, e2.afii10019 = 1042, e2.afii10020 = 1043, e2.afii10021 = 1044, e2.afii10022 = 1045, e2.afii10023 = 1025, e2.afii10024 = 1046, e2.afii10025 = 1047, e2.afii10026 = 1048, e2.afii10027 = 1049, e2.afii10028 = 1050, e2.afii10029 = 1051, e2.afii10030 = 1052;
      e2.afii10031 = 1053, e2.afii10032 = 1054, e2.afii10033 = 1055, e2.afii10034 = 1056, e2.afii10035 = 1057, e2.afii10036 = 1058, e2.afii10037 = 1059, e2.afii10038 = 1060, e2.afii10039 = 1061, e2.afii10040 = 1062, e2.afii10041 = 1063, e2.afii10042 = 1064, e2.afii10043 = 1065, e2.afii10044 = 1066, e2.afii10045 = 1067, e2.afii10046 = 1068, e2.afii10047 = 1069, e2.afii10048 = 1070, e2.afii10049 = 1071, e2.afii10050 = 1168, e2.afii10051 = 1026, e2.afii10052 = 1027, e2.afii10053 = 1028, e2.afii10054 = 1029, e2.afii10055 = 1030, e2.afii10056 = 1031, e2.afii10057 = 1032, e2.afii10058 = 1033, e2.afii10059 = 1034, e2.afii10060 = 1035, e2.afii10061 = 1036, e2.afii10062 = 1038, e2.afii10063 = 63172, e2.afii10064 = 63173, e2.afii10065 = 1072, e2.afii10066 = 1073, e2.afii10067 = 1074, e2.afii10068 = 1075, e2.afii10069 = 1076, e2.afii10070 = 1077, e2.afii10071 = 1105, e2.afii10072 = 1078, e2.afii10073 = 1079, e2.afii10074 = 1080, e2.afii10075 = 1081, e2.afii10076 = 1082, e2.afii10077 = 1083, e2.afii10078 = 1084, e2.afii10079 = 1085, e2.afii10080 = 1086, e2.afii10081 = 1087, e2.afii10082 = 1088, e2.afii10083 = 1089, e2.afii10084 = 1090, e2.afii10085 = 1091, e2.afii10086 = 1092, e2.afii10087 = 1093, e2.afii10088 = 1094, e2.afii10089 = 1095, e2.afii10090 = 1096, e2.afii10091 = 1097, e2.afii10092 = 1098, e2.afii10093 = 1099, e2.afii10094 = 1100, e2.afii10095 = 1101, e2.afii10096 = 1102, e2.afii10097 = 1103, e2.afii10098 = 1169, e2.afii10099 = 1106, e2.afii10100 = 1107, e2.afii10101 = 1108, e2.afii10102 = 1109, e2.afii10103 = 1110, e2.afii10104 = 1111, e2.afii10105 = 1112, e2.afii10106 = 1113, e2.afii10107 = 1114, e2.afii10108 = 1115, e2.afii10109 = 1116, e2.afii10110 = 1118, e2.afii10145 = 1039, e2.afii10146 = 1122, e2.afii10147 = 1138, e2.afii10148 = 1140, e2.afii10192 = 63174, e2.afii10193 = 1119, e2.afii10194 = 1123, e2.afii10195 = 1139, e2.afii10196 = 1141, e2.afii10831 = 63175, e2.afii10832 = 63176, e2.afii10846 = 1241, e2.afii299 = 8206, e2.afii300 = 8207, e2.afii301 = 8205, e2.afii57381 = 1642, e2.afii57388 = 1548, e2.afii57392 = 1632, e2.afii57393 = 1633, e2.afii57394 = 1634, e2.afii57395 = 1635, e2.afii57396 = 1636, e2.afii57397 = 1637, e2.afii57398 = 1638, e2.afii57399 = 1639, e2.afii57400 = 1640, e2.afii57401 = 1641, e2.afii57403 = 1563, e2.afii57407 = 1567, e2.afii57409 = 1569, e2.afii57410 = 1570, e2.afii57411 = 1571, e2.afii57412 = 1572, e2.afii57413 = 1573, e2.afii57414 = 1574, e2.afii57415 = 1575, e2.afii57416 = 1576, e2.afii57417 = 1577, e2.afii57418 = 1578, e2.afii57419 = 1579, e2.afii57420 = 1580, e2.afii57421 = 1581, e2.afii57422 = 1582, e2.afii57423 = 1583, e2.afii57424 = 1584, e2.afii57425 = 1585, e2.afii57426 = 1586, e2.afii57427 = 1587, e2.afii57428 = 1588, e2.afii57429 = 1589, e2.afii57430 = 1590, e2.afii57431 = 1591, e2.afii57432 = 1592, e2.afii57433 = 1593, e2.afii57434 = 1594, e2.afii57440 = 1600, e2.afii57441 = 1601, e2.afii57442 = 1602, e2.afii57443 = 1603, e2.afii57444 = 1604, e2.afii57445 = 1605, e2.afii57446 = 1606, e2.afii57448 = 1608, e2.afii57449 = 1609, e2.afii57450 = 1610, e2.afii57451 = 1611, e2.afii57452 = 1612, e2.afii57453 = 1613, e2.afii57454 = 1614, e2.afii57455 = 1615, e2.afii57456 = 1616, e2.afii57457 = 1617, e2.afii57458 = 1618, e2.afii57470 = 1607, e2.afii57505 = 1700, e2.afii57506 = 1662, e2.afii57507 = 1670, e2.afii57508 = 1688, e2.afii57509 = 1711, e2.afii57511 = 1657, e2.afii57512 = 1672, e2.afii57513 = 1681, e2.afii57514 = 1722, e2.afii57519 = 1746, e2.afii57534 = 1749, e2.afii57636 = 8362, e2.afii57645 = 1470, e2.afii57658 = 1475, e2.afii57664 = 1488, e2.afii57665 = 1489, e2.afii57666 = 1490, e2.afii57667 = 1491, e2.afii57668 = 1492, e2.afii57669 = 1493, e2.afii57670 = 1494, e2.afii57671 = 1495, e2.afii57672 = 1496, e2.afii57673 = 1497, e2.afii57674 = 1498, e2.afii57675 = 1499, e2.afii57676 = 1500, e2.afii57677 = 1501, e2.afii57678 = 1502, e2.afii57679 = 1503, e2.afii57680 = 1504, e2.afii57681 = 1505, e2.afii57682 = 1506, e2.afii57683 = 1507, e2.afii57684 = 1508, e2.afii57685 = 1509, e2.afii57686 = 1510, e2.afii57687 = 1511, e2.afii57688 = 1512, e2.afii57689 = 1513, e2.afii57690 = 1514, e2.afii57694 = 64298, e2.afii57695 = 64299, e2.afii57700 = 64331, e2.afii57705 = 64287, e2.afii57716 = 1520, e2.afii57717 = 1521, e2.afii57718 = 1522, e2.afii57723 = 64309, e2.afii57793 = 1460, e2.afii57794 = 1461, e2.afii57795 = 1462, e2.afii57796 = 1467, e2.afii57797 = 1464, e2.afii57798 = 1463, e2.afii57799 = 1456, e2.afii57800 = 1458, e2.afii57801 = 1457, e2.afii57802 = 1459, e2.afii57803 = 1474, e2.afii57804 = 1473, e2.afii57806 = 1465, e2.afii57807 = 1468, e2.afii57839 = 1469, e2.afii57841 = 1471, e2.afii57842 = 1472, e2.afii57929 = 700, e2.afii61248 = 8453, e2.afii61289 = 8467, e2.afii61352 = 8470, e2.afii61573 = 8236, e2.afii61574 = 8237, e2.afii61575 = 8238, e2.afii61664 = 8204, e2.afii63167 = 1645, e2.afii64937 = 701, e2.agrave = 224, e2.agujarati = 2693, e2.agurmukhi = 2565, e2.ahiragana = 12354, e2.ahookabove = 7843, e2.aibengali = 2448, e2.aibopomofo = 12574, e2.aideva = 2320, e2.aiecyrillic = 1237, e2.aigujarati = 2704, e2.aigurmukhi = 2576, e2.aimatragurmukhi = 2632, e2.ainarabic = 1593, e2.ainfinalarabic = 65226, e2.aininitialarabic = 65227, e2.ainmedialarabic = 65228, e2.ainvertedbreve = 515, e2.aivowelsignbengali = 2504, e2.aivowelsigndeva = 2376, e2.aivowelsigngujarati = 2760, e2.akatakana = 12450, e2.akatakanahalfwidth = 65393, e2.akorean = 12623, e2.alef = 1488, e2.alefarabic = 1575, e2.alefdageshhebrew = 64304, e2.aleffinalarabic = 65166, e2.alefhamzaabovearabic = 1571, e2.alefhamzaabovefinalarabic = 65156, e2.alefhamzabelowarabic = 1573, e2.alefhamzabelowfinalarabic = 65160, e2.alefhebrew = 1488, e2.aleflamedhebrew = 64335, e2.alefmaddaabovearabic = 1570, e2.alefmaddaabovefinalarabic = 65154, e2.alefmaksuraarabic = 1609, e2.alefmaksurafinalarabic = 65264, e2.alefmaksurainitialarabic = 65267, e2.alefmaksuramedialarabic = 65268, e2.alefpatahhebrew = 64302, e2.alefqamatshebrew = 64303, e2.aleph = 8501, e2.allequal = 8780, e2.alpha = 945, e2.alphatonos = 940, e2.amacron = 257, e2.amonospace = 65345, e2.ampersand = 38, e2.ampersandmonospace = 65286, e2.ampersandsmall = 63270, e2.amsquare = 13250, e2.anbopomofo = 12578, e2.angbopomofo = 12580, e2.angbracketleft = 12296, e2.angbracketright = 12297, e2.angkhankhuthai = 3674, e2.angle = 8736, e2.anglebracketleft = 12296, e2.anglebracketleftvertical = 65087, e2.anglebracketright = 12297, e2.anglebracketrightvertical = 65088, e2.angleleft = 9001, e2.angleright = 9002, e2.angstrom = 8491, e2.anoteleia = 903, e2.anudattadeva = 2386, e2.anusvarabengali = 2434, e2.anusvaradeva = 2306, e2.anusvaragujarati = 2690, e2.aogonek = 261, e2.apaatosquare = 13056, e2.aparen = 9372, e2.apostrophearmenian = 1370, e2.apostrophemod = 700, e2.apple = 63743, e2.approaches = 8784, e2.approxequal = 8776, e2.approxequalorimage = 8786, e2.approximatelyequal = 8773, e2.araeaekorean = 12686, e2.araeakorean = 12685, e2.arc = 8978, e2.arighthalfring = 7834, e2.aring = 229, e2.aringacute = 507, e2.aringbelow = 7681, e2.arrowboth = 8596, e2.arrowdashdown = 8675, e2.arrowdashleft = 8672, e2.arrowdashright = 8674, e2.arrowdashup = 8673, e2.arrowdblboth = 8660, e2.arrowdbldown = 8659, e2.arrowdblleft = 8656, e2.arrowdblright = 8658, e2.arrowdblup = 8657, e2.arrowdown = 8595, e2.arrowdownleft = 8601, e2.arrowdownright = 8600, e2.arrowdownwhite = 8681, e2.arrowheaddownmod = 709, e2.arrowheadleftmod = 706, e2.arrowheadrightmod = 707, e2.arrowheadupmod = 708, e2.arrowhorizex = 63719, e2.arrowleft = 8592, e2.arrowleftdbl = 8656, e2.arrowleftdblstroke = 8653, e2.arrowleftoverright = 8646, e2.arrowleftwhite = 8678, e2.arrowright = 8594, e2.arrowrightdblstroke = 8655, e2.arrowrightheavy = 10142, e2.arrowrightoverleft = 8644, e2.arrowrightwhite = 8680, e2.arrowtableft = 8676, e2.arrowtabright = 8677, e2.arrowup = 8593, e2.arrowupdn = 8597, e2.arrowupdnbse = 8616, e2.arrowupdownbase = 8616, e2.arrowupleft = 8598, e2.arrowupleftofdown = 8645, e2.arrowupright = 8599, e2.arrowupwhite = 8679, e2.arrowvertex = 63718, e2.asciicircum = 94, e2.asciicircummonospace = 65342, e2.asciitilde = 126, e2.asciitildemonospace = 65374, e2.ascript = 593, e2.ascriptturned = 594, e2.asmallhiragana = 12353, e2.asmallkatakana = 12449, e2.asmallkatakanahalfwidth = 65383, e2.asterisk = 42, e2.asteriskaltonearabic = 1645, e2.asteriskarabic = 1645, e2.asteriskmath = 8727, e2.asteriskmonospace = 65290, e2.asterisksmall = 65121, e2.asterism = 8258, e2.asuperior = 63209, e2.asymptoticallyequal = 8771, e2.at = 64, e2.atilde = 227, e2.atmonospace = 65312, e2.atsmall = 65131, e2.aturned = 592, e2.aubengali = 2452, e2.aubopomofo = 12576, e2.audeva = 2324, e2.augujarati = 2708, e2.augurmukhi = 2580, e2.aulengthmarkbengali = 2519, e2.aumatragurmukhi = 2636, e2.auvowelsignbengali = 2508, e2.auvowelsigndeva = 2380, e2.auvowelsigngujarati = 2764, e2.avagrahadeva = 2365, e2.aybarmenian = 1377, e2.ayin = 1506, e2.ayinaltonehebrew = 64288, e2.ayinhebrew = 1506, e2.b = 98, e2.babengali = 2476, e2.backslash = 92, e2.backslashmonospace = 65340, e2.badeva = 2348, e2.bagujarati = 2732, e2.bagurmukhi = 2604, e2.bahiragana = 12400, e2.bahtthai = 3647, e2.bakatakana = 12496, e2.bar = 124, e2.barmonospace = 65372, e2.bbopomofo = 12549, e2.bcircle = 9425, e2.bdotaccent = 7683, e2.bdotbelow = 7685, e2.beamedsixteenthnotes = 9836, e2.because = 8757, e2.becyrillic = 1073, e2.beharabic = 1576, e2.behfinalarabic = 65168, e2.behinitialarabic = 65169, e2.behiragana = 12409, e2.behmedialarabic = 65170, e2.behmeeminitialarabic = 64671, e2.behmeemisolatedarabic = 64520, e2.behnoonfinalarabic = 64621, e2.bekatakana = 12505, e2.benarmenian = 1378, e2.bet = 1489, e2.beta = 946, e2.betasymbolgreek = 976, e2.betdagesh = 64305, e2.betdageshhebrew = 64305, e2.bethebrew = 1489, e2.betrafehebrew = 64332, e2.bhabengali = 2477, e2.bhadeva = 2349, e2.bhagujarati = 2733, e2.bhagurmukhi = 2605, e2.bhook = 595, e2.bihiragana = 12403, e2.bikatakana = 12499, e2.bilabialclick = 664, e2.bindigurmukhi = 2562, e2.birusquare = 13105, e2.blackcircle = 9679, e2.blackdiamond = 9670, e2.blackdownpointingtriangle = 9660, e2.blackleftpointingpointer = 9668, e2.blackleftpointingtriangle = 9664, e2.blacklenticularbracketleft = 12304, e2.blacklenticularbracketleftvertical = 65083, e2.blacklenticularbracketright = 12305, e2.blacklenticularbracketrightvertical = 65084, e2.blacklowerlefttriangle = 9699, e2.blacklowerrighttriangle = 9698, e2.blackrectangle = 9644, e2.blackrightpointingpointer = 9658, e2.blackrightpointingtriangle = 9654, e2.blacksmallsquare = 9642, e2.blacksmilingface = 9787, e2.blacksquare = 9632, e2.blackstar = 9733, e2.blackupperlefttriangle = 9700, e2.blackupperrighttriangle = 9701, e2.blackuppointingsmalltriangle = 9652, e2.blackuppointingtriangle = 9650, e2.blank = 9251, e2.blinebelow = 7687, e2.block = 9608, e2.bmonospace = 65346, e2.bobaimaithai = 3610, e2.bohiragana = 12412, e2.bokatakana = 12508, e2.bparen = 9373, e2.bqsquare = 13251, e2.braceex = 63732, e2.braceleft = 123, e2.braceleftbt = 63731, e2.braceleftmid = 63730, e2.braceleftmonospace = 65371, e2.braceleftsmall = 65115, e2.bracelefttp = 63729, e2.braceleftvertical = 65079, e2.braceright = 125, e2.bracerightbt = 63742, e2.bracerightmid = 63741, e2.bracerightmonospace = 65373, e2.bracerightsmall = 65116, e2.bracerighttp = 63740, e2.bracerightvertical = 65080, e2.bracketleft = 91, e2.bracketleftbt = 63728, e2.bracketleftex = 63727, e2.bracketleftmonospace = 65339, e2.bracketlefttp = 63726, e2.bracketright = 93, e2.bracketrightbt = 63739, e2.bracketrightex = 63738, e2.bracketrightmonospace = 65341, e2.bracketrighttp = 63737, e2.breve = 728, e2.brevebelowcmb = 814, e2.brevecmb = 774, e2.breveinvertedbelowcmb = 815, e2.breveinvertedcmb = 785, e2.breveinverteddoublecmb = 865, e2.bridgebelowcmb = 810, e2.bridgeinvertedbelowcmb = 826, e2.brokenbar = 166, e2.bstroke = 384, e2.bsuperior = 63210, e2.btopbar = 387, e2.buhiragana = 12406, e2.bukatakana = 12502, e2.bullet = 8226, e2.bulletinverse = 9688, e2.bulletoperator = 8729, e2.bullseye = 9678, e2.c = 99, e2.caarmenian = 1390, e2.cabengali = 2458, e2.cacute = 263, e2.cadeva = 2330, e2.cagujarati = 2714, e2.cagurmukhi = 2586, e2.calsquare = 13192, e2.candrabindubengali = 2433, e2.candrabinducmb = 784, e2.candrabindudeva = 2305, e2.candrabindugujarati = 2689, e2.capslock = 8682, e2.careof = 8453, e2.caron = 711, e2.caronbelowcmb = 812, e2.caroncmb = 780, e2.carriagereturn = 8629, e2.cbopomofo = 12568, e2.ccaron = 269, e2.ccedilla = 231, e2.ccedillaacute = 7689, e2.ccircle = 9426, e2.ccircumflex = 265, e2.ccurl = 597, e2.cdot = 267, e2.cdotaccent = 267, e2.cdsquare = 13253, e2.cedilla = 184, e2.cedillacmb = 807, e2.cent = 162, e2.centigrade = 8451, e2.centinferior = 63199, e2.centmonospace = 65504, e2.centoldstyle = 63394, e2.centsuperior = 63200, e2.chaarmenian = 1401, e2.chabengali = 2459, e2.chadeva = 2331, e2.chagujarati = 2715, e2.chagurmukhi = 2587, e2.chbopomofo = 12564, e2.cheabkhasiancyrillic = 1213, e2.checkmark = 10003, e2.checyrillic = 1095, e2.chedescenderabkhasiancyrillic = 1215, e2.chedescendercyrillic = 1207, e2.chedieresiscyrillic = 1269, e2.cheharmenian = 1395, e2.chekhakassiancyrillic = 1228, e2.cheverticalstrokecyrillic = 1209, e2.chi = 967, e2.chieuchacirclekorean = 12919, e2.chieuchaparenkorean = 12823, e2.chieuchcirclekorean = 12905, e2.chieuchkorean = 12618, e2.chieuchparenkorean = 12809, e2.chochangthai = 3594, e2.chochanthai = 3592, e2.chochingthai = 3593, e2.chochoethai = 3596, e2.chook = 392, e2.cieucacirclekorean = 12918, e2.cieucaparenkorean = 12822, e2.cieuccirclekorean = 12904, e2.cieuckorean = 12616, e2.cieucparenkorean = 12808, e2.cieucuparenkorean = 12828, e2.circle = 9675, e2.circlecopyrt = 169, e2.circlemultiply = 8855, e2.circleot = 8857, e2.circleplus = 8853, e2.circlepostalmark = 12342, e2.circlewithlefthalfblack = 9680, e2.circlewithrighthalfblack = 9681, e2.circumflex = 710, e2.circumflexbelowcmb = 813, e2.circumflexcmb = 770, e2.clear = 8999, e2.clickalveolar = 450, e2.clickdental = 448, e2.clicklateral = 449, e2.clickretroflex = 451, e2.club = 9827, e2.clubsuitblack = 9827, e2.clubsuitwhite = 9831, e2.cmcubedsquare = 13220, e2.cmonospace = 65347, e2.cmsquaredsquare = 13216, e2.coarmenian = 1409, e2.colon = 58, e2.colonmonetary = 8353, e2.colonmonospace = 65306, e2.colonsign = 8353, e2.colonsmall = 65109, e2.colontriangularhalfmod = 721, e2.colontriangularmod = 720, e2.comma = 44, e2.commaabovecmb = 787, e2.commaaboverightcmb = 789, e2.commaaccent = 63171, e2.commaarabic = 1548, e2.commaarmenian = 1373, e2.commainferior = 63201, e2.commamonospace = 65292, e2.commareversedabovecmb = 788, e2.commareversedmod = 701, e2.commasmall = 65104, e2.commasuperior = 63202, e2.commaturnedabovecmb = 786, e2.commaturnedmod = 699, e2.compass = 9788, e2.congruent = 8773, e2.contourintegral = 8750, e2.control = 8963, e2.controlACK = 6, e2.controlBEL = 7, e2.controlBS = 8, e2.controlCAN = 24, e2.controlCR = 13, e2.controlDC1 = 17, e2.controlDC2 = 18, e2.controlDC3 = 19, e2.controlDC4 = 20, e2.controlDEL = 127, e2.controlDLE = 16, e2.controlEM = 25, e2.controlENQ = 5, e2.controlEOT = 4, e2.controlESC = 27, e2.controlETB = 23, e2.controlETX = 3, e2.controlFF = 12, e2.controlFS = 28, e2.controlGS = 29, e2.controlHT = 9, e2.controlLF = 10, e2.controlNAK = 21, e2.controlNULL = 0, e2.controlRS = 30, e2.controlSI = 15, e2.controlSO = 14, e2.controlSOT = 2, e2.controlSTX = 1, e2.controlSUB = 26, e2.controlSYN = 22, e2.controlUS = 31, e2.controlVT = 11, e2.copyright = 169, e2.copyrightsans = 63721, e2.copyrightserif = 63193, e2.cornerbracketleft = 12300, e2.cornerbracketlefthalfwidth = 65378, e2.cornerbracketleftvertical = 65089, e2.cornerbracketright = 12301, e2.cornerbracketrighthalfwidth = 65379, e2.cornerbracketrightvertical = 65090, e2.corporationsquare = 13183, e2.cosquare = 13255, e2.coverkgsquare = 13254, e2.cparen = 9374, e2.cruzeiro = 8354, e2.cstretched = 663, e2.curlyand = 8911, e2.curlyor = 8910, e2.currency = 164, e2.cyrBreve = 63185, e2.cyrFlex = 63186, e2.cyrbreve = 63188, e2.cyrflex = 63189, e2.d = 100, e2.daarmenian = 1380, e2.dabengali = 2470, e2.dadarabic = 1590, e2.dadeva = 2342, e2.dadfinalarabic = 65214, e2.dadinitialarabic = 65215, e2.dadmedialarabic = 65216, e2.dagesh = 1468, e2.dageshhebrew = 1468, e2.dagger = 8224, e2.daggerdbl = 8225, e2.dagujarati = 2726, e2.dagurmukhi = 2598, e2.dahiragana = 12384, e2.dakatakana = 12480, e2.dalarabic = 1583, e2.dalet = 1491, e2.daletdagesh = 64307, e2.daletdageshhebrew = 64307, e2.dalethebrew = 1491, e2.dalfinalarabic = 65194, e2.dammaarabic = 1615, e2.dammalowarabic = 1615, e2.dammatanaltonearabic = 1612, e2.dammatanarabic = 1612, e2.danda = 2404, e2.dargahebrew = 1447, e2.dargalefthebrew = 1447, e2.dasiapneumatacyrilliccmb = 1157, e2.dblGrave = 63187, e2.dblanglebracketleft = 12298, e2.dblanglebracketleftvertical = 65085, e2.dblanglebracketright = 12299, e2.dblanglebracketrightvertical = 65086, e2.dblarchinvertedbelowcmb = 811, e2.dblarrowleft = 8660, e2.dblarrowright = 8658, e2.dbldanda = 2405, e2.dblgrave = 63190, e2.dblgravecmb = 783, e2.dblintegral = 8748, e2.dbllowline = 8215, e2.dbllowlinecmb = 819, e2.dbloverlinecmb = 831, e2.dblprimemod = 698, e2.dblverticalbar = 8214, e2.dblverticallineabovecmb = 782, e2.dbopomofo = 12553, e2.dbsquare = 13256, e2.dcaron = 271, e2.dcedilla = 7697, e2.dcircle = 9427, e2.dcircumflexbelow = 7699, e2.dcroat = 273, e2.ddabengali = 2465, e2.ddadeva = 2337, e2.ddagujarati = 2721, e2.ddagurmukhi = 2593, e2.ddalarabic = 1672, e2.ddalfinalarabic = 64393, e2.dddhadeva = 2396, e2.ddhabengali = 2466, e2.ddhadeva = 2338, e2.ddhagujarati = 2722, e2.ddhagurmukhi = 2594, e2.ddotaccent = 7691, e2.ddotbelow = 7693, e2.decimalseparatorarabic = 1643, e2.decimalseparatorpersian = 1643, e2.decyrillic = 1076, e2.degree = 176, e2.dehihebrew = 1453, e2.dehiragana = 12391, e2.deicoptic = 1007, e2.dekatakana = 12487, e2.deleteleft = 9003, e2.deleteright = 8998, e2.delta = 948, e2.deltaturned = 397, e2.denominatorminusonenumeratorbengali = 2552, e2.dezh = 676, e2.dhabengali = 2471, e2.dhadeva = 2343, e2.dhagujarati = 2727, e2.dhagurmukhi = 2599, e2.dhook = 599, e2.dialytikatonos = 901, e2.dialytikatonoscmb = 836, e2.diamond = 9830, e2.diamondsuitwhite = 9826, e2.dieresis = 168, e2.dieresisacute = 63191, e2.dieresisbelowcmb = 804, e2.dieresiscmb = 776, e2.dieresisgrave = 63192, e2.dieresistonos = 901, e2.dihiragana = 12386, e2.dikatakana = 12482, e2.dittomark = 12291, e2.divide = 247, e2.divides = 8739, e2.divisionslash = 8725, e2.djecyrillic = 1106, e2.dkshade = 9619, e2.dlinebelow = 7695, e2.dlsquare = 13207, e2.dmacron = 273, e2.dmonospace = 65348, e2.dnblock = 9604, e2.dochadathai = 3598, e2.dodekthai = 3604, e2.dohiragana = 12393, e2.dokatakana = 12489, e2.dollar = 36;
      e2.dollarinferior = 63203, e2.dollarmonospace = 65284, e2.dollaroldstyle = 63268, e2.dollarsmall = 65129, e2.dollarsuperior = 63204, e2.dong = 8363, e2.dorusquare = 13094, e2.dotaccent = 729, e2.dotaccentcmb = 775, e2.dotbelowcmb = 803, e2.dotbelowcomb = 803, e2.dotkatakana = 12539, e2.dotlessi = 305, e2.dotlessj = 63166, e2.dotlessjstrokehook = 644, e2.dotmath = 8901, e2.dottedcircle = 9676, e2.doubleyodpatah = 64287, e2.doubleyodpatahhebrew = 64287, e2.downtackbelowcmb = 798, e2.downtackmod = 725, e2.dparen = 9375, e2.dsuperior = 63211, e2.dtail = 598, e2.dtopbar = 396, e2.duhiragana = 12389, e2.dukatakana = 12485, e2.dz = 499, e2.dzaltone = 675, e2.dzcaron = 454, e2.dzcurl = 677, e2.dzeabkhasiancyrillic = 1249, e2.dzecyrillic = 1109, e2.dzhecyrillic = 1119, e2.e = 101, e2.eacute = 233, e2.earth = 9793, e2.ebengali = 2447, e2.ebopomofo = 12572, e2.ebreve = 277, e2.ecandradeva = 2317, e2.ecandragujarati = 2701, e2.ecandravowelsigndeva = 2373, e2.ecandravowelsigngujarati = 2757, e2.ecaron = 283, e2.ecedillabreve = 7709, e2.echarmenian = 1381, e2.echyiwnarmenian = 1415, e2.ecircle = 9428, e2.ecircumflex = 234, e2.ecircumflexacute = 7871, e2.ecircumflexbelow = 7705, e2.ecircumflexdotbelow = 7879, e2.ecircumflexgrave = 7873, e2.ecircumflexhookabove = 7875, e2.ecircumflextilde = 7877, e2.ecyrillic = 1108, e2.edblgrave = 517, e2.edeva = 2319, e2.edieresis = 235, e2.edot = 279, e2.edotaccent = 279, e2.edotbelow = 7865, e2.eegurmukhi = 2575, e2.eematragurmukhi = 2631, e2.efcyrillic = 1092, e2.egrave = 232, e2.egujarati = 2703, e2.eharmenian = 1383, e2.ehbopomofo = 12573, e2.ehiragana = 12360, e2.ehookabove = 7867, e2.eibopomofo = 12575, e2.eight = 56, e2.eightarabic = 1640, e2.eightbengali = 2542, e2.eightcircle = 9319, e2.eightcircleinversesansserif = 10129, e2.eightdeva = 2414, e2.eighteencircle = 9329, e2.eighteenparen = 9349, e2.eighteenperiod = 9369, e2.eightgujarati = 2798, e2.eightgurmukhi = 2670, e2.eighthackarabic = 1640, e2.eighthangzhou = 12328, e2.eighthnotebeamed = 9835, e2.eightideographicparen = 12839, e2.eightinferior = 8328, e2.eightmonospace = 65304, e2.eightoldstyle = 63288, e2.eightparen = 9339, e2.eightperiod = 9359, e2.eightpersian = 1784, e2.eightroman = 8567, e2.eightsuperior = 8312, e2.eightthai = 3672, e2.einvertedbreve = 519, e2.eiotifiedcyrillic = 1125, e2.ekatakana = 12456, e2.ekatakanahalfwidth = 65396, e2.ekonkargurmukhi = 2676, e2.ekorean = 12628, e2.elcyrillic = 1083, e2.element = 8712, e2.elevencircle = 9322, e2.elevenparen = 9342, e2.elevenperiod = 9362, e2.elevenroman = 8570, e2.ellipsis = 8230, e2.ellipsisvertical = 8942, e2.emacron = 275, e2.emacronacute = 7703, e2.emacrongrave = 7701, e2.emcyrillic = 1084, e2.emdash = 8212, e2.emdashvertical = 65073, e2.emonospace = 65349, e2.emphasismarkarmenian = 1371, e2.emptyset = 8709, e2.enbopomofo = 12579, e2.encyrillic = 1085, e2.endash = 8211, e2.endashvertical = 65074, e2.endescendercyrillic = 1187, e2.eng = 331, e2.engbopomofo = 12581, e2.enghecyrillic = 1189, e2.enhookcyrillic = 1224, e2.enspace = 8194, e2.eogonek = 281, e2.eokorean = 12627, e2.eopen = 603, e2.eopenclosed = 666, e2.eopenreversed = 604, e2.eopenreversedclosed = 606, e2.eopenreversedhook = 605, e2.eparen = 9376, e2.epsilon = 949, e2.epsilontonos = 941, e2.equal = 61, e2.equalmonospace = 65309, e2.equalsmall = 65126, e2.equalsuperior = 8316, e2.equivalence = 8801, e2.erbopomofo = 12582, e2.ercyrillic = 1088, e2.ereversed = 600, e2.ereversedcyrillic = 1101, e2.escyrillic = 1089, e2.esdescendercyrillic = 1195, e2.esh = 643, e2.eshcurl = 646, e2.eshortdeva = 2318, e2.eshortvowelsigndeva = 2374, e2.eshreversedloop = 426, e2.eshsquatreversed = 645, e2.esmallhiragana = 12359, e2.esmallkatakana = 12455, e2.esmallkatakanahalfwidth = 65386, e2.estimated = 8494, e2.esuperior = 63212, e2.eta = 951, e2.etarmenian = 1384, e2.etatonos = 942, e2.eth = 240, e2.etilde = 7869, e2.etildebelow = 7707, e2.etnahtafoukhhebrew = 1425, e2.etnahtafoukhlefthebrew = 1425, e2.etnahtahebrew = 1425, e2.etnahtalefthebrew = 1425, e2.eturned = 477, e2.eukorean = 12641, e2.euro = 8364, e2.evowelsignbengali = 2503, e2.evowelsigndeva = 2375, e2.evowelsigngujarati = 2759, e2.exclam = 33, e2.exclamarmenian = 1372, e2.exclamdbl = 8252, e2.exclamdown = 161, e2.exclamdownsmall = 63393, e2.exclammonospace = 65281, e2.exclamsmall = 63265, e2.existential = 8707, e2.ezh = 658, e2.ezhcaron = 495, e2.ezhcurl = 659, e2.ezhreversed = 441, e2.ezhtail = 442, e2.f = 102, e2.fadeva = 2398, e2.fagurmukhi = 2654, e2.fahrenheit = 8457, e2.fathaarabic = 1614, e2.fathalowarabic = 1614, e2.fathatanarabic = 1611, e2.fbopomofo = 12552, e2.fcircle = 9429, e2.fdotaccent = 7711, e2.feharabic = 1601, e2.feharmenian = 1414, e2.fehfinalarabic = 65234, e2.fehinitialarabic = 65235, e2.fehmedialarabic = 65236, e2.feicoptic = 997, e2.female = 9792, e2.ff = 64256, e2.f_f = 64256, e2.ffi = 64259, e2.f_f_i = 64259, e2.ffl = 64260, e2.f_f_l = 64260, e2.fi = 64257, e2.f_i = 64257, e2.fifteencircle = 9326, e2.fifteenparen = 9346, e2.fifteenperiod = 9366, e2.figuredash = 8210, e2.filledbox = 9632, e2.filledrect = 9644, e2.finalkaf = 1498, e2.finalkafdagesh = 64314, e2.finalkafdageshhebrew = 64314, e2.finalkafhebrew = 1498, e2.finalmem = 1501, e2.finalmemhebrew = 1501, e2.finalnun = 1503, e2.finalnunhebrew = 1503, e2.finalpe = 1507, e2.finalpehebrew = 1507, e2.finaltsadi = 1509, e2.finaltsadihebrew = 1509, e2.firsttonechinese = 713, e2.fisheye = 9673, e2.fitacyrillic = 1139, e2.five = 53, e2.fivearabic = 1637, e2.fivebengali = 2539, e2.fivecircle = 9316, e2.fivecircleinversesansserif = 10126, e2.fivedeva = 2411, e2.fiveeighths = 8541, e2.fivegujarati = 2795, e2.fivegurmukhi = 2667, e2.fivehackarabic = 1637, e2.fivehangzhou = 12325, e2.fiveideographicparen = 12836, e2.fiveinferior = 8325, e2.fivemonospace = 65301, e2.fiveoldstyle = 63285, e2.fiveparen = 9336, e2.fiveperiod = 9356, e2.fivepersian = 1781, e2.fiveroman = 8564, e2.fivesuperior = 8309, e2.fivethai = 3669, e2.fl = 64258, e2.f_l = 64258, e2.florin = 402, e2.fmonospace = 65350, e2.fmsquare = 13209, e2.fofanthai = 3615, e2.fofathai = 3613, e2.fongmanthai = 3663, e2.forall = 8704, e2.four = 52, e2.fourarabic = 1636, e2.fourbengali = 2538, e2.fourcircle = 9315, e2.fourcircleinversesansserif = 10125, e2.fourdeva = 2410, e2.fourgujarati = 2794, e2.fourgurmukhi = 2666, e2.fourhackarabic = 1636, e2.fourhangzhou = 12324, e2.fourideographicparen = 12835, e2.fourinferior = 8324, e2.fourmonospace = 65300, e2.fournumeratorbengali = 2551, e2.fouroldstyle = 63284, e2.fourparen = 9335, e2.fourperiod = 9355, e2.fourpersian = 1780, e2.fourroman = 8563, e2.foursuperior = 8308, e2.fourteencircle = 9325, e2.fourteenparen = 9345, e2.fourteenperiod = 9365, e2.fourthai = 3668, e2.fourthtonechinese = 715, e2.fparen = 9377, e2.fraction = 8260, e2.franc = 8355, e2.g = 103, e2.gabengali = 2455, e2.gacute = 501, e2.gadeva = 2327, e2.gafarabic = 1711, e2.gaffinalarabic = 64403, e2.gafinitialarabic = 64404, e2.gafmedialarabic = 64405, e2.gagujarati = 2711, e2.gagurmukhi = 2583, e2.gahiragana = 12364, e2.gakatakana = 12460, e2.gamma = 947, e2.gammalatinsmall = 611, e2.gammasuperior = 736, e2.gangiacoptic = 1003, e2.gbopomofo = 12557, e2.gbreve = 287, e2.gcaron = 487, e2.gcedilla = 291, e2.gcircle = 9430, e2.gcircumflex = 285, e2.gcommaaccent = 291, e2.gdot = 289, e2.gdotaccent = 289, e2.gecyrillic = 1075, e2.gehiragana = 12370, e2.gekatakana = 12466, e2.geometricallyequal = 8785, e2.gereshaccenthebrew = 1436, e2.gereshhebrew = 1523, e2.gereshmuqdamhebrew = 1437, e2.germandbls = 223, e2.gershayimaccenthebrew = 1438, e2.gershayimhebrew = 1524, e2.getamark = 12307, e2.ghabengali = 2456, e2.ghadarmenian = 1394, e2.ghadeva = 2328, e2.ghagujarati = 2712, e2.ghagurmukhi = 2584, e2.ghainarabic = 1594, e2.ghainfinalarabic = 65230, e2.ghaininitialarabic = 65231, e2.ghainmedialarabic = 65232, e2.ghemiddlehookcyrillic = 1173, e2.ghestrokecyrillic = 1171, e2.gheupturncyrillic = 1169, e2.ghhadeva = 2394, e2.ghhagurmukhi = 2650, e2.ghook = 608, e2.ghzsquare = 13203, e2.gihiragana = 12366, e2.gikatakana = 12462, e2.gimarmenian = 1379, e2.gimel = 1490, e2.gimeldagesh = 64306, e2.gimeldageshhebrew = 64306, e2.gimelhebrew = 1490, e2.gjecyrillic = 1107, e2.glottalinvertedstroke = 446, e2.glottalstop = 660, e2.glottalstopinverted = 662, e2.glottalstopmod = 704, e2.glottalstopreversed = 661, e2.glottalstopreversedmod = 705, e2.glottalstopreversedsuperior = 740, e2.glottalstopstroke = 673, e2.glottalstopstrokereversed = 674, e2.gmacron = 7713, e2.gmonospace = 65351, e2.gohiragana = 12372, e2.gokatakana = 12468, e2.gparen = 9378, e2.gpasquare = 13228, e2.gradient = 8711, e2.grave = 96, e2.gravebelowcmb = 790, e2.gravecmb = 768, e2.gravecomb = 768, e2.gravedeva = 2387, e2.gravelowmod = 718, e2.gravemonospace = 65344, e2.gravetonecmb = 832, e2.greater = 62, e2.greaterequal = 8805, e2.greaterequalorless = 8923, e2.greatermonospace = 65310, e2.greaterorequivalent = 8819, e2.greaterorless = 8823, e2.greateroverequal = 8807, e2.greatersmall = 65125, e2.gscript = 609, e2.gstroke = 485, e2.guhiragana = 12368, e2.guillemotleft = 171, e2.guillemotright = 187, e2.guilsinglleft = 8249, e2.guilsinglright = 8250, e2.gukatakana = 12464, e2.guramusquare = 13080, e2.gysquare = 13257, e2.h = 104, e2.haabkhasiancyrillic = 1193, e2.haaltonearabic = 1729, e2.habengali = 2489, e2.hadescendercyrillic = 1203, e2.hadeva = 2361, e2.hagujarati = 2745, e2.hagurmukhi = 2617, e2.haharabic = 1581, e2.hahfinalarabic = 65186, e2.hahinitialarabic = 65187, e2.hahiragana = 12399, e2.hahmedialarabic = 65188, e2.haitusquare = 13098, e2.hakatakana = 12495, e2.hakatakanahalfwidth = 65418, e2.halantgurmukhi = 2637, e2.hamzaarabic = 1569, e2.hamzalowarabic = 1569, e2.hangulfiller = 12644, e2.hardsigncyrillic = 1098, e2.harpoonleftbarbup = 8636, e2.harpoonrightbarbup = 8640, e2.hasquare = 13258, e2.hatafpatah = 1458, e2.hatafpatah16 = 1458, e2.hatafpatah23 = 1458, e2.hatafpatah2f = 1458, e2.hatafpatahhebrew = 1458, e2.hatafpatahnarrowhebrew = 1458, e2.hatafpatahquarterhebrew = 1458, e2.hatafpatahwidehebrew = 1458, e2.hatafqamats = 1459, e2.hatafqamats1b = 1459, e2.hatafqamats28 = 1459, e2.hatafqamats34 = 1459, e2.hatafqamatshebrew = 1459, e2.hatafqamatsnarrowhebrew = 1459, e2.hatafqamatsquarterhebrew = 1459, e2.hatafqamatswidehebrew = 1459, e2.hatafsegol = 1457, e2.hatafsegol17 = 1457, e2.hatafsegol24 = 1457, e2.hatafsegol30 = 1457, e2.hatafsegolhebrew = 1457, e2.hatafsegolnarrowhebrew = 1457, e2.hatafsegolquarterhebrew = 1457, e2.hatafsegolwidehebrew = 1457, e2.hbar = 295, e2.hbopomofo = 12559, e2.hbrevebelow = 7723, e2.hcedilla = 7721, e2.hcircle = 9431, e2.hcircumflex = 293, e2.hdieresis = 7719, e2.hdotaccent = 7715, e2.hdotbelow = 7717, e2.he = 1492, e2.heart = 9829, e2.heartsuitblack = 9829, e2.heartsuitwhite = 9825, e2.hedagesh = 64308, e2.hedageshhebrew = 64308, e2.hehaltonearabic = 1729, e2.heharabic = 1607, e2.hehebrew = 1492, e2.hehfinalaltonearabic = 64423, e2.hehfinalalttwoarabic = 65258, e2.hehfinalarabic = 65258, e2.hehhamzaabovefinalarabic = 64421, e2.hehhamzaaboveisolatedarabic = 64420, e2.hehinitialaltonearabic = 64424, e2.hehinitialarabic = 65259, e2.hehiragana = 12408, e2.hehmedialaltonearabic = 64425, e2.hehmedialarabic = 65260, e2.heiseierasquare = 13179, e2.hekatakana = 12504, e2.hekatakanahalfwidth = 65421, e2.hekutaarusquare = 13110, e2.henghook = 615, e2.herutusquare = 13113, e2.het = 1495, e2.hethebrew = 1495, e2.hhook = 614, e2.hhooksuperior = 689, e2.hieuhacirclekorean = 12923, e2.hieuhaparenkorean = 12827, e2.hieuhcirclekorean = 12909, e2.hieuhkorean = 12622, e2.hieuhparenkorean = 12813, e2.hihiragana = 12402, e2.hikatakana = 12498, e2.hikatakanahalfwidth = 65419, e2.hiriq = 1460, e2.hiriq14 = 1460, e2.hiriq21 = 1460, e2.hiriq2d = 1460, e2.hiriqhebrew = 1460, e2.hiriqnarrowhebrew = 1460, e2.hiriqquarterhebrew = 1460, e2.hiriqwidehebrew = 1460, e2.hlinebelow = 7830, e2.hmonospace = 65352, e2.hoarmenian = 1392, e2.hohipthai = 3627, e2.hohiragana = 12411, e2.hokatakana = 12507, e2.hokatakanahalfwidth = 65422, e2.holam = 1465, e2.holam19 = 1465, e2.holam26 = 1465, e2.holam32 = 1465, e2.holamhebrew = 1465, e2.holamnarrowhebrew = 1465, e2.holamquarterhebrew = 1465, e2.holamwidehebrew = 1465, e2.honokhukthai = 3630, e2.hookabovecomb = 777, e2.hookcmb = 777, e2.hookpalatalizedbelowcmb = 801, e2.hookretroflexbelowcmb = 802, e2.hoonsquare = 13122, e2.horicoptic = 1001, e2.horizontalbar = 8213, e2.horncmb = 795, e2.hotsprings = 9832, e2.house = 8962, e2.hparen = 9379, e2.hsuperior = 688, e2.hturned = 613, e2.huhiragana = 12405, e2.huiitosquare = 13107, e2.hukatakana = 12501, e2.hukatakanahalfwidth = 65420, e2.hungarumlaut = 733, e2.hungarumlautcmb = 779, e2.hv = 405, e2.hyphen = 45, e2.hypheninferior = 63205, e2.hyphenmonospace = 65293, e2.hyphensmall = 65123, e2.hyphensuperior = 63206, e2.hyphentwo = 8208, e2.i = 105, e2.iacute = 237, e2.iacyrillic = 1103, e2.ibengali = 2439, e2.ibopomofo = 12583, e2.ibreve = 301, e2.icaron = 464, e2.icircle = 9432, e2.icircumflex = 238, e2.icyrillic = 1110, e2.idblgrave = 521, e2.ideographearthcircle = 12943, e2.ideographfirecircle = 12939, e2.ideographicallianceparen = 12863, e2.ideographiccallparen = 12858, e2.ideographiccentrecircle = 12965, e2.ideographicclose = 12294, e2.ideographiccomma = 12289, e2.ideographiccommaleft = 65380, e2.ideographiccongratulationparen = 12855, e2.ideographiccorrectcircle = 12963, e2.ideographicearthparen = 12847, e2.ideographicenterpriseparen = 12861, e2.ideographicexcellentcircle = 12957, e2.ideographicfestivalparen = 12864, e2.ideographicfinancialcircle = 12950, e2.ideographicfinancialparen = 12854, e2.ideographicfireparen = 12843, e2.ideographichaveparen = 12850, e2.ideographichighcircle = 12964, e2.ideographiciterationmark = 12293, e2.ideographiclaborcircle = 12952, e2.ideographiclaborparen = 12856, e2.ideographicleftcircle = 12967, e2.ideographiclowcircle = 12966, e2.ideographicmedicinecircle = 12969, e2.ideographicmetalparen = 12846, e2.ideographicmoonparen = 12842, e2.ideographicnameparen = 12852, e2.ideographicperiod = 12290, e2.ideographicprintcircle = 12958, e2.ideographicreachparen = 12867, e2.ideographicrepresentparen = 12857, e2.ideographicresourceparen = 12862, e2.ideographicrightcircle = 12968, e2.ideographicsecretcircle = 12953, e2.ideographicselfparen = 12866, e2.ideographicsocietyparen = 12851, e2.ideographicspace = 12288, e2.ideographicspecialparen = 12853, e2.ideographicstockparen = 12849, e2.ideographicstudyparen = 12859, e2.ideographicsunparen = 12848, e2.ideographicsuperviseparen = 12860, e2.ideographicwaterparen = 12844, e2.ideographicwoodparen = 12845, e2.ideographiczero = 12295, e2.ideographmetalcircle = 12942, e2.ideographmooncircle = 12938, e2.ideographnamecircle = 12948, e2.ideographsuncircle = 12944, e2.ideographwatercircle = 12940, e2.ideographwoodcircle = 12941, e2.ideva = 2311, e2.idieresis = 239, e2.idieresisacute = 7727, e2.idieresiscyrillic = 1253, e2.idotbelow = 7883, e2.iebrevecyrillic = 1239, e2.iecyrillic = 1077, e2.ieungacirclekorean = 12917, e2.ieungaparenkorean = 12821, e2.ieungcirclekorean = 12903, e2.ieungkorean = 12615, e2.ieungparenkorean = 12807, e2.igrave = 236, e2.igujarati = 2695, e2.igurmukhi = 2567, e2.ihiragana = 12356, e2.ihookabove = 7881, e2.iibengali = 2440, e2.iicyrillic = 1080, e2.iideva = 2312, e2.iigujarati = 2696, e2.iigurmukhi = 2568, e2.iimatragurmukhi = 2624, e2.iinvertedbreve = 523, e2.iishortcyrillic = 1081, e2.iivowelsignbengali = 2496, e2.iivowelsigndeva = 2368, e2.iivowelsigngujarati = 2752, e2.ij = 307, e2.ikatakana = 12452, e2.ikatakanahalfwidth = 65394, e2.ikorean = 12643, e2.ilde = 732, e2.iluyhebrew = 1452, e2.imacron = 299, e2.imacroncyrillic = 1251, e2.imageorapproximatelyequal = 8787, e2.imatragurmukhi = 2623, e2.imonospace = 65353, e2.increment = 8710, e2.infinity = 8734, e2.iniarmenian = 1387, e2.integral = 8747, e2.integralbottom = 8993, e2.integralbt = 8993, e2.integralex = 63733, e2.integraltop = 8992, e2.integraltp = 8992, e2.intersection = 8745, e2.intisquare = 13061, e2.invbullet = 9688, e2.invcircle = 9689, e2.invsmileface = 9787, e2.iocyrillic = 1105, e2.iogonek = 303, e2.iota = 953, e2.iotadieresis = 970, e2.iotadieresistonos = 912, e2.iotalatin = 617, e2.iotatonos = 943, e2.iparen = 9380, e2.irigurmukhi = 2674, e2.ismallhiragana = 12355, e2.ismallkatakana = 12451, e2.ismallkatakanahalfwidth = 65384, e2.issharbengali = 2554, e2.istroke = 616, e2.isuperior = 63213, e2.iterationhiragana = 12445, e2.iterationkatakana = 12541, e2.itilde = 297, e2.itildebelow = 7725, e2.iubopomofo = 12585, e2.iucyrillic = 1102, e2.ivowelsignbengali = 2495, e2.ivowelsigndeva = 2367, e2.ivowelsigngujarati = 2751, e2.izhitsacyrillic = 1141, e2.izhitsadblgravecyrillic = 1143, e2.j = 106, e2.jaarmenian = 1393, e2.jabengali = 2460, e2.jadeva = 2332, e2.jagujarati = 2716, e2.jagurmukhi = 2588, e2.jbopomofo = 12560, e2.jcaron = 496, e2.jcircle = 9433, e2.jcircumflex = 309, e2.jcrossedtail = 669, e2.jdotlessstroke = 607, e2.jecyrillic = 1112, e2.jeemarabic = 1580, e2.jeemfinalarabic = 65182, e2.jeeminitialarabic = 65183, e2.jeemmedialarabic = 65184, e2.jeharabic = 1688, e2.jehfinalarabic = 64395, e2.jhabengali = 2461, e2.jhadeva = 2333, e2.jhagujarati = 2717, e2.jhagurmukhi = 2589, e2.jheharmenian = 1403, e2.jis = 12292, e2.jmonospace = 65354, e2.jparen = 9381, e2.jsuperior = 690, e2.k = 107, e2.kabashkircyrillic = 1185, e2.kabengali = 2453, e2.kacute = 7729, e2.kacyrillic = 1082, e2.kadescendercyrillic = 1179, e2.kadeva = 2325, e2.kaf = 1499, e2.kafarabic = 1603, e2.kafdagesh = 64315, e2.kafdageshhebrew = 64315, e2.kaffinalarabic = 65242, e2.kafhebrew = 1499, e2.kafinitialarabic = 65243, e2.kafmedialarabic = 65244, e2.kafrafehebrew = 64333, e2.kagujarati = 2709, e2.kagurmukhi = 2581, e2.kahiragana = 12363, e2.kahookcyrillic = 1220, e2.kakatakana = 12459, e2.kakatakanahalfwidth = 65398, e2.kappa = 954, e2.kappasymbolgreek = 1008, e2.kapyeounmieumkorean = 12657, e2.kapyeounphieuphkorean = 12676, e2.kapyeounpieupkorean = 12664, e2.kapyeounssangpieupkorean = 12665, e2.karoriisquare = 13069, e2.kashidaautoarabic = 1600, e2.kashidaautonosidebearingarabic = 1600, e2.kasmallkatakana = 12533, e2.kasquare = 13188, e2.kasraarabic = 1616, e2.kasratanarabic = 1613, e2.kastrokecyrillic = 1183, e2.katahiraprolongmarkhalfwidth = 65392, e2.kaverticalstrokecyrillic = 1181, e2.kbopomofo = 12558, e2.kcalsquare = 13193, e2.kcaron = 489, e2.kcedilla = 311, e2.kcircle = 9434, e2.kcommaaccent = 311, e2.kdotbelow = 7731, e2.keharmenian = 1412, e2.kehiragana = 12369, e2.kekatakana = 12465, e2.kekatakanahalfwidth = 65401, e2.kenarmenian = 1391, e2.kesmallkatakana = 12534, e2.kgreenlandic = 312, e2.khabengali = 2454, e2.khacyrillic = 1093, e2.khadeva = 2326, e2.khagujarati = 2710, e2.khagurmukhi = 2582, e2.khaharabic = 1582, e2.khahfinalarabic = 65190, e2.khahinitialarabic = 65191, e2.khahmedialarabic = 65192, e2.kheicoptic = 999, e2.khhadeva = 2393, e2.khhagurmukhi = 2649, e2.khieukhacirclekorean = 12920, e2.khieukhaparenkorean = 12824, e2.khieukhcirclekorean = 12906, e2.khieukhkorean = 12619, e2.khieukhparenkorean = 12810, e2.khokhaithai = 3586, e2.khokhonthai = 3589, e2.khokhuatthai = 3587, e2.khokhwaithai = 3588, e2.khomutthai = 3675, e2.khook = 409, e2.khorakhangthai = 3590, e2.khzsquare = 13201, e2.kihiragana = 12365, e2.kikatakana = 12461, e2.kikatakanahalfwidth = 65399, e2.kiroguramusquare = 13077, e2.kiromeetorusquare = 13078, e2.kirosquare = 13076, e2.kiyeokacirclekorean = 12910, e2.kiyeokaparenkorean = 12814, e2.kiyeokcirclekorean = 12896, e2.kiyeokkorean = 12593, e2.kiyeokparenkorean = 12800, e2.kiyeoksioskorean = 12595;
      e2.kjecyrillic = 1116, e2.klinebelow = 7733, e2.klsquare = 13208, e2.kmcubedsquare = 13222, e2.kmonospace = 65355, e2.kmsquaredsquare = 13218, e2.kohiragana = 12371, e2.kohmsquare = 13248, e2.kokaithai = 3585, e2.kokatakana = 12467, e2.kokatakanahalfwidth = 65402, e2.kooposquare = 13086, e2.koppacyrillic = 1153, e2.koreanstandardsymbol = 12927, e2.koroniscmb = 835, e2.kparen = 9382, e2.kpasquare = 13226, e2.ksicyrillic = 1135, e2.ktsquare = 13263, e2.kturned = 670, e2.kuhiragana = 12367, e2.kukatakana = 12463, e2.kukatakanahalfwidth = 65400, e2.kvsquare = 13240, e2.kwsquare = 13246, e2.l = 108, e2.labengali = 2482, e2.lacute = 314, e2.ladeva = 2354, e2.lagujarati = 2738, e2.lagurmukhi = 2610, e2.lakkhangyaothai = 3653, e2.lamaleffinalarabic = 65276, e2.lamalefhamzaabovefinalarabic = 65272, e2.lamalefhamzaaboveisolatedarabic = 65271, e2.lamalefhamzabelowfinalarabic = 65274, e2.lamalefhamzabelowisolatedarabic = 65273, e2.lamalefisolatedarabic = 65275, e2.lamalefmaddaabovefinalarabic = 65270, e2.lamalefmaddaaboveisolatedarabic = 65269, e2.lamarabic = 1604, e2.lambda = 955, e2.lambdastroke = 411, e2.lamed = 1500, e2.lameddagesh = 64316, e2.lameddageshhebrew = 64316, e2.lamedhebrew = 1500, e2.lamfinalarabic = 65246, e2.lamhahinitialarabic = 64714, e2.laminitialarabic = 65247, e2.lamjeeminitialarabic = 64713, e2.lamkhahinitialarabic = 64715, e2.lamlamhehisolatedarabic = 65010, e2.lammedialarabic = 65248, e2.lammeemhahinitialarabic = 64904, e2.lammeeminitialarabic = 64716, e2.largecircle = 9711, e2.lbar = 410, e2.lbelt = 620, e2.lbopomofo = 12556, e2.lcaron = 318, e2.lcedilla = 316, e2.lcircle = 9435, e2.lcircumflexbelow = 7741, e2.lcommaaccent = 316, e2.ldot = 320, e2.ldotaccent = 320, e2.ldotbelow = 7735, e2.ldotbelowmacron = 7737, e2.leftangleabovecmb = 794, e2.lefttackbelowcmb = 792, e2.less = 60, e2.lessequal = 8804, e2.lessequalorgreater = 8922, e2.lessmonospace = 65308, e2.lessorequivalent = 8818, e2.lessorgreater = 8822, e2.lessoverequal = 8806, e2.lesssmall = 65124, e2.lezh = 622, e2.lfblock = 9612, e2.lhookretroflex = 621, e2.lira = 8356, e2.liwnarmenian = 1388, e2.lj = 457, e2.ljecyrillic = 1113, e2.ll = 63168, e2.lladeva = 2355, e2.llagujarati = 2739, e2.llinebelow = 7739, e2.llladeva = 2356, e2.llvocalicbengali = 2529, e2.llvocalicdeva = 2401, e2.llvocalicvowelsignbengali = 2531, e2.llvocalicvowelsigndeva = 2403, e2.lmiddletilde = 619, e2.lmonospace = 65356, e2.lmsquare = 13264, e2.lochulathai = 3628, e2.logicaland = 8743, e2.logicalnot = 172, e2.logicalnotreversed = 8976, e2.logicalor = 8744, e2.lolingthai = 3621, e2.longs = 383, e2.lowlinecenterline = 65102, e2.lowlinecmb = 818, e2.lowlinedashed = 65101, e2.lozenge = 9674, e2.lparen = 9383, e2.lslash = 322, e2.lsquare = 8467, e2.lsuperior = 63214, e2.ltshade = 9617, e2.luthai = 3622, e2.lvocalicbengali = 2444, e2.lvocalicdeva = 2316, e2.lvocalicvowelsignbengali = 2530, e2.lvocalicvowelsigndeva = 2402, e2.lxsquare = 13267, e2.m = 109, e2.mabengali = 2478, e2.macron = 175, e2.macronbelowcmb = 817, e2.macroncmb = 772, e2.macronlowmod = 717, e2.macronmonospace = 65507, e2.macute = 7743, e2.madeva = 2350, e2.magujarati = 2734, e2.magurmukhi = 2606, e2.mahapakhhebrew = 1444, e2.mahapakhlefthebrew = 1444, e2.mahiragana = 12414, e2.maichattawalowleftthai = 63637, e2.maichattawalowrightthai = 63636, e2.maichattawathai = 3659, e2.maichattawaupperleftthai = 63635, e2.maieklowleftthai = 63628, e2.maieklowrightthai = 63627, e2.maiekthai = 3656, e2.maiekupperleftthai = 63626, e2.maihanakatleftthai = 63620, e2.maihanakatthai = 3633, e2.maitaikhuleftthai = 63625, e2.maitaikhuthai = 3655, e2.maitholowleftthai = 63631, e2.maitholowrightthai = 63630, e2.maithothai = 3657, e2.maithoupperleftthai = 63629, e2.maitrilowleftthai = 63634, e2.maitrilowrightthai = 63633, e2.maitrithai = 3658, e2.maitriupperleftthai = 63632, e2.maiyamokthai = 3654, e2.makatakana = 12510, e2.makatakanahalfwidth = 65423, e2.male = 9794, e2.mansyonsquare = 13127, e2.maqafhebrew = 1470, e2.mars = 9794, e2.masoracirclehebrew = 1455, e2.masquare = 13187, e2.mbopomofo = 12551, e2.mbsquare = 13268, e2.mcircle = 9436, e2.mcubedsquare = 13221, e2.mdotaccent = 7745, e2.mdotbelow = 7747, e2.meemarabic = 1605, e2.meemfinalarabic = 65250, e2.meeminitialarabic = 65251, e2.meemmedialarabic = 65252, e2.meemmeeminitialarabic = 64721, e2.meemmeemisolatedarabic = 64584, e2.meetorusquare = 13133, e2.mehiragana = 12417, e2.meizierasquare = 13182, e2.mekatakana = 12513, e2.mekatakanahalfwidth = 65426, e2.mem = 1502, e2.memdagesh = 64318, e2.memdageshhebrew = 64318, e2.memhebrew = 1502, e2.menarmenian = 1396, e2.merkhahebrew = 1445, e2.merkhakefulahebrew = 1446, e2.merkhakefulalefthebrew = 1446, e2.merkhalefthebrew = 1445, e2.mhook = 625, e2.mhzsquare = 13202, e2.middledotkatakanahalfwidth = 65381, e2.middot = 183, e2.mieumacirclekorean = 12914, e2.mieumaparenkorean = 12818, e2.mieumcirclekorean = 12900, e2.mieumkorean = 12609, e2.mieumpansioskorean = 12656, e2.mieumparenkorean = 12804, e2.mieumpieupkorean = 12654, e2.mieumsioskorean = 12655, e2.mihiragana = 12415, e2.mikatakana = 12511, e2.mikatakanahalfwidth = 65424, e2.minus = 8722, e2.minusbelowcmb = 800, e2.minuscircle = 8854, e2.minusmod = 727, e2.minusplus = 8723, e2.minute = 8242, e2.miribaarusquare = 13130, e2.mirisquare = 13129, e2.mlonglegturned = 624, e2.mlsquare = 13206, e2.mmcubedsquare = 13219, e2.mmonospace = 65357, e2.mmsquaredsquare = 13215, e2.mohiragana = 12418, e2.mohmsquare = 13249, e2.mokatakana = 12514, e2.mokatakanahalfwidth = 65427, e2.molsquare = 13270, e2.momathai = 3617, e2.moverssquare = 13223, e2.moverssquaredsquare = 13224, e2.mparen = 9384, e2.mpasquare = 13227, e2.mssquare = 13235, e2.msuperior = 63215, e2.mturned = 623, e2.mu = 181, e2.mu1 = 181, e2.muasquare = 13186, e2.muchgreater = 8811, e2.muchless = 8810, e2.mufsquare = 13196, e2.mugreek = 956, e2.mugsquare = 13197, e2.muhiragana = 12416, e2.mukatakana = 12512, e2.mukatakanahalfwidth = 65425, e2.mulsquare = 13205, e2.multiply = 215, e2.mumsquare = 13211, e2.munahhebrew = 1443, e2.munahlefthebrew = 1443, e2.musicalnote = 9834, e2.musicalnotedbl = 9835, e2.musicflatsign = 9837, e2.musicsharpsign = 9839, e2.mussquare = 13234, e2.muvsquare = 13238, e2.muwsquare = 13244, e2.mvmegasquare = 13241, e2.mvsquare = 13239, e2.mwmegasquare = 13247, e2.mwsquare = 13245, e2.n = 110, e2.nabengali = 2472, e2.nabla = 8711, e2.nacute = 324, e2.nadeva = 2344, e2.nagujarati = 2728, e2.nagurmukhi = 2600, e2.nahiragana = 12394, e2.nakatakana = 12490, e2.nakatakanahalfwidth = 65413, e2.napostrophe = 329, e2.nasquare = 13185, e2.nbopomofo = 12555, e2.nbspace = 160, e2.ncaron = 328, e2.ncedilla = 326, e2.ncircle = 9437, e2.ncircumflexbelow = 7755, e2.ncommaaccent = 326, e2.ndotaccent = 7749, e2.ndotbelow = 7751, e2.nehiragana = 12397, e2.nekatakana = 12493, e2.nekatakanahalfwidth = 65416, e2.newsheqelsign = 8362, e2.nfsquare = 13195, e2.ngabengali = 2457, e2.ngadeva = 2329, e2.ngagujarati = 2713, e2.ngagurmukhi = 2585, e2.ngonguthai = 3591, e2.nhiragana = 12435, e2.nhookleft = 626, e2.nhookretroflex = 627, e2.nieunacirclekorean = 12911, e2.nieunaparenkorean = 12815, e2.nieuncieuckorean = 12597, e2.nieuncirclekorean = 12897, e2.nieunhieuhkorean = 12598, e2.nieunkorean = 12596, e2.nieunpansioskorean = 12648, e2.nieunparenkorean = 12801, e2.nieunsioskorean = 12647, e2.nieuntikeutkorean = 12646, e2.nihiragana = 12395, e2.nikatakana = 12491, e2.nikatakanahalfwidth = 65414, e2.nikhahitleftthai = 63641, e2.nikhahitthai = 3661, e2.nine = 57, e2.ninearabic = 1641, e2.ninebengali = 2543, e2.ninecircle = 9320, e2.ninecircleinversesansserif = 10130, e2.ninedeva = 2415, e2.ninegujarati = 2799, e2.ninegurmukhi = 2671, e2.ninehackarabic = 1641, e2.ninehangzhou = 12329, e2.nineideographicparen = 12840, e2.nineinferior = 8329, e2.ninemonospace = 65305, e2.nineoldstyle = 63289, e2.nineparen = 9340, e2.nineperiod = 9360, e2.ninepersian = 1785, e2.nineroman = 8568, e2.ninesuperior = 8313, e2.nineteencircle = 9330, e2.nineteenparen = 9350, e2.nineteenperiod = 9370, e2.ninethai = 3673, e2.nj = 460, e2.njecyrillic = 1114, e2.nkatakana = 12531, e2.nkatakanahalfwidth = 65437, e2.nlegrightlong = 414, e2.nlinebelow = 7753, e2.nmonospace = 65358, e2.nmsquare = 13210, e2.nnabengali = 2467, e2.nnadeva = 2339, e2.nnagujarati = 2723, e2.nnagurmukhi = 2595, e2.nnnadeva = 2345, e2.nohiragana = 12398, e2.nokatakana = 12494, e2.nokatakanahalfwidth = 65417, e2.nonbreakingspace = 160, e2.nonenthai = 3603, e2.nonuthai = 3609, e2.noonarabic = 1606, e2.noonfinalarabic = 65254, e2.noonghunnaarabic = 1722, e2.noonghunnafinalarabic = 64415, e2.nooninitialarabic = 65255, e2.noonjeeminitialarabic = 64722, e2.noonjeemisolatedarabic = 64587, e2.noonmedialarabic = 65256, e2.noonmeeminitialarabic = 64725, e2.noonmeemisolatedarabic = 64590, e2.noonnoonfinalarabic = 64653, e2.notcontains = 8716, e2.notelement = 8713, e2.notelementof = 8713, e2.notequal = 8800, e2.notgreater = 8815, e2.notgreaternorequal = 8817, e2.notgreaternorless = 8825, e2.notidentical = 8802, e2.notless = 8814, e2.notlessnorequal = 8816, e2.notparallel = 8742, e2.notprecedes = 8832, e2.notsubset = 8836, e2.notsucceeds = 8833, e2.notsuperset = 8837, e2.nowarmenian = 1398, e2.nparen = 9385, e2.nssquare = 13233, e2.nsuperior = 8319, e2.ntilde = 241, e2.nu = 957, e2.nuhiragana = 12396, e2.nukatakana = 12492, e2.nukatakanahalfwidth = 65415, e2.nuktabengali = 2492, e2.nuktadeva = 2364, e2.nuktagujarati = 2748, e2.nuktagurmukhi = 2620, e2.numbersign = 35, e2.numbersignmonospace = 65283, e2.numbersignsmall = 65119, e2.numeralsigngreek = 884, e2.numeralsignlowergreek = 885, e2.numero = 8470, e2.nun = 1504, e2.nundagesh = 64320, e2.nundageshhebrew = 64320, e2.nunhebrew = 1504, e2.nvsquare = 13237, e2.nwsquare = 13243, e2.nyabengali = 2462, e2.nyadeva = 2334, e2.nyagujarati = 2718, e2.nyagurmukhi = 2590, e2.o = 111, e2.oacute = 243, e2.oangthai = 3629, e2.obarred = 629, e2.obarredcyrillic = 1257, e2.obarreddieresiscyrillic = 1259, e2.obengali = 2451, e2.obopomofo = 12571, e2.obreve = 335, e2.ocandradeva = 2321, e2.ocandragujarati = 2705, e2.ocandravowelsigndeva = 2377, e2.ocandravowelsigngujarati = 2761, e2.ocaron = 466, e2.ocircle = 9438, e2.ocircumflex = 244, e2.ocircumflexacute = 7889, e2.ocircumflexdotbelow = 7897, e2.ocircumflexgrave = 7891, e2.ocircumflexhookabove = 7893, e2.ocircumflextilde = 7895, e2.ocyrillic = 1086, e2.odblacute = 337, e2.odblgrave = 525, e2.odeva = 2323, e2.odieresis = 246, e2.odieresiscyrillic = 1255, e2.odotbelow = 7885, e2.oe = 339, e2.oekorean = 12634, e2.ogonek = 731, e2.ogonekcmb = 808, e2.ograve = 242, e2.ogujarati = 2707, e2.oharmenian = 1413, e2.ohiragana = 12362, e2.ohookabove = 7887, e2.ohorn = 417, e2.ohornacute = 7899, e2.ohorndotbelow = 7907, e2.ohorngrave = 7901, e2.ohornhookabove = 7903, e2.ohorntilde = 7905, e2.ohungarumlaut = 337, e2.oi = 419, e2.oinvertedbreve = 527, e2.okatakana = 12458, e2.okatakanahalfwidth = 65397, e2.okorean = 12631, e2.olehebrew = 1451, e2.omacron = 333, e2.omacronacute = 7763, e2.omacrongrave = 7761, e2.omdeva = 2384, e2.omega = 969, e2.omega1 = 982, e2.omegacyrillic = 1121, e2.omegalatinclosed = 631, e2.omegaroundcyrillic = 1147, e2.omegatitlocyrillic = 1149, e2.omegatonos = 974, e2.omgujarati = 2768, e2.omicron = 959, e2.omicrontonos = 972, e2.omonospace = 65359, e2.one = 49, e2.onearabic = 1633, e2.onebengali = 2535, e2.onecircle = 9312, e2.onecircleinversesansserif = 10122, e2.onedeva = 2407, e2.onedotenleader = 8228, e2.oneeighth = 8539, e2.onefitted = 63196, e2.onegujarati = 2791, e2.onegurmukhi = 2663, e2.onehackarabic = 1633, e2.onehalf = 189, e2.onehangzhou = 12321, e2.oneideographicparen = 12832, e2.oneinferior = 8321, e2.onemonospace = 65297, e2.onenumeratorbengali = 2548, e2.oneoldstyle = 63281, e2.oneparen = 9332, e2.oneperiod = 9352, e2.onepersian = 1777, e2.onequarter = 188, e2.oneroman = 8560, e2.onesuperior = 185, e2.onethai = 3665, e2.onethird = 8531, e2.oogonek = 491, e2.oogonekmacron = 493, e2.oogurmukhi = 2579, e2.oomatragurmukhi = 2635, e2.oopen = 596, e2.oparen = 9386, e2.openbullet = 9702, e2.option = 8997, e2.ordfeminine = 170, e2.ordmasculine = 186, e2.orthogonal = 8735, e2.oshortdeva = 2322, e2.oshortvowelsigndeva = 2378, e2.oslash = 248, e2.oslashacute = 511, e2.osmallhiragana = 12361, e2.osmallkatakana = 12457, e2.osmallkatakanahalfwidth = 65387, e2.ostrokeacute = 511, e2.osuperior = 63216, e2.otcyrillic = 1151, e2.otilde = 245, e2.otildeacute = 7757, e2.otildedieresis = 7759, e2.oubopomofo = 12577, e2.overline = 8254, e2.overlinecenterline = 65098, e2.overlinecmb = 773, e2.overlinedashed = 65097, e2.overlinedblwavy = 65100, e2.overlinewavy = 65099, e2.overscore = 175, e2.ovowelsignbengali = 2507, e2.ovowelsigndeva = 2379, e2.ovowelsigngujarati = 2763, e2.p = 112, e2.paampssquare = 13184, e2.paasentosquare = 13099, e2.pabengali = 2474, e2.pacute = 7765, e2.padeva = 2346, e2.pagedown = 8671, e2.pageup = 8670, e2.pagujarati = 2730, e2.pagurmukhi = 2602, e2.pahiragana = 12401, e2.paiyannoithai = 3631, e2.pakatakana = 12497, e2.palatalizationcyrilliccmb = 1156, e2.palochkacyrillic = 1216, e2.pansioskorean = 12671, e2.paragraph = 182, e2.parallel = 8741, e2.parenleft = 40, e2.parenleftaltonearabic = 64830, e2.parenleftbt = 63725, e2.parenleftex = 63724, e2.parenleftinferior = 8333, e2.parenleftmonospace = 65288, e2.parenleftsmall = 65113, e2.parenleftsuperior = 8317, e2.parenlefttp = 63723, e2.parenleftvertical = 65077, e2.parenright = 41, e2.parenrightaltonearabic = 64831, e2.parenrightbt = 63736, e2.parenrightex = 63735, e2.parenrightinferior = 8334, e2.parenrightmonospace = 65289, e2.parenrightsmall = 65114, e2.parenrightsuperior = 8318, e2.parenrighttp = 63734, e2.parenrightvertical = 65078, e2.partialdiff = 8706, e2.paseqhebrew = 1472, e2.pashtahebrew = 1433, e2.pasquare = 13225, e2.patah = 1463, e2.patah11 = 1463, e2.patah1d = 1463, e2.patah2a = 1463, e2.patahhebrew = 1463, e2.patahnarrowhebrew = 1463, e2.patahquarterhebrew = 1463, e2.patahwidehebrew = 1463, e2.pazerhebrew = 1441, e2.pbopomofo = 12550, e2.pcircle = 9439, e2.pdotaccent = 7767, e2.pe = 1508, e2.pecyrillic = 1087, e2.pedagesh = 64324, e2.pedageshhebrew = 64324, e2.peezisquare = 13115, e2.pefinaldageshhebrew = 64323, e2.peharabic = 1662, e2.peharmenian = 1402, e2.pehebrew = 1508, e2.pehfinalarabic = 64343, e2.pehinitialarabic = 64344, e2.pehiragana = 12410, e2.pehmedialarabic = 64345, e2.pekatakana = 12506, e2.pemiddlehookcyrillic = 1191, e2.perafehebrew = 64334, e2.percent = 37, e2.percentarabic = 1642, e2.percentmonospace = 65285, e2.percentsmall = 65130, e2.period = 46, e2.periodarmenian = 1417, e2.periodcentered = 183, e2.periodhalfwidth = 65377, e2.periodinferior = 63207, e2.periodmonospace = 65294, e2.periodsmall = 65106, e2.periodsuperior = 63208, e2.perispomenigreekcmb = 834, e2.perpendicular = 8869, e2.perthousand = 8240, e2.peseta = 8359, e2.pfsquare = 13194, e2.phabengali = 2475, e2.phadeva = 2347, e2.phagujarati = 2731, e2.phagurmukhi = 2603, e2.phi = 966, e2.phi1 = 981, e2.phieuphacirclekorean = 12922, e2.phieuphaparenkorean = 12826, e2.phieuphcirclekorean = 12908, e2.phieuphkorean = 12621, e2.phieuphparenkorean = 12812, e2.philatin = 632, e2.phinthuthai = 3642, e2.phisymbolgreek = 981, e2.phook = 421, e2.phophanthai = 3614, e2.phophungthai = 3612, e2.phosamphaothai = 3616, e2.pi = 960, e2.pieupacirclekorean = 12915, e2.pieupaparenkorean = 12819, e2.pieupcieuckorean = 12662, e2.pieupcirclekorean = 12901, e2.pieupkiyeokkorean = 12658, e2.pieupkorean = 12610, e2.pieupparenkorean = 12805, e2.pieupsioskiyeokkorean = 12660, e2.pieupsioskorean = 12612, e2.pieupsiostikeutkorean = 12661, e2.pieupthieuthkorean = 12663, e2.pieuptikeutkorean = 12659, e2.pihiragana = 12404, e2.pikatakana = 12500, e2.pisymbolgreek = 982, e2.piwrarmenian = 1411, e2.planckover2pi = 8463, e2.planckover2pi1 = 8463, e2.plus = 43, e2.plusbelowcmb = 799, e2.pluscircle = 8853, e2.plusminus = 177, e2.plusmod = 726, e2.plusmonospace = 65291, e2.plussmall = 65122, e2.plussuperior = 8314, e2.pmonospace = 65360, e2.pmsquare = 13272, e2.pohiragana = 12413, e2.pointingindexdownwhite = 9759, e2.pointingindexleftwhite = 9756, e2.pointingindexrightwhite = 9758, e2.pointingindexupwhite = 9757, e2.pokatakana = 12509, e2.poplathai = 3611, e2.postalmark = 12306, e2.postalmarkface = 12320, e2.pparen = 9387, e2.precedes = 8826, e2.prescription = 8478, e2.primemod = 697, e2.primereversed = 8245, e2.product = 8719, e2.projective = 8965, e2.prolongedkana = 12540, e2.propellor = 8984, e2.propersubset = 8834, e2.propersuperset = 8835, e2.proportion = 8759, e2.proportional = 8733, e2.psi = 968, e2.psicyrillic = 1137, e2.psilipneumatacyrilliccmb = 1158, e2.pssquare = 13232, e2.puhiragana = 12407, e2.pukatakana = 12503, e2.pvsquare = 13236, e2.pwsquare = 13242, e2.q = 113, e2.qadeva = 2392, e2.qadmahebrew = 1448, e2.qafarabic = 1602, e2.qaffinalarabic = 65238, e2.qafinitialarabic = 65239, e2.qafmedialarabic = 65240, e2.qamats = 1464, e2.qamats10 = 1464, e2.qamats1a = 1464, e2.qamats1c = 1464, e2.qamats27 = 1464, e2.qamats29 = 1464, e2.qamats33 = 1464, e2.qamatsde = 1464, e2.qamatshebrew = 1464, e2.qamatsnarrowhebrew = 1464, e2.qamatsqatanhebrew = 1464, e2.qamatsqatannarrowhebrew = 1464, e2.qamatsqatanquarterhebrew = 1464, e2.qamatsqatanwidehebrew = 1464, e2.qamatsquarterhebrew = 1464, e2.qamatswidehebrew = 1464, e2.qarneyparahebrew = 1439, e2.qbopomofo = 12561, e2.qcircle = 9440, e2.qhook = 672, e2.qmonospace = 65361, e2.qof = 1511, e2.qofdagesh = 64327, e2.qofdageshhebrew = 64327, e2.qofhebrew = 1511, e2.qparen = 9388, e2.quarternote = 9833, e2.qubuts = 1467, e2.qubuts18 = 1467, e2.qubuts25 = 1467, e2.qubuts31 = 1467, e2.qubutshebrew = 1467, e2.qubutsnarrowhebrew = 1467, e2.qubutsquarterhebrew = 1467, e2.qubutswidehebrew = 1467, e2.question = 63, e2.questionarabic = 1567, e2.questionarmenian = 1374, e2.questiondown = 191, e2.questiondownsmall = 63423, e2.questiongreek = 894, e2.questionmonospace = 65311, e2.questionsmall = 63295, e2.quotedbl = 34, e2.quotedblbase = 8222, e2.quotedblleft = 8220, e2.quotedblmonospace = 65282, e2.quotedblprime = 12318, e2.quotedblprimereversed = 12317, e2.quotedblright = 8221, e2.quoteleft = 8216, e2.quoteleftreversed = 8219, e2.quotereversed = 8219, e2.quoteright = 8217, e2.quoterightn = 329, e2.quotesinglbase = 8218, e2.quotesingle = 39, e2.quotesinglemonospace = 65287, e2.r = 114, e2.raarmenian = 1404, e2.rabengali = 2480, e2.racute = 341, e2.radeva = 2352, e2.radical = 8730, e2.radicalex = 63717, e2.radoverssquare = 13230, e2.radoverssquaredsquare = 13231, e2.radsquare = 13229, e2.rafe = 1471, e2.rafehebrew = 1471, e2.ragujarati = 2736, e2.ragurmukhi = 2608, e2.rahiragana = 12425, e2.rakatakana = 12521, e2.rakatakanahalfwidth = 65431, e2.ralowerdiagonalbengali = 2545, e2.ramiddlediagonalbengali = 2544, e2.ramshorn = 612, e2.ratio = 8758, e2.rbopomofo = 12566, e2.rcaron = 345, e2.rcedilla = 343, e2.rcircle = 9441, e2.rcommaaccent = 343, e2.rdblgrave = 529, e2.rdotaccent = 7769, e2.rdotbelow = 7771, e2.rdotbelowmacron = 7773, e2.referencemark = 8251, e2.reflexsubset = 8838, e2.reflexsuperset = 8839, e2.registered = 174, e2.registersans = 63720, e2.registerserif = 63194, e2.reharabic = 1585, e2.reharmenian = 1408, e2.rehfinalarabic = 65198, e2.rehiragana = 12428, e2.rekatakana = 12524;
      e2.rekatakanahalfwidth = 65434, e2.resh = 1512, e2.reshdageshhebrew = 64328, e2.reshhebrew = 1512, e2.reversedtilde = 8765, e2.reviahebrew = 1431, e2.reviamugrashhebrew = 1431, e2.revlogicalnot = 8976, e2.rfishhook = 638, e2.rfishhookreversed = 639, e2.rhabengali = 2525, e2.rhadeva = 2397, e2.rho = 961, e2.rhook = 637, e2.rhookturned = 635, e2.rhookturnedsuperior = 693, e2.rhosymbolgreek = 1009, e2.rhotichookmod = 734, e2.rieulacirclekorean = 12913, e2.rieulaparenkorean = 12817, e2.rieulcirclekorean = 12899, e2.rieulhieuhkorean = 12608, e2.rieulkiyeokkorean = 12602, e2.rieulkiyeoksioskorean = 12649, e2.rieulkorean = 12601, e2.rieulmieumkorean = 12603, e2.rieulpansioskorean = 12652, e2.rieulparenkorean = 12803, e2.rieulphieuphkorean = 12607, e2.rieulpieupkorean = 12604, e2.rieulpieupsioskorean = 12651, e2.rieulsioskorean = 12605, e2.rieulthieuthkorean = 12606, e2.rieultikeutkorean = 12650, e2.rieulyeorinhieuhkorean = 12653, e2.rightangle = 8735, e2.righttackbelowcmb = 793, e2.righttriangle = 8895, e2.rihiragana = 12426, e2.rikatakana = 12522, e2.rikatakanahalfwidth = 65432, e2.ring = 730, e2.ringbelowcmb = 805, e2.ringcmb = 778, e2.ringhalfleft = 703, e2.ringhalfleftarmenian = 1369, e2.ringhalfleftbelowcmb = 796, e2.ringhalfleftcentered = 723, e2.ringhalfright = 702, e2.ringhalfrightbelowcmb = 825, e2.ringhalfrightcentered = 722, e2.rinvertedbreve = 531, e2.rittorusquare = 13137, e2.rlinebelow = 7775, e2.rlongleg = 636, e2.rlonglegturned = 634, e2.rmonospace = 65362, e2.rohiragana = 12429, e2.rokatakana = 12525, e2.rokatakanahalfwidth = 65435, e2.roruathai = 3619, e2.rparen = 9389, e2.rrabengali = 2524, e2.rradeva = 2353, e2.rragurmukhi = 2652, e2.rreharabic = 1681, e2.rrehfinalarabic = 64397, e2.rrvocalicbengali = 2528, e2.rrvocalicdeva = 2400, e2.rrvocalicgujarati = 2784, e2.rrvocalicvowelsignbengali = 2500, e2.rrvocalicvowelsigndeva = 2372, e2.rrvocalicvowelsigngujarati = 2756, e2.rsuperior = 63217, e2.rtblock = 9616, e2.rturned = 633, e2.rturnedsuperior = 692, e2.ruhiragana = 12427, e2.rukatakana = 12523, e2.rukatakanahalfwidth = 65433, e2.rupeemarkbengali = 2546, e2.rupeesignbengali = 2547, e2.rupiah = 63197, e2.ruthai = 3620, e2.rvocalicbengali = 2443, e2.rvocalicdeva = 2315, e2.rvocalicgujarati = 2699, e2.rvocalicvowelsignbengali = 2499, e2.rvocalicvowelsigndeva = 2371, e2.rvocalicvowelsigngujarati = 2755, e2.s = 115, e2.sabengali = 2488, e2.sacute = 347, e2.sacutedotaccent = 7781, e2.sadarabic = 1589, e2.sadeva = 2360, e2.sadfinalarabic = 65210, e2.sadinitialarabic = 65211, e2.sadmedialarabic = 65212, e2.sagujarati = 2744, e2.sagurmukhi = 2616, e2.sahiragana = 12373, e2.sakatakana = 12469, e2.sakatakanahalfwidth = 65403, e2.sallallahoualayhewasallamarabic = 65018, e2.samekh = 1505, e2.samekhdagesh = 64321, e2.samekhdageshhebrew = 64321, e2.samekhhebrew = 1505, e2.saraaathai = 3634, e2.saraaethai = 3649, e2.saraaimaimalaithai = 3652, e2.saraaimaimuanthai = 3651, e2.saraamthai = 3635, e2.saraathai = 3632, e2.saraethai = 3648, e2.saraiileftthai = 63622, e2.saraiithai = 3637, e2.saraileftthai = 63621, e2.saraithai = 3636, e2.saraothai = 3650, e2.saraueeleftthai = 63624, e2.saraueethai = 3639, e2.saraueleftthai = 63623, e2.sarauethai = 3638, e2.sarauthai = 3640, e2.sarauuthai = 3641, e2.sbopomofo = 12569, e2.scaron = 353, e2.scarondotaccent = 7783, e2.scedilla = 351, e2.schwa = 601, e2.schwacyrillic = 1241, e2.schwadieresiscyrillic = 1243, e2.schwahook = 602, e2.scircle = 9442, e2.scircumflex = 349, e2.scommaaccent = 537, e2.sdotaccent = 7777, e2.sdotbelow = 7779, e2.sdotbelowdotaccent = 7785, e2.seagullbelowcmb = 828, e2.second = 8243, e2.secondtonechinese = 714, e2.section = 167, e2.seenarabic = 1587, e2.seenfinalarabic = 65202, e2.seeninitialarabic = 65203, e2.seenmedialarabic = 65204, e2.segol = 1462, e2.segol13 = 1462, e2.segol1f = 1462, e2.segol2c = 1462, e2.segolhebrew = 1462, e2.segolnarrowhebrew = 1462, e2.segolquarterhebrew = 1462, e2.segoltahebrew = 1426, e2.segolwidehebrew = 1462, e2.seharmenian = 1405, e2.sehiragana = 12379, e2.sekatakana = 12475, e2.sekatakanahalfwidth = 65406, e2.semicolon = 59, e2.semicolonarabic = 1563, e2.semicolonmonospace = 65307, e2.semicolonsmall = 65108, e2.semivoicedmarkkana = 12444, e2.semivoicedmarkkanahalfwidth = 65439, e2.sentisquare = 13090, e2.sentosquare = 13091, e2.seven = 55, e2.sevenarabic = 1639, e2.sevenbengali = 2541, e2.sevencircle = 9318, e2.sevencircleinversesansserif = 10128, e2.sevendeva = 2413, e2.seveneighths = 8542, e2.sevengujarati = 2797, e2.sevengurmukhi = 2669, e2.sevenhackarabic = 1639, e2.sevenhangzhou = 12327, e2.sevenideographicparen = 12838, e2.seveninferior = 8327, e2.sevenmonospace = 65303, e2.sevenoldstyle = 63287, e2.sevenparen = 9338, e2.sevenperiod = 9358, e2.sevenpersian = 1783, e2.sevenroman = 8566, e2.sevensuperior = 8311, e2.seventeencircle = 9328, e2.seventeenparen = 9348, e2.seventeenperiod = 9368, e2.seventhai = 3671, e2.sfthyphen = 173, e2.shaarmenian = 1399, e2.shabengali = 2486, e2.shacyrillic = 1096, e2.shaddaarabic = 1617, e2.shaddadammaarabic = 64609, e2.shaddadammatanarabic = 64606, e2.shaddafathaarabic = 64608, e2.shaddakasraarabic = 64610, e2.shaddakasratanarabic = 64607, e2.shade = 9618, e2.shadedark = 9619, e2.shadelight = 9617, e2.shademedium = 9618, e2.shadeva = 2358, e2.shagujarati = 2742, e2.shagurmukhi = 2614, e2.shalshelethebrew = 1427, e2.shbopomofo = 12565, e2.shchacyrillic = 1097, e2.sheenarabic = 1588, e2.sheenfinalarabic = 65206, e2.sheeninitialarabic = 65207, e2.sheenmedialarabic = 65208, e2.sheicoptic = 995, e2.sheqel = 8362, e2.sheqelhebrew = 8362, e2.sheva = 1456, e2.sheva115 = 1456, e2.sheva15 = 1456, e2.sheva22 = 1456, e2.sheva2e = 1456, e2.shevahebrew = 1456, e2.shevanarrowhebrew = 1456, e2.shevaquarterhebrew = 1456, e2.shevawidehebrew = 1456, e2.shhacyrillic = 1211, e2.shimacoptic = 1005, e2.shin = 1513, e2.shindagesh = 64329, e2.shindageshhebrew = 64329, e2.shindageshshindot = 64300, e2.shindageshshindothebrew = 64300, e2.shindageshsindot = 64301, e2.shindageshsindothebrew = 64301, e2.shindothebrew = 1473, e2.shinhebrew = 1513, e2.shinshindot = 64298, e2.shinshindothebrew = 64298, e2.shinsindot = 64299, e2.shinsindothebrew = 64299, e2.shook = 642, e2.sigma = 963, e2.sigma1 = 962, e2.sigmafinal = 962, e2.sigmalunatesymbolgreek = 1010, e2.sihiragana = 12375, e2.sikatakana = 12471, e2.sikatakanahalfwidth = 65404, e2.siluqhebrew = 1469, e2.siluqlefthebrew = 1469, e2.similar = 8764, e2.sindothebrew = 1474, e2.siosacirclekorean = 12916, e2.siosaparenkorean = 12820, e2.sioscieuckorean = 12670, e2.sioscirclekorean = 12902, e2.sioskiyeokkorean = 12666, e2.sioskorean = 12613, e2.siosnieunkorean = 12667, e2.siosparenkorean = 12806, e2.siospieupkorean = 12669, e2.siostikeutkorean = 12668, e2.six = 54, e2.sixarabic = 1638, e2.sixbengali = 2540, e2.sixcircle = 9317, e2.sixcircleinversesansserif = 10127, e2.sixdeva = 2412, e2.sixgujarati = 2796, e2.sixgurmukhi = 2668, e2.sixhackarabic = 1638, e2.sixhangzhou = 12326, e2.sixideographicparen = 12837, e2.sixinferior = 8326, e2.sixmonospace = 65302, e2.sixoldstyle = 63286, e2.sixparen = 9337, e2.sixperiod = 9357, e2.sixpersian = 1782, e2.sixroman = 8565, e2.sixsuperior = 8310, e2.sixteencircle = 9327, e2.sixteencurrencydenominatorbengali = 2553, e2.sixteenparen = 9347, e2.sixteenperiod = 9367, e2.sixthai = 3670, e2.slash = 47, e2.slashmonospace = 65295, e2.slong = 383, e2.slongdotaccent = 7835, e2.smileface = 9786, e2.smonospace = 65363, e2.sofpasuqhebrew = 1475, e2.softhyphen = 173, e2.softsigncyrillic = 1100, e2.sohiragana = 12381, e2.sokatakana = 12477, e2.sokatakanahalfwidth = 65407, e2.soliduslongoverlaycmb = 824, e2.solidusshortoverlaycmb = 823, e2.sorusithai = 3625, e2.sosalathai = 3624, e2.sosothai = 3595, e2.sosuathai = 3626, e2.space = 32, e2.spacehackarabic = 32, e2.spade = 9824, e2.spadesuitblack = 9824, e2.spadesuitwhite = 9828, e2.sparen = 9390, e2.squarebelowcmb = 827, e2.squarecc = 13252, e2.squarecm = 13213, e2.squarediagonalcrosshatchfill = 9641, e2.squarehorizontalfill = 9636, e2.squarekg = 13199, e2.squarekm = 13214, e2.squarekmcapital = 13262, e2.squareln = 13265, e2.squarelog = 13266, e2.squaremg = 13198, e2.squaremil = 13269, e2.squaremm = 13212, e2.squaremsquared = 13217, e2.squareorthogonalcrosshatchfill = 9638, e2.squareupperlefttolowerrightfill = 9639, e2.squareupperrighttolowerleftfill = 9640, e2.squareverticalfill = 9637, e2.squarewhitewithsmallblack = 9635, e2.srsquare = 13275, e2.ssabengali = 2487, e2.ssadeva = 2359, e2.ssagujarati = 2743, e2.ssangcieuckorean = 12617, e2.ssanghieuhkorean = 12677, e2.ssangieungkorean = 12672, e2.ssangkiyeokkorean = 12594, e2.ssangnieunkorean = 12645, e2.ssangpieupkorean = 12611, e2.ssangsioskorean = 12614, e2.ssangtikeutkorean = 12600, e2.ssuperior = 63218, e2.sterling = 163, e2.sterlingmonospace = 65505, e2.strokelongoverlaycmb = 822, e2.strokeshortoverlaycmb = 821, e2.subset = 8834, e2.subsetnotequal = 8842, e2.subsetorequal = 8838, e2.succeeds = 8827, e2.suchthat = 8715, e2.suhiragana = 12377, e2.sukatakana = 12473, e2.sukatakanahalfwidth = 65405, e2.sukunarabic = 1618, e2.summation = 8721, e2.sun = 9788, e2.superset = 8835, e2.supersetnotequal = 8843, e2.supersetorequal = 8839, e2.svsquare = 13276, e2.syouwaerasquare = 13180, e2.t = 116, e2.tabengali = 2468, e2.tackdown = 8868, e2.tackleft = 8867, e2.tadeva = 2340, e2.tagujarati = 2724, e2.tagurmukhi = 2596, e2.taharabic = 1591, e2.tahfinalarabic = 65218, e2.tahinitialarabic = 65219, e2.tahiragana = 12383, e2.tahmedialarabic = 65220, e2.taisyouerasquare = 13181, e2.takatakana = 12479, e2.takatakanahalfwidth = 65408, e2.tatweelarabic = 1600, e2.tau = 964, e2.tav = 1514, e2.tavdages = 64330, e2.tavdagesh = 64330, e2.tavdageshhebrew = 64330, e2.tavhebrew = 1514, e2.tbar = 359, e2.tbopomofo = 12554, e2.tcaron = 357, e2.tccurl = 680, e2.tcedilla = 355, e2.tcheharabic = 1670, e2.tchehfinalarabic = 64379, e2.tchehinitialarabic = 64380, e2.tchehmedialarabic = 64381, e2.tcircle = 9443, e2.tcircumflexbelow = 7793, e2.tcommaaccent = 355, e2.tdieresis = 7831, e2.tdotaccent = 7787, e2.tdotbelow = 7789, e2.tecyrillic = 1090, e2.tedescendercyrillic = 1197, e2.teharabic = 1578, e2.tehfinalarabic = 65174, e2.tehhahinitialarabic = 64674, e2.tehhahisolatedarabic = 64524, e2.tehinitialarabic = 65175, e2.tehiragana = 12390, e2.tehjeeminitialarabic = 64673, e2.tehjeemisolatedarabic = 64523, e2.tehmarbutaarabic = 1577, e2.tehmarbutafinalarabic = 65172, e2.tehmedialarabic = 65176, e2.tehmeeminitialarabic = 64676, e2.tehmeemisolatedarabic = 64526, e2.tehnoonfinalarabic = 64627, e2.tekatakana = 12486, e2.tekatakanahalfwidth = 65411, e2.telephone = 8481, e2.telephoneblack = 9742, e2.telishagedolahebrew = 1440, e2.telishaqetanahebrew = 1449, e2.tencircle = 9321, e2.tenideographicparen = 12841, e2.tenparen = 9341, e2.tenperiod = 9361, e2.tenroman = 8569, e2.tesh = 679, e2.tet = 1496, e2.tetdagesh = 64312, e2.tetdageshhebrew = 64312, e2.tethebrew = 1496, e2.tetsecyrillic = 1205, e2.tevirhebrew = 1435, e2.tevirlefthebrew = 1435, e2.thabengali = 2469, e2.thadeva = 2341, e2.thagujarati = 2725, e2.thagurmukhi = 2597, e2.thalarabic = 1584, e2.thalfinalarabic = 65196, e2.thanthakhatlowleftthai = 63640, e2.thanthakhatlowrightthai = 63639, e2.thanthakhatthai = 3660, e2.thanthakhatupperleftthai = 63638, e2.theharabic = 1579, e2.thehfinalarabic = 65178, e2.thehinitialarabic = 65179, e2.thehmedialarabic = 65180, e2.thereexists = 8707, e2.therefore = 8756, e2.theta = 952, e2.theta1 = 977, e2.thetasymbolgreek = 977, e2.thieuthacirclekorean = 12921, e2.thieuthaparenkorean = 12825, e2.thieuthcirclekorean = 12907, e2.thieuthkorean = 12620, e2.thieuthparenkorean = 12811, e2.thirteencircle = 9324, e2.thirteenparen = 9344, e2.thirteenperiod = 9364, e2.thonangmonthothai = 3601, e2.thook = 429, e2.thophuthaothai = 3602, e2.thorn = 254, e2.thothahanthai = 3607, e2.thothanthai = 3600, e2.thothongthai = 3608, e2.thothungthai = 3606, e2.thousandcyrillic = 1154, e2.thousandsseparatorarabic = 1644, e2.thousandsseparatorpersian = 1644, e2.three = 51, e2.threearabic = 1635, e2.threebengali = 2537, e2.threecircle = 9314, e2.threecircleinversesansserif = 10124, e2.threedeva = 2409, e2.threeeighths = 8540, e2.threegujarati = 2793, e2.threegurmukhi = 2665, e2.threehackarabic = 1635, e2.threehangzhou = 12323, e2.threeideographicparen = 12834, e2.threeinferior = 8323, e2.threemonospace = 65299, e2.threenumeratorbengali = 2550, e2.threeoldstyle = 63283, e2.threeparen = 9334, e2.threeperiod = 9354, e2.threepersian = 1779, e2.threequarters = 190, e2.threequartersemdash = 63198, e2.threeroman = 8562, e2.threesuperior = 179, e2.threethai = 3667, e2.thzsquare = 13204, e2.tihiragana = 12385, e2.tikatakana = 12481, e2.tikatakanahalfwidth = 65409, e2.tikeutacirclekorean = 12912, e2.tikeutaparenkorean = 12816, e2.tikeutcirclekorean = 12898, e2.tikeutkorean = 12599, e2.tikeutparenkorean = 12802, e2.tilde = 732, e2.tildebelowcmb = 816, e2.tildecmb = 771, e2.tildecomb = 771, e2.tildedoublecmb = 864, e2.tildeoperator = 8764, e2.tildeoverlaycmb = 820, e2.tildeverticalcmb = 830, e2.timescircle = 8855, e2.tipehahebrew = 1430, e2.tipehalefthebrew = 1430, e2.tippigurmukhi = 2672, e2.titlocyrilliccmb = 1155, e2.tiwnarmenian = 1407, e2.tlinebelow = 7791, e2.tmonospace = 65364, e2.toarmenian = 1385, e2.tohiragana = 12392, e2.tokatakana = 12488, e2.tokatakanahalfwidth = 65412, e2.tonebarextrahighmod = 741, e2.tonebarextralowmod = 745, e2.tonebarhighmod = 742, e2.tonebarlowmod = 744, e2.tonebarmidmod = 743, e2.tonefive = 445, e2.tonesix = 389, e2.tonetwo = 424, e2.tonos = 900, e2.tonsquare = 13095, e2.topatakthai = 3599, e2.tortoiseshellbracketleft = 12308, e2.tortoiseshellbracketleftsmall = 65117, e2.tortoiseshellbracketleftvertical = 65081, e2.tortoiseshellbracketright = 12309, e2.tortoiseshellbracketrightsmall = 65118, e2.tortoiseshellbracketrightvertical = 65082, e2.totaothai = 3605, e2.tpalatalhook = 427, e2.tparen = 9391, e2.trademark = 8482, e2.trademarksans = 63722, e2.trademarkserif = 63195, e2.tretroflexhook = 648, e2.triagdn = 9660, e2.triaglf = 9668, e2.triagrt = 9658, e2.triagup = 9650, e2.ts = 678, e2.tsadi = 1510, e2.tsadidagesh = 64326, e2.tsadidageshhebrew = 64326, e2.tsadihebrew = 1510, e2.tsecyrillic = 1094, e2.tsere = 1461, e2.tsere12 = 1461, e2.tsere1e = 1461, e2.tsere2b = 1461, e2.tserehebrew = 1461, e2.tserenarrowhebrew = 1461, e2.tserequarterhebrew = 1461, e2.tserewidehebrew = 1461, e2.tshecyrillic = 1115, e2.tsuperior = 63219, e2.ttabengali = 2463, e2.ttadeva = 2335, e2.ttagujarati = 2719, e2.ttagurmukhi = 2591, e2.tteharabic = 1657, e2.ttehfinalarabic = 64359, e2.ttehinitialarabic = 64360, e2.ttehmedialarabic = 64361, e2.tthabengali = 2464, e2.tthadeva = 2336, e2.tthagujarati = 2720, e2.tthagurmukhi = 2592, e2.tturned = 647, e2.tuhiragana = 12388, e2.tukatakana = 12484, e2.tukatakanahalfwidth = 65410, e2.tusmallhiragana = 12387, e2.tusmallkatakana = 12483, e2.tusmallkatakanahalfwidth = 65391, e2.twelvecircle = 9323, e2.twelveparen = 9343, e2.twelveperiod = 9363, e2.twelveroman = 8571, e2.twentycircle = 9331, e2.twentyhangzhou = 21316, e2.twentyparen = 9351, e2.twentyperiod = 9371, e2.two = 50, e2.twoarabic = 1634, e2.twobengali = 2536, e2.twocircle = 9313, e2.twocircleinversesansserif = 10123, e2.twodeva = 2408, e2.twodotenleader = 8229, e2.twodotleader = 8229, e2.twodotleadervertical = 65072, e2.twogujarati = 2792, e2.twogurmukhi = 2664, e2.twohackarabic = 1634, e2.twohangzhou = 12322, e2.twoideographicparen = 12833, e2.twoinferior = 8322, e2.twomonospace = 65298, e2.twonumeratorbengali = 2549, e2.twooldstyle = 63282, e2.twoparen = 9333, e2.twoperiod = 9353, e2.twopersian = 1778, e2.tworoman = 8561, e2.twostroke = 443, e2.twosuperior = 178, e2.twothai = 3666, e2.twothirds = 8532, e2.u = 117, e2.uacute = 250, e2.ubar = 649, e2.ubengali = 2441, e2.ubopomofo = 12584, e2.ubreve = 365, e2.ucaron = 468, e2.ucircle = 9444, e2.ucircumflex = 251, e2.ucircumflexbelow = 7799, e2.ucyrillic = 1091, e2.udattadeva = 2385, e2.udblacute = 369, e2.udblgrave = 533, e2.udeva = 2313, e2.udieresis = 252, e2.udieresisacute = 472, e2.udieresisbelow = 7795, e2.udieresiscaron = 474, e2.udieresiscyrillic = 1265, e2.udieresisgrave = 476, e2.udieresismacron = 470, e2.udotbelow = 7909, e2.ugrave = 249, e2.ugujarati = 2697, e2.ugurmukhi = 2569, e2.uhiragana = 12358, e2.uhookabove = 7911, e2.uhorn = 432, e2.uhornacute = 7913, e2.uhorndotbelow = 7921, e2.uhorngrave = 7915, e2.uhornhookabove = 7917, e2.uhorntilde = 7919, e2.uhungarumlaut = 369, e2.uhungarumlautcyrillic = 1267, e2.uinvertedbreve = 535, e2.ukatakana = 12454, e2.ukatakanahalfwidth = 65395, e2.ukcyrillic = 1145, e2.ukorean = 12636, e2.umacron = 363, e2.umacroncyrillic = 1263, e2.umacrondieresis = 7803, e2.umatragurmukhi = 2625, e2.umonospace = 65365, e2.underscore = 95, e2.underscoredbl = 8215, e2.underscoremonospace = 65343, e2.underscorevertical = 65075, e2.underscorewavy = 65103, e2.union = 8746, e2.universal = 8704, e2.uogonek = 371, e2.uparen = 9392, e2.upblock = 9600, e2.upperdothebrew = 1476, e2.upsilon = 965, e2.upsilondieresis = 971, e2.upsilondieresistonos = 944, e2.upsilonlatin = 650, e2.upsilontonos = 973, e2.uptackbelowcmb = 797, e2.uptackmod = 724, e2.uragurmukhi = 2675, e2.uring = 367, e2.ushortcyrillic = 1118, e2.usmallhiragana = 12357, e2.usmallkatakana = 12453, e2.usmallkatakanahalfwidth = 65385, e2.ustraightcyrillic = 1199, e2.ustraightstrokecyrillic = 1201, e2.utilde = 361, e2.utildeacute = 7801, e2.utildebelow = 7797, e2.uubengali = 2442, e2.uudeva = 2314, e2.uugujarati = 2698, e2.uugurmukhi = 2570, e2.uumatragurmukhi = 2626, e2.uuvowelsignbengali = 2498, e2.uuvowelsigndeva = 2370, e2.uuvowelsigngujarati = 2754, e2.uvowelsignbengali = 2497, e2.uvowelsigndeva = 2369, e2.uvowelsigngujarati = 2753, e2.v = 118, e2.vadeva = 2357, e2.vagujarati = 2741, e2.vagurmukhi = 2613, e2.vakatakana = 12535, e2.vav = 1493, e2.vavdagesh = 64309, e2.vavdagesh65 = 64309, e2.vavdageshhebrew = 64309, e2.vavhebrew = 1493, e2.vavholam = 64331, e2.vavholamhebrew = 64331, e2.vavvavhebrew = 1520, e2.vavyodhebrew = 1521, e2.vcircle = 9445, e2.vdotbelow = 7807, e2.vecyrillic = 1074, e2.veharabic = 1700, e2.vehfinalarabic = 64363, e2.vehinitialarabic = 64364, e2.vehmedialarabic = 64365, e2.vekatakana = 12537, e2.venus = 9792, e2.verticalbar = 124, e2.verticallineabovecmb = 781, e2.verticallinebelowcmb = 809, e2.verticallinelowmod = 716, e2.verticallinemod = 712, e2.vewarmenian = 1406, e2.vhook = 651, e2.vikatakana = 12536, e2.viramabengali = 2509, e2.viramadeva = 2381, e2.viramagujarati = 2765, e2.visargabengali = 2435, e2.visargadeva = 2307, e2.visargagujarati = 2691, e2.vmonospace = 65366, e2.voarmenian = 1400, e2.voicediterationhiragana = 12446, e2.voicediterationkatakana = 12542, e2.voicedmarkkana = 12443, e2.voicedmarkkanahalfwidth = 65438, e2.vokatakana = 12538, e2.vparen = 9393, e2.vtilde = 7805, e2.vturned = 652, e2.vuhiragana = 12436, e2.vukatakana = 12532, e2.w = 119, e2.wacute = 7811, e2.waekorean = 12633, e2.wahiragana = 12431, e2.wakatakana = 12527, e2.wakatakanahalfwidth = 65436, e2.wakorean = 12632, e2.wasmallhiragana = 12430, e2.wasmallkatakana = 12526, e2.wattosquare = 13143, e2.wavedash = 12316, e2.wavyunderscorevertical = 65076, e2.wawarabic = 1608, e2.wawfinalarabic = 65262, e2.wawhamzaabovearabic = 1572, e2.wawhamzaabovefinalarabic = 65158, e2.wbsquare = 13277, e2.wcircle = 9446, e2.wcircumflex = 373, e2.wdieresis = 7813, e2.wdotaccent = 7815, e2.wdotbelow = 7817, e2.wehiragana = 12433, e2.weierstrass = 8472, e2.wekatakana = 12529, e2.wekorean = 12638, e2.weokorean = 12637, e2.wgrave = 7809, e2.whitebullet = 9702, e2.whitecircle = 9675, e2.whitecircleinverse = 9689, e2.whitecornerbracketleft = 12302, e2.whitecornerbracketleftvertical = 65091, e2.whitecornerbracketright = 12303, e2.whitecornerbracketrightvertical = 65092, e2.whitediamond = 9671, e2.whitediamondcontainingblacksmalldiamond = 9672, e2.whitedownpointingsmalltriangle = 9663;
      e2.whitedownpointingtriangle = 9661, e2.whiteleftpointingsmalltriangle = 9667, e2.whiteleftpointingtriangle = 9665, e2.whitelenticularbracketleft = 12310, e2.whitelenticularbracketright = 12311, e2.whiterightpointingsmalltriangle = 9657, e2.whiterightpointingtriangle = 9655, e2.whitesmallsquare = 9643, e2.whitesmilingface = 9786, e2.whitesquare = 9633, e2.whitestar = 9734, e2.whitetelephone = 9743, e2.whitetortoiseshellbracketleft = 12312, e2.whitetortoiseshellbracketright = 12313, e2.whiteuppointingsmalltriangle = 9653, e2.whiteuppointingtriangle = 9651, e2.wihiragana = 12432, e2.wikatakana = 12528, e2.wikorean = 12639, e2.wmonospace = 65367, e2.wohiragana = 12434, e2.wokatakana = 12530, e2.wokatakanahalfwidth = 65382, e2.won = 8361, e2.wonmonospace = 65510, e2.wowaenthai = 3623, e2.wparen = 9394, e2.wring = 7832, e2.wsuperior = 695, e2.wturned = 653, e2.wynn = 447, e2.x = 120, e2.xabovecmb = 829, e2.xbopomofo = 12562, e2.xcircle = 9447, e2.xdieresis = 7821, e2.xdotaccent = 7819, e2.xeharmenian = 1389, e2.xi = 958, e2.xmonospace = 65368, e2.xparen = 9395, e2.xsuperior = 739, e2.y = 121, e2.yaadosquare = 13134, e2.yabengali = 2479, e2.yacute = 253, e2.yadeva = 2351, e2.yaekorean = 12626, e2.yagujarati = 2735, e2.yagurmukhi = 2607, e2.yahiragana = 12420, e2.yakatakana = 12516, e2.yakatakanahalfwidth = 65428, e2.yakorean = 12625, e2.yamakkanthai = 3662, e2.yasmallhiragana = 12419, e2.yasmallkatakana = 12515, e2.yasmallkatakanahalfwidth = 65388, e2.yatcyrillic = 1123, e2.ycircle = 9448, e2.ycircumflex = 375, e2.ydieresis = 255, e2.ydotaccent = 7823, e2.ydotbelow = 7925, e2.yeharabic = 1610, e2.yehbarreearabic = 1746, e2.yehbarreefinalarabic = 64431, e2.yehfinalarabic = 65266, e2.yehhamzaabovearabic = 1574, e2.yehhamzaabovefinalarabic = 65162, e2.yehhamzaaboveinitialarabic = 65163, e2.yehhamzaabovemedialarabic = 65164, e2.yehinitialarabic = 65267, e2.yehmedialarabic = 65268, e2.yehmeeminitialarabic = 64733, e2.yehmeemisolatedarabic = 64600, e2.yehnoonfinalarabic = 64660, e2.yehthreedotsbelowarabic = 1745, e2.yekorean = 12630, e2.yen = 165, e2.yenmonospace = 65509, e2.yeokorean = 12629, e2.yeorinhieuhkorean = 12678, e2.yerahbenyomohebrew = 1450, e2.yerahbenyomolefthebrew = 1450, e2.yericyrillic = 1099, e2.yerudieresiscyrillic = 1273, e2.yesieungkorean = 12673, e2.yesieungpansioskorean = 12675, e2.yesieungsioskorean = 12674, e2.yetivhebrew = 1434, e2.ygrave = 7923, e2.yhook = 436, e2.yhookabove = 7927, e2.yiarmenian = 1397, e2.yicyrillic = 1111, e2.yikorean = 12642, e2.yinyang = 9775, e2.yiwnarmenian = 1410, e2.ymonospace = 65369, e2.yod = 1497, e2.yoddagesh = 64313, e2.yoddageshhebrew = 64313, e2.yodhebrew = 1497, e2.yodyodhebrew = 1522, e2.yodyodpatahhebrew = 64287, e2.yohiragana = 12424, e2.yoikorean = 12681, e2.yokatakana = 12520, e2.yokatakanahalfwidth = 65430, e2.yokorean = 12635, e2.yosmallhiragana = 12423, e2.yosmallkatakana = 12519, e2.yosmallkatakanahalfwidth = 65390, e2.yotgreek = 1011, e2.yoyaekorean = 12680, e2.yoyakorean = 12679, e2.yoyakthai = 3618, e2.yoyingthai = 3597, e2.yparen = 9396, e2.ypogegrammeni = 890, e2.ypogegrammenigreekcmb = 837, e2.yr = 422, e2.yring = 7833, e2.ysuperior = 696, e2.ytilde = 7929, e2.yturned = 654, e2.yuhiragana = 12422, e2.yuikorean = 12684, e2.yukatakana = 12518, e2.yukatakanahalfwidth = 65429, e2.yukorean = 12640, e2.yusbigcyrillic = 1131, e2.yusbigiotifiedcyrillic = 1133, e2.yuslittlecyrillic = 1127, e2.yuslittleiotifiedcyrillic = 1129, e2.yusmallhiragana = 12421, e2.yusmallkatakana = 12517, e2.yusmallkatakanahalfwidth = 65389, e2.yuyekorean = 12683, e2.yuyeokorean = 12682, e2.yyabengali = 2527, e2.yyadeva = 2399, e2.z = 122, e2.zaarmenian = 1382, e2.zacute = 378, e2.zadeva = 2395, e2.zagurmukhi = 2651, e2.zaharabic = 1592, e2.zahfinalarabic = 65222, e2.zahinitialarabic = 65223, e2.zahiragana = 12374, e2.zahmedialarabic = 65224, e2.zainarabic = 1586, e2.zainfinalarabic = 65200, e2.zakatakana = 12470, e2.zaqefgadolhebrew = 1429, e2.zaqefqatanhebrew = 1428, e2.zarqahebrew = 1432, e2.zayin = 1494, e2.zayindagesh = 64310, e2.zayindageshhebrew = 64310, e2.zayinhebrew = 1494, e2.zbopomofo = 12567, e2.zcaron = 382, e2.zcircle = 9449, e2.zcircumflex = 7825, e2.zcurl = 657, e2.zdot = 380, e2.zdotaccent = 380, e2.zdotbelow = 7827, e2.zecyrillic = 1079, e2.zedescendercyrillic = 1177, e2.zedieresiscyrillic = 1247, e2.zehiragana = 12380, e2.zekatakana = 12476, e2.zero = 48, e2.zeroarabic = 1632, e2.zerobengali = 2534, e2.zerodeva = 2406, e2.zerogujarati = 2790, e2.zerogurmukhi = 2662, e2.zerohackarabic = 1632, e2.zeroinferior = 8320, e2.zeromonospace = 65296, e2.zerooldstyle = 63280, e2.zeropersian = 1776, e2.zerosuperior = 8304, e2.zerothai = 3664, e2.zerowidthjoiner = 65279, e2.zerowidthnonjoiner = 8204, e2.zerowidthspace = 8203, e2.zeta = 950, e2.zhbopomofo = 12563, e2.zhearmenian = 1386, e2.zhebrevecyrillic = 1218, e2.zhecyrillic = 1078, e2.zhedescendercyrillic = 1175, e2.zhedieresiscyrillic = 1245, e2.zihiragana = 12376, e2.zikatakana = 12472, e2.zinorhebrew = 1454, e2.zlinebelow = 7829, e2.zmonospace = 65370, e2.zohiragana = 12382, e2.zokatakana = 12478, e2.zparen = 9397, e2.zretroflexhook = 656, e2.zstroke = 438, e2.zuhiragana = 12378, e2.zukatakana = 12474, e2[".notdef"] = 0, e2.angbracketleftbig = 9001, e2.angbracketleftBig = 9001, e2.angbracketleftbigg = 9001, e2.angbracketleftBigg = 9001, e2.angbracketrightBig = 9002, e2.angbracketrightbig = 9002, e2.angbracketrightBigg = 9002, e2.angbracketrightbigg = 9002, e2.arrowhookleft = 8618, e2.arrowhookright = 8617, e2.arrowlefttophalf = 8636, e2.arrowleftbothalf = 8637, e2.arrownortheast = 8599, e2.arrownorthwest = 8598, e2.arrowrighttophalf = 8640, e2.arrowrightbothalf = 8641, e2.arrowsoutheast = 8600, e2.arrowsouthwest = 8601, e2.backslashbig = 8726, e2.backslashBig = 8726, e2.backslashBigg = 8726, e2.backslashbigg = 8726, e2.bardbl = 8214, e2.bracehtipdownleft = 65079, e2.bracehtipdownright = 65079, e2.bracehtipupleft = 65080, e2.bracehtipupright = 65080, e2.braceleftBig = 123, e2.braceleftbig = 123, e2.braceleftbigg = 123, e2.braceleftBigg = 123, e2.bracerightBig = 125, e2.bracerightbig = 125, e2.bracerightbigg = 125, e2.bracerightBigg = 125, e2.bracketleftbig = 91, e2.bracketleftBig = 91, e2.bracketleftbigg = 91, e2.bracketleftBigg = 91, e2.bracketrightBig = 93, e2.bracketrightbig = 93, e2.bracketrightbigg = 93, e2.bracketrightBigg = 93, e2.ceilingleftbig = 8968, e2.ceilingleftBig = 8968, e2.ceilingleftBigg = 8968, e2.ceilingleftbigg = 8968, e2.ceilingrightbig = 8969, e2.ceilingrightBig = 8969, e2.ceilingrightbigg = 8969, e2.ceilingrightBigg = 8969, e2.circledotdisplay = 8857, e2.circledottext = 8857, e2.circlemultiplydisplay = 8855, e2.circlemultiplytext = 8855, e2.circleplusdisplay = 8853, e2.circleplustext = 8853, e2.contintegraldisplay = 8750, e2.contintegraltext = 8750, e2.coproductdisplay = 8720, e2.coproducttext = 8720, e2.floorleftBig = 8970, e2.floorleftbig = 8970, e2.floorleftbigg = 8970, e2.floorleftBigg = 8970, e2.floorrightbig = 8971, e2.floorrightBig = 8971, e2.floorrightBigg = 8971, e2.floorrightbigg = 8971, e2.hatwide = 770, e2.hatwider = 770, e2.hatwidest = 770, e2.intercal = 7488, e2.integraldisplay = 8747, e2.integraltext = 8747, e2.intersectiondisplay = 8898, e2.intersectiontext = 8898, e2.logicalanddisplay = 8743, e2.logicalandtext = 8743, e2.logicalordisplay = 8744, e2.logicalortext = 8744, e2.parenleftBig = 40, e2.parenleftbig = 40, e2.parenleftBigg = 40, e2.parenleftbigg = 40, e2.parenrightBig = 41, e2.parenrightbig = 41, e2.parenrightBigg = 41, e2.parenrightbigg = 41, e2.prime = 8242, e2.productdisplay = 8719, e2.producttext = 8719, e2.radicalbig = 8730, e2.radicalBig = 8730, e2.radicalBigg = 8730, e2.radicalbigg = 8730, e2.radicalbt = 8730, e2.radicaltp = 8730, e2.radicalvertex = 8730, e2.slashbig = 47, e2.slashBig = 47, e2.slashBigg = 47, e2.slashbigg = 47, e2.summationdisplay = 8721, e2.summationtext = 8721, e2.tildewide = 732, e2.tildewider = 732, e2.tildewidest = 732, e2.uniondisplay = 8899, e2.unionmultidisplay = 8846, e2.unionmultitext = 8846, e2.unionsqdisplay = 8852, e2.unionsqtext = 8852, e2.uniontext = 8899, e2.vextenddouble = 8741, e2.vextendsingle = 8739;
    });
    ma = getLookupTableFactory(function(e2) {
      e2.space = 32, e2.a1 = 9985, e2.a2 = 9986, e2.a202 = 9987, e2.a3 = 9988, e2.a4 = 9742, e2.a5 = 9990, e2.a119 = 9991, e2.a118 = 9992, e2.a117 = 9993, e2.a11 = 9755, e2.a12 = 9758, e2.a13 = 9996, e2.a14 = 9997, e2.a15 = 9998, e2.a16 = 9999, e2.a105 = 1e4, e2.a17 = 10001, e2.a18 = 10002, e2.a19 = 10003, e2.a20 = 10004, e2.a21 = 10005, e2.a22 = 10006, e2.a23 = 10007, e2.a24 = 10008, e2.a25 = 10009, e2.a26 = 10010, e2.a27 = 10011, e2.a28 = 10012, e2.a6 = 10013, e2.a7 = 10014, e2.a8 = 10015, e2.a9 = 10016, e2.a10 = 10017, e2.a29 = 10018, e2.a30 = 10019, e2.a31 = 10020, e2.a32 = 10021, e2.a33 = 10022, e2.a34 = 10023, e2.a35 = 9733, e2.a36 = 10025, e2.a37 = 10026, e2.a38 = 10027, e2.a39 = 10028, e2.a40 = 10029, e2.a41 = 10030, e2.a42 = 10031, e2.a43 = 10032, e2.a44 = 10033, e2.a45 = 10034, e2.a46 = 10035, e2.a47 = 10036, e2.a48 = 10037, e2.a49 = 10038, e2.a50 = 10039, e2.a51 = 10040, e2.a52 = 10041, e2.a53 = 10042, e2.a54 = 10043, e2.a55 = 10044, e2.a56 = 10045, e2.a57 = 10046, e2.a58 = 10047, e2.a59 = 10048, e2.a60 = 10049, e2.a61 = 10050, e2.a62 = 10051, e2.a63 = 10052, e2.a64 = 10053, e2.a65 = 10054, e2.a66 = 10055, e2.a67 = 10056, e2.a68 = 10057, e2.a69 = 10058, e2.a70 = 10059, e2.a71 = 9679, e2.a72 = 10061, e2.a73 = 9632, e2.a74 = 10063, e2.a203 = 10064, e2.a75 = 10065, e2.a204 = 10066, e2.a76 = 9650, e2.a77 = 9660, e2.a78 = 9670, e2.a79 = 10070, e2.a81 = 9687, e2.a82 = 10072, e2.a83 = 10073, e2.a84 = 10074, e2.a97 = 10075, e2.a98 = 10076, e2.a99 = 10077, e2.a100 = 10078, e2.a101 = 10081, e2.a102 = 10082, e2.a103 = 10083, e2.a104 = 10084, e2.a106 = 10085, e2.a107 = 10086, e2.a108 = 10087, e2.a112 = 9827, e2.a111 = 9830, e2.a110 = 9829, e2.a109 = 9824, e2.a120 = 9312, e2.a121 = 9313, e2.a122 = 9314, e2.a123 = 9315, e2.a124 = 9316, e2.a125 = 9317, e2.a126 = 9318, e2.a127 = 9319, e2.a128 = 9320, e2.a129 = 9321, e2.a130 = 10102, e2.a131 = 10103, e2.a132 = 10104, e2.a133 = 10105, e2.a134 = 10106, e2.a135 = 10107, e2.a136 = 10108, e2.a137 = 10109, e2.a138 = 10110, e2.a139 = 10111, e2.a140 = 10112, e2.a141 = 10113, e2.a142 = 10114, e2.a143 = 10115, e2.a144 = 10116, e2.a145 = 10117, e2.a146 = 10118, e2.a147 = 10119, e2.a148 = 10120, e2.a149 = 10121, e2.a150 = 10122, e2.a151 = 10123, e2.a152 = 10124, e2.a153 = 10125, e2.a154 = 10126, e2.a155 = 10127, e2.a156 = 10128, e2.a157 = 10129, e2.a158 = 10130, e2.a159 = 10131, e2.a160 = 10132, e2.a161 = 8594, e2.a163 = 8596, e2.a164 = 8597, e2.a196 = 10136, e2.a165 = 10137, e2.a192 = 10138, e2.a166 = 10139, e2.a167 = 10140, e2.a168 = 10141, e2.a169 = 10142, e2.a170 = 10143, e2.a171 = 10144, e2.a172 = 10145, e2.a173 = 10146, e2.a162 = 10147, e2.a174 = 10148, e2.a175 = 10149, e2.a176 = 10150, e2.a177 = 10151, e2.a178 = 10152, e2.a179 = 10153, e2.a193 = 10154, e2.a180 = 10155, e2.a199 = 10156, e2.a181 = 10157, e2.a200 = 10158, e2.a182 = 10159, e2.a201 = 10161, e2.a183 = 10162, e2.a184 = 10163, e2.a197 = 10164, e2.a185 = 10165, e2.a194 = 10166, e2.a198 = 10167, e2.a186 = 10168, e2.a195 = 10169, e2.a187 = 10170, e2.a188 = 10171, e2.a189 = 10172, e2.a190 = 10173, e2.a191 = 10174, e2.a89 = 10088, e2.a90 = 10089, e2.a93 = 10090, e2.a94 = 10091, e2.a91 = 10092, e2.a92 = 10093, e2.a205 = 10094, e2.a85 = 10095, e2.a206 = 10096, e2.a86 = 10097, e2.a87 = 10098, e2.a88 = 10099, e2.a95 = 10100, e2.a96 = 10101, e2[".notdef"] = 0;
    });
    ba = getLookupTableFactory(function(e2) {
      e2[63721] = 169, e2[63193] = 169, e2[63720] = 174, e2[63194] = 174, e2[63722] = 8482, e2[63195] = 8482, e2[63729] = 9127, e2[63730] = 9128, e2[63731] = 9129, e2[63740] = 9131, e2[63741] = 9132, e2[63742] = 9133, e2[63726] = 9121, e2[63727] = 9122, e2[63728] = 9123, e2[63737] = 9124, e2[63738] = 9125, e2[63739] = 9126, e2[63723] = 9115, e2[63724] = 9116, e2[63725] = 9117, e2[63734] = 9118, e2[63735] = 9119, e2[63736] = 9120;
    });
    __name(getUnicodeForGlyph, "getUnicodeForGlyph");
    ya = [[0, 127], [128, 255], [256, 383], [384, 591], [592, 687, 7424, 7551, 7552, 7615], [688, 767, 42752, 42783], [768, 879, 7616, 7679], [880, 1023], [11392, 11519], [1024, 1279, 1280, 1327, 11744, 11775, 42560, 42655], [1328, 1423], [1424, 1535], [42240, 42559], [1536, 1791, 1872, 1919], [1984, 2047], [2304, 2431], [2432, 2559], [2560, 2687], [2688, 2815], [2816, 2943], [2944, 3071], [3072, 3199], [3200, 3327], [3328, 3455], [3584, 3711], [3712, 3839], [4256, 4351, 11520, 11567], [6912, 7039], [4352, 4607], [7680, 7935, 11360, 11391, 42784, 43007], [7936, 8191], [8192, 8303, 11776, 11903], [8304, 8351], [8352, 8399], [8400, 8447], [8448, 8527], [8528, 8591], [8592, 8703, 10224, 10239, 10496, 10623, 11008, 11263], [8704, 8959, 10752, 11007, 10176, 10223, 10624, 10751], [8960, 9215], [9216, 9279], [9280, 9311], [9312, 9471], [9472, 9599], [9600, 9631], [9632, 9727], [9728, 9983], [9984, 10175], [12288, 12351], [12352, 12447], [12448, 12543, 12784, 12799], [12544, 12591, 12704, 12735], [12592, 12687], [43072, 43135], [12800, 13055], [13056, 13311], [44032, 55215], [55296, 57343], [67840, 67871], [19968, 40959, 11904, 12031, 12032, 12255, 12272, 12287, 13312, 19903, 131072, 173791, 12688, 12703], [57344, 63743], [12736, 12783, 63744, 64255, 194560, 195103], [64256, 64335], [64336, 65023], [65056, 65071], [65040, 65055], [65104, 65135], [65136, 65279], [65280, 65519], [65520, 65535], [3840, 4095], [1792, 1871], [1920, 1983], [3456, 3583], [4096, 4255], [4608, 4991, 4992, 5023, 11648, 11743], [5024, 5119], [5120, 5759], [5760, 5791], [5792, 5887], [6016, 6143], [6144, 6319], [10240, 10495], [40960, 42127], [5888, 5919, 5920, 5951, 5952, 5983, 5984, 6015], [66304, 66351], [66352, 66383], [66560, 66639], [118784, 119039, 119040, 119295, 119296, 119375], [119808, 120831], [1044480, 1048573], [65024, 65039, 917760, 917999], [917504, 917631], [6400, 6479], [6480, 6527], [6528, 6623], [6656, 6687], [11264, 11359], [11568, 11647], [19904, 19967], [43008, 43055], [65536, 65663, 65664, 65791, 65792, 65855], [65856, 65935], [66432, 66463], [66464, 66527], [66640, 66687], [66688, 66735], [67584, 67647], [68096, 68191], [119552, 119647], [73728, 74751, 74752, 74879], [119648, 119679], [7040, 7103], [7168, 7247], [7248, 7295], [43136, 43231], [43264, 43311], [43312, 43359], [43520, 43615], [65936, 65999], [66e3, 66047], [66208, 66271, 66176, 66207, 67872, 67903], [127024, 127135, 126976, 127023]];
    __name(getUnicodeRangeFor, "getUnicodeRangeFor");
    wa = new RegExp("^(\\s)|(\\p{Mn})|(\\p{Cf})$", "u");
    Aa = /* @__PURE__ */ new Map();
    xa = true;
    Sa = 1;
    va = 2;
    Ca = 4;
    ka = 32;
    Ta = [".notdef", ".null", "nonmarkingreturn", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "nonbreakingspace", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "Lslash", "lslash", "Scaron", "scaron", "Zcaron", "zcaron", "brokenbar", "Eth", "eth", "Yacute", "yacute", "Thorn", "thorn", "minus", "multiply", "onesuperior", "twosuperior", "threesuperior", "onehalf", "onequarter", "threequarters", "franc", "Gbreve", "gbreve", "Idotaccent", "Scedilla", "scedilla", "Cacute", "cacute", "Ccaron", "ccaron", "dcroat"];
    __name(recoverGlyphName, "recoverGlyphName");
    __name(type1FontGlyphMapping, "type1FontGlyphMapping");
    __name(normalizeFontName, "normalizeFontName");
    Ia = getLookupTableFactory((e2) => {
      e2[8211] = 65074, e2[8212] = 65073, e2[8229] = 65072, e2[8230] = 65049, e2[12289] = 65041, e2[12290] = 65042, e2[12296] = 65087, e2[12297] = 65088, e2[12298] = 65085, e2[12299] = 65086, e2[12300] = 65089, e2[12301] = 65090, e2[12302] = 65091, e2[12303] = 65092, e2[12304] = 65083, e2[12305] = 65084, e2[12308] = 65081, e2[12309] = 65082, e2[12310] = 65047, e2[12311] = 65048, e2[65103] = 65076, e2[65281] = 65045, e2[65288] = 65077, e2[65289] = 65078, e2[65292] = 65040, e2[65306] = 65043, e2[65307] = 65044, e2[65311] = 65046, e2[65339] = 65095, e2[65341] = 65096, e2[65343] = 65075, e2[65371] = 65079, e2[65373] = 65080;
    });
    Fa = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron"];
    Ma = [".notdef", "space", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"];
    Da = [".notdef", "space", "dollaroldstyle", "dollarsuperior", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "hyphensuperior", "colonmonetary", "onefitted", "rupiah", "centoldstyle", "figuredash", "hypheninferior", "onequarter", "onehalf", "threequarters", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior"];
    Ea = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall", "001.000", "001.001", "001.002", "001.003", "Black", "Bold", "Book", "Light", "Medium", "Regular", "Roman", "Semibold"];
    Oa = 391;
    _a3 = [null, { id: "hstem", min: 2, stackClearing: true, stem: true }, null, { id: "vstem", min: 2, stackClearing: true, stem: true }, { id: "vmoveto", min: 1, stackClearing: true }, { id: "rlineto", min: 2, resetStack: true }, { id: "hlineto", min: 1, resetStack: true }, { id: "vlineto", min: 1, resetStack: true }, { id: "rrcurveto", min: 6, resetStack: true }, null, { id: "callsubr", min: 1, undefStack: true }, { id: "return", min: 0, undefStack: true }, null, null, { id: "endchar", min: 0, stackClearing: true }, null, null, null, { id: "hstemhm", min: 2, stackClearing: true, stem: true }, { id: "hintmask", min: 0, stackClearing: true }, { id: "cntrmask", min: 0, stackClearing: true }, { id: "rmoveto", min: 2, stackClearing: true }, { id: "hmoveto", min: 1, stackClearing: true }, { id: "vstemhm", min: 2, stackClearing: true, stem: true }, { id: "rcurveline", min: 8, resetStack: true }, { id: "rlinecurve", min: 8, resetStack: true }, { id: "vvcurveto", min: 4, resetStack: true }, { id: "hhcurveto", min: 4, resetStack: true }, null, { id: "callgsubr", min: 1, undefStack: true }, { id: "vhcurveto", min: 4, resetStack: true }, { id: "hvcurveto", min: 4, resetStack: true }];
    Pa = [null, null, null, { id: "and", min: 2, stackDelta: -1 }, { id: "or", min: 2, stackDelta: -1 }, { id: "not", min: 1, stackDelta: 0 }, null, null, null, { id: "abs", min: 1, stackDelta: 0 }, { id: "add", min: 2, stackDelta: -1, stackFn(e2, t2) {
      e2[t2 - 2] = e2[t2 - 2] + e2[t2 - 1];
    } }, { id: "sub", min: 2, stackDelta: -1, stackFn(e2, t2) {
      e2[t2 - 2] = e2[t2 - 2] - e2[t2 - 1];
    } }, { id: "div", min: 2, stackDelta: -1, stackFn(e2, t2) {
      e2[t2 - 2] = e2[t2 - 2] / e2[t2 - 1];
    } }, null, { id: "neg", min: 1, stackDelta: 0, stackFn(e2, t2) {
      e2[t2 - 1] = -e2[t2 - 1];
    } }, { id: "eq", min: 2, stackDelta: -1 }, null, null, { id: "drop", min: 1, stackDelta: -1 }, null, { id: "put", min: 2, stackDelta: -2 }, { id: "get", min: 1, stackDelta: 0 }, { id: "ifelse", min: 4, stackDelta: -3 }, { id: "random", min: 0, stackDelta: 1 }, { id: "mul", min: 2, stackDelta: -1, stackFn(e2, t2) {
      e2[t2 - 2] = e2[t2 - 2] * e2[t2 - 1];
    } }, null, { id: "sqrt", min: 1, stackDelta: 0 }, { id: "dup", min: 1, stackDelta: 1 }, { id: "exch", min: 2, stackDelta: 0 }, { id: "index", min: 2, stackDelta: 0 }, { id: "roll", min: 3, stackDelta: -2 }, null, null, null, { id: "hflex", min: 7, resetStack: true }, { id: "flex", min: 13, resetStack: true }, { id: "hflex1", min: 9, resetStack: true }, { id: "flex1", min: 11, resetStack: true }];
    CFFParser = class {
      constructor(e2, t2, i2) {
        this.bytes = e2.getBytes(), this.properties = t2, this.seacAnalysisEnabled = !!i2;
      }
      parse() {
        const e2 = this.properties, t2 = new CFF();
        this.cff = t2;
        const i2 = this.parseHeader(), a2 = this.parseIndex(i2.endPos), n2 = this.parseIndex(a2.endPos), s2 = this.parseIndex(n2.endPos), r2 = this.parseIndex(s2.endPos), o2 = this.parseDict(n2.obj.get(0)), l3 = this.createDict(CFFTopDict, o2, t2.strings);
        t2.header = i2.obj, t2.names = this.parseNameIndex(a2.obj), t2.strings = this.parseStringIndex(s2.obj), t2.topDict = l3, t2.globalSubrIndex = r2.obj, this.parsePrivateDict(t2.topDict), t2.isCIDFont = l3.hasName("ROS");
        const c2 = l3.getByName("CharStrings"), h2 = this.parseIndex(c2).obj, d2 = l3.getByName("FontMatrix");
        d2 && (e2.fontMatrix = d2);
        const u2 = l3.getByName("FontBBox");
        let g2, p2;
        if (u2 && (e2.ascent = Math.max(u2[3], u2[1]), e2.descent = Math.min(u2[1], u2[3]), e2.ascentScaled = true), t2.isCIDFont) {
          const e3 = this.parseIndex(l3.getByName("FDArray")).obj;
          for (let i3 = 0, a3 = e3.count; i3 < a3; ++i3) {
            const a4 = e3.get(i3), n3 = this.createDict(CFFTopDict, this.parseDict(a4), t2.strings);
            this.parsePrivateDict(n3), t2.fdArray.push(n3);
          }
          p2 = null, g2 = this.parseCharsets(l3.getByName("charset"), h2.count, t2.strings, true), t2.fdSelect = this.parseFDSelect(l3.getByName("FDSelect"), h2.count);
        } else
          g2 = this.parseCharsets(l3.getByName("charset"), h2.count, t2.strings, false), p2 = this.parseEncoding(l3.getByName("Encoding"), e2, t2.strings, g2.charset);
        t2.charset = g2, t2.encoding = p2;
        const f2 = this.parseCharStrings({ charStrings: h2, localSubrIndex: l3.privateDict.subrsIndex, globalSubrIndex: r2.obj, fdSelect: t2.fdSelect, fdArray: t2.fdArray, privateDict: l3.privateDict });
        return t2.charStrings = f2.charStrings, t2.seacs = f2.seacs, t2.widths = f2.widths, t2;
      }
      parseHeader() {
        let e2 = this.bytes;
        const t2 = e2.length;
        let i2 = 0;
        for (; i2 < t2 && 1 !== e2[i2]; )
          ++i2;
        if (i2 >= t2)
          throw new ti("Invalid CFF header");
        0 !== i2 && (info$1("cff data is shifted"), e2 = e2.subarray(i2), this.bytes = e2);
        const a2 = e2[0], n2 = e2[1], s2 = e2[2], r2 = e2[3];
        return { obj: new CFFHeader(a2, n2, s2, r2), endPos: s2 };
      }
      parseDict(e2) {
        let t2 = 0;
        function parseOperand() {
          let i3 = e2[t2++];
          return 30 === i3 ? function() {
            let i4 = "";
            const a3 = 15, n3 = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "E", "E-", null, "-"], s2 = e2.length;
            for (; t2 < s2; ) {
              const s3 = e2[t2++], r2 = s3 >> 4, o2 = 15 & s3;
              if (r2 === a3)
                break;
              if (i4 += n3[r2], o2 === a3)
                break;
              i4 += n3[o2];
            }
            return parseFloat(i4);
          }() : 28 === i3 ? (i3 = readInt16(e2, t2), t2 += 2, i3) : 29 === i3 ? (i3 = e2[t2++], i3 = i3 << 8 | e2[t2++], i3 = i3 << 8 | e2[t2++], i3 = i3 << 8 | e2[t2++], i3) : i3 >= 32 && i3 <= 246 ? i3 - 139 : i3 >= 247 && i3 <= 250 ? 256 * (i3 - 247) + e2[t2++] + 108 : i3 >= 251 && i3 <= 254 ? -256 * (i3 - 251) - e2[t2++] - 108 : (warn$1('CFFParser_parseDict: "' + i3 + '" is a reserved command.'), NaN);
        }
        __name(parseOperand, "parseOperand");
        let i2 = [];
        const a2 = [];
        t2 = 0;
        const n2 = e2.length;
        for (; t2 < n2; ) {
          let n3 = e2[t2];
          n3 <= 21 ? (12 === n3 && (n3 = n3 << 8 | e2[++t2]), a2.push([n3, i2]), i2 = [], ++t2) : i2.push(parseOperand());
        }
        return a2;
      }
      parseIndex(e2) {
        const t2 = new CFFIndex(), i2 = this.bytes, a2 = i2[e2++] << 8 | i2[e2++], n2 = [];
        let s2, r2, o2 = e2;
        if (0 !== a2) {
          const t3 = i2[e2++], l3 = e2 + (a2 + 1) * t3 - 1;
          for (s2 = 0, r2 = a2 + 1; s2 < r2; ++s2) {
            let a3 = 0;
            for (let n3 = 0; n3 < t3; ++n3)
              a3 <<= 8, a3 += i2[e2++];
            n2.push(l3 + a3);
          }
          o2 = n2[a2];
        }
        for (s2 = 0, r2 = n2.length - 1; s2 < r2; ++s2) {
          const e3 = n2[s2], a3 = n2[s2 + 1];
          t2.add(i2.subarray(e3, a3));
        }
        return { obj: t2, endPos: o2 };
      }
      parseNameIndex(e2) {
        const t2 = [];
        for (let i2 = 0, a2 = e2.count; i2 < a2; ++i2) {
          const a3 = e2.get(i2);
          t2.push(bytesToString$1(a3));
        }
        return t2;
      }
      parseStringIndex(e2) {
        const t2 = new CFFStrings();
        for (let i2 = 0, a2 = e2.count; i2 < a2; ++i2) {
          const a3 = e2.get(i2);
          t2.add(bytesToString$1(a3));
        }
        return t2;
      }
      createDict(e2, t2, i2) {
        const a2 = new e2(i2);
        for (const [e3, i3] of t2)
          a2.setByKey(e3, i3);
        return a2;
      }
      parseCharString(e2, t2, i2, a2) {
        if (!t2 || e2.callDepth > 10)
          return false;
        let n2 = e2.stackSize;
        const s2 = e2.stack;
        let r2 = t2.length;
        for (let o2 = 0; o2 < r2; ) {
          const l3 = t2[o2++];
          let c2 = null;
          if (12 === l3) {
            const e3 = t2[o2++];
            0 === e3 ? (t2[o2 - 2] = 139, t2[o2 - 1] = 22, n2 = 0) : c2 = Pa[e3];
          } else if (28 === l3)
            s2[n2] = readInt16(t2, o2), o2 += 2, n2++;
          else if (14 === l3) {
            if (n2 >= 4 && (n2 -= 4, this.seacAnalysisEnabled))
              return e2.seac = s2.slice(n2, n2 + 4), false;
            c2 = _a3[l3];
          } else if (l3 >= 32 && l3 <= 246)
            s2[n2] = l3 - 139, n2++;
          else if (l3 >= 247 && l3 <= 254)
            s2[n2] = l3 < 251 ? (l3 - 247 << 8) + t2[o2] + 108 : -(l3 - 251 << 8) - t2[o2] - 108, o2++, n2++;
          else if (255 === l3)
            s2[n2] = (t2[o2] << 24 | t2[o2 + 1] << 16 | t2[o2 + 2] << 8 | t2[o2 + 3]) / 65536, o2 += 4, n2++;
          else if (19 === l3 || 20 === l3) {
            if (e2.hints += n2 >> 1, 0 === e2.hints) {
              t2.copyWithin(o2 - 1, o2, -1), o2 -= 1, r2 -= 1;
              continue;
            }
            o2 += e2.hints + 7 >> 3, n2 %= 2, c2 = _a3[l3];
          } else {
            if (10 === l3 || 29 === l3) {
              const t3 = 10 === l3 ? i2 : a2;
              if (!t3)
                return c2 = _a3[l3], warn$1("Missing subrsIndex for " + c2.id), false;
              let r3 = 32768;
              t3.count < 1240 ? r3 = 107 : t3.count < 33900 && (r3 = 1131);
              const o3 = s2[--n2] + r3;
              if (o3 < 0 || o3 >= t3.count || isNaN(o3))
                return c2 = _a3[l3], warn$1("Out of bounds subrIndex for " + c2.id), false;
              e2.stackSize = n2, e2.callDepth++;
              if (!this.parseCharString(e2, t3.get(o3), i2, a2))
                return false;
              e2.callDepth--, n2 = e2.stackSize;
              continue;
            }
            if (11 === l3)
              return e2.stackSize = n2, true;
            if (0 === l3 && o2 === t2.length)
              t2[o2 - 1] = 14, c2 = _a3[14];
            else {
              if (9 === l3) {
                t2.copyWithin(o2 - 1, o2, -1), o2 -= 1, r2 -= 1;
                continue;
              }
              c2 = _a3[l3];
            }
          }
          if (c2) {
            if (c2.stem && (e2.hints += n2 >> 1, 3 === l3 || 23 === l3 ? e2.hasVStems = true : !e2.hasVStems || 1 !== l3 && 18 !== l3 || (warn$1("CFF stem hints are in wrong order"), t2[o2 - 1] = 1 === l3 ? 3 : 23)), "min" in c2 && !e2.undefStack && n2 < c2.min)
              return warn$1("Not enough parameters for " + c2.id + "; actual: " + n2 + ", expected: " + c2.min), 0 === n2 && (t2[o2 - 1] = 14, true);
            e2.firstStackClearing && c2.stackClearing && (e2.firstStackClearing = false, n2 -= c2.min, n2 >= 2 && c2.stem ? n2 %= 2 : n2 > 1 && warn$1("Found too many parameters for stack-clearing command"), n2 > 0 && (e2.width = s2[n2 - 1])), "stackDelta" in c2 ? ("stackFn" in c2 && c2.stackFn(s2, n2), n2 += c2.stackDelta) : c2.stackClearing ? n2 = 0 : c2.resetStack ? (n2 = 0, e2.undefStack = false) : c2.undefStack && (n2 = 0, e2.undefStack = true, e2.firstStackClearing = false);
          }
        }
        return r2 < t2.length && t2.fill(14, r2), e2.stackSize = n2, true;
      }
      parseCharStrings({ charStrings: e2, localSubrIndex: t2, globalSubrIndex: i2, fdSelect: a2, fdArray: n2, privateDict: s2 }) {
        const r2 = [], o2 = [], l3 = e2.count;
        for (let c2 = 0; c2 < l3; c2++) {
          const l4 = e2.get(c2), h2 = { callDepth: 0, stackSize: 0, stack: [], undefStack: true, hints: 0, firstStackClearing: true, seac: null, width: null, hasVStems: false };
          let d2 = true, u2 = null, g2 = s2;
          if (a2 && n2.length) {
            const e3 = a2.getFDIndex(c2);
            -1 === e3 && (warn$1("Glyph index is not in fd select."), d2 = false), e3 >= n2.length && (warn$1("Invalid fd index for glyph index."), d2 = false), d2 && (g2 = n2[e3].privateDict, u2 = g2.subrsIndex);
          } else
            t2 && (u2 = t2);
          if (d2 && (d2 = this.parseCharString(h2, l4, u2, i2)), null !== h2.width) {
            const e3 = g2.getByName("nominalWidthX");
            o2[c2] = e3 + h2.width;
          } else {
            const e3 = g2.getByName("defaultWidthX");
            o2[c2] = e3;
          }
          null !== h2.seac && (r2[c2] = h2.seac), d2 || e2.set(c2, new Uint8Array([14]));
        }
        return { charStrings: e2, seacs: r2, widths: o2 };
      }
      emptyPrivateDictionary(e2) {
        const t2 = this.createDict(CFFPrivateDict, [], e2.strings);
        e2.setByKey(18, [0, 0]), e2.privateDict = t2;
      }
      parsePrivateDict(e2) {
        if (!e2.hasName("Private"))
          return void this.emptyPrivateDictionary(e2);
        const t2 = e2.getByName("Private");
        if (!Array.isArray(t2) || 2 !== t2.length)
          return void e2.removeByName("Private");
        const i2 = t2[0], a2 = t2[1];
        if (0 === i2 || a2 >= this.bytes.length)
          return void this.emptyPrivateDictionary(e2);
        const n2 = a2 + i2, s2 = this.bytes.subarray(a2, n2), r2 = this.parseDict(s2), o2 = this.createDict(CFFPrivateDict, r2, e2.strings);
        if (e2.privateDict = o2, 0 === o2.getByName("ExpansionFactor") && o2.setByName("ExpansionFactor", 0.06), !o2.getByName("Subrs"))
          return;
        const l3 = o2.getByName("Subrs"), c2 = a2 + l3;
        if (0 === l3 || c2 >= this.bytes.length)
          return void this.emptyPrivateDictionary(e2);
        const h2 = this.parseIndex(c2);
        o2.subrsIndex = h2.obj;
      }
      parseCharsets(e2, t2, i2, a2) {
        if (0 === e2)
          return new CFFCharset(true, Na.ISO_ADOBE, Fa);
        if (1 === e2)
          return new CFFCharset(true, Na.EXPERT, Ma);
        if (2 === e2)
          return new CFFCharset(true, Na.EXPERT_SUBSET, Da);
        const n2 = this.bytes, s2 = e2, r2 = n2[e2++], o2 = [a2 ? 0 : ".notdef"];
        let l3, c2, h2;
        switch (t2 -= 1, r2) {
          case 0:
            for (h2 = 0; h2 < t2; h2++)
              l3 = n2[e2++] << 8 | n2[e2++], o2.push(a2 ? l3 : i2.get(l3));
            break;
          case 1:
            for (; o2.length <= t2; )
              for (l3 = n2[e2++] << 8 | n2[e2++], c2 = n2[e2++], h2 = 0; h2 <= c2; h2++)
                o2.push(a2 ? l3++ : i2.get(l3++));
            break;
          case 2:
            for (; o2.length <= t2; )
              for (l3 = n2[e2++] << 8 | n2[e2++], c2 = n2[e2++] << 8 | n2[e2++], h2 = 0; h2 <= c2; h2++)
                o2.push(a2 ? l3++ : i2.get(l3++));
            break;
          default:
            throw new ti("Unknown charset format");
        }
        const d2 = e2, u2 = n2.subarray(s2, d2);
        return new CFFCharset(false, r2, o2, u2);
      }
      parseEncoding(e2, t2, i2, a2) {
        const n2 = /* @__PURE__ */ Object.create(null), s2 = this.bytes;
        let r2, o2, l3, c2 = false, h2 = null;
        if (0 === e2 || 1 === e2) {
          c2 = true, r2 = e2;
          const t3 = e2 ? la : da;
          for (o2 = 0, l3 = a2.length; o2 < l3; o2++) {
            const e3 = t3.indexOf(a2[o2]);
            -1 !== e3 && (n2[e3] = o2);
          }
        } else {
          const t3 = e2;
          switch (r2 = s2[e2++], 127 & r2) {
            case 0:
              const t4 = s2[e2++];
              for (o2 = 1; o2 <= t4; o2++)
                n2[s2[e2++]] = o2;
              break;
            case 1:
              const i3 = s2[e2++];
              let a3 = 1;
              for (o2 = 0; o2 < i3; o2++) {
                const t5 = s2[e2++], i4 = s2[e2++];
                for (let e3 = t5; e3 <= t5 + i4; e3++)
                  n2[e3] = a3++;
              }
              break;
            default:
              throw new ti(`Unknown encoding format: ${r2} in CFF`);
          }
          const l4 = e2;
          128 & r2 && (s2[t3] &= 127, function() {
            const t4 = s2[e2++];
            for (o2 = 0; o2 < t4; o2++) {
              const t5 = s2[e2++], r3 = (s2[e2++] << 8) + (255 & s2[e2++]);
              n2[t5] = a2.indexOf(i2.get(r3));
            }
          }()), h2 = s2.subarray(t3, l4);
        }
        return r2 &= 127, new CFFEncoding(c2, r2, n2, h2);
      }
      parseFDSelect(e2, t2) {
        const i2 = this.bytes, a2 = i2[e2++], n2 = [];
        let s2;
        switch (a2) {
          case 0:
            for (s2 = 0; s2 < t2; ++s2) {
              const t3 = i2[e2++];
              n2.push(t3);
            }
            break;
          case 3:
            const r2 = i2[e2++] << 8 | i2[e2++];
            for (s2 = 0; s2 < r2; ++s2) {
              let t3 = i2[e2++] << 8 | i2[e2++];
              0 === s2 && 0 !== t3 && (warn$1("parseFDSelect: The first range must have a first GID of 0 -- trying to recover."), t3 = 0);
              const a3 = i2[e2++], r3 = i2[e2] << 8 | i2[e2 + 1];
              for (let e3 = t3; e3 < r3; ++e3)
                n2.push(a3);
            }
            e2 += 2;
            break;
          default:
            throw new ti(`parseFDSelect: Unknown format "${a2}".`);
        }
        if (n2.length !== t2)
          throw new ti("parseFDSelect: Invalid font data.");
        return new CFFFDSelect(a2, n2);
      }
    };
    __name(CFFParser, "CFFParser");
    CFF = class {
      constructor() {
        this.header = null, this.names = [], this.topDict = null, this.strings = new CFFStrings(), this.globalSubrIndex = null, this.encoding = null, this.charset = null, this.charStrings = null, this.fdArray = [], this.fdSelect = null, this.isCIDFont = false;
      }
      duplicateFirstGlyph() {
        if (this.charStrings.count >= 65535)
          return void warn$1("Not enough space in charstrings to duplicate first glyph.");
        const e2 = this.charStrings.get(0);
        this.charStrings.add(e2), this.isCIDFont && this.fdSelect.fdSelect.push(this.fdSelect.fdSelect[0]);
      }
      hasGlyphId(e2) {
        if (e2 < 0 || e2 >= this.charStrings.count)
          return false;
        return this.charStrings.get(e2).length > 0;
      }
    };
    __name(CFF, "CFF");
    CFFHeader = class {
      constructor(e2, t2, i2, a2) {
        this.major = e2, this.minor = t2, this.hdrSize = i2, this.offSize = a2;
      }
    };
    __name(CFFHeader, "CFFHeader");
    CFFStrings = class {
      constructor() {
        this.strings = [];
      }
      get(e2) {
        return e2 >= 0 && e2 <= 390 ? Ea[e2] : e2 - Oa <= this.strings.length ? this.strings[e2 - Oa] : Ea[0];
      }
      getSID(e2) {
        let t2 = Ea.indexOf(e2);
        return -1 !== t2 ? t2 : (t2 = this.strings.indexOf(e2), -1 !== t2 ? t2 + Oa : -1);
      }
      add(e2) {
        this.strings.push(e2);
      }
      get count() {
        return this.strings.length;
      }
    };
    __name(CFFStrings, "CFFStrings");
    CFFIndex = class {
      constructor() {
        this.objects = [], this.length = 0;
      }
      add(e2) {
        this.length += e2.length, this.objects.push(e2);
      }
      set(e2, t2) {
        this.length += t2.length - this.objects[e2].length, this.objects[e2] = t2;
      }
      get(e2) {
        return this.objects[e2];
      }
      get count() {
        return this.objects.length;
      }
    };
    __name(CFFIndex, "CFFIndex");
    CFFDict = class {
      constructor(e2, t2) {
        this.keyToNameMap = e2.keyToNameMap, this.nameToKeyMap = e2.nameToKeyMap, this.defaults = e2.defaults, this.types = e2.types, this.opcodes = e2.opcodes, this.order = e2.order, this.strings = t2, this.values = /* @__PURE__ */ Object.create(null);
      }
      setByKey(e2, t2) {
        if (!(e2 in this.keyToNameMap))
          return false;
        if (0 === t2.length)
          return true;
        for (const i3 of t2)
          if (isNaN(i3))
            return warn$1(`Invalid CFFDict value: "${t2}" for key "${e2}".`), true;
        const i2 = this.types[e2];
        return "num" !== i2 && "sid" !== i2 && "offset" !== i2 || (t2 = t2[0]), this.values[e2] = t2, true;
      }
      setByName(e2, t2) {
        if (!(e2 in this.nameToKeyMap))
          throw new ti(`Invalid dictionary name "${e2}"`);
        this.values[this.nameToKeyMap[e2]] = t2;
      }
      hasName(e2) {
        return this.nameToKeyMap[e2] in this.values;
      }
      getByName(e2) {
        if (!(e2 in this.nameToKeyMap))
          throw new ti(`Invalid dictionary name ${e2}"`);
        const t2 = this.nameToKeyMap[e2];
        return t2 in this.values ? this.values[t2] : this.defaults[t2];
      }
      removeByName(e2) {
        delete this.values[this.nameToKeyMap[e2]];
      }
      static createTables(e2) {
        const t2 = { keyToNameMap: {}, nameToKeyMap: {}, defaults: {}, types: {}, opcodes: {}, order: [] };
        for (const i2 of e2) {
          const e3 = Array.isArray(i2[0]) ? (i2[0][0] << 8) + i2[0][1] : i2[0];
          t2.keyToNameMap[e3] = i2[1], t2.nameToKeyMap[i2[1]] = e3, t2.types[e3] = i2[2], t2.defaults[e3] = i2[3], t2.opcodes[e3] = Array.isArray(i2[0]) ? i2[0] : [i2[0]], t2.order.push(e3);
        }
        return t2;
      }
    };
    __name(CFFDict, "CFFDict");
    Ra = [[[12, 30], "ROS", ["sid", "sid", "num"], null], [[12, 20], "SyntheticBase", "num", null], [0, "version", "sid", null], [1, "Notice", "sid", null], [[12, 0], "Copyright", "sid", null], [2, "FullName", "sid", null], [3, "FamilyName", "sid", null], [4, "Weight", "sid", null], [[12, 1], "isFixedPitch", "num", 0], [[12, 2], "ItalicAngle", "num", 0], [[12, 3], "UnderlinePosition", "num", -100], [[12, 4], "UnderlineThickness", "num", 50], [[12, 5], "PaintType", "num", 0], [[12, 6], "CharstringType", "num", 2], [[12, 7], "FontMatrix", ["num", "num", "num", "num", "num", "num"], [1e-3, 0, 0, 1e-3, 0, 0]], [13, "UniqueID", "num", null], [5, "FontBBox", ["num", "num", "num", "num"], [0, 0, 0, 0]], [[12, 8], "StrokeWidth", "num", 0], [14, "XUID", "array", null], [15, "charset", "offset", 0], [16, "Encoding", "offset", 0], [17, "CharStrings", "offset", 0], [18, "Private", ["offset", "offset"], null], [[12, 21], "PostScript", "sid", null], [[12, 22], "BaseFontName", "sid", null], [[12, 23], "BaseFontBlend", "delta", null], [[12, 31], "CIDFontVersion", "num", 0], [[12, 32], "CIDFontRevision", "num", 0], [[12, 33], "CIDFontType", "num", 0], [[12, 34], "CIDCount", "num", 8720], [[12, 35], "UIDBase", "num", null], [[12, 37], "FDSelect", "offset", null], [[12, 36], "FDArray", "offset", null], [[12, 38], "FontName", "sid", null]];
    CFFTopDict = class extends CFFDict {
      static get tables() {
        return shadow$1(this, "tables", this.createTables(Ra));
      }
      constructor(e2) {
        super(CFFTopDict.tables, e2), this.privateDict = null;
      }
    };
    __name(CFFTopDict, "CFFTopDict");
    Ba = [[6, "BlueValues", "delta", null], [7, "OtherBlues", "delta", null], [8, "FamilyBlues", "delta", null], [9, "FamilyOtherBlues", "delta", null], [[12, 9], "BlueScale", "num", 0.039625], [[12, 10], "BlueShift", "num", 7], [[12, 11], "BlueFuzz", "num", 1], [10, "StdHW", "num", null], [11, "StdVW", "num", null], [[12, 12], "StemSnapH", "delta", null], [[12, 13], "StemSnapV", "delta", null], [[12, 14], "ForceBold", "num", 0], [[12, 17], "LanguageGroup", "num", 0], [[12, 18], "ExpansionFactor", "num", 0.06], [[12, 19], "initialRandomSeed", "num", 0], [20, "defaultWidthX", "num", 0], [21, "nominalWidthX", "num", 0], [19, "Subrs", "offset", null]];
    CFFPrivateDict = class extends CFFDict {
      static get tables() {
        return shadow$1(this, "tables", this.createTables(Ba));
      }
      constructor(e2) {
        super(CFFPrivateDict.tables, e2), this.subrsIndex = null;
      }
    };
    __name(CFFPrivateDict, "CFFPrivateDict");
    Na = { ISO_ADOBE: 0, EXPERT: 1, EXPERT_SUBSET: 2 };
    CFFCharset = class {
      constructor(e2, t2, i2, a2) {
        this.predefined = e2, this.format = t2, this.charset = i2, this.raw = a2;
      }
    };
    __name(CFFCharset, "CFFCharset");
    CFFEncoding = class {
      constructor(e2, t2, i2, a2) {
        this.predefined = e2, this.format = t2, this.encoding = i2, this.raw = a2;
      }
    };
    __name(CFFEncoding, "CFFEncoding");
    CFFFDSelect = class {
      constructor(e2, t2) {
        this.format = e2, this.fdSelect = t2;
      }
      getFDIndex(e2) {
        return e2 < 0 || e2 >= this.fdSelect.length ? -1 : this.fdSelect[e2];
      }
    };
    __name(CFFFDSelect, "CFFFDSelect");
    CFFOffsetTracker = class {
      constructor() {
        this.offsets = /* @__PURE__ */ Object.create(null);
      }
      isTracking(e2) {
        return e2 in this.offsets;
      }
      track(e2, t2) {
        if (e2 in this.offsets)
          throw new ti(`Already tracking location of ${e2}`);
        this.offsets[e2] = t2;
      }
      offset(e2) {
        for (const t2 in this.offsets)
          this.offsets[t2] += e2;
      }
      setEntryLocation(e2, t2, i2) {
        if (!(e2 in this.offsets))
          throw new ti(`Not tracking location of ${e2}`);
        const a2 = i2.data, n2 = this.offsets[e2];
        for (let e3 = 0, i3 = t2.length; e3 < i3; ++e3) {
          const i4 = 5 * e3 + n2, s2 = i4 + 1, r2 = i4 + 2, o2 = i4 + 3, l3 = i4 + 4;
          if (29 !== a2[i4] || 0 !== a2[s2] || 0 !== a2[r2] || 0 !== a2[o2] || 0 !== a2[l3])
            throw new ti("writing to an offset that is not empty");
          const c2 = t2[e3];
          a2[i4] = 29, a2[s2] = c2 >> 24 & 255, a2[r2] = c2 >> 16 & 255, a2[o2] = c2 >> 8 & 255, a2[l3] = 255 & c2;
        }
      }
    };
    __name(CFFOffsetTracker, "CFFOffsetTracker");
    CFFCompiler = class {
      constructor(e2) {
        this.cff = e2;
      }
      compile() {
        const e2 = this.cff, t2 = { data: [], length: 0, add(e3) {
          try {
            this.data.push(...e3);
          } catch {
            this.data = this.data.concat(e3);
          }
          this.length = this.data.length;
        } }, i2 = this.compileHeader(e2.header);
        t2.add(i2);
        const a2 = this.compileNameIndex(e2.names);
        if (t2.add(a2), e2.isCIDFont && e2.topDict.hasName("FontMatrix")) {
          const t3 = e2.topDict.getByName("FontMatrix");
          e2.topDict.removeByName("FontMatrix");
          for (const i3 of e2.fdArray) {
            let e3 = t3.slice(0);
            i3.hasName("FontMatrix") && (e3 = ni.transform(e3, i3.getByName("FontMatrix"))), i3.setByName("FontMatrix", e3);
          }
        }
        const n2 = e2.topDict.getByName("XUID");
        n2?.length > 16 && e2.topDict.removeByName("XUID"), e2.topDict.setByName("charset", 0);
        let s2 = this.compileTopDicts([e2.topDict], t2.length, e2.isCIDFont);
        t2.add(s2.output);
        const r2 = s2.trackers[0], o2 = this.compileStringIndex(e2.strings.strings);
        t2.add(o2);
        const l3 = this.compileIndex(e2.globalSubrIndex);
        if (t2.add(l3), e2.encoding && e2.topDict.hasName("Encoding"))
          if (e2.encoding.predefined)
            r2.setEntryLocation("Encoding", [e2.encoding.format], t2);
          else {
            const i3 = this.compileEncoding(e2.encoding);
            r2.setEntryLocation("Encoding", [t2.length], t2), t2.add(i3);
          }
        const c2 = this.compileCharset(e2.charset, e2.charStrings.count, e2.strings, e2.isCIDFont);
        r2.setEntryLocation("charset", [t2.length], t2), t2.add(c2);
        const h2 = this.compileCharStrings(e2.charStrings);
        if (r2.setEntryLocation("CharStrings", [t2.length], t2), t2.add(h2), e2.isCIDFont) {
          r2.setEntryLocation("FDSelect", [t2.length], t2);
          const i3 = this.compileFDSelect(e2.fdSelect);
          t2.add(i3), s2 = this.compileTopDicts(e2.fdArray, t2.length, true), r2.setEntryLocation("FDArray", [t2.length], t2), t2.add(s2.output);
          const a3 = s2.trackers;
          this.compilePrivateDicts(e2.fdArray, a3, t2);
        }
        return this.compilePrivateDicts([e2.topDict], [r2], t2), t2.add([0]), t2.data;
      }
      encodeNumber(e2) {
        return Number.isInteger(e2) ? this.encodeInteger(e2) : this.encodeFloat(e2);
      }
      static get EncodeFloatRegExp() {
        return shadow$1(this, "EncodeFloatRegExp", /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/);
      }
      encodeFloat(e2) {
        let t2 = e2.toString();
        const i2 = CFFCompiler.EncodeFloatRegExp.exec(t2);
        if (i2) {
          const a3 = parseFloat("1e" + ((i2[2] ? +i2[2] : 0) + i2[1].length));
          t2 = (Math.round(e2 * a3) / a3).toString();
        }
        let a2, n2, s2 = "";
        for (a2 = 0, n2 = t2.length; a2 < n2; ++a2) {
          const e3 = t2[a2];
          s2 += "e" === e3 ? "-" === t2[++a2] ? "c" : "b" : "." === e3 ? "a" : "-" === e3 ? "e" : e3;
        }
        s2 += 1 & s2.length ? "f" : "ff";
        const r2 = [30];
        for (a2 = 0, n2 = s2.length; a2 < n2; a2 += 2)
          r2.push(parseInt(s2.substring(a2, a2 + 2), 16));
        return r2;
      }
      encodeInteger(e2) {
        let t2;
        return t2 = e2 >= -107 && e2 <= 107 ? [e2 + 139] : e2 >= 108 && e2 <= 1131 ? [247 + ((e2 -= 108) >> 8), 255 & e2] : e2 >= -1131 && e2 <= -108 ? [251 + ((e2 = -e2 - 108) >> 8), 255 & e2] : e2 >= -32768 && e2 <= 32767 ? [28, e2 >> 8 & 255, 255 & e2] : [29, e2 >> 24 & 255, e2 >> 16 & 255, e2 >> 8 & 255, 255 & e2], t2;
      }
      compileHeader(e2) {
        return [e2.major, e2.minor, 4, e2.offSize];
      }
      compileNameIndex(e2) {
        const t2 = new CFFIndex();
        for (const i2 of e2) {
          const e3 = Math.min(i2.length, 127);
          let a2 = new Array(e3);
          for (let t3 = 0; t3 < e3; t3++) {
            let e4 = i2[t3];
            (e4 < "!" || e4 > "~" || "[" === e4 || "]" === e4 || "(" === e4 || ")" === e4 || "{" === e4 || "}" === e4 || "<" === e4 || ">" === e4 || "/" === e4 || "%" === e4) && (e4 = "_"), a2[t3] = e4;
          }
          a2 = a2.join(""), "" === a2 && (a2 = "Bad_Font_Name"), t2.add(stringToBytes$1(a2));
        }
        return this.compileIndex(t2);
      }
      compileTopDicts(e2, t2, i2) {
        const a2 = [];
        let n2 = new CFFIndex();
        for (const s2 of e2) {
          i2 && (s2.removeByName("CIDFontVersion"), s2.removeByName("CIDFontRevision"), s2.removeByName("CIDFontType"), s2.removeByName("CIDCount"), s2.removeByName("UIDBase"));
          const e3 = new CFFOffsetTracker(), r2 = this.compileDict(s2, e3);
          a2.push(e3), n2.add(r2), e3.offset(t2);
        }
        return n2 = this.compileIndex(n2, a2), { trackers: a2, output: n2 };
      }
      compilePrivateDicts(e2, t2, i2) {
        for (let a2 = 0, n2 = e2.length; a2 < n2; ++a2) {
          const n3 = e2[a2], s2 = n3.privateDict;
          if (!s2 || !n3.hasName("Private"))
            throw new ti("There must be a private dictionary.");
          const r2 = new CFFOffsetTracker(), o2 = this.compileDict(s2, r2);
          let l3 = i2.length;
          if (r2.offset(l3), o2.length || (l3 = 0), t2[a2].setEntryLocation("Private", [o2.length, l3], i2), i2.add(o2), s2.subrsIndex && s2.hasName("Subrs")) {
            const e3 = this.compileIndex(s2.subrsIndex);
            r2.setEntryLocation("Subrs", [o2.length], i2), i2.add(e3);
          }
        }
      }
      compileDict(e2, t2) {
        const i2 = [];
        for (const a2 of e2.order) {
          if (!(a2 in e2.values))
            continue;
          let n2 = e2.values[a2], s2 = e2.types[a2];
          if (Array.isArray(s2) || (s2 = [s2]), Array.isArray(n2) || (n2 = [n2]), 0 !== n2.length) {
            for (let r2 = 0, o2 = s2.length; r2 < o2; ++r2) {
              const o3 = s2[r2], l3 = n2[r2];
              switch (o3) {
                case "num":
                case "sid":
                  i2.push(...this.encodeNumber(l3));
                  break;
                case "offset":
                  const s3 = e2.keyToNameMap[a2];
                  t2.isTracking(s3) || t2.track(s3, i2.length), i2.push(29, 0, 0, 0, 0);
                  break;
                case "array":
                case "delta":
                  i2.push(...this.encodeNumber(l3));
                  for (let e3 = 1, t3 = n2.length; e3 < t3; ++e3)
                    i2.push(...this.encodeNumber(n2[e3]));
                  break;
                default:
                  throw new ti(`Unknown data type of ${o3}`);
              }
            }
            i2.push(...e2.opcodes[a2]);
          }
        }
        return i2;
      }
      compileStringIndex(e2) {
        const t2 = new CFFIndex();
        for (const i2 of e2)
          t2.add(stringToBytes$1(i2));
        return this.compileIndex(t2);
      }
      compileCharStrings(e2) {
        const t2 = new CFFIndex();
        for (let i2 = 0; i2 < e2.count; i2++) {
          const a2 = e2.get(i2);
          0 !== a2.length ? t2.add(a2) : t2.add(new Uint8Array([139, 14]));
        }
        return this.compileIndex(t2);
      }
      compileCharset(e2, t2, i2, a2) {
        let n2;
        const s2 = t2 - 1;
        if (a2) {
          const e3 = s2 - 1;
          n2 = new Uint8Array([2, 0, 1, e3 >> 8 & 255, 255 & e3]);
        } else {
          n2 = new Uint8Array(1 + 2 * s2), n2[0] = 0;
          let t3 = 0;
          const a3 = e2.charset.length;
          let r2 = false;
          for (let s3 = 1; s3 < n2.length; s3 += 2) {
            let o2 = 0;
            if (t3 < a3) {
              const a4 = e2.charset[t3++];
              o2 = i2.getSID(a4), -1 === o2 && (o2 = 0, r2 || (r2 = true, warn$1(`Couldn't find ${a4} in CFF strings`)));
            }
            n2[s3] = o2 >> 8 & 255, n2[s3 + 1] = 255 & o2;
          }
        }
        return this.compileTypedArray(n2);
      }
      compileEncoding(e2) {
        return this.compileTypedArray(e2.raw);
      }
      compileFDSelect(e2) {
        const t2 = e2.format;
        let i2, a2;
        switch (t2) {
          case 0:
            for (i2 = new Uint8Array(1 + e2.fdSelect.length), i2[0] = t2, a2 = 0; a2 < e2.fdSelect.length; a2++)
              i2[a2 + 1] = e2.fdSelect[a2];
            break;
          case 3:
            const n2 = 0;
            let s2 = e2.fdSelect[0];
            const r2 = [t2, 0, 0, n2 >> 8 & 255, 255 & n2, s2];
            for (a2 = 1; a2 < e2.fdSelect.length; a2++) {
              const t3 = e2.fdSelect[a2];
              t3 !== s2 && (r2.push(a2 >> 8 & 255, 255 & a2, t3), s2 = t3);
            }
            const o2 = (r2.length - 3) / 3;
            r2[1] = o2 >> 8 & 255, r2[2] = 255 & o2, r2.push(a2 >> 8 & 255, 255 & a2), i2 = new Uint8Array(r2);
        }
        return this.compileTypedArray(i2);
      }
      compileTypedArray(e2) {
        return Array.from(e2);
      }
      compileIndex(e2, t2 = []) {
        const i2 = e2.objects, a2 = i2.length;
        if (0 === a2)
          return [0, 0];
        const n2 = [a2 >> 8 & 255, 255 & a2];
        let s2, r2, o2 = 1;
        for (s2 = 0; s2 < a2; ++s2)
          o2 += i2[s2].length;
        r2 = o2 < 256 ? 1 : o2 < 65536 ? 2 : o2 < 16777216 ? 3 : 4, n2.push(r2);
        let l3 = 1;
        for (s2 = 0; s2 < a2 + 1; s2++)
          1 === r2 ? n2.push(255 & l3) : 2 === r2 ? n2.push(l3 >> 8 & 255, 255 & l3) : 3 === r2 ? n2.push(l3 >> 16 & 255, l3 >> 8 & 255, 255 & l3) : n2.push(l3 >>> 24 & 255, l3 >> 16 & 255, l3 >> 8 & 255, 255 & l3), i2[s2] && (l3 += i2[s2].length);
        for (s2 = 0; s2 < a2; s2++)
          t2[s2] && t2[s2].offset(n2.length), n2.push(...i2[s2]);
        return n2;
      }
    };
    __name(CFFCompiler, "CFFCompiler");
    La = getLookupTableFactory(function(e2) {
      e2["Times-Roman"] = "Times-Roman", e2.Helvetica = "Helvetica", e2.Courier = "Courier", e2.Symbol = "Symbol", e2["Times-Bold"] = "Times-Bold", e2["Helvetica-Bold"] = "Helvetica-Bold", e2["Courier-Bold"] = "Courier-Bold", e2.ZapfDingbats = "ZapfDingbats", e2["Times-Italic"] = "Times-Italic", e2["Helvetica-Oblique"] = "Helvetica-Oblique", e2["Courier-Oblique"] = "Courier-Oblique", e2["Times-BoldItalic"] = "Times-BoldItalic", e2["Helvetica-BoldOblique"] = "Helvetica-BoldOblique", e2["Courier-BoldOblique"] = "Courier-BoldOblique", e2.ArialNarrow = "Helvetica", e2["ArialNarrow-Bold"] = "Helvetica-Bold", e2["ArialNarrow-BoldItalic"] = "Helvetica-BoldOblique", e2["ArialNarrow-Italic"] = "Helvetica-Oblique", e2.ArialBlack = "Helvetica", e2["ArialBlack-Bold"] = "Helvetica-Bold", e2["ArialBlack-BoldItalic"] = "Helvetica-BoldOblique", e2["ArialBlack-Italic"] = "Helvetica-Oblique", e2["Arial-Black"] = "Helvetica", e2["Arial-Black-Bold"] = "Helvetica-Bold", e2["Arial-Black-BoldItalic"] = "Helvetica-BoldOblique", e2["Arial-Black-Italic"] = "Helvetica-Oblique", e2.Arial = "Helvetica", e2["Arial-Bold"] = "Helvetica-Bold", e2["Arial-BoldItalic"] = "Helvetica-BoldOblique", e2["Arial-Italic"] = "Helvetica-Oblique", e2.ArialMT = "Helvetica", e2["Arial-BoldItalicMT"] = "Helvetica-BoldOblique", e2["Arial-BoldMT"] = "Helvetica-Bold", e2["Arial-ItalicMT"] = "Helvetica-Oblique", e2["Arial-BoldItalicMT-BoldItalic"] = "Helvetica-BoldOblique", e2["Arial-BoldMT-Bold"] = "Helvetica-Bold", e2["Arial-ItalicMT-Italic"] = "Helvetica-Oblique", e2.ArialUnicodeMS = "Helvetica", e2["ArialUnicodeMS-Bold"] = "Helvetica-Bold", e2["ArialUnicodeMS-BoldItalic"] = "Helvetica-BoldOblique", e2["ArialUnicodeMS-Italic"] = "Helvetica-Oblique", e2["Courier-BoldItalic"] = "Courier-BoldOblique", e2["Courier-Italic"] = "Courier-Oblique", e2.CourierNew = "Courier", e2["CourierNew-Bold"] = "Courier-Bold", e2["CourierNew-BoldItalic"] = "Courier-BoldOblique", e2["CourierNew-Italic"] = "Courier-Oblique", e2["CourierNewPS-BoldItalicMT"] = "Courier-BoldOblique", e2["CourierNewPS-BoldMT"] = "Courier-Bold", e2["CourierNewPS-ItalicMT"] = "Courier-Oblique", e2.CourierNewPSMT = "Courier", e2["Helvetica-BoldItalic"] = "Helvetica-BoldOblique", e2["Helvetica-Italic"] = "Helvetica-Oblique", e2["HelveticaLTStd-Bold"] = "Helvetica-Bold", e2["Symbol-Bold"] = "Symbol", e2["Symbol-BoldItalic"] = "Symbol", e2["Symbol-Italic"] = "Symbol", e2.TimesNewRoman = "Times-Roman", e2["TimesNewRoman-Bold"] = "Times-Bold", e2["TimesNewRoman-BoldItalic"] = "Times-BoldItalic", e2["TimesNewRoman-Italic"] = "Times-Italic", e2.TimesNewRomanPS = "Times-Roman", e2["TimesNewRomanPS-Bold"] = "Times-Bold", e2["TimesNewRomanPS-BoldItalic"] = "Times-BoldItalic", e2["TimesNewRomanPS-BoldItalicMT"] = "Times-BoldItalic", e2["TimesNewRomanPS-BoldMT"] = "Times-Bold", e2["TimesNewRomanPS-Italic"] = "Times-Italic", e2["TimesNewRomanPS-ItalicMT"] = "Times-Italic", e2.TimesNewRomanPSMT = "Times-Roman", e2["TimesNewRomanPSMT-Bold"] = "Times-Bold", e2["TimesNewRomanPSMT-BoldItalic"] = "Times-BoldItalic", e2["TimesNewRomanPSMT-Italic"] = "Times-Italic";
    });
    Ua = getLookupTableFactory(function(e2) {
      e2.Courier = "FoxitFixed.pfb", e2["Courier-Bold"] = "FoxitFixedBold.pfb", e2["Courier-BoldOblique"] = "FoxitFixedBoldItalic.pfb", e2["Courier-Oblique"] = "FoxitFixedItalic.pfb", e2.Helvetica = "LiberationSans-Regular.ttf", e2["Helvetica-Bold"] = "LiberationSans-Bold.ttf", e2["Helvetica-BoldOblique"] = "LiberationSans-BoldItalic.ttf", e2["Helvetica-Oblique"] = "LiberationSans-Italic.ttf", e2["Times-Roman"] = "FoxitSerif.pfb", e2["Times-Bold"] = "FoxitSerifBold.pfb", e2["Times-BoldItalic"] = "FoxitSerifBoldItalic.pfb", e2["Times-Italic"] = "FoxitSerifItalic.pfb", e2.Symbol = "FoxitSymbol.pfb", e2.ZapfDingbats = "FoxitDingbats.pfb", e2["LiberationSans-Regular"] = "LiberationSans-Regular.ttf", e2["LiberationSans-Bold"] = "LiberationSans-Bold.ttf", e2["LiberationSans-Italic"] = "LiberationSans-Italic.ttf", e2["LiberationSans-BoldItalic"] = "LiberationSans-BoldItalic.ttf";
    });
    ja = getLookupTableFactory(function(e2) {
      e2.Calibri = "Helvetica", e2["Calibri-Bold"] = "Helvetica-Bold", e2["Calibri-BoldItalic"] = "Helvetica-BoldOblique", e2["Calibri-Italic"] = "Helvetica-Oblique", e2.CenturyGothic = "Helvetica", e2["CenturyGothic-Bold"] = "Helvetica-Bold", e2["CenturyGothic-BoldItalic"] = "Helvetica-BoldOblique", e2["CenturyGothic-Italic"] = "Helvetica-Oblique", e2.ComicSansMS = "Comic Sans MS", e2["ComicSansMS-Bold"] = "Comic Sans MS-Bold", e2["ComicSansMS-BoldItalic"] = "Comic Sans MS-BoldItalic", e2["ComicSansMS-Italic"] = "Comic Sans MS-Italic", e2.GillSansMT = "Helvetica", e2["GillSansMT-Bold"] = "Helvetica-Bold", e2["GillSansMT-BoldItalic"] = "Helvetica-BoldOblique", e2["GillSansMT-Italic"] = "Helvetica-Oblique", e2.Impact = "Helvetica", e2["ItcSymbol-Bold"] = "Helvetica-Bold", e2["ItcSymbol-BoldItalic"] = "Helvetica-BoldOblique", e2["ItcSymbol-Book"] = "Helvetica", e2["ItcSymbol-BookItalic"] = "Helvetica-Oblique", e2["ItcSymbol-Medium"] = "Helvetica", e2["ItcSymbol-MediumItalic"] = "Helvetica-Oblique", e2.LucidaConsole = "Courier", e2["LucidaConsole-Bold"] = "Courier-Bold", e2["LucidaConsole-BoldItalic"] = "Courier-BoldOblique", e2["LucidaConsole-Italic"] = "Courier-Oblique", e2["LucidaSans-Demi"] = "Helvetica-Bold", e2["MS-Gothic"] = "MS Gothic", e2["MS-Gothic-Bold"] = "MS Gothic-Bold", e2["MS-Gothic-BoldItalic"] = "MS Gothic-BoldItalic", e2["MS-Gothic-Italic"] = "MS Gothic-Italic", e2["MS-Mincho"] = "MS Mincho", e2["MS-Mincho-Bold"] = "MS Mincho-Bold", e2["MS-Mincho-BoldItalic"] = "MS Mincho-BoldItalic", e2["MS-Mincho-Italic"] = "MS Mincho-Italic", e2["MS-PGothic"] = "MS PGothic", e2["MS-PGothic-Bold"] = "MS PGothic-Bold", e2["MS-PGothic-BoldItalic"] = "MS PGothic-BoldItalic", e2["MS-PGothic-Italic"] = "MS PGothic-Italic", e2["MS-PMincho"] = "MS PMincho", e2["MS-PMincho-Bold"] = "MS PMincho-Bold", e2["MS-PMincho-BoldItalic"] = "MS PMincho-BoldItalic", e2["MS-PMincho-Italic"] = "MS PMincho-Italic", e2.NuptialScript = "Times-Italic", e2.SegoeUISymbol = "Helvetica";
    });
    $a = getLookupTableFactory(function(e2) {
      e2["Adobe Jenson"] = true, e2["Adobe Text"] = true, e2.Albertus = true, e2.Aldus = true, e2.Alexandria = true, e2.Algerian = true, e2["American Typewriter"] = true, e2.Antiqua = true, e2.Apex = true, e2.Arno = true, e2.Aster = true, e2.Aurora = true, e2.Baskerville = true, e2.Bell = true, e2.Bembo = true, e2["Bembo Schoolbook"] = true, e2.Benguiat = true, e2["Berkeley Old Style"] = true, e2["Bernhard Modern"] = true, e2["Berthold City"] = true, e2.Bodoni = true, e2["Bauer Bodoni"] = true, e2["Book Antiqua"] = true, e2.Bookman = true, e2["Bordeaux Roman"] = true, e2["Californian FB"] = true, e2.Calisto = true, e2.Calvert = true, e2.Capitals = true, e2.Cambria = true, e2.Cartier = true, e2.Caslon = true, e2.Catull = true, e2.Centaur = true, e2["Century Old Style"] = true, e2["Century Schoolbook"] = true, e2.Chaparral = true, e2["Charis SIL"] = true, e2.Cheltenham = true, e2["Cholla Slab"] = true, e2.Clarendon = true, e2.Clearface = true, e2.Cochin = true, e2.Colonna = true, e2["Computer Modern"] = true, e2["Concrete Roman"] = true, e2.Constantia = true, e2["Cooper Black"] = true, e2.Corona = true, e2.Ecotype = true, e2.Egyptienne = true, e2.Elephant = true, e2.Excelsior = true, e2.Fairfield = true, e2["FF Scala"] = true, e2.Folkard = true, e2.Footlight = true, e2.FreeSerif = true, e2["Friz Quadrata"] = true, e2.Garamond = true, e2.Gentium = true, e2.Georgia = true, e2.Gloucester = true, e2["Goudy Old Style"] = true, e2["Goudy Schoolbook"] = true, e2["Goudy Pro Font"] = true, e2.Granjon = true, e2["Guardian Egyptian"] = true, e2.Heather = true, e2.Hercules = true, e2["High Tower Text"] = true, e2.Hiroshige = true, e2["Hoefler Text"] = true, e2["Humana Serif"] = true, e2.Imprint = true, e2["Ionic No. 5"] = true, e2.Janson = true, e2.Joanna = true, e2.Korinna = true, e2.Lexicon = true, e2.LiberationSerif = true, e2["Liberation Serif"] = true, e2["Linux Libertine"] = true, e2.Literaturnaya = true, e2.Lucida = true, e2["Lucida Bright"] = true, e2.Melior = true, e2.Memphis = true, e2.Miller = true, e2.Minion = true, e2.Modern = true, e2["Mona Lisa"] = true, e2["Mrs Eaves"] = true, e2["MS Serif"] = true, e2["Museo Slab"] = true, e2["New York"] = true, e2["Nimbus Roman"] = true, e2["NPS Rawlinson Roadway"] = true, e2.NuptialScript = true, e2.Palatino = true, e2.Perpetua = true, e2.Plantin = true, e2["Plantin Schoolbook"] = true, e2.Playbill = true, e2["Poor Richard"] = true, e2["Rawlinson Roadway"] = true, e2.Renault = true, e2.Requiem = true, e2.Rockwell = true, e2.Roman = true, e2["Rotis Serif"] = true, e2.Sabon = true, e2.Scala = true, e2.Seagull = true, e2.Sistina = true, e2.Souvenir = true, e2.STIX = true, e2["Stone Informal"] = true, e2["Stone Serif"] = true, e2.Sylfaen = true, e2.Times = true, e2.Trajan = true, e2["Trinit\xE9"] = true, e2["Trump Mediaeval"] = true, e2.Utopia = true, e2["Vale Type"] = true, e2["Bitstream Vera"] = true, e2["Vera Serif"] = true, e2.Versailles = true, e2.Wanted = true, e2.Weiss = true, e2["Wide Latin"] = true, e2.Windsor = true, e2.XITS = true;
    });
    Ha = getLookupTableFactory(function(e2) {
      e2.Dingbats = true, e2.Symbol = true, e2.ZapfDingbats = true, e2.Wingdings = true, e2["Wingdings-Bold"] = true, e2["Wingdings-Regular"] = true;
    });
    qa = getLookupTableFactory(function(e2) {
      e2[2] = 10, e2[3] = 32, e2[4] = 33, e2[5] = 34, e2[6] = 35, e2[7] = 36, e2[8] = 37, e2[9] = 38, e2[10] = 39, e2[11] = 40, e2[12] = 41, e2[13] = 42, e2[14] = 43, e2[15] = 44, e2[16] = 45, e2[17] = 46, e2[18] = 47, e2[19] = 48, e2[20] = 49, e2[21] = 50, e2[22] = 51, e2[23] = 52, e2[24] = 53, e2[25] = 54, e2[26] = 55, e2[27] = 56, e2[28] = 57, e2[29] = 58, e2[30] = 894, e2[31] = 60, e2[32] = 61, e2[33] = 62, e2[34] = 63, e2[35] = 64, e2[36] = 65, e2[37] = 66, e2[38] = 67, e2[39] = 68, e2[40] = 69, e2[41] = 70, e2[42] = 71, e2[43] = 72, e2[44] = 73, e2[45] = 74, e2[46] = 75, e2[47] = 76, e2[48] = 77, e2[49] = 78, e2[50] = 79, e2[51] = 80, e2[52] = 81, e2[53] = 82, e2[54] = 83, e2[55] = 84, e2[56] = 85, e2[57] = 86, e2[58] = 87, e2[59] = 88, e2[60] = 89, e2[61] = 90, e2[62] = 91, e2[63] = 92, e2[64] = 93, e2[65] = 94, e2[66] = 95, e2[67] = 96, e2[68] = 97, e2[69] = 98, e2[70] = 99, e2[71] = 100, e2[72] = 101, e2[73] = 102, e2[74] = 103, e2[75] = 104, e2[76] = 105, e2[77] = 106, e2[78] = 107, e2[79] = 108, e2[80] = 109, e2[81] = 110, e2[82] = 111, e2[83] = 112, e2[84] = 113, e2[85] = 114, e2[86] = 115, e2[87] = 116, e2[88] = 117, e2[89] = 118, e2[90] = 119, e2[91] = 120, e2[92] = 121, e2[93] = 122, e2[94] = 123, e2[95] = 124, e2[96] = 125, e2[97] = 126, e2[98] = 196, e2[99] = 197, e2[100] = 199, e2[101] = 201, e2[102] = 209, e2[103] = 214, e2[104] = 220, e2[105] = 225, e2[106] = 224, e2[107] = 226, e2[108] = 228, e2[109] = 227, e2[110] = 229, e2[111] = 231, e2[112] = 233, e2[113] = 232, e2[114] = 234, e2[115] = 235, e2[116] = 237, e2[117] = 236, e2[118] = 238, e2[119] = 239, e2[120] = 241, e2[121] = 243, e2[122] = 242, e2[123] = 244, e2[124] = 246, e2[125] = 245, e2[126] = 250, e2[127] = 249, e2[128] = 251, e2[129] = 252, e2[130] = 8224, e2[131] = 176, e2[132] = 162, e2[133] = 163, e2[134] = 167, e2[135] = 8226, e2[136] = 182, e2[137] = 223, e2[138] = 174, e2[139] = 169, e2[140] = 8482, e2[141] = 180, e2[142] = 168, e2[143] = 8800, e2[144] = 198, e2[145] = 216, e2[146] = 8734, e2[147] = 177, e2[148] = 8804, e2[149] = 8805, e2[150] = 165, e2[151] = 181, e2[152] = 8706, e2[153] = 8721, e2[154] = 8719, e2[156] = 8747, e2[157] = 170, e2[158] = 186, e2[159] = 8486, e2[160] = 230, e2[161] = 248, e2[162] = 191, e2[163] = 161, e2[164] = 172, e2[165] = 8730, e2[166] = 402, e2[167] = 8776, e2[168] = 8710, e2[169] = 171, e2[170] = 187, e2[171] = 8230, e2[179] = 8220, e2[180] = 8221, e2[181] = 8216, e2[182] = 8217, e2[200] = 193, e2[203] = 205, e2[207] = 211, e2[210] = 218, e2[223] = 711, e2[224] = 321, e2[225] = 322, e2[226] = 352, e2[227] = 353, e2[228] = 381, e2[229] = 382, e2[233] = 221, e2[234] = 253, e2[252] = 263, e2[253] = 268, e2[254] = 269, e2[258] = 258, e2[260] = 260, e2[261] = 261, e2[265] = 280, e2[266] = 281, e2[267] = 282, e2[268] = 283, e2[269] = 313, e2[275] = 323, e2[276] = 324, e2[278] = 328, e2[283] = 344, e2[284] = 345, e2[285] = 346, e2[286] = 347, e2[292] = 367, e2[295] = 377, e2[296] = 378, e2[298] = 380, e2[305] = 963, e2[306] = 964, e2[307] = 966, e2[308] = 8215, e2[309] = 8252, e2[310] = 8319, e2[311] = 8359, e2[312] = 8592, e2[313] = 8593, e2[337] = 9552, e2[493] = 1039, e2[494] = 1040, e2[570] = 1040, e2[571] = 1041, e2[572] = 1042, e2[573] = 1043, e2[574] = 1044, e2[575] = 1045, e2[576] = 1046, e2[577] = 1047, e2[578] = 1048, e2[579] = 1049, e2[580] = 1050, e2[581] = 1051, e2[582] = 1052, e2[583] = 1053, e2[584] = 1054, e2[585] = 1055, e2[586] = 1056, e2[587] = 1057, e2[588] = 1058, e2[589] = 1059, e2[590] = 1060, e2[591] = 1061, e2[592] = 1062, e2[593] = 1063, e2[594] = 1064, e2[595] = 1065, e2[596] = 1066, e2[597] = 1067, e2[598] = 1068, e2[599] = 1069, e2[600] = 1070, e2[672] = 1488, e2[673] = 1489, e2[674] = 1490, e2[675] = 1491, e2[676] = 1492, e2[677] = 1493, e2[678] = 1494, e2[679] = 1495, e2[680] = 1496, e2[681] = 1497, e2[682] = 1498, e2[683] = 1499, e2[684] = 1500, e2[685] = 1501, e2[686] = 1502, e2[687] = 1503, e2[688] = 1504, e2[689] = 1505, e2[690] = 1506, e2[691] = 1507, e2[692] = 1508, e2[693] = 1509, e2[694] = 1510, e2[695] = 1511, e2[696] = 1512, e2[697] = 1513, e2[698] = 1514, e2[705] = 1524, e2[706] = 8362, e2[710] = 64288, e2[711] = 64298, e2[759] = 1617, e2[761] = 1776, e2[763] = 1778, e2[775] = 1652, e2[777] = 1764, e2[778] = 1780, e2[779] = 1781, e2[780] = 1782, e2[782] = 771, e2[783] = 64726, e2[786] = 8363, e2[788] = 8532, e2[790] = 768, e2[791] = 769, e2[792] = 768, e2[795] = 803, e2[797] = 64336, e2[798] = 64337, e2[799] = 64342, e2[800] = 64343, e2[801] = 64344, e2[802] = 64345, e2[803] = 64362, e2[804] = 64363, e2[805] = 64364, e2[2424] = 7821, e2[2425] = 7822, e2[2426] = 7823, e2[2427] = 7824, e2[2428] = 7825, e2[2429] = 7826, e2[2430] = 7827, e2[2433] = 7682, e2[2678] = 8045, e2[2679] = 8046, e2[2830] = 1552, e2[2838] = 686, e2[2840] = 751, e2[2842] = 753, e2[2843] = 754, e2[2844] = 755, e2[2846] = 757, e2[2856] = 767, e2[2857] = 848, e2[2858] = 849, e2[2862] = 853, e2[2863] = 854, e2[2864] = 855, e2[2865] = 861, e2[2866] = 862, e2[2906] = 7460, e2[2908] = 7462, e2[2909] = 7463, e2[2910] = 7464, e2[2912] = 7466, e2[2913] = 7467, e2[2914] = 7468, e2[2916] = 7470, e2[2917] = 7471, e2[2918] = 7472, e2[2920] = 7474, e2[2921] = 7475, e2[2922] = 7476, e2[2924] = 7478, e2[2925] = 7479, e2[2926] = 7480, e2[2928] = 7482, e2[2929] = 7483, e2[2930] = 7484, e2[2932] = 7486, e2[2933] = 7487, e2[2934] = 7488, e2[2936] = 7490, e2[2937] = 7491, e2[2938] = 7492, e2[2940] = 7494, e2[2941] = 7495, e2[2942] = 7496, e2[2944] = 7498, e2[2946] = 7500, e2[2948] = 7502, e2[2950] = 7504, e2[2951] = 7505, e2[2952] = 7506, e2[2954] = 7508, e2[2955] = 7509, e2[2956] = 7510, e2[2958] = 7512, e2[2959] = 7513, e2[2960] = 7514, e2[2962] = 7516, e2[2963] = 7517, e2[2964] = 7518, e2[2966] = 7520, e2[2967] = 7521, e2[2968] = 7522, e2[2970] = 7524, e2[2971] = 7525, e2[2972] = 7526, e2[2974] = 7528, e2[2975] = 7529, e2[2976] = 7530, e2[2978] = 1537, e2[2979] = 1538, e2[2980] = 1539, e2[2982] = 1549, e2[2983] = 1551, e2[2984] = 1552, e2[2986] = 1554, e2[2987] = 1555, e2[2988] = 1556, e2[2990] = 1623, e2[2991] = 1624, e2[2995] = 1775, e2[2999] = 1791, e2[3002] = 64290, e2[3003] = 64291, e2[3004] = 64292, e2[3006] = 64294, e2[3007] = 64295, e2[3008] = 64296, e2[3011] = 1900, e2[3014] = 8223, e2[3015] = 8244, e2[3017] = 7532, e2[3018] = 7533, e2[3019] = 7534, e2[3075] = 7590, e2[3076] = 7591, e2[3079] = 7594, e2[3080] = 7595, e2[3083] = 7598, e2[3084] = 7599, e2[3087] = 7602, e2[3088] = 7603, e2[3091] = 7606, e2[3092] = 7607, e2[3095] = 7610, e2[3096] = 7611, e2[3099] = 7614, e2[3100] = 7615, e2[3103] = 7618, e2[3104] = 7619, e2[3107] = 8337, e2[3108] = 8338, e2[3116] = 1884, e2[3119] = 1885, e2[3120] = 1885, e2[3123] = 1886, e2[3124] = 1886, e2[3127] = 1887, e2[3128] = 1887, e2[3131] = 1888, e2[3132] = 1888, e2[3135] = 1889, e2[3136] = 1889, e2[3139] = 1890, e2[3140] = 1890, e2[3143] = 1891, e2[3144] = 1891, e2[3147] = 1892, e2[3148] = 1892, e2[3153] = 580, e2[3154] = 581, e2[3157] = 584, e2[3158] = 585, e2[3161] = 588, e2[3162] = 589, e2[3165] = 891, e2[3166] = 892, e2[3169] = 1274, e2[3170] = 1275, e2[3173] = 1278, e2[3174] = 1279, e2[3181] = 7622, e2[3182] = 7623, e2[3282] = 11799, e2[3316] = 578, e2[3379] = 42785, e2[3393] = 1159, e2[3416] = 8377;
    });
    Xa = getLookupTableFactory(function(e2) {
      e2[227] = 322, e2[264] = 261, e2[291] = 346;
    });
    za = getLookupTableFactory(function(e2) {
      e2[1] = 32, e2[4] = 65, e2[5] = 192, e2[6] = 193, e2[9] = 196, e2[17] = 66, e2[18] = 67, e2[21] = 268, e2[24] = 68, e2[28] = 69, e2[29] = 200, e2[30] = 201, e2[32] = 282, e2[38] = 70, e2[39] = 71, e2[44] = 72, e2[47] = 73, e2[48] = 204, e2[49] = 205, e2[58] = 74, e2[60] = 75, e2[62] = 76, e2[68] = 77, e2[69] = 78, e2[75] = 79, e2[76] = 210, e2[80] = 214, e2[87] = 80, e2[89] = 81, e2[90] = 82, e2[92] = 344, e2[94] = 83, e2[97] = 352, e2[100] = 84, e2[104] = 85, e2[109] = 220, e2[115] = 86, e2[116] = 87, e2[121] = 88, e2[122] = 89, e2[124] = 221, e2[127] = 90, e2[129] = 381, e2[258] = 97, e2[259] = 224, e2[260] = 225, e2[263] = 228, e2[268] = 261, e2[271] = 98, e2[272] = 99, e2[273] = 263, e2[275] = 269, e2[282] = 100, e2[286] = 101, e2[287] = 232, e2[288] = 233, e2[290] = 283, e2[295] = 281, e2[296] = 102, e2[336] = 103, e2[346] = 104, e2[349] = 105, e2[350] = 236, e2[351] = 237, e2[361] = 106, e2[364] = 107, e2[367] = 108, e2[371] = 322, e2[373] = 109, e2[374] = 110, e2[381] = 111, e2[382] = 242, e2[383] = 243, e2[386] = 246, e2[393] = 112, e2[395] = 113, e2[396] = 114, e2[398] = 345, e2[400] = 115, e2[401] = 347, e2[403] = 353, e2[410] = 116, e2[437] = 117, e2[442] = 252, e2[448] = 118, e2[449] = 119, e2[454] = 120, e2[455] = 121, e2[457] = 253, e2[460] = 122, e2[462] = 382, e2[463] = 380, e2[853] = 44, e2[855] = 58, e2[856] = 46, e2[876] = 47, e2[878] = 45, e2[882] = 45, e2[894] = 40, e2[895] = 41, e2[896] = 91, e2[897] = 93, e2[923] = 64, e2[940] = 163, e2[1004] = 48, e2[1005] = 49, e2[1006] = 50, e2[1007] = 51, e2[1008] = 52, e2[1009] = 53, e2[1010] = 54, e2[1011] = 55, e2[1012] = 56, e2[1013] = 57, e2[1081] = 37, e2[1085] = 43, e2[1086] = 45;
    });
    __name(getStandardFontName, "getStandardFontName");
    __name(isKnownFontName, "isKnownFontName");
    ToUnicodeMap = class {
      constructor(e2 = []) {
        this._map = e2;
      }
      get length() {
        return this._map.length;
      }
      forEach(e2) {
        for (const t2 in this._map)
          e2(t2, this._map[t2].codePointAt(0));
      }
      has(e2) {
        return void 0 !== this._map[e2];
      }
      get(e2) {
        return this._map[e2];
      }
      charCodeOf(e2) {
        const t2 = this._map;
        if (t2.length <= 65536)
          return t2.indexOf(e2);
        for (const i2 in t2)
          if (t2[i2] === e2)
            return 0 | i2;
        return -1;
      }
      amend(e2) {
        for (const t2 in e2)
          this._map[t2] = e2[t2];
      }
    };
    __name(ToUnicodeMap, "ToUnicodeMap");
    IdentityToUnicodeMap = class {
      constructor(e2, t2) {
        this.firstChar = e2, this.lastChar = t2;
      }
      get length() {
        return this.lastChar + 1 - this.firstChar;
      }
      forEach(e2) {
        for (let t2 = this.firstChar, i2 = this.lastChar; t2 <= i2; t2++)
          e2(t2, t2);
      }
      has(e2) {
        return this.firstChar <= e2 && e2 <= this.lastChar;
      }
      get(e2) {
        if (this.firstChar <= e2 && e2 <= this.lastChar)
          return String.fromCharCode(e2);
      }
      charCodeOf(e2) {
        return Number.isInteger(e2) && e2 >= this.firstChar && e2 <= this.lastChar ? e2 : -1;
      }
      amend(e2) {
        unreachable$1("Should not call amend()");
      }
    };
    __name(IdentityToUnicodeMap, "IdentityToUnicodeMap");
    CFFFont = class {
      constructor(e2, t2) {
        this.properties = t2;
        const i2 = new CFFParser(e2, t2, xa);
        this.cff = i2.parse(), this.cff.duplicateFirstGlyph();
        const a2 = new CFFCompiler(this.cff);
        this.seacs = this.cff.seacs;
        try {
          this.data = a2.compile();
        } catch {
          warn$1("Failed to compile font " + t2.loadedName), this.data = e2;
        }
        this._createBuiltInEncoding();
      }
      get numGlyphs() {
        return this.cff.charStrings.count;
      }
      getCharset() {
        return this.cff.charset.charset;
      }
      getGlyphMapping() {
        const e2 = this.cff, t2 = this.properties, { cidToGidMap: i2, cMap: a2 } = t2, n2 = e2.charset.charset;
        let s2, r2;
        if (t2.composite) {
          let t3, o3;
          if (i2?.length > 0) {
            t3 = /* @__PURE__ */ Object.create(null);
            for (let e3 = 0, a3 = i2.length; e3 < a3; e3++) {
              const a4 = i2[e3];
              void 0 !== a4 && (t3[a4] = e3);
            }
          }
          if (s2 = /* @__PURE__ */ Object.create(null), e2.isCIDFont)
            for (r2 = 0; r2 < n2.length; r2++) {
              const e3 = n2[r2];
              o3 = a2.charCodeOf(e3), void 0 !== t3?.[o3] && (o3 = t3[o3]), s2[o3] = r2;
            }
          else
            for (r2 = 0; r2 < e2.charStrings.count; r2++)
              o3 = a2.charCodeOf(r2), s2[o3] = r2;
          return s2;
        }
        let o2 = e2.encoding ? e2.encoding.encoding : null;
        return t2.isInternalFont && (o2 = t2.defaultEncoding), s2 = type1FontGlyphMapping(t2, o2, n2), s2;
      }
      hasGlyphId(e2) {
        return this.cff.hasGlyphId(e2);
      }
      _createBuiltInEncoding() {
        const { charset: e2, encoding: t2 } = this.cff;
        if (!e2 || !t2)
          return;
        const i2 = e2.charset, a2 = t2.encoding, n2 = [];
        for (const e3 in a2) {
          const t3 = a2[e3];
          if (t3 >= 0) {
            const a3 = i2[t3];
            a3 && (n2[e3] = a3);
          }
        }
        n2.length > 0 && (this.properties.builtInEncoding = n2);
      }
    };
    __name(CFFFont, "CFFFont");
    __name(getFloat214, "getFloat214");
    __name(getSubroutineBias, "getSubroutineBias");
    __name(parseCmap, "parseCmap");
    __name(parseCff, "parseCff");
    __name(lookupCmap, "lookupCmap");
    __name(compileGlyf, "compileGlyf");
    __name(compileCharString, "compileCharString");
    Commands = class {
      cmds = [];
      transformStack = [];
      currentTransform = [1, 0, 0, 1, 0, 0];
      add(e2, t2) {
        if (t2) {
          const { currentTransform: i2 } = this;
          for (let e3 = 0, a2 = t2.length; e3 < a2; e3 += 2)
            ni.applyTransform(t2, i2, e3);
          this.cmds.push(`${e2}${t2.join(" ")}`);
        } else
          this.cmds.push(e2);
      }
      transform(e2) {
        this.currentTransform = ni.transform(this.currentTransform, e2);
      }
      translate(e2, t2) {
        this.transform([1, 0, 0, 1, e2, t2]);
      }
      save() {
        this.transformStack.push(this.currentTransform.slice());
      }
      restore() {
        this.currentTransform = this.transformStack.pop() || [1, 0, 0, 1, 0, 0];
      }
      getSVG() {
        return this.cmds.join("");
      }
    };
    __name(Commands, "Commands");
    CompiledFont = class {
      constructor(e2) {
        this.fontMatrix = e2, this.compiledGlyphs = /* @__PURE__ */ Object.create(null), this.compiledCharCodeToGlyphId = /* @__PURE__ */ Object.create(null);
      }
      getPathJs(e2) {
        const { charCode: t2, glyphId: i2 } = lookupCmap(this.cmap, e2);
        let a2, n2 = this.compiledGlyphs[i2];
        if (void 0 === n2) {
          try {
            n2 = this.compileGlyph(this.glyphs[i2], i2);
          } catch (e3) {
            n2 = "", a2 = e3;
          }
          this.compiledGlyphs[i2] = n2;
        }
        if (this.compiledCharCodeToGlyphId[t2] ??= i2, a2)
          throw a2;
        return n2;
      }
      compileGlyph(e2, i2) {
        if (!e2?.length || 14 === e2[0])
          return "";
        let a2 = this.fontMatrix;
        if (this.isCFFCIDFont) {
          const e3 = this.fdSelect.getFDIndex(i2);
          if (e3 >= 0 && e3 < this.fdArray.length) {
            a2 = this.fdArray[e3].getByName("FontMatrix") || t;
          } else
            warn$1("Invalid fd index for glyph index.");
        }
        assert$1(isNumberArray(a2, 6), "Expected a valid fontMatrix.");
        const n2 = new Commands();
        return n2.transform(a2.slice()), this.compileGlyphImpl(e2, n2, i2), n2.add("Z"), n2.getSVG();
      }
      compileGlyphImpl() {
        unreachable$1("Children classes should implement this.");
      }
      hasBuiltPath(e2) {
        const { charCode: t2, glyphId: i2 } = lookupCmap(this.cmap, e2);
        return void 0 !== this.compiledGlyphs[i2] && void 0 !== this.compiledCharCodeToGlyphId[t2];
      }
    };
    __name(CompiledFont, "CompiledFont");
    TrueTypeCompiled = class extends CompiledFont {
      constructor(e2, t2, i2) {
        super(i2 || [488e-6, 0, 0, 488e-6, 0, 0]), this.glyphs = e2, this.cmap = t2;
      }
      compileGlyphImpl(e2, t2) {
        compileGlyf(e2, t2, this);
      }
    };
    __name(TrueTypeCompiled, "TrueTypeCompiled");
    Type2Compiled = class extends CompiledFont {
      constructor(e2, t2, i2) {
        super(i2 || [1e-3, 0, 0, 1e-3, 0, 0]), this.glyphs = e2.glyphs, this.gsubrs = e2.gsubrs || [], this.subrs = e2.subrs || [], this.cmap = t2, this.glyphNameMap = fa(), this.gsubrsBias = getSubroutineBias(this.gsubrs), this.subrsBias = getSubroutineBias(this.subrs), this.isCFFCIDFont = e2.isCFFCIDFont, this.fdSelect = e2.fdSelect, this.fdArray = e2.fdArray;
      }
      compileGlyphImpl(e2, t2, i2) {
        compileCharString(e2, t2, this, i2);
      }
    };
    __name(Type2Compiled, "Type2Compiled");
    FontRendererFactory = class {
      static create(e2, t2) {
        const i2 = new Uint8Array(e2.data);
        let a2, n2, s2, r2, o2, l3;
        const c2 = readUint16(i2, 4);
        for (let e3 = 0, h2 = 12; e3 < c2; e3++, h2 += 16) {
          const e4 = bytesToString$1(i2.subarray(h2, h2 + 4)), c3 = readUint32(i2, h2 + 8), d2 = readUint32(i2, h2 + 12);
          switch (e4) {
            case "cmap":
              a2 = parseCmap(i2, c3);
              break;
            case "glyf":
              n2 = i2.subarray(c3, c3 + d2);
              break;
            case "loca":
              s2 = i2.subarray(c3, c3 + d2);
              break;
            case "head":
              l3 = readUint16(i2, c3 + 18), o2 = readUint16(i2, c3 + 50);
              break;
            case "CFF ":
              r2 = parseCff(i2, c3, c3 + d2, t2);
          }
        }
        if (n2) {
          const t3 = l3 ? [1 / l3, 0, 0, 1 / l3, 0, 0] : e2.fontMatrix;
          return new TrueTypeCompiled(function(e3, t4, i3) {
            let a3, n3;
            i3 ? (a3 = 4, n3 = readUint32) : (a3 = 2, n3 = /* @__PURE__ */ __name((e4, t5) => 2 * readUint16(e4, t5), "n"));
            const s3 = [];
            let r3 = n3(t4, 0);
            for (let i4 = a3; i4 < t4.length; i4 += a3) {
              const a4 = n3(t4, i4);
              s3.push(e3.subarray(r3, a4)), r3 = a4;
            }
            return s3;
          }(n2, s2, o2), a2, t3);
        }
        return new Type2Compiled(r2, a2, e2.fontMatrix);
      }
    };
    __name(FontRendererFactory, "FontRendererFactory");
    Wa = getLookupTableFactory(function(e2) {
      e2.Courier = 600, e2["Courier-Bold"] = 600, e2["Courier-BoldOblique"] = 600, e2["Courier-Oblique"] = 600, e2.Helvetica = getLookupTableFactory(function(e3) {
        e3.space = 278, e3.exclam = 278, e3.quotedbl = 355, e3.numbersign = 556, e3.dollar = 556, e3.percent = 889, e3.ampersand = 667, e3.quoteright = 222, e3.parenleft = 333, e3.parenright = 333, e3.asterisk = 389, e3.plus = 584, e3.comma = 278, e3.hyphen = 333, e3.period = 278, e3.slash = 278, e3.zero = 556, e3.one = 556, e3.two = 556, e3.three = 556, e3.four = 556, e3.five = 556, e3.six = 556, e3.seven = 556, e3.eight = 556, e3.nine = 556, e3.colon = 278, e3.semicolon = 278, e3.less = 584, e3.equal = 584, e3.greater = 584, e3.question = 556, e3.at = 1015, e3.A = 667, e3.B = 667, e3.C = 722, e3.D = 722, e3.E = 667, e3.F = 611, e3.G = 778, e3.H = 722, e3.I = 278, e3.J = 500, e3.K = 667, e3.L = 556, e3.M = 833, e3.N = 722, e3.O = 778, e3.P = 667, e3.Q = 778, e3.R = 722, e3.S = 667, e3.T = 611, e3.U = 722, e3.V = 667, e3.W = 944, e3.X = 667, e3.Y = 667, e3.Z = 611, e3.bracketleft = 278, e3.backslash = 278, e3.bracketright = 278, e3.asciicircum = 469, e3.underscore = 556, e3.quoteleft = 222, e3.a = 556, e3.b = 556, e3.c = 500, e3.d = 556, e3.e = 556, e3.f = 278, e3.g = 556, e3.h = 556, e3.i = 222, e3.j = 222, e3.k = 500, e3.l = 222, e3.m = 833, e3.n = 556, e3.o = 556, e3.p = 556, e3.q = 556, e3.r = 333, e3.s = 500, e3.t = 278, e3.u = 556, e3.v = 500, e3.w = 722, e3.x = 500, e3.y = 500, e3.z = 500, e3.braceleft = 334, e3.bar = 260, e3.braceright = 334, e3.asciitilde = 584, e3.exclamdown = 333, e3.cent = 556, e3.sterling = 556, e3.fraction = 167, e3.yen = 556, e3.florin = 556, e3.section = 556, e3.currency = 556, e3.quotesingle = 191, e3.quotedblleft = 333, e3.guillemotleft = 556, e3.guilsinglleft = 333, e3.guilsinglright = 333, e3.fi = 500, e3.fl = 500, e3.endash = 556, e3.dagger = 556, e3.daggerdbl = 556, e3.periodcentered = 278, e3.paragraph = 537, e3.bullet = 350, e3.quotesinglbase = 222, e3.quotedblbase = 333, e3.quotedblright = 333, e3.guillemotright = 556, e3.ellipsis = 1e3, e3.perthousand = 1e3, e3.questiondown = 611, e3.grave = 333, e3.acute = 333, e3.circumflex = 333, e3.tilde = 333, e3.macron = 333, e3.breve = 333, e3.dotaccent = 333, e3.dieresis = 333, e3.ring = 333, e3.cedilla = 333, e3.hungarumlaut = 333, e3.ogonek = 333, e3.caron = 333, e3.emdash = 1e3, e3.AE = 1e3, e3.ordfeminine = 370, e3.Lslash = 556, e3.Oslash = 778, e3.OE = 1e3, e3.ordmasculine = 365, e3.ae = 889, e3.dotlessi = 278, e3.lslash = 222, e3.oslash = 611, e3.oe = 944, e3.germandbls = 611, e3.Idieresis = 278, e3.eacute = 556, e3.abreve = 556, e3.uhungarumlaut = 556, e3.ecaron = 556, e3.Ydieresis = 667, e3.divide = 584, e3.Yacute = 667, e3.Acircumflex = 667, e3.aacute = 556, e3.Ucircumflex = 722, e3.yacute = 500, e3.scommaaccent = 500, e3.ecircumflex = 556, e3.Uring = 722, e3.Udieresis = 722, e3.aogonek = 556, e3.Uacute = 722, e3.uogonek = 556, e3.Edieresis = 667, e3.Dcroat = 722, e3.commaaccent = 250, e3.copyright = 737, e3.Emacron = 667, e3.ccaron = 500, e3.aring = 556, e3.Ncommaaccent = 722, e3.lacute = 222, e3.agrave = 556, e3.Tcommaaccent = 611, e3.Cacute = 722, e3.atilde = 556, e3.Edotaccent = 667, e3.scaron = 500, e3.scedilla = 500, e3.iacute = 278, e3.lozenge = 471, e3.Rcaron = 722, e3.Gcommaaccent = 778, e3.ucircumflex = 556, e3.acircumflex = 556, e3.Amacron = 667, e3.rcaron = 333, e3.ccedilla = 500, e3.Zdotaccent = 611, e3.Thorn = 667, e3.Omacron = 778, e3.Racute = 722, e3.Sacute = 667, e3.dcaron = 643, e3.Umacron = 722, e3.uring = 556, e3.threesuperior = 333, e3.Ograve = 778, e3.Agrave = 667, e3.Abreve = 667, e3.multiply = 584, e3.uacute = 556, e3.Tcaron = 611, e3.partialdiff = 476, e3.ydieresis = 500, e3.Nacute = 722, e3.icircumflex = 278, e3.Ecircumflex = 667, e3.adieresis = 556, e3.edieresis = 556, e3.cacute = 500, e3.nacute = 556, e3.umacron = 556, e3.Ncaron = 722, e3.Iacute = 278, e3.plusminus = 584, e3.brokenbar = 260, e3.registered = 737, e3.Gbreve = 778, e3.Idotaccent = 278, e3.summation = 600, e3.Egrave = 667, e3.racute = 333, e3.omacron = 556, e3.Zacute = 611, e3.Zcaron = 611, e3.greaterequal = 549, e3.Eth = 722, e3.Ccedilla = 722, e3.lcommaaccent = 222, e3.tcaron = 317, e3.eogonek = 556, e3.Uogonek = 722, e3.Aacute = 667, e3.Adieresis = 667, e3.egrave = 556, e3.zacute = 500, e3.iogonek = 222, e3.Oacute = 778, e3.oacute = 556, e3.amacron = 556, e3.sacute = 500, e3.idieresis = 278, e3.Ocircumflex = 778, e3.Ugrave = 722, e3.Delta = 612, e3.thorn = 556, e3.twosuperior = 333, e3.Odieresis = 778, e3.mu = 556, e3.igrave = 278, e3.ohungarumlaut = 556, e3.Eogonek = 667, e3.dcroat = 556, e3.threequarters = 834, e3.Scedilla = 667, e3.lcaron = 299, e3.Kcommaaccent = 667, e3.Lacute = 556, e3.trademark = 1e3, e3.edotaccent = 556, e3.Igrave = 278, e3.Imacron = 278, e3.Lcaron = 556, e3.onehalf = 834, e3.lessequal = 549, e3.ocircumflex = 556, e3.ntilde = 556, e3.Uhungarumlaut = 722, e3.Eacute = 667, e3.emacron = 556, e3.gbreve = 556, e3.onequarter = 834, e3.Scaron = 667, e3.Scommaaccent = 667, e3.Ohungarumlaut = 778, e3.degree = 400, e3.ograve = 556, e3.Ccaron = 722, e3.ugrave = 556, e3.radical = 453, e3.Dcaron = 722, e3.rcommaaccent = 333, e3.Ntilde = 722, e3.otilde = 556, e3.Rcommaaccent = 722, e3.Lcommaaccent = 556, e3.Atilde = 667, e3.Aogonek = 667, e3.Aring = 667, e3.Otilde = 778, e3.zdotaccent = 500, e3.Ecaron = 667, e3.Iogonek = 278, e3.kcommaaccent = 500, e3.minus = 584, e3.Icircumflex = 278, e3.ncaron = 556, e3.tcommaaccent = 278, e3.logicalnot = 584, e3.odieresis = 556, e3.udieresis = 556, e3.notequal = 549, e3.gcommaaccent = 556, e3.eth = 556, e3.zcaron = 500, e3.ncommaaccent = 556, e3.onesuperior = 333, e3.imacron = 278, e3.Euro = 556;
      }), e2["Helvetica-Bold"] = getLookupTableFactory(function(e3) {
        e3.space = 278, e3.exclam = 333, e3.quotedbl = 474, e3.numbersign = 556, e3.dollar = 556, e3.percent = 889, e3.ampersand = 722, e3.quoteright = 278, e3.parenleft = 333, e3.parenright = 333, e3.asterisk = 389, e3.plus = 584, e3.comma = 278, e3.hyphen = 333, e3.period = 278, e3.slash = 278, e3.zero = 556, e3.one = 556, e3.two = 556, e3.three = 556, e3.four = 556, e3.five = 556, e3.six = 556, e3.seven = 556, e3.eight = 556, e3.nine = 556, e3.colon = 333, e3.semicolon = 333, e3.less = 584, e3.equal = 584, e3.greater = 584, e3.question = 611, e3.at = 975, e3.A = 722, e3.B = 722, e3.C = 722, e3.D = 722, e3.E = 667, e3.F = 611, e3.G = 778, e3.H = 722, e3.I = 278, e3.J = 556, e3.K = 722, e3.L = 611, e3.M = 833, e3.N = 722, e3.O = 778, e3.P = 667, e3.Q = 778, e3.R = 722, e3.S = 667, e3.T = 611, e3.U = 722, e3.V = 667, e3.W = 944, e3.X = 667, e3.Y = 667, e3.Z = 611, e3.bracketleft = 333, e3.backslash = 278, e3.bracketright = 333, e3.asciicircum = 584, e3.underscore = 556, e3.quoteleft = 278, e3.a = 556, e3.b = 611, e3.c = 556, e3.d = 611, e3.e = 556, e3.f = 333, e3.g = 611, e3.h = 611, e3.i = 278, e3.j = 278, e3.k = 556, e3.l = 278, e3.m = 889, e3.n = 611, e3.o = 611, e3.p = 611, e3.q = 611, e3.r = 389, e3.s = 556, e3.t = 333, e3.u = 611, e3.v = 556, e3.w = 778, e3.x = 556, e3.y = 556, e3.z = 500, e3.braceleft = 389, e3.bar = 280, e3.braceright = 389, e3.asciitilde = 584, e3.exclamdown = 333, e3.cent = 556, e3.sterling = 556, e3.fraction = 167, e3.yen = 556, e3.florin = 556, e3.section = 556, e3.currency = 556, e3.quotesingle = 238, e3.quotedblleft = 500, e3.guillemotleft = 556, e3.guilsinglleft = 333, e3.guilsinglright = 333, e3.fi = 611, e3.fl = 611, e3.endash = 556, e3.dagger = 556, e3.daggerdbl = 556, e3.periodcentered = 278, e3.paragraph = 556, e3.bullet = 350, e3.quotesinglbase = 278, e3.quotedblbase = 500, e3.quotedblright = 500, e3.guillemotright = 556, e3.ellipsis = 1e3, e3.perthousand = 1e3, e3.questiondown = 611, e3.grave = 333, e3.acute = 333, e3.circumflex = 333, e3.tilde = 333, e3.macron = 333, e3.breve = 333, e3.dotaccent = 333, e3.dieresis = 333, e3.ring = 333, e3.cedilla = 333, e3.hungarumlaut = 333, e3.ogonek = 333, e3.caron = 333, e3.emdash = 1e3, e3.AE = 1e3, e3.ordfeminine = 370, e3.Lslash = 611, e3.Oslash = 778, e3.OE = 1e3, e3.ordmasculine = 365, e3.ae = 889, e3.dotlessi = 278, e3.lslash = 278, e3.oslash = 611, e3.oe = 944, e3.germandbls = 611, e3.Idieresis = 278, e3.eacute = 556, e3.abreve = 556, e3.uhungarumlaut = 611, e3.ecaron = 556, e3.Ydieresis = 667, e3.divide = 584, e3.Yacute = 667, e3.Acircumflex = 722, e3.aacute = 556, e3.Ucircumflex = 722, e3.yacute = 556, e3.scommaaccent = 556, e3.ecircumflex = 556, e3.Uring = 722, e3.Udieresis = 722, e3.aogonek = 556, e3.Uacute = 722, e3.uogonek = 611, e3.Edieresis = 667, e3.Dcroat = 722, e3.commaaccent = 250, e3.copyright = 737, e3.Emacron = 667, e3.ccaron = 556, e3.aring = 556, e3.Ncommaaccent = 722, e3.lacute = 278, e3.agrave = 556, e3.Tcommaaccent = 611, e3.Cacute = 722, e3.atilde = 556, e3.Edotaccent = 667, e3.scaron = 556, e3.scedilla = 556, e3.iacute = 278, e3.lozenge = 494, e3.Rcaron = 722, e3.Gcommaaccent = 778, e3.ucircumflex = 611, e3.acircumflex = 556, e3.Amacron = 722, e3.rcaron = 389, e3.ccedilla = 556, e3.Zdotaccent = 611, e3.Thorn = 667, e3.Omacron = 778, e3.Racute = 722, e3.Sacute = 667, e3.dcaron = 743, e3.Umacron = 722, e3.uring = 611, e3.threesuperior = 333, e3.Ograve = 778, e3.Agrave = 722, e3.Abreve = 722, e3.multiply = 584, e3.uacute = 611, e3.Tcaron = 611, e3.partialdiff = 494, e3.ydieresis = 556, e3.Nacute = 722, e3.icircumflex = 278, e3.Ecircumflex = 667, e3.adieresis = 556, e3.edieresis = 556, e3.cacute = 556, e3.nacute = 611, e3.umacron = 611, e3.Ncaron = 722, e3.Iacute = 278, e3.plusminus = 584, e3.brokenbar = 280, e3.registered = 737, e3.Gbreve = 778, e3.Idotaccent = 278, e3.summation = 600, e3.Egrave = 667, e3.racute = 389, e3.omacron = 611, e3.Zacute = 611, e3.Zcaron = 611, e3.greaterequal = 549, e3.Eth = 722, e3.Ccedilla = 722, e3.lcommaaccent = 278, e3.tcaron = 389, e3.eogonek = 556, e3.Uogonek = 722, e3.Aacute = 722, e3.Adieresis = 722, e3.egrave = 556, e3.zacute = 500, e3.iogonek = 278, e3.Oacute = 778, e3.oacute = 611, e3.amacron = 556, e3.sacute = 556, e3.idieresis = 278, e3.Ocircumflex = 778, e3.Ugrave = 722, e3.Delta = 612, e3.thorn = 611, e3.twosuperior = 333, e3.Odieresis = 778, e3.mu = 611, e3.igrave = 278, e3.ohungarumlaut = 611, e3.Eogonek = 667, e3.dcroat = 611, e3.threequarters = 834, e3.Scedilla = 667, e3.lcaron = 400, e3.Kcommaaccent = 722, e3.Lacute = 611, e3.trademark = 1e3, e3.edotaccent = 556, e3.Igrave = 278, e3.Imacron = 278, e3.Lcaron = 611, e3.onehalf = 834, e3.lessequal = 549, e3.ocircumflex = 611, e3.ntilde = 611, e3.Uhungarumlaut = 722, e3.Eacute = 667, e3.emacron = 556, e3.gbreve = 611, e3.onequarter = 834, e3.Scaron = 667, e3.Scommaaccent = 667, e3.Ohungarumlaut = 778, e3.degree = 400, e3.ograve = 611, e3.Ccaron = 722, e3.ugrave = 611, e3.radical = 549, e3.Dcaron = 722, e3.rcommaaccent = 389, e3.Ntilde = 722, e3.otilde = 611, e3.Rcommaaccent = 722, e3.Lcommaaccent = 611, e3.Atilde = 722, e3.Aogonek = 722, e3.Aring = 722, e3.Otilde = 778, e3.zdotaccent = 500, e3.Ecaron = 667, e3.Iogonek = 278, e3.kcommaaccent = 556, e3.minus = 584, e3.Icircumflex = 278, e3.ncaron = 611, e3.tcommaaccent = 333, e3.logicalnot = 584, e3.odieresis = 611, e3.udieresis = 611, e3.notequal = 549, e3.gcommaaccent = 611, e3.eth = 611, e3.zcaron = 500, e3.ncommaaccent = 611, e3.onesuperior = 333, e3.imacron = 278, e3.Euro = 556;
      }), e2["Helvetica-BoldOblique"] = getLookupTableFactory(function(e3) {
        e3.space = 278, e3.exclam = 333, e3.quotedbl = 474, e3.numbersign = 556, e3.dollar = 556, e3.percent = 889, e3.ampersand = 722, e3.quoteright = 278, e3.parenleft = 333, e3.parenright = 333, e3.asterisk = 389, e3.plus = 584, e3.comma = 278, e3.hyphen = 333, e3.period = 278, e3.slash = 278, e3.zero = 556, e3.one = 556, e3.two = 556, e3.three = 556, e3.four = 556, e3.five = 556, e3.six = 556, e3.seven = 556, e3.eight = 556, e3.nine = 556, e3.colon = 333, e3.semicolon = 333, e3.less = 584, e3.equal = 584, e3.greater = 584, e3.question = 611, e3.at = 975, e3.A = 722, e3.B = 722, e3.C = 722, e3.D = 722, e3.E = 667, e3.F = 611, e3.G = 778, e3.H = 722, e3.I = 278, e3.J = 556, e3.K = 722, e3.L = 611, e3.M = 833, e3.N = 722, e3.O = 778, e3.P = 667, e3.Q = 778, e3.R = 722, e3.S = 667, e3.T = 611, e3.U = 722, e3.V = 667, e3.W = 944, e3.X = 667, e3.Y = 667, e3.Z = 611, e3.bracketleft = 333, e3.backslash = 278, e3.bracketright = 333, e3.asciicircum = 584, e3.underscore = 556, e3.quoteleft = 278, e3.a = 556, e3.b = 611, e3.c = 556, e3.d = 611, e3.e = 556, e3.f = 333, e3.g = 611, e3.h = 611, e3.i = 278, e3.j = 278, e3.k = 556, e3.l = 278, e3.m = 889, e3.n = 611, e3.o = 611, e3.p = 611, e3.q = 611, e3.r = 389, e3.s = 556, e3.t = 333, e3.u = 611, e3.v = 556, e3.w = 778, e3.x = 556, e3.y = 556, e3.z = 500, e3.braceleft = 389, e3.bar = 280, e3.braceright = 389, e3.asciitilde = 584, e3.exclamdown = 333, e3.cent = 556, e3.sterling = 556, e3.fraction = 167, e3.yen = 556, e3.florin = 556, e3.section = 556, e3.currency = 556, e3.quotesingle = 238, e3.quotedblleft = 500, e3.guillemotleft = 556, e3.guilsinglleft = 333, e3.guilsinglright = 333, e3.fi = 611, e3.fl = 611, e3.endash = 556, e3.dagger = 556, e3.daggerdbl = 556, e3.periodcentered = 278, e3.paragraph = 556, e3.bullet = 350, e3.quotesinglbase = 278, e3.quotedblbase = 500, e3.quotedblright = 500, e3.guillemotright = 556, e3.ellipsis = 1e3, e3.perthousand = 1e3, e3.questiondown = 611, e3.grave = 333, e3.acute = 333, e3.circumflex = 333, e3.tilde = 333, e3.macron = 333, e3.breve = 333, e3.dotaccent = 333, e3.dieresis = 333, e3.ring = 333, e3.cedilla = 333, e3.hungarumlaut = 333, e3.ogonek = 333, e3.caron = 333, e3.emdash = 1e3, e3.AE = 1e3, e3.ordfeminine = 370, e3.Lslash = 611, e3.Oslash = 778, e3.OE = 1e3, e3.ordmasculine = 365, e3.ae = 889, e3.dotlessi = 278, e3.lslash = 278, e3.oslash = 611, e3.oe = 944, e3.germandbls = 611, e3.Idieresis = 278, e3.eacute = 556, e3.abreve = 556, e3.uhungarumlaut = 611, e3.ecaron = 556, e3.Ydieresis = 667, e3.divide = 584, e3.Yacute = 667, e3.Acircumflex = 722, e3.aacute = 556, e3.Ucircumflex = 722, e3.yacute = 556, e3.scommaaccent = 556, e3.ecircumflex = 556, e3.Uring = 722, e3.Udieresis = 722, e3.aogonek = 556, e3.Uacute = 722, e3.uogonek = 611, e3.Edieresis = 667, e3.Dcroat = 722, e3.commaaccent = 250, e3.copyright = 737, e3.Emacron = 667, e3.ccaron = 556, e3.aring = 556, e3.Ncommaaccent = 722, e3.lacute = 278, e3.agrave = 556, e3.Tcommaaccent = 611, e3.Cacute = 722, e3.atilde = 556, e3.Edotaccent = 667, e3.scaron = 556, e3.scedilla = 556, e3.iacute = 278, e3.lozenge = 494, e3.Rcaron = 722, e3.Gcommaaccent = 778, e3.ucircumflex = 611, e3.acircumflex = 556, e3.Amacron = 722, e3.rcaron = 389, e3.ccedilla = 556, e3.Zdotaccent = 611, e3.Thorn = 667, e3.Omacron = 778, e3.Racute = 722, e3.Sacute = 667, e3.dcaron = 743, e3.Umacron = 722, e3.uring = 611, e3.threesuperior = 333, e3.Ograve = 778, e3.Agrave = 722, e3.Abreve = 722, e3.multiply = 584, e3.uacute = 611, e3.Tcaron = 611, e3.partialdiff = 494, e3.ydieresis = 556, e3.Nacute = 722, e3.icircumflex = 278, e3.Ecircumflex = 667, e3.adieresis = 556, e3.edieresis = 556, e3.cacute = 556, e3.nacute = 611, e3.umacron = 611, e3.Ncaron = 722, e3.Iacute = 278, e3.plusminus = 584, e3.brokenbar = 280, e3.registered = 737, e3.Gbreve = 778, e3.Idotaccent = 278, e3.summation = 600, e3.Egrave = 667, e3.racute = 389, e3.omacron = 611, e3.Zacute = 611, e3.Zcaron = 611, e3.greaterequal = 549, e3.Eth = 722, e3.Ccedilla = 722, e3.lcommaaccent = 278, e3.tcaron = 389, e3.eogonek = 556, e3.Uogonek = 722, e3.Aacute = 722, e3.Adieresis = 722, e3.egrave = 556, e3.zacute = 500, e3.iogonek = 278, e3.Oacute = 778, e3.oacute = 611, e3.amacron = 556, e3.sacute = 556, e3.idieresis = 278, e3.Ocircumflex = 778, e3.Ugrave = 722, e3.Delta = 612, e3.thorn = 611, e3.twosuperior = 333, e3.Odieresis = 778, e3.mu = 611, e3.igrave = 278, e3.ohungarumlaut = 611, e3.Eogonek = 667, e3.dcroat = 611, e3.threequarters = 834, e3.Scedilla = 667, e3.lcaron = 400, e3.Kcommaaccent = 722, e3.Lacute = 611, e3.trademark = 1e3, e3.edotaccent = 556, e3.Igrave = 278, e3.Imacron = 278, e3.Lcaron = 611, e3.onehalf = 834, e3.lessequal = 549, e3.ocircumflex = 611, e3.ntilde = 611, e3.Uhungarumlaut = 722, e3.Eacute = 667, e3.emacron = 556, e3.gbreve = 611, e3.onequarter = 834, e3.Scaron = 667, e3.Scommaaccent = 667, e3.Ohungarumlaut = 778, e3.degree = 400, e3.ograve = 611, e3.Ccaron = 722, e3.ugrave = 611, e3.radical = 549, e3.Dcaron = 722, e3.rcommaaccent = 389, e3.Ntilde = 722, e3.otilde = 611, e3.Rcommaaccent = 722, e3.Lcommaaccent = 611, e3.Atilde = 722, e3.Aogonek = 722, e3.Aring = 722, e3.Otilde = 778, e3.zdotaccent = 500, e3.Ecaron = 667, e3.Iogonek = 278, e3.kcommaaccent = 556, e3.minus = 584, e3.Icircumflex = 278, e3.ncaron = 611, e3.tcommaaccent = 333, e3.logicalnot = 584, e3.odieresis = 611, e3.udieresis = 611, e3.notequal = 549, e3.gcommaaccent = 611, e3.eth = 611, e3.zcaron = 500, e3.ncommaaccent = 611, e3.onesuperior = 333, e3.imacron = 278, e3.Euro = 556;
      }), e2["Helvetica-Oblique"] = getLookupTableFactory(function(e3) {
        e3.space = 278, e3.exclam = 278, e3.quotedbl = 355, e3.numbersign = 556, e3.dollar = 556, e3.percent = 889, e3.ampersand = 667, e3.quoteright = 222, e3.parenleft = 333, e3.parenright = 333, e3.asterisk = 389, e3.plus = 584, e3.comma = 278, e3.hyphen = 333, e3.period = 278, e3.slash = 278, e3.zero = 556, e3.one = 556, e3.two = 556, e3.three = 556, e3.four = 556, e3.five = 556, e3.six = 556, e3.seven = 556, e3.eight = 556, e3.nine = 556, e3.colon = 278, e3.semicolon = 278, e3.less = 584, e3.equal = 584, e3.greater = 584, e3.question = 556, e3.at = 1015, e3.A = 667, e3.B = 667, e3.C = 722, e3.D = 722, e3.E = 667, e3.F = 611, e3.G = 778, e3.H = 722, e3.I = 278, e3.J = 500, e3.K = 667, e3.L = 556, e3.M = 833, e3.N = 722, e3.O = 778, e3.P = 667, e3.Q = 778, e3.R = 722, e3.S = 667, e3.T = 611, e3.U = 722, e3.V = 667, e3.W = 944, e3.X = 667, e3.Y = 667, e3.Z = 611, e3.bracketleft = 278, e3.backslash = 278, e3.bracketright = 278, e3.asciicircum = 469, e3.underscore = 556, e3.quoteleft = 222, e3.a = 556, e3.b = 556, e3.c = 500, e3.d = 556, e3.e = 556, e3.f = 278, e3.g = 556, e3.h = 556, e3.i = 222, e3.j = 222, e3.k = 500, e3.l = 222, e3.m = 833, e3.n = 556, e3.o = 556, e3.p = 556, e3.q = 556, e3.r = 333, e3.s = 500, e3.t = 278, e3.u = 556, e3.v = 500, e3.w = 722, e3.x = 500, e3.y = 500, e3.z = 500, e3.braceleft = 334, e3.bar = 260, e3.braceright = 334, e3.asciitilde = 584, e3.exclamdown = 333, e3.cent = 556, e3.sterling = 556, e3.fraction = 167, e3.yen = 556, e3.florin = 556, e3.section = 556, e3.currency = 556, e3.quotesingle = 191, e3.quotedblleft = 333, e3.guillemotleft = 556, e3.guilsinglleft = 333, e3.guilsinglright = 333, e3.fi = 500, e3.fl = 500, e3.endash = 556, e3.dagger = 556, e3.daggerdbl = 556, e3.periodcentered = 278, e3.paragraph = 537, e3.bullet = 350, e3.quotesinglbase = 222, e3.quotedblbase = 333, e3.quotedblright = 333, e3.guillemotright = 556, e3.ellipsis = 1e3, e3.perthousand = 1e3, e3.questiondown = 611, e3.grave = 333, e3.acute = 333, e3.circumflex = 333, e3.tilde = 333, e3.macron = 333, e3.breve = 333, e3.dotaccent = 333, e3.dieresis = 333, e3.ring = 333, e3.cedilla = 333, e3.hungarumlaut = 333, e3.ogonek = 333, e3.caron = 333, e3.emdash = 1e3, e3.AE = 1e3, e3.ordfeminine = 370, e3.Lslash = 556, e3.Oslash = 778, e3.OE = 1e3, e3.ordmasculine = 365, e3.ae = 889, e3.dotlessi = 278, e3.lslash = 222, e3.oslash = 611, e3.oe = 944, e3.germandbls = 611, e3.Idieresis = 278, e3.eacute = 556, e3.abreve = 556, e3.uhungarumlaut = 556, e3.ecaron = 556, e3.Ydieresis = 667, e3.divide = 584, e3.Yacute = 667, e3.Acircumflex = 667, e3.aacute = 556, e3.Ucircumflex = 722, e3.yacute = 500, e3.scommaaccent = 500, e3.ecircumflex = 556, e3.Uring = 722, e3.Udieresis = 722, e3.aogonek = 556, e3.Uacute = 722, e3.uogonek = 556, e3.Edieresis = 667, e3.Dcroat = 722, e3.commaaccent = 250, e3.copyright = 737, e3.Emacron = 667, e3.ccaron = 500, e3.aring = 556, e3.Ncommaaccent = 722, e3.lacute = 222, e3.agrave = 556, e3.Tcommaaccent = 611, e3.Cacute = 722, e3.atilde = 556, e3.Edotaccent = 667, e3.scaron = 500, e3.scedilla = 500, e3.iacute = 278, e3.lozenge = 471, e3.Rcaron = 722, e3.Gcommaaccent = 778, e3.ucircumflex = 556, e3.acircumflex = 556, e3.Amacron = 667, e3.rcaron = 333, e3.ccedilla = 500, e3.Zdotaccent = 611, e3.Thorn = 667, e3.Omacron = 778, e3.Racute = 722, e3.Sacute = 667, e3.dcaron = 643, e3.Umacron = 722, e3.uring = 556, e3.threesuperior = 333, e3.Ograve = 778, e3.Agrave = 667, e3.Abreve = 667, e3.multiply = 584, e3.uacute = 556, e3.Tcaron = 611, e3.partialdiff = 476, e3.ydieresis = 500, e3.Nacute = 722, e3.icircumflex = 278, e3.Ecircumflex = 667, e3.adieresis = 556, e3.edieresis = 556, e3.cacute = 500, e3.nacute = 556, e3.umacron = 556, e3.Ncaron = 722, e3.Iacute = 278, e3.plusminus = 584, e3.brokenbar = 260, e3.registered = 737, e3.Gbreve = 778, e3.Idotaccent = 278, e3.summation = 600, e3.Egrave = 667, e3.racute = 333, e3.omacron = 556, e3.Zacute = 611, e3.Zcaron = 611, e3.greaterequal = 549, e3.Eth = 722, e3.Ccedilla = 722, e3.lcommaaccent = 222, e3.tcaron = 317, e3.eogonek = 556, e3.Uogonek = 722, e3.Aacute = 667, e3.Adieresis = 667, e3.egrave = 556, e3.zacute = 500, e3.iogonek = 222, e3.Oacute = 778, e3.oacute = 556, e3.amacron = 556, e3.sacute = 500, e3.idieresis = 278, e3.Ocircumflex = 778, e3.Ugrave = 722, e3.Delta = 612, e3.thorn = 556, e3.twosuperior = 333, e3.Odieresis = 778, e3.mu = 556, e3.igrave = 278, e3.ohungarumlaut = 556, e3.Eogonek = 667, e3.dcroat = 556, e3.threequarters = 834, e3.Scedilla = 667, e3.lcaron = 299, e3.Kcommaaccent = 667, e3.Lacute = 556, e3.trademark = 1e3, e3.edotaccent = 556, e3.Igrave = 278, e3.Imacron = 278, e3.Lcaron = 556, e3.onehalf = 834, e3.lessequal = 549, e3.ocircumflex = 556, e3.ntilde = 556, e3.Uhungarumlaut = 722, e3.Eacute = 667, e3.emacron = 556, e3.gbreve = 556, e3.onequarter = 834, e3.Scaron = 667, e3.Scommaaccent = 667, e3.Ohungarumlaut = 778, e3.degree = 400, e3.ograve = 556, e3.Ccaron = 722, e3.ugrave = 556, e3.radical = 453, e3.Dcaron = 722, e3.rcommaaccent = 333, e3.Ntilde = 722, e3.otilde = 556, e3.Rcommaaccent = 722, e3.Lcommaaccent = 556, e3.Atilde = 667, e3.Aogonek = 667, e3.Aring = 667, e3.Otilde = 778, e3.zdotaccent = 500, e3.Ecaron = 667, e3.Iogonek = 278, e3.kcommaaccent = 500, e3.minus = 584, e3.Icircumflex = 278, e3.ncaron = 556, e3.tcommaaccent = 278, e3.logicalnot = 584, e3.odieresis = 556, e3.udieresis = 556, e3.notequal = 549, e3.gcommaaccent = 556, e3.eth = 556, e3.zcaron = 500, e3.ncommaaccent = 556, e3.onesuperior = 333, e3.imacron = 278, e3.Euro = 556;
      }), e2.Symbol = getLookupTableFactory(function(e3) {
        e3.space = 250, e3.exclam = 333, e3.universal = 713, e3.numbersign = 500, e3.existential = 549, e3.percent = 833, e3.ampersand = 778, e3.suchthat = 439, e3.parenleft = 333, e3.parenright = 333, e3.asteriskmath = 500, e3.plus = 549, e3.comma = 250, e3.minus = 549, e3.period = 250, e3.slash = 278, e3.zero = 500, e3.one = 500, e3.two = 500, e3.three = 500, e3.four = 500, e3.five = 500, e3.six = 500, e3.seven = 500, e3.eight = 500, e3.nine = 500, e3.colon = 278, e3.semicolon = 278, e3.less = 549, e3.equal = 549, e3.greater = 549, e3.question = 444, e3.congruent = 549, e3.Alpha = 722, e3.Beta = 667, e3.Chi = 722, e3.Delta = 612, e3.Epsilon = 611, e3.Phi = 763, e3.Gamma = 603, e3.Eta = 722, e3.Iota = 333, e3.theta1 = 631, e3.Kappa = 722, e3.Lambda = 686, e3.Mu = 889, e3.Nu = 722, e3.Omicron = 722, e3.Pi = 768, e3.Theta = 741, e3.Rho = 556, e3.Sigma = 592, e3.Tau = 611, e3.Upsilon = 690, e3.sigma1 = 439, e3.Omega = 768, e3.Xi = 645, e3.Psi = 795, e3.Zeta = 611, e3.bracketleft = 333, e3.therefore = 863, e3.bracketright = 333, e3.perpendicular = 658, e3.underscore = 500, e3.radicalex = 500, e3.alpha = 631, e3.beta = 549, e3.chi = 549, e3.delta = 494, e3.epsilon = 439, e3.phi = 521, e3.gamma = 411, e3.eta = 603, e3.iota = 329, e3.phi1 = 603, e3.kappa = 549, e3.lambda = 549, e3.mu = 576, e3.nu = 521, e3.omicron = 549, e3.pi = 549, e3.theta = 521, e3.rho = 549, e3.sigma = 603, e3.tau = 439, e3.upsilon = 576, e3.omega1 = 713, e3.omega = 686, e3.xi = 493, e3.psi = 686, e3.zeta = 494, e3.braceleft = 480, e3.bar = 200, e3.braceright = 480, e3.similar = 549, e3.Euro = 750, e3.Upsilon1 = 620, e3.minute = 247, e3.lessequal = 549, e3.fraction = 167, e3.infinity = 713, e3.florin = 500, e3.club = 753, e3.diamond = 753, e3.heart = 753, e3.spade = 753, e3.arrowboth = 1042, e3.arrowleft = 987, e3.arrowup = 603, e3.arrowright = 987, e3.arrowdown = 603, e3.degree = 400, e3.plusminus = 549, e3.second = 411, e3.greaterequal = 549, e3.multiply = 549, e3.proportional = 713, e3.partialdiff = 494, e3.bullet = 460, e3.divide = 549, e3.notequal = 549, e3.equivalence = 549, e3.approxequal = 549, e3.ellipsis = 1e3, e3.arrowvertex = 603, e3.arrowhorizex = 1e3, e3.carriagereturn = 658, e3.aleph = 823, e3.Ifraktur = 686, e3.Rfraktur = 795, e3.weierstrass = 987, e3.circlemultiply = 768, e3.circleplus = 768, e3.emptyset = 823, e3.intersection = 768, e3.union = 768, e3.propersuperset = 713, e3.reflexsuperset = 713, e3.notsubset = 713, e3.propersubset = 713, e3.reflexsubset = 713, e3.element = 713, e3.notelement = 713, e3.angle = 768, e3.gradient = 713, e3.registerserif = 790, e3.copyrightserif = 790, e3.trademarkserif = 890, e3.product = 823, e3.radical = 549, e3.dotmath = 250, e3.logicalnot = 713, e3.logicaland = 603, e3.logicalor = 603, e3.arrowdblboth = 1042, e3.arrowdblleft = 987, e3.arrowdblup = 603, e3.arrowdblright = 987, e3.arrowdbldown = 603, e3.lozenge = 494, e3.angleleft = 329, e3.registersans = 790, e3.copyrightsans = 790, e3.trademarksans = 786, e3.summation = 713, e3.parenlefttp = 384, e3.parenleftex = 384, e3.parenleftbt = 384, e3.bracketlefttp = 384, e3.bracketleftex = 384, e3.bracketleftbt = 384, e3.bracelefttp = 494, e3.braceleftmid = 494, e3.braceleftbt = 494, e3.braceex = 494, e3.angleright = 329, e3.integral = 274, e3.integraltp = 686, e3.integralex = 686, e3.integralbt = 686, e3.parenrighttp = 384, e3.parenrightex = 384, e3.parenrightbt = 384, e3.bracketrighttp = 384, e3.bracketrightex = 384, e3.bracketrightbt = 384, e3.bracerighttp = 494, e3.bracerightmid = 494, e3.bracerightbt = 494, e3.apple = 790;
      }), e2["Times-Roman"] = getLookupTableFactory(function(e3) {
        e3.space = 250, e3.exclam = 333, e3.quotedbl = 408, e3.numbersign = 500, e3.dollar = 500, e3.percent = 833, e3.ampersand = 778, e3.quoteright = 333, e3.parenleft = 333, e3.parenright = 333, e3.asterisk = 500, e3.plus = 564, e3.comma = 250, e3.hyphen = 333, e3.period = 250, e3.slash = 278, e3.zero = 500, e3.one = 500, e3.two = 500, e3.three = 500, e3.four = 500, e3.five = 500, e3.six = 500, e3.seven = 500, e3.eight = 500, e3.nine = 500, e3.colon = 278, e3.semicolon = 278, e3.less = 564, e3.equal = 564, e3.greater = 564, e3.question = 444, e3.at = 921, e3.A = 722, e3.B = 667, e3.C = 667, e3.D = 722, e3.E = 611, e3.F = 556, e3.G = 722, e3.H = 722, e3.I = 333, e3.J = 389, e3.K = 722, e3.L = 611, e3.M = 889, e3.N = 722, e3.O = 722, e3.P = 556, e3.Q = 722, e3.R = 667, e3.S = 556, e3.T = 611, e3.U = 722, e3.V = 722, e3.W = 944, e3.X = 722, e3.Y = 722, e3.Z = 611, e3.bracketleft = 333, e3.backslash = 278, e3.bracketright = 333, e3.asciicircum = 469, e3.underscore = 500, e3.quoteleft = 333, e3.a = 444, e3.b = 500, e3.c = 444, e3.d = 500, e3.e = 444, e3.f = 333, e3.g = 500, e3.h = 500, e3.i = 278, e3.j = 278, e3.k = 500, e3.l = 278, e3.m = 778, e3.n = 500, e3.o = 500, e3.p = 500, e3.q = 500, e3.r = 333, e3.s = 389, e3.t = 278, e3.u = 500, e3.v = 500, e3.w = 722, e3.x = 500, e3.y = 500, e3.z = 444, e3.braceleft = 480, e3.bar = 200, e3.braceright = 480, e3.asciitilde = 541, e3.exclamdown = 333, e3.cent = 500, e3.sterling = 500, e3.fraction = 167, e3.yen = 500, e3.florin = 500, e3.section = 500, e3.currency = 500, e3.quotesingle = 180, e3.quotedblleft = 444, e3.guillemotleft = 500, e3.guilsinglleft = 333, e3.guilsinglright = 333, e3.fi = 556, e3.fl = 556, e3.endash = 500, e3.dagger = 500, e3.daggerdbl = 500, e3.periodcentered = 250, e3.paragraph = 453, e3.bullet = 350, e3.quotesinglbase = 333, e3.quotedblbase = 444, e3.quotedblright = 444, e3.guillemotright = 500, e3.ellipsis = 1e3, e3.perthousand = 1e3, e3.questiondown = 444, e3.grave = 333, e3.acute = 333, e3.circumflex = 333, e3.tilde = 333, e3.macron = 333, e3.breve = 333, e3.dotaccent = 333, e3.dieresis = 333, e3.ring = 333, e3.cedilla = 333, e3.hungarumlaut = 333, e3.ogonek = 333, e3.caron = 333, e3.emdash = 1e3, e3.AE = 889, e3.ordfeminine = 276, e3.Lslash = 611, e3.Oslash = 722, e3.OE = 889, e3.ordmasculine = 310, e3.ae = 667, e3.dotlessi = 278, e3.lslash = 278, e3.oslash = 500, e3.oe = 722, e3.germandbls = 500, e3.Idieresis = 333, e3.eacute = 444, e3.abreve = 444, e3.uhungarumlaut = 500, e3.ecaron = 444, e3.Ydieresis = 722, e3.divide = 564, e3.Yacute = 722, e3.Acircumflex = 722, e3.aacute = 444, e3.Ucircumflex = 722, e3.yacute = 500, e3.scommaaccent = 389, e3.ecircumflex = 444, e3.Uring = 722, e3.Udieresis = 722, e3.aogonek = 444, e3.Uacute = 722, e3.uogonek = 500, e3.Edieresis = 611, e3.Dcroat = 722, e3.commaaccent = 250, e3.copyright = 760, e3.Emacron = 611, e3.ccaron = 444, e3.aring = 444, e3.Ncommaaccent = 722, e3.lacute = 278, e3.agrave = 444, e3.Tcommaaccent = 611, e3.Cacute = 667, e3.atilde = 444, e3.Edotaccent = 611, e3.scaron = 389, e3.scedilla = 389, e3.iacute = 278, e3.lozenge = 471, e3.Rcaron = 667, e3.Gcommaaccent = 722, e3.ucircumflex = 500, e3.acircumflex = 444, e3.Amacron = 722, e3.rcaron = 333, e3.ccedilla = 444, e3.Zdotaccent = 611, e3.Thorn = 556, e3.Omacron = 722, e3.Racute = 667, e3.Sacute = 556, e3.dcaron = 588, e3.Umacron = 722, e3.uring = 500, e3.threesuperior = 300, e3.Ograve = 722, e3.Agrave = 722, e3.Abreve = 722, e3.multiply = 564, e3.uacute = 500, e3.Tcaron = 611, e3.partialdiff = 476, e3.ydieresis = 500, e3.Nacute = 722, e3.icircumflex = 278, e3.Ecircumflex = 611, e3.adieresis = 444, e3.edieresis = 444, e3.cacute = 444, e3.nacute = 500, e3.umacron = 500, e3.Ncaron = 722, e3.Iacute = 333, e3.plusminus = 564, e3.brokenbar = 200, e3.registered = 760, e3.Gbreve = 722, e3.Idotaccent = 333, e3.summation = 600, e3.Egrave = 611, e3.racute = 333, e3.omacron = 500, e3.Zacute = 611, e3.Zcaron = 611, e3.greaterequal = 549, e3.Eth = 722, e3.Ccedilla = 667, e3.lcommaaccent = 278, e3.tcaron = 326, e3.eogonek = 444, e3.Uogonek = 722, e3.Aacute = 722, e3.Adieresis = 722, e3.egrave = 444, e3.zacute = 444, e3.iogonek = 278, e3.Oacute = 722, e3.oacute = 500, e3.amacron = 444, e3.sacute = 389, e3.idieresis = 278, e3.Ocircumflex = 722, e3.Ugrave = 722, e3.Delta = 612, e3.thorn = 500, e3.twosuperior = 300, e3.Odieresis = 722, e3.mu = 500, e3.igrave = 278, e3.ohungarumlaut = 500, e3.Eogonek = 611, e3.dcroat = 500, e3.threequarters = 750, e3.Scedilla = 556, e3.lcaron = 344, e3.Kcommaaccent = 722, e3.Lacute = 611, e3.trademark = 980, e3.edotaccent = 444, e3.Igrave = 333, e3.Imacron = 333, e3.Lcaron = 611, e3.onehalf = 750, e3.lessequal = 549, e3.ocircumflex = 500, e3.ntilde = 500, e3.Uhungarumlaut = 722, e3.Eacute = 611, e3.emacron = 444, e3.gbreve = 500, e3.onequarter = 750, e3.Scaron = 556, e3.Scommaaccent = 556, e3.Ohungarumlaut = 722, e3.degree = 400, e3.ograve = 500, e3.Ccaron = 667, e3.ugrave = 500, e3.radical = 453, e3.Dcaron = 722, e3.rcommaaccent = 333, e3.Ntilde = 722, e3.otilde = 500, e3.Rcommaaccent = 667, e3.Lcommaaccent = 611, e3.Atilde = 722, e3.Aogonek = 722, e3.Aring = 722, e3.Otilde = 722, e3.zdotaccent = 444, e3.Ecaron = 611, e3.Iogonek = 333, e3.kcommaaccent = 500, e3.minus = 564, e3.Icircumflex = 333, e3.ncaron = 500, e3.tcommaaccent = 278, e3.logicalnot = 564, e3.odieresis = 500, e3.udieresis = 500, e3.notequal = 549, e3.gcommaaccent = 500, e3.eth = 500, e3.zcaron = 444, e3.ncommaaccent = 500, e3.onesuperior = 300, e3.imacron = 278, e3.Euro = 500;
      }), e2["Times-Bold"] = getLookupTableFactory(function(e3) {
        e3.space = 250, e3.exclam = 333, e3.quotedbl = 555, e3.numbersign = 500, e3.dollar = 500, e3.percent = 1e3, e3.ampersand = 833, e3.quoteright = 333, e3.parenleft = 333, e3.parenright = 333, e3.asterisk = 500, e3.plus = 570, e3.comma = 250, e3.hyphen = 333, e3.period = 250, e3.slash = 278, e3.zero = 500, e3.one = 500, e3.two = 500, e3.three = 500, e3.four = 500, e3.five = 500, e3.six = 500, e3.seven = 500, e3.eight = 500, e3.nine = 500, e3.colon = 333, e3.semicolon = 333, e3.less = 570, e3.equal = 570, e3.greater = 570, e3.question = 500, e3.at = 930, e3.A = 722, e3.B = 667, e3.C = 722, e3.D = 722, e3.E = 667, e3.F = 611, e3.G = 778, e3.H = 778, e3.I = 389, e3.J = 500, e3.K = 778, e3.L = 667, e3.M = 944, e3.N = 722, e3.O = 778, e3.P = 611, e3.Q = 778, e3.R = 722, e3.S = 556, e3.T = 667, e3.U = 722, e3.V = 722, e3.W = 1e3, e3.X = 722, e3.Y = 722, e3.Z = 667, e3.bracketleft = 333, e3.backslash = 278, e3.bracketright = 333, e3.asciicircum = 581, e3.underscore = 500, e3.quoteleft = 333, e3.a = 500, e3.b = 556, e3.c = 444, e3.d = 556, e3.e = 444, e3.f = 333, e3.g = 500, e3.h = 556, e3.i = 278, e3.j = 333, e3.k = 556, e3.l = 278, e3.m = 833, e3.n = 556, e3.o = 500, e3.p = 556, e3.q = 556, e3.r = 444, e3.s = 389, e3.t = 333, e3.u = 556, e3.v = 500, e3.w = 722, e3.x = 500, e3.y = 500, e3.z = 444, e3.braceleft = 394, e3.bar = 220, e3.braceright = 394, e3.asciitilde = 520, e3.exclamdown = 333, e3.cent = 500, e3.sterling = 500, e3.fraction = 167, e3.yen = 500, e3.florin = 500, e3.section = 500, e3.currency = 500, e3.quotesingle = 278, e3.quotedblleft = 500, e3.guillemotleft = 500, e3.guilsinglleft = 333, e3.guilsinglright = 333, e3.fi = 556, e3.fl = 556, e3.endash = 500, e3.dagger = 500, e3.daggerdbl = 500, e3.periodcentered = 250, e3.paragraph = 540, e3.bullet = 350, e3.quotesinglbase = 333, e3.quotedblbase = 500, e3.quotedblright = 500, e3.guillemotright = 500, e3.ellipsis = 1e3, e3.perthousand = 1e3, e3.questiondown = 500, e3.grave = 333, e3.acute = 333, e3.circumflex = 333, e3.tilde = 333, e3.macron = 333, e3.breve = 333, e3.dotaccent = 333, e3.dieresis = 333, e3.ring = 333, e3.cedilla = 333, e3.hungarumlaut = 333, e3.ogonek = 333, e3.caron = 333, e3.emdash = 1e3, e3.AE = 1e3, e3.ordfeminine = 300, e3.Lslash = 667, e3.Oslash = 778, e3.OE = 1e3, e3.ordmasculine = 330, e3.ae = 722, e3.dotlessi = 278, e3.lslash = 278, e3.oslash = 500, e3.oe = 722, e3.germandbls = 556, e3.Idieresis = 389, e3.eacute = 444, e3.abreve = 500, e3.uhungarumlaut = 556, e3.ecaron = 444, e3.Ydieresis = 722, e3.divide = 570, e3.Yacute = 722, e3.Acircumflex = 722, e3.aacute = 500, e3.Ucircumflex = 722, e3.yacute = 500, e3.scommaaccent = 389, e3.ecircumflex = 444, e3.Uring = 722, e3.Udieresis = 722, e3.aogonek = 500, e3.Uacute = 722, e3.uogonek = 556, e3.Edieresis = 667, e3.Dcroat = 722, e3.commaaccent = 250, e3.copyright = 747, e3.Emacron = 667, e3.ccaron = 444, e3.aring = 500, e3.Ncommaaccent = 722, e3.lacute = 278, e3.agrave = 500, e3.Tcommaaccent = 667, e3.Cacute = 722, e3.atilde = 500, e3.Edotaccent = 667, e3.scaron = 389, e3.scedilla = 389, e3.iacute = 278, e3.lozenge = 494, e3.Rcaron = 722, e3.Gcommaaccent = 778, e3.ucircumflex = 556, e3.acircumflex = 500, e3.Amacron = 722, e3.rcaron = 444, e3.ccedilla = 444, e3.Zdotaccent = 667, e3.Thorn = 611, e3.Omacron = 778, e3.Racute = 722, e3.Sacute = 556, e3.dcaron = 672, e3.Umacron = 722, e3.uring = 556, e3.threesuperior = 300, e3.Ograve = 778, e3.Agrave = 722, e3.Abreve = 722, e3.multiply = 570, e3.uacute = 556, e3.Tcaron = 667, e3.partialdiff = 494, e3.ydieresis = 500, e3.Nacute = 722, e3.icircumflex = 278, e3.Ecircumflex = 667, e3.adieresis = 500, e3.edieresis = 444, e3.cacute = 444, e3.nacute = 556, e3.umacron = 556, e3.Ncaron = 722, e3.Iacute = 389, e3.plusminus = 570, e3.brokenbar = 220, e3.registered = 747, e3.Gbreve = 778, e3.Idotaccent = 389, e3.summation = 600, e3.Egrave = 667, e3.racute = 444, e3.omacron = 500, e3.Zacute = 667, e3.Zcaron = 667, e3.greaterequal = 549, e3.Eth = 722, e3.Ccedilla = 722, e3.lcommaaccent = 278, e3.tcaron = 416, e3.eogonek = 444, e3.Uogonek = 722, e3.Aacute = 722, e3.Adieresis = 722, e3.egrave = 444, e3.zacute = 444, e3.iogonek = 278, e3.Oacute = 778, e3.oacute = 500, e3.amacron = 500, e3.sacute = 389, e3.idieresis = 278, e3.Ocircumflex = 778, e3.Ugrave = 722, e3.Delta = 612, e3.thorn = 556, e3.twosuperior = 300, e3.Odieresis = 778, e3.mu = 556, e3.igrave = 278, e3.ohungarumlaut = 500, e3.Eogonek = 667, e3.dcroat = 556, e3.threequarters = 750, e3.Scedilla = 556, e3.lcaron = 394, e3.Kcommaaccent = 778, e3.Lacute = 667, e3.trademark = 1e3, e3.edotaccent = 444, e3.Igrave = 389, e3.Imacron = 389, e3.Lcaron = 667, e3.onehalf = 750, e3.lessequal = 549, e3.ocircumflex = 500, e3.ntilde = 556, e3.Uhungarumlaut = 722, e3.Eacute = 667, e3.emacron = 444, e3.gbreve = 500, e3.onequarter = 750, e3.Scaron = 556, e3.Scommaaccent = 556, e3.Ohungarumlaut = 778, e3.degree = 400, e3.ograve = 500, e3.Ccaron = 722, e3.ugrave = 556, e3.radical = 549, e3.Dcaron = 722, e3.rcommaaccent = 444, e3.Ntilde = 722, e3.otilde = 500, e3.Rcommaaccent = 722, e3.Lcommaaccent = 667, e3.Atilde = 722, e3.Aogonek = 722, e3.Aring = 722, e3.Otilde = 778, e3.zdotaccent = 444, e3.Ecaron = 667, e3.Iogonek = 389, e3.kcommaaccent = 556, e3.minus = 570, e3.Icircumflex = 389, e3.ncaron = 556, e3.tcommaaccent = 333, e3.logicalnot = 570, e3.odieresis = 500, e3.udieresis = 556, e3.notequal = 549, e3.gcommaaccent = 500, e3.eth = 500, e3.zcaron = 444, e3.ncommaaccent = 556, e3.onesuperior = 300, e3.imacron = 278, e3.Euro = 500;
      }), e2["Times-BoldItalic"] = getLookupTableFactory(function(e3) {
        e3.space = 250, e3.exclam = 389, e3.quotedbl = 555, e3.numbersign = 500, e3.dollar = 500, e3.percent = 833, e3.ampersand = 778, e3.quoteright = 333, e3.parenleft = 333, e3.parenright = 333, e3.asterisk = 500, e3.plus = 570, e3.comma = 250, e3.hyphen = 333, e3.period = 250, e3.slash = 278, e3.zero = 500, e3.one = 500, e3.two = 500, e3.three = 500, e3.four = 500, e3.five = 500, e3.six = 500, e3.seven = 500, e3.eight = 500, e3.nine = 500, e3.colon = 333, e3.semicolon = 333, e3.less = 570, e3.equal = 570, e3.greater = 570, e3.question = 500, e3.at = 832, e3.A = 667, e3.B = 667, e3.C = 667, e3.D = 722, e3.E = 667, e3.F = 667, e3.G = 722, e3.H = 778, e3.I = 389, e3.J = 500, e3.K = 667, e3.L = 611, e3.M = 889, e3.N = 722, e3.O = 722, e3.P = 611, e3.Q = 722, e3.R = 667, e3.S = 556, e3.T = 611, e3.U = 722, e3.V = 667, e3.W = 889, e3.X = 667, e3.Y = 611, e3.Z = 611, e3.bracketleft = 333, e3.backslash = 278, e3.bracketright = 333, e3.asciicircum = 570, e3.underscore = 500, e3.quoteleft = 333, e3.a = 500, e3.b = 500, e3.c = 444, e3.d = 500, e3.e = 444, e3.f = 333, e3.g = 500, e3.h = 556, e3.i = 278, e3.j = 278, e3.k = 500, e3.l = 278, e3.m = 778, e3.n = 556, e3.o = 500, e3.p = 500, e3.q = 500, e3.r = 389, e3.s = 389, e3.t = 278, e3.u = 556, e3.v = 444, e3.w = 667, e3.x = 500, e3.y = 444, e3.z = 389, e3.braceleft = 348, e3.bar = 220, e3.braceright = 348, e3.asciitilde = 570, e3.exclamdown = 389, e3.cent = 500, e3.sterling = 500, e3.fraction = 167, e3.yen = 500, e3.florin = 500, e3.section = 500, e3.currency = 500, e3.quotesingle = 278, e3.quotedblleft = 500, e3.guillemotleft = 500, e3.guilsinglleft = 333, e3.guilsinglright = 333, e3.fi = 556, e3.fl = 556, e3.endash = 500, e3.dagger = 500, e3.daggerdbl = 500, e3.periodcentered = 250, e3.paragraph = 500, e3.bullet = 350, e3.quotesinglbase = 333, e3.quotedblbase = 500, e3.quotedblright = 500, e3.guillemotright = 500, e3.ellipsis = 1e3, e3.perthousand = 1e3, e3.questiondown = 500, e3.grave = 333, e3.acute = 333, e3.circumflex = 333, e3.tilde = 333, e3.macron = 333, e3.breve = 333, e3.dotaccent = 333, e3.dieresis = 333, e3.ring = 333, e3.cedilla = 333, e3.hungarumlaut = 333, e3.ogonek = 333, e3.caron = 333, e3.emdash = 1e3, e3.AE = 944, e3.ordfeminine = 266, e3.Lslash = 611, e3.Oslash = 722, e3.OE = 944, e3.ordmasculine = 300, e3.ae = 722, e3.dotlessi = 278, e3.lslash = 278, e3.oslash = 500, e3.oe = 722, e3.germandbls = 500, e3.Idieresis = 389, e3.eacute = 444, e3.abreve = 500, e3.uhungarumlaut = 556, e3.ecaron = 444, e3.Ydieresis = 611, e3.divide = 570, e3.Yacute = 611, e3.Acircumflex = 667, e3.aacute = 500, e3.Ucircumflex = 722, e3.yacute = 444, e3.scommaaccent = 389, e3.ecircumflex = 444, e3.Uring = 722, e3.Udieresis = 722, e3.aogonek = 500, e3.Uacute = 722, e3.uogonek = 556, e3.Edieresis = 667, e3.Dcroat = 722, e3.commaaccent = 250, e3.copyright = 747, e3.Emacron = 667, e3.ccaron = 444, e3.aring = 500, e3.Ncommaaccent = 722, e3.lacute = 278, e3.agrave = 500, e3.Tcommaaccent = 611, e3.Cacute = 667, e3.atilde = 500, e3.Edotaccent = 667, e3.scaron = 389, e3.scedilla = 389, e3.iacute = 278, e3.lozenge = 494, e3.Rcaron = 667, e3.Gcommaaccent = 722, e3.ucircumflex = 556, e3.acircumflex = 500, e3.Amacron = 667, e3.rcaron = 389, e3.ccedilla = 444, e3.Zdotaccent = 611, e3.Thorn = 611, e3.Omacron = 722, e3.Racute = 667, e3.Sacute = 556, e3.dcaron = 608, e3.Umacron = 722, e3.uring = 556, e3.threesuperior = 300, e3.Ograve = 722, e3.Agrave = 667, e3.Abreve = 667, e3.multiply = 570, e3.uacute = 556, e3.Tcaron = 611, e3.partialdiff = 494, e3.ydieresis = 444, e3.Nacute = 722, e3.icircumflex = 278, e3.Ecircumflex = 667, e3.adieresis = 500, e3.edieresis = 444, e3.cacute = 444, e3.nacute = 556, e3.umacron = 556, e3.Ncaron = 722, e3.Iacute = 389, e3.plusminus = 570, e3.brokenbar = 220, e3.registered = 747, e3.Gbreve = 722, e3.Idotaccent = 389, e3.summation = 600, e3.Egrave = 667, e3.racute = 389, e3.omacron = 500, e3.Zacute = 611, e3.Zcaron = 611, e3.greaterequal = 549, e3.Eth = 722, e3.Ccedilla = 667, e3.lcommaaccent = 278, e3.tcaron = 366, e3.eogonek = 444, e3.Uogonek = 722, e3.Aacute = 667, e3.Adieresis = 667, e3.egrave = 444, e3.zacute = 389, e3.iogonek = 278, e3.Oacute = 722, e3.oacute = 500, e3.amacron = 500, e3.sacute = 389, e3.idieresis = 278, e3.Ocircumflex = 722, e3.Ugrave = 722, e3.Delta = 612, e3.thorn = 500, e3.twosuperior = 300, e3.Odieresis = 722, e3.mu = 576, e3.igrave = 278, e3.ohungarumlaut = 500, e3.Eogonek = 667, e3.dcroat = 500, e3.threequarters = 750, e3.Scedilla = 556, e3.lcaron = 382, e3.Kcommaaccent = 667, e3.Lacute = 611, e3.trademark = 1e3, e3.edotaccent = 444, e3.Igrave = 389, e3.Imacron = 389, e3.Lcaron = 611, e3.onehalf = 750, e3.lessequal = 549, e3.ocircumflex = 500, e3.ntilde = 556, e3.Uhungarumlaut = 722, e3.Eacute = 667, e3.emacron = 444, e3.gbreve = 500, e3.onequarter = 750, e3.Scaron = 556, e3.Scommaaccent = 556, e3.Ohungarumlaut = 722, e3.degree = 400, e3.ograve = 500, e3.Ccaron = 667, e3.ugrave = 556, e3.radical = 549, e3.Dcaron = 722, e3.rcommaaccent = 389, e3.Ntilde = 722, e3.otilde = 500, e3.Rcommaaccent = 667, e3.Lcommaaccent = 611, e3.Atilde = 667, e3.Aogonek = 667, e3.Aring = 667, e3.Otilde = 722, e3.zdotaccent = 389, e3.Ecaron = 667, e3.Iogonek = 389, e3.kcommaaccent = 500, e3.minus = 606, e3.Icircumflex = 389, e3.ncaron = 556, e3.tcommaaccent = 278, e3.logicalnot = 606, e3.odieresis = 500, e3.udieresis = 556, e3.notequal = 549, e3.gcommaaccent = 500, e3.eth = 500, e3.zcaron = 389, e3.ncommaaccent = 556, e3.onesuperior = 300, e3.imacron = 278, e3.Euro = 500;
      }), e2["Times-Italic"] = getLookupTableFactory(function(e3) {
        e3.space = 250, e3.exclam = 333, e3.quotedbl = 420, e3.numbersign = 500, e3.dollar = 500, e3.percent = 833, e3.ampersand = 778, e3.quoteright = 333, e3.parenleft = 333, e3.parenright = 333, e3.asterisk = 500, e3.plus = 675, e3.comma = 250, e3.hyphen = 333, e3.period = 250, e3.slash = 278, e3.zero = 500, e3.one = 500, e3.two = 500, e3.three = 500, e3.four = 500, e3.five = 500, e3.six = 500, e3.seven = 500, e3.eight = 500, e3.nine = 500, e3.colon = 333, e3.semicolon = 333, e3.less = 675, e3.equal = 675, e3.greater = 675, e3.question = 500, e3.at = 920, e3.A = 611, e3.B = 611, e3.C = 667, e3.D = 722, e3.E = 611, e3.F = 611, e3.G = 722, e3.H = 722, e3.I = 333, e3.J = 444, e3.K = 667, e3.L = 556, e3.M = 833, e3.N = 667, e3.O = 722, e3.P = 611, e3.Q = 722, e3.R = 611, e3.S = 500, e3.T = 556, e3.U = 722, e3.V = 611, e3.W = 833, e3.X = 611, e3.Y = 556, e3.Z = 556, e3.bracketleft = 389, e3.backslash = 278, e3.bracketright = 389, e3.asciicircum = 422, e3.underscore = 500, e3.quoteleft = 333, e3.a = 500, e3.b = 500, e3.c = 444, e3.d = 500, e3.e = 444, e3.f = 278, e3.g = 500, e3.h = 500, e3.i = 278, e3.j = 278, e3.k = 444, e3.l = 278, e3.m = 722, e3.n = 500, e3.o = 500, e3.p = 500, e3.q = 500, e3.r = 389, e3.s = 389, e3.t = 278, e3.u = 500, e3.v = 444, e3.w = 667, e3.x = 444, e3.y = 444, e3.z = 389, e3.braceleft = 400, e3.bar = 275, e3.braceright = 400, e3.asciitilde = 541, e3.exclamdown = 389, e3.cent = 500, e3.sterling = 500, e3.fraction = 167, e3.yen = 500, e3.florin = 500, e3.section = 500, e3.currency = 500, e3.quotesingle = 214, e3.quotedblleft = 556, e3.guillemotleft = 500, e3.guilsinglleft = 333, e3.guilsinglright = 333, e3.fi = 500, e3.fl = 500, e3.endash = 500, e3.dagger = 500, e3.daggerdbl = 500, e3.periodcentered = 250, e3.paragraph = 523, e3.bullet = 350, e3.quotesinglbase = 333, e3.quotedblbase = 556, e3.quotedblright = 556, e3.guillemotright = 500, e3.ellipsis = 889, e3.perthousand = 1e3, e3.questiondown = 500, e3.grave = 333, e3.acute = 333, e3.circumflex = 333, e3.tilde = 333, e3.macron = 333, e3.breve = 333, e3.dotaccent = 333, e3.dieresis = 333, e3.ring = 333, e3.cedilla = 333, e3.hungarumlaut = 333, e3.ogonek = 333, e3.caron = 333, e3.emdash = 889, e3.AE = 889, e3.ordfeminine = 276, e3.Lslash = 556, e3.Oslash = 722, e3.OE = 944, e3.ordmasculine = 310, e3.ae = 667, e3.dotlessi = 278, e3.lslash = 278, e3.oslash = 500, e3.oe = 667, e3.germandbls = 500, e3.Idieresis = 333, e3.eacute = 444, e3.abreve = 500, e3.uhungarumlaut = 500, e3.ecaron = 444, e3.Ydieresis = 556, e3.divide = 675, e3.Yacute = 556, e3.Acircumflex = 611, e3.aacute = 500, e3.Ucircumflex = 722, e3.yacute = 444, e3.scommaaccent = 389, e3.ecircumflex = 444, e3.Uring = 722, e3.Udieresis = 722, e3.aogonek = 500, e3.Uacute = 722, e3.uogonek = 500, e3.Edieresis = 611, e3.Dcroat = 722, e3.commaaccent = 250, e3.copyright = 760, e3.Emacron = 611, e3.ccaron = 444, e3.aring = 500, e3.Ncommaaccent = 667, e3.lacute = 278, e3.agrave = 500, e3.Tcommaaccent = 556, e3.Cacute = 667, e3.atilde = 500, e3.Edotaccent = 611, e3.scaron = 389, e3.scedilla = 389, e3.iacute = 278, e3.lozenge = 471, e3.Rcaron = 611, e3.Gcommaaccent = 722, e3.ucircumflex = 500, e3.acircumflex = 500, e3.Amacron = 611, e3.rcaron = 389, e3.ccedilla = 444, e3.Zdotaccent = 556, e3.Thorn = 611, e3.Omacron = 722, e3.Racute = 611, e3.Sacute = 500, e3.dcaron = 544, e3.Umacron = 722, e3.uring = 500, e3.threesuperior = 300, e3.Ograve = 722, e3.Agrave = 611, e3.Abreve = 611, e3.multiply = 675, e3.uacute = 500, e3.Tcaron = 556, e3.partialdiff = 476, e3.ydieresis = 444, e3.Nacute = 667, e3.icircumflex = 278, e3.Ecircumflex = 611, e3.adieresis = 500, e3.edieresis = 444, e3.cacute = 444, e3.nacute = 500, e3.umacron = 500, e3.Ncaron = 667, e3.Iacute = 333, e3.plusminus = 675, e3.brokenbar = 275, e3.registered = 760, e3.Gbreve = 722, e3.Idotaccent = 333, e3.summation = 600, e3.Egrave = 611, e3.racute = 389, e3.omacron = 500, e3.Zacute = 556, e3.Zcaron = 556, e3.greaterequal = 549, e3.Eth = 722, e3.Ccedilla = 667, e3.lcommaaccent = 278, e3.tcaron = 300, e3.eogonek = 444, e3.Uogonek = 722, e3.Aacute = 611, e3.Adieresis = 611, e3.egrave = 444, e3.zacute = 389, e3.iogonek = 278, e3.Oacute = 722, e3.oacute = 500, e3.amacron = 500, e3.sacute = 389, e3.idieresis = 278, e3.Ocircumflex = 722, e3.Ugrave = 722, e3.Delta = 612, e3.thorn = 500, e3.twosuperior = 300, e3.Odieresis = 722, e3.mu = 500, e3.igrave = 278, e3.ohungarumlaut = 500, e3.Eogonek = 611, e3.dcroat = 500, e3.threequarters = 750, e3.Scedilla = 500, e3.lcaron = 300, e3.Kcommaaccent = 667, e3.Lacute = 556, e3.trademark = 980, e3.edotaccent = 444, e3.Igrave = 333, e3.Imacron = 333, e3.Lcaron = 611, e3.onehalf = 750, e3.lessequal = 549, e3.ocircumflex = 500, e3.ntilde = 500, e3.Uhungarumlaut = 722, e3.Eacute = 611, e3.emacron = 444, e3.gbreve = 500, e3.onequarter = 750, e3.Scaron = 500, e3.Scommaaccent = 500, e3.Ohungarumlaut = 722, e3.degree = 400, e3.ograve = 500, e3.Ccaron = 667, e3.ugrave = 500, e3.radical = 453, e3.Dcaron = 722, e3.rcommaaccent = 389, e3.Ntilde = 667, e3.otilde = 500, e3.Rcommaaccent = 611, e3.Lcommaaccent = 556, e3.Atilde = 611, e3.Aogonek = 611, e3.Aring = 611, e3.Otilde = 722, e3.zdotaccent = 389, e3.Ecaron = 611, e3.Iogonek = 333, e3.kcommaaccent = 444, e3.minus = 675, e3.Icircumflex = 333, e3.ncaron = 500, e3.tcommaaccent = 278, e3.logicalnot = 675, e3.odieresis = 500, e3.udieresis = 500, e3.notequal = 549, e3.gcommaaccent = 500, e3.eth = 500, e3.zcaron = 389, e3.ncommaaccent = 500, e3.onesuperior = 300, e3.imacron = 278, e3.Euro = 500;
      }), e2.ZapfDingbats = getLookupTableFactory(function(e3) {
        e3.space = 278, e3.a1 = 974, e3.a2 = 961, e3.a202 = 974, e3.a3 = 980, e3.a4 = 719, e3.a5 = 789, e3.a119 = 790, e3.a118 = 791, e3.a117 = 690, e3.a11 = 960, e3.a12 = 939, e3.a13 = 549, e3.a14 = 855, e3.a15 = 911, e3.a16 = 933, e3.a105 = 911, e3.a17 = 945, e3.a18 = 974, e3.a19 = 755, e3.a20 = 846, e3.a21 = 762, e3.a22 = 761, e3.a23 = 571, e3.a24 = 677, e3.a25 = 763, e3.a26 = 760, e3.a27 = 759, e3.a28 = 754, e3.a6 = 494, e3.a7 = 552, e3.a8 = 537, e3.a9 = 577, e3.a10 = 692, e3.a29 = 786, e3.a30 = 788, e3.a31 = 788, e3.a32 = 790, e3.a33 = 793, e3.a34 = 794, e3.a35 = 816, e3.a36 = 823, e3.a37 = 789, e3.a38 = 841, e3.a39 = 823, e3.a40 = 833, e3.a41 = 816, e3.a42 = 831, e3.a43 = 923, e3.a44 = 744, e3.a45 = 723, e3.a46 = 749, e3.a47 = 790, e3.a48 = 792, e3.a49 = 695, e3.a50 = 776, e3.a51 = 768, e3.a52 = 792, e3.a53 = 759, e3.a54 = 707, e3.a55 = 708, e3.a56 = 682, e3.a57 = 701, e3.a58 = 826, e3.a59 = 815, e3.a60 = 789, e3.a61 = 789, e3.a62 = 707, e3.a63 = 687, e3.a64 = 696, e3.a65 = 689, e3.a66 = 786, e3.a67 = 787, e3.a68 = 713, e3.a69 = 791, e3.a70 = 785, e3.a71 = 791, e3.a72 = 873, e3.a73 = 761, e3.a74 = 762, e3.a203 = 762, e3.a75 = 759, e3.a204 = 759, e3.a76 = 892, e3.a77 = 892, e3.a78 = 788, e3.a79 = 784, e3.a81 = 438, e3.a82 = 138, e3.a83 = 277, e3.a84 = 415, e3.a97 = 392, e3.a98 = 392, e3.a99 = 668, e3.a100 = 668, e3.a89 = 390, e3.a90 = 390, e3.a93 = 317, e3.a94 = 317, e3.a91 = 276, e3.a92 = 276, e3.a205 = 509, e3.a85 = 509, e3.a206 = 410, e3.a86 = 410, e3.a87 = 234, e3.a88 = 234, e3.a95 = 334, e3.a96 = 334, e3.a101 = 732, e3.a102 = 544, e3.a103 = 544, e3.a104 = 910, e3.a106 = 667, e3.a107 = 760, e3.a108 = 760, e3.a112 = 776, e3.a111 = 595, e3.a110 = 694, e3.a109 = 626, e3.a120 = 788, e3.a121 = 788, e3.a122 = 788, e3.a123 = 788, e3.a124 = 788, e3.a125 = 788, e3.a126 = 788, e3.a127 = 788, e3.a128 = 788, e3.a129 = 788, e3.a130 = 788, e3.a131 = 788, e3.a132 = 788, e3.a133 = 788, e3.a134 = 788, e3.a135 = 788, e3.a136 = 788, e3.a137 = 788, e3.a138 = 788, e3.a139 = 788, e3.a140 = 788, e3.a141 = 788, e3.a142 = 788, e3.a143 = 788, e3.a144 = 788, e3.a145 = 788, e3.a146 = 788, e3.a147 = 788, e3.a148 = 788, e3.a149 = 788, e3.a150 = 788, e3.a151 = 788, e3.a152 = 788, e3.a153 = 788, e3.a154 = 788, e3.a155 = 788, e3.a156 = 788, e3.a157 = 788, e3.a158 = 788, e3.a159 = 788, e3.a160 = 894, e3.a161 = 838, e3.a163 = 1016, e3.a164 = 458, e3.a196 = 748, e3.a165 = 924, e3.a192 = 748, e3.a166 = 918, e3.a167 = 927, e3.a168 = 928, e3.a169 = 928, e3.a170 = 834, e3.a171 = 873, e3.a172 = 828, e3.a173 = 924, e3.a162 = 924, e3.a174 = 917, e3.a175 = 930, e3.a176 = 931, e3.a177 = 463, e3.a178 = 883, e3.a179 = 836, e3.a193 = 836, e3.a180 = 867, e3.a199 = 867, e3.a181 = 696, e3.a200 = 696, e3.a182 = 874, e3.a201 = 874, e3.a183 = 760, e3.a184 = 946, e3.a197 = 771, e3.a185 = 865, e3.a194 = 771, e3.a198 = 888, e3.a186 = 967, e3.a195 = 888, e3.a187 = 831, e3.a188 = 873, e3.a189 = 927, e3.a190 = 970, e3.a191 = 918;
      });
    });
    Ga = getLookupTableFactory(function(e2) {
      e2.Courier = { ascent: 629, descent: -157, capHeight: 562, xHeight: -426 }, e2["Courier-Bold"] = { ascent: 629, descent: -157, capHeight: 562, xHeight: 439 }, e2["Courier-Oblique"] = { ascent: 629, descent: -157, capHeight: 562, xHeight: 426 }, e2["Courier-BoldOblique"] = { ascent: 629, descent: -157, capHeight: 562, xHeight: 426 }, e2.Helvetica = { ascent: 718, descent: -207, capHeight: 718, xHeight: 523 }, e2["Helvetica-Bold"] = { ascent: 718, descent: -207, capHeight: 718, xHeight: 532 }, e2["Helvetica-Oblique"] = { ascent: 718, descent: -207, capHeight: 718, xHeight: 523 }, e2["Helvetica-BoldOblique"] = { ascent: 718, descent: -207, capHeight: 718, xHeight: 532 }, e2["Times-Roman"] = { ascent: 683, descent: -217, capHeight: 662, xHeight: 450 }, e2["Times-Bold"] = { ascent: 683, descent: -217, capHeight: 676, xHeight: 461 }, e2["Times-Italic"] = { ascent: 683, descent: -217, capHeight: 653, xHeight: 441 }, e2["Times-BoldItalic"] = { ascent: 683, descent: -217, capHeight: 669, xHeight: 462 }, e2.Symbol = { ascent: Math.NaN, descent: Math.NaN, capHeight: Math.NaN, xHeight: Math.NaN }, e2.ZapfDingbats = { ascent: Math.NaN, descent: Math.NaN, capHeight: Math.NaN, xHeight: Math.NaN };
    });
    GlyfTable = class {
      constructor({ glyfTable: e2, isGlyphLocationsLong: t2, locaTable: i2, numGlyphs: a2 }) {
        this.glyphs = [];
        const n2 = new DataView(i2.buffer, i2.byteOffset, i2.byteLength), s2 = new DataView(e2.buffer, e2.byteOffset, e2.byteLength), r2 = t2 ? 4 : 2;
        let o2 = t2 ? n2.getUint32(0) : 2 * n2.getUint16(0), l3 = 0;
        for (let e3 = 0; e3 < a2; e3++) {
          l3 += r2;
          const e4 = t2 ? n2.getUint32(l3) : 2 * n2.getUint16(l3);
          if (e4 === o2) {
            this.glyphs.push(new Glyph({}));
            continue;
          }
          const i3 = Glyph.parse(o2, s2);
          this.glyphs.push(i3), o2 = e4;
        }
      }
      getSize() {
        return Math.sumPrecise(this.glyphs.map((e2) => e2.getSize() + 3 & -4));
      }
      write() {
        const e2 = this.getSize(), t2 = new DataView(new ArrayBuffer(e2)), i2 = e2 > 131070, a2 = i2 ? 4 : 2, n2 = new DataView(new ArrayBuffer((this.glyphs.length + 1) * a2));
        i2 ? n2.setUint32(0, 0) : n2.setUint16(0, 0);
        let s2 = 0, r2 = 0;
        for (const e3 of this.glyphs)
          s2 += e3.write(s2, t2), s2 = s2 + 3 & -4, r2 += a2, i2 ? n2.setUint32(r2, s2) : n2.setUint16(r2, s2 >> 1);
        return { isLocationLong: i2, loca: new Uint8Array(n2.buffer), glyf: new Uint8Array(t2.buffer) };
      }
      scale(e2) {
        for (let t2 = 0, i2 = this.glyphs.length; t2 < i2; t2++)
          this.glyphs[t2].scale(e2[t2]);
      }
    };
    __name(GlyfTable, "GlyfTable");
    Glyph = class {
      constructor({ header: e2 = null, simple: t2 = null, composites: i2 = null }) {
        this.header = e2, this.simple = t2, this.composites = i2;
      }
      static parse(e2, t2) {
        const [i2, a2] = GlyphHeader.parse(e2, t2);
        if (e2 += i2, a2.numberOfContours < 0) {
          const i3 = [];
          for (; ; ) {
            const [a3, n3] = CompositeGlyph.parse(e2, t2);
            if (e2 += a3, i3.push(n3), !(32 & n3.flags))
              break;
          }
          return new Glyph({ header: a2, composites: i3 });
        }
        const n2 = SimpleGlyph.parse(e2, t2, a2.numberOfContours);
        return new Glyph({ header: a2, simple: n2 });
      }
      getSize() {
        if (!this.header)
          return 0;
        const e2 = this.simple ? this.simple.getSize() : Math.sumPrecise(this.composites.map((e3) => e3.getSize()));
        return this.header.getSize() + e2;
      }
      write(e2, t2) {
        if (!this.header)
          return 0;
        const i2 = e2;
        if (e2 += this.header.write(e2, t2), this.simple)
          e2 += this.simple.write(e2, t2);
        else
          for (const i3 of this.composites)
            e2 += i3.write(e2, t2);
        return e2 - i2;
      }
      scale(e2) {
        if (!this.header)
          return;
        const t2 = (this.header.xMin + this.header.xMax) / 2;
        if (this.header.scale(t2, e2), this.simple)
          this.simple.scale(t2, e2);
        else
          for (const i2 of this.composites)
            i2.scale(t2, e2);
      }
    };
    __name(Glyph, "Glyph");
    GlyphHeader = class {
      constructor({ numberOfContours: e2, xMin: t2, yMin: i2, xMax: a2, yMax: n2 }) {
        this.numberOfContours = e2, this.xMin = t2, this.yMin = i2, this.xMax = a2, this.yMax = n2;
      }
      static parse(e2, t2) {
        return [10, new GlyphHeader({ numberOfContours: t2.getInt16(e2), xMin: t2.getInt16(e2 + 2), yMin: t2.getInt16(e2 + 4), xMax: t2.getInt16(e2 + 6), yMax: t2.getInt16(e2 + 8) })];
      }
      getSize() {
        return 10;
      }
      write(e2, t2) {
        return t2.setInt16(e2, this.numberOfContours), t2.setInt16(e2 + 2, this.xMin), t2.setInt16(e2 + 4, this.yMin), t2.setInt16(e2 + 6, this.xMax), t2.setInt16(e2 + 8, this.yMax), 10;
      }
      scale(e2, t2) {
        this.xMin = Math.round(e2 + (this.xMin - e2) * t2), this.xMax = Math.round(e2 + (this.xMax - e2) * t2);
      }
    };
    __name(GlyphHeader, "GlyphHeader");
    Contour = class {
      constructor({ flags: e2, xCoordinates: t2, yCoordinates: i2 }) {
        this.xCoordinates = t2, this.yCoordinates = i2, this.flags = e2;
      }
    };
    __name(Contour, "Contour");
    SimpleGlyph = class {
      constructor({ contours: e2, instructions: t2 }) {
        this.contours = e2, this.instructions = t2;
      }
      static parse(e2, t2, i2) {
        const a2 = [];
        for (let n3 = 0; n3 < i2; n3++) {
          const i3 = t2.getUint16(e2);
          e2 += 2, a2.push(i3);
        }
        const n2 = a2[i2 - 1] + 1, s2 = t2.getUint16(e2);
        e2 += 2;
        const r2 = new Uint8Array(t2).slice(e2, e2 + s2);
        e2 += s2;
        const o2 = [];
        for (let i3 = 0; i3 < n2; e2++, i3++) {
          let a3 = t2.getUint8(e2);
          if (o2.push(a3), 8 & a3) {
            const n3 = t2.getUint8(++e2);
            a3 ^= 8;
            for (let e3 = 0; e3 < n3; e3++)
              o2.push(a3);
            i3 += n3;
          }
        }
        const l3 = [];
        let c2 = [], h2 = [], d2 = [];
        const u2 = [];
        let g2 = 0, p2 = 0;
        for (let i3 = 0; i3 < n2; i3++) {
          const n3 = o2[i3];
          if (2 & n3) {
            const i4 = t2.getUint8(e2++);
            p2 += 16 & n3 ? i4 : -i4, c2.push(p2);
          } else
            16 & n3 || (p2 += t2.getInt16(e2), e2 += 2), c2.push(p2);
          a2[g2] === i3 && (g2++, l3.push(c2), c2 = []);
        }
        p2 = 0, g2 = 0;
        for (let i3 = 0; i3 < n2; i3++) {
          const n3 = o2[i3];
          if (4 & n3) {
            const i4 = t2.getUint8(e2++);
            p2 += 32 & n3 ? i4 : -i4, h2.push(p2);
          } else
            32 & n3 || (p2 += t2.getInt16(e2), e2 += 2), h2.push(p2);
          d2.push(1 & n3 | 64 & n3), a2[g2] === i3 && (c2 = l3[g2], g2++, u2.push(new Contour({ flags: d2, xCoordinates: c2, yCoordinates: h2 })), h2 = [], d2 = []);
        }
        return new SimpleGlyph({ contours: u2, instructions: r2 });
      }
      getSize() {
        let e2 = 2 * this.contours.length + 2 + this.instructions.length, t2 = 0, i2 = 0;
        for (const a2 of this.contours) {
          e2 += a2.flags.length;
          for (let n2 = 0, s2 = a2.xCoordinates.length; n2 < s2; n2++) {
            const s3 = a2.xCoordinates[n2], r2 = a2.yCoordinates[n2];
            let o2 = Math.abs(s3 - t2);
            o2 > 255 ? e2 += 2 : o2 > 0 && (e2 += 1), t2 = s3, o2 = Math.abs(r2 - i2), o2 > 255 ? e2 += 2 : o2 > 0 && (e2 += 1), i2 = r2;
          }
        }
        return e2;
      }
      write(e2, t2) {
        const i2 = e2, a2 = [], n2 = [], s2 = [];
        let r2 = 0, o2 = 0;
        for (const i3 of this.contours) {
          for (let e3 = 0, t3 = i3.xCoordinates.length; e3 < t3; e3++) {
            let t4 = i3.flags[e3];
            const l3 = i3.xCoordinates[e3];
            let c2 = l3 - r2;
            if (0 === c2)
              t4 |= 16, a2.push(0);
            else {
              const e4 = Math.abs(c2);
              e4 <= 255 ? (t4 |= c2 >= 0 ? 18 : 2, a2.push(e4)) : a2.push(c2);
            }
            r2 = l3;
            const h2 = i3.yCoordinates[e3];
            if (c2 = h2 - o2, 0 === c2)
              t4 |= 32, n2.push(0);
            else {
              const e4 = Math.abs(c2);
              e4 <= 255 ? (t4 |= c2 >= 0 ? 36 : 4, n2.push(e4)) : n2.push(c2);
            }
            o2 = h2, s2.push(t4);
          }
          t2.setUint16(e2, a2.length - 1), e2 += 2;
        }
        t2.setUint16(e2, this.instructions.length), e2 += 2, this.instructions.length && (new Uint8Array(t2.buffer, 0, t2.buffer.byteLength).set(this.instructions, e2), e2 += this.instructions.length);
        for (const i3 of s2)
          t2.setUint8(e2++, i3);
        for (let i3 = 0, n3 = a2.length; i3 < n3; i3++) {
          const n4 = a2[i3], r3 = s2[i3];
          2 & r3 ? t2.setUint8(e2++, n4) : 16 & r3 || (t2.setInt16(e2, n4), e2 += 2);
        }
        for (let i3 = 0, a3 = n2.length; i3 < a3; i3++) {
          const a4 = n2[i3], r3 = s2[i3];
          4 & r3 ? t2.setUint8(e2++, a4) : 32 & r3 || (t2.setInt16(e2, a4), e2 += 2);
        }
        return e2 - i2;
      }
      scale(e2, t2) {
        for (const i2 of this.contours)
          if (0 !== i2.xCoordinates.length)
            for (let a2 = 0, n2 = i2.xCoordinates.length; a2 < n2; a2++)
              i2.xCoordinates[a2] = Math.round(e2 + (i2.xCoordinates[a2] - e2) * t2);
      }
    };
    __name(SimpleGlyph, "SimpleGlyph");
    CompositeGlyph = class {
      constructor({ flags: e2, glyphIndex: t2, argument1: i2, argument2: a2, transf: n2, instructions: s2 }) {
        this.flags = e2, this.glyphIndex = t2, this.argument1 = i2, this.argument2 = a2, this.transf = n2, this.instructions = s2;
      }
      static parse(e2, t2) {
        const i2 = e2, a2 = [];
        let n2 = t2.getUint16(e2);
        const s2 = t2.getUint16(e2 + 2);
        let r2, o2;
        e2 += 4, 1 & n2 ? (2 & n2 ? (r2 = t2.getInt16(e2), o2 = t2.getInt16(e2 + 2)) : (r2 = t2.getUint16(e2), o2 = t2.getUint16(e2 + 2)), e2 += 4, n2 ^= 1) : (2 & n2 ? (r2 = t2.getInt8(e2), o2 = t2.getInt8(e2 + 1)) : (r2 = t2.getUint8(e2), o2 = t2.getUint8(e2 + 1)), e2 += 2), 8 & n2 ? (a2.push(t2.getUint16(e2)), e2 += 2) : 64 & n2 ? (a2.push(t2.getUint16(e2), t2.getUint16(e2 + 2)), e2 += 4) : 128 & n2 && (a2.push(t2.getUint16(e2), t2.getUint16(e2 + 2), t2.getUint16(e2 + 4), t2.getUint16(e2 + 6)), e2 += 8);
        let l3 = null;
        if (256 & n2) {
          const i3 = t2.getUint16(e2);
          e2 += 2, l3 = new Uint8Array(t2).slice(e2, e2 + i3), e2 += i3;
        }
        return [e2 - i2, new CompositeGlyph({ flags: n2, glyphIndex: s2, argument1: r2, argument2: o2, transf: a2, instructions: l3 })];
      }
      getSize() {
        let e2 = 4 + 2 * this.transf.length;
        return 256 & this.flags && (e2 += 2 + this.instructions.length), e2 += 2, 2 & this.flags ? this.argument1 >= -128 && this.argument1 <= 127 && this.argument2 >= -128 && this.argument2 <= 127 || (e2 += 2) : this.argument1 >= 0 && this.argument1 <= 255 && this.argument2 >= 0 && this.argument2 <= 255 || (e2 += 2), e2;
      }
      write(e2, t2) {
        const i2 = e2;
        return 2 & this.flags ? this.argument1 >= -128 && this.argument1 <= 127 && this.argument2 >= -128 && this.argument2 <= 127 || (this.flags |= 1) : this.argument1 >= 0 && this.argument1 <= 255 && this.argument2 >= 0 && this.argument2 <= 255 || (this.flags |= 1), t2.setUint16(e2, this.flags), t2.setUint16(e2 + 2, this.glyphIndex), e2 += 4, 1 & this.flags ? (2 & this.flags ? (t2.setInt16(e2, this.argument1), t2.setInt16(e2 + 2, this.argument2)) : (t2.setUint16(e2, this.argument1), t2.setUint16(e2 + 2, this.argument2)), e2 += 4) : (t2.setUint8(e2, this.argument1), t2.setUint8(e2 + 1, this.argument2), e2 += 2), 256 & this.flags && (t2.setUint16(e2, this.instructions.length), e2 += 2, this.instructions.length && (new Uint8Array(t2.buffer, 0, t2.buffer.byteLength).set(this.instructions, e2), e2 += this.instructions.length)), e2 - i2;
      }
      scale(e2, t2) {
      }
    };
    __name(CompositeGlyph, "CompositeGlyph");
    __name(writeInt16, "writeInt16");
    __name(writeInt32, "writeInt32");
    __name(writeData, "writeData");
    OpenTypeFileBuilder = class {
      constructor(e2) {
        this.sfnt = e2, this.tables = /* @__PURE__ */ Object.create(null);
      }
      static getSearchParams(e2, t2) {
        let i2 = 1, a2 = 0;
        for (; (i2 ^ e2) > i2; )
          i2 <<= 1, a2++;
        const n2 = i2 * t2;
        return { range: n2, entry: a2, rangeShift: t2 * e2 - n2 };
      }
      toArray() {
        let e2 = this.sfnt;
        const t2 = this.tables, i2 = Object.keys(t2);
        i2.sort();
        const a2 = i2.length;
        let n2, s2, r2, o2, l3, c2 = 12 + 16 * a2;
        const h2 = [c2];
        for (n2 = 0; n2 < a2; n2++) {
          o2 = t2[i2[n2]];
          c2 += (o2.length + 3 & -4) >>> 0, h2.push(c2);
        }
        const d2 = new Uint8Array(c2);
        for (n2 = 0; n2 < a2; n2++)
          o2 = t2[i2[n2]], writeData(d2, h2[n2], o2);
        "true" === e2 && (e2 = string32$1(65536)), d2[0] = 255 & e2.charCodeAt(0), d2[1] = 255 & e2.charCodeAt(1), d2[2] = 255 & e2.charCodeAt(2), d2[3] = 255 & e2.charCodeAt(3), writeInt16(d2, 4, a2);
        const u2 = OpenTypeFileBuilder.getSearchParams(a2, 16);
        for (writeInt16(d2, 6, u2.range), writeInt16(d2, 8, u2.entry), writeInt16(d2, 10, u2.rangeShift), c2 = 12, n2 = 0; n2 < a2; n2++) {
          l3 = i2[n2], d2[c2] = 255 & l3.charCodeAt(0), d2[c2 + 1] = 255 & l3.charCodeAt(1), d2[c2 + 2] = 255 & l3.charCodeAt(2), d2[c2 + 3] = 255 & l3.charCodeAt(3);
          let e3 = 0;
          for (s2 = h2[n2], r2 = h2[n2 + 1]; s2 < r2; s2 += 4) {
            e3 = e3 + readUint32(d2, s2) >>> 0;
          }
          writeInt32(d2, c2 + 4, e3), writeInt32(d2, c2 + 8, h2[n2]), writeInt32(d2, c2 + 12, t2[l3].length), c2 += 16;
        }
        return d2;
      }
      addTable(e2, t2) {
        if (e2 in this.tables)
          throw new Error("Table " + e2 + " already exists");
        this.tables[e2] = t2;
      }
    };
    __name(OpenTypeFileBuilder, "OpenTypeFileBuilder");
    Va = [4];
    Ka = [5];
    Ya = [6];
    Ja = [7];
    Za = [8];
    Qa = [12, 35];
    en = [14];
    tn = [21];
    an = [22];
    nn = [30];
    sn = [31];
    Type1CharString = class {
      constructor() {
        this.width = 0, this.lsb = 0, this.flexing = false, this.output = [], this.stack = [];
      }
      convert(e2, t2, i2) {
        const a2 = e2.length;
        let n2, s2, r2, o2 = false;
        for (let l3 = 0; l3 < a2; l3++) {
          let a3 = e2[l3];
          if (a3 < 32) {
            switch (12 === a3 && (a3 = (a3 << 8) + e2[++l3]), a3) {
              case 1:
              case 3:
              case 9:
              case 3072:
              case 3073:
              case 3074:
              case 3105:
                this.stack = [];
                break;
              case 4:
                if (this.flexing) {
                  if (this.stack.length < 1) {
                    o2 = true;
                    break;
                  }
                  const e4 = this.stack.pop();
                  this.stack.push(0, e4);
                  break;
                }
                o2 = this.executeCommand(1, Va);
                break;
              case 5:
                o2 = this.executeCommand(2, Ka);
                break;
              case 6:
                o2 = this.executeCommand(1, Ya);
                break;
              case 7:
                o2 = this.executeCommand(1, Ja);
                break;
              case 8:
                o2 = this.executeCommand(6, Za);
                break;
              case 10:
                if (this.stack.length < 1) {
                  o2 = true;
                  break;
                }
                if (r2 = this.stack.pop(), !t2[r2]) {
                  o2 = true;
                  break;
                }
                o2 = this.convert(t2[r2], t2, i2);
                break;
              case 11:
                return o2;
              case 13:
                if (this.stack.length < 2) {
                  o2 = true;
                  break;
                }
                n2 = this.stack.pop(), s2 = this.stack.pop(), this.lsb = s2, this.width = n2, this.stack.push(n2, s2), o2 = this.executeCommand(2, an);
                break;
              case 14:
                this.output.push(en[0]);
                break;
              case 21:
                if (this.flexing)
                  break;
                o2 = this.executeCommand(2, tn);
                break;
              case 22:
                if (this.flexing) {
                  this.stack.push(0);
                  break;
                }
                o2 = this.executeCommand(1, an);
                break;
              case 30:
                o2 = this.executeCommand(4, nn);
                break;
              case 31:
                o2 = this.executeCommand(4, sn);
                break;
              case 3078:
                if (i2) {
                  const e4 = this.stack.at(-5);
                  this.seac = this.stack.splice(-4, 4), this.seac[0] += this.lsb - e4, o2 = this.executeCommand(0, en);
                } else
                  o2 = this.executeCommand(4, en);
                break;
              case 3079:
                if (this.stack.length < 4) {
                  o2 = true;
                  break;
                }
                this.stack.pop(), n2 = this.stack.pop();
                const e3 = this.stack.pop();
                s2 = this.stack.pop(), this.lsb = s2, this.width = n2, this.stack.push(n2, s2, e3), o2 = this.executeCommand(3, tn);
                break;
              case 3084:
                if (this.stack.length < 2) {
                  o2 = true;
                  break;
                }
                const l4 = this.stack.pop(), c2 = this.stack.pop();
                this.stack.push(c2 / l4);
                break;
              case 3088:
                if (this.stack.length < 2) {
                  o2 = true;
                  break;
                }
                r2 = this.stack.pop();
                const h2 = this.stack.pop();
                if (0 === r2 && 3 === h2) {
                  const e4 = this.stack.splice(-17, 17);
                  this.stack.push(e4[2] + e4[0], e4[3] + e4[1], e4[4], e4[5], e4[6], e4[7], e4[8], e4[9], e4[10], e4[11], e4[12], e4[13], e4[14]), o2 = this.executeCommand(13, Qa, true), this.flexing = false, this.stack.push(e4[15], e4[16]);
                } else
                  1 === r2 && 0 === h2 && (this.flexing = true);
                break;
              case 3089:
                break;
              default:
                warn$1('Unknown type 1 charstring command of "' + a3 + '"');
            }
            if (o2)
              break;
          } else
            a3 <= 246 ? a3 -= 139 : a3 = a3 <= 250 ? 256 * (a3 - 247) + e2[++l3] + 108 : a3 <= 254 ? -256 * (a3 - 251) - e2[++l3] - 108 : (255 & e2[++l3]) << 24 | (255 & e2[++l3]) << 16 | (255 & e2[++l3]) << 8 | 255 & e2[++l3], this.stack.push(a3);
        }
        return o2;
      }
      executeCommand(e2, t2, i2) {
        const a2 = this.stack.length;
        if (e2 > a2)
          return true;
        const n2 = a2 - e2;
        for (let e3 = n2; e3 < a2; e3++) {
          let t3 = this.stack[e3];
          Number.isInteger(t3) ? this.output.push(28, t3 >> 8 & 255, 255 & t3) : (t3 = 65536 * t3 | 0, this.output.push(255, t3 >> 24 & 255, t3 >> 16 & 255, t3 >> 8 & 255, 255 & t3));
        }
        return this.output.push(...t2), i2 ? this.stack.splice(n2, e2) : this.stack.length = 0, false;
      }
    };
    __name(Type1CharString, "Type1CharString");
    __name(isHexDigit, "isHexDigit");
    __name(decrypt, "decrypt");
    __name(isSpecial, "isSpecial");
    Type1Parser = class {
      constructor(e2, t2, i2) {
        if (t2) {
          const t3 = e2.getBytes(), i3 = !((isHexDigit(t3[0]) || isWhiteSpace(t3[0])) && isHexDigit(t3[1]) && isHexDigit(t3[2]) && isHexDigit(t3[3]) && isHexDigit(t3[4]) && isHexDigit(t3[5]) && isHexDigit(t3[6]) && isHexDigit(t3[7]));
          e2 = new Stream(i3 ? decrypt(t3, 55665, 4) : function(e3, t4, i4) {
            let a2 = 0 | t4;
            const n2 = e3.length, s2 = new Uint8Array(n2 >>> 1);
            let r2, o2;
            for (r2 = 0, o2 = 0; r2 < n2; r2++) {
              const t5 = e3[r2];
              if (!isHexDigit(t5))
                continue;
              let i5;
              for (r2++; r2 < n2 && !isHexDigit(i5 = e3[r2]); )
                r2++;
              if (r2 < n2) {
                const e4 = parseInt(String.fromCharCode(t5, i5), 16);
                s2[o2++] = e4 ^ a2 >> 8, a2 = 52845 * (e4 + a2) + 22719 & 65535;
              }
            }
            return s2.slice(i4, o2);
          }(t3, 55665, 4));
        }
        this.seacAnalysisEnabled = !!i2, this.stream = e2, this.nextChar();
      }
      readNumberArray() {
        this.getToken();
        const e2 = [];
        for (; ; ) {
          const t2 = this.getToken();
          if (null === t2 || "]" === t2 || "}" === t2)
            break;
          e2.push(parseFloat(t2 || 0));
        }
        return e2;
      }
      readNumber() {
        const e2 = this.getToken();
        return parseFloat(e2 || 0);
      }
      readInt() {
        const e2 = this.getToken();
        return 0 | parseInt(e2 || 0, 10);
      }
      readBoolean() {
        return "true" === this.getToken() ? 1 : 0;
      }
      nextChar() {
        return this.currentChar = this.stream.getByte();
      }
      prevChar() {
        return this.stream.skip(-2), this.currentChar = this.stream.getByte();
      }
      getToken() {
        let e2 = false, t2 = this.currentChar;
        for (; ; ) {
          if (-1 === t2)
            return null;
          if (e2)
            10 !== t2 && 13 !== t2 || (e2 = false);
          else if (37 === t2)
            e2 = true;
          else if (!isWhiteSpace(t2))
            break;
          t2 = this.nextChar();
        }
        if (isSpecial(t2))
          return this.nextChar(), String.fromCharCode(t2);
        let i2 = "";
        do {
          i2 += String.fromCharCode(t2), t2 = this.nextChar();
        } while (t2 >= 0 && !isWhiteSpace(t2) && !isSpecial(t2));
        return i2;
      }
      readCharStrings(e2, t2) {
        return -1 === t2 ? e2 : decrypt(e2, 4330, t2);
      }
      extractFontProgram(e2) {
        const t2 = this.stream, i2 = [], a2 = [], n2 = /* @__PURE__ */ Object.create(null);
        n2.lenIV = 4;
        const s2 = { subrs: [], charstrings: [], properties: { privateData: n2 } };
        let r2, o2, l3, c2;
        for (; null !== (r2 = this.getToken()); )
          if ("/" === r2)
            switch (r2 = this.getToken(), r2) {
              case "CharStrings":
                for (this.getToken(), this.getToken(), this.getToken(), this.getToken(); r2 = this.getToken(), null !== r2 && "end" !== r2; ) {
                  if ("/" !== r2)
                    continue;
                  const e4 = this.getToken();
                  o2 = this.readInt(), this.getToken(), l3 = o2 > 0 ? t2.getBytes(o2) : new Uint8Array(0), c2 = s2.properties.privateData.lenIV;
                  const i3 = this.readCharStrings(l3, c2);
                  this.nextChar(), r2 = this.getToken(), "noaccess" === r2 ? this.getToken() : "/" === r2 && this.prevChar(), a2.push({ glyph: e4, encoded: i3 });
                }
                break;
              case "Subrs":
                for (this.readInt(), this.getToken(); "dup" === this.getToken(); ) {
                  const e4 = this.readInt();
                  o2 = this.readInt(), this.getToken(), l3 = o2 > 0 ? t2.getBytes(o2) : new Uint8Array(0), c2 = s2.properties.privateData.lenIV;
                  const a3 = this.readCharStrings(l3, c2);
                  this.nextChar(), r2 = this.getToken(), "noaccess" === r2 && this.getToken(), i2[e4] = a3;
                }
                break;
              case "BlueValues":
              case "OtherBlues":
              case "FamilyBlues":
              case "FamilyOtherBlues":
                const e3 = this.readNumberArray();
                e3.length > 0 && e3.length, 0;
                break;
              case "StemSnapH":
              case "StemSnapV":
                s2.properties.privateData[r2] = this.readNumberArray();
                break;
              case "StdHW":
              case "StdVW":
                s2.properties.privateData[r2] = this.readNumberArray()[0];
                break;
              case "BlueShift":
              case "lenIV":
              case "BlueFuzz":
              case "BlueScale":
              case "LanguageGroup":
                s2.properties.privateData[r2] = this.readNumber();
                break;
              case "ExpansionFactor":
                s2.properties.privateData[r2] = this.readNumber() || 0.06;
                break;
              case "ForceBold":
                s2.properties.privateData[r2] = this.readBoolean();
            }
        for (const { encoded: t3, glyph: n3 } of a2) {
          const a3 = new Type1CharString(), r3 = a3.convert(t3, i2, this.seacAnalysisEnabled);
          let o3 = a3.output;
          r3 && (o3 = [14]);
          const l4 = { glyphName: n3, charstring: o3, width: a3.width, lsb: a3.lsb, seac: a3.seac };
          if (".notdef" === n3 ? s2.charstrings.unshift(l4) : s2.charstrings.push(l4), e2.builtInEncoding) {
            const t4 = e2.builtInEncoding.indexOf(n3);
            t4 > -1 && void 0 === e2.widths[t4] && t4 >= e2.firstChar && t4 <= e2.lastChar && (e2.widths[t4] = a3.width);
          }
        }
        return s2;
      }
      extractFontHeader(e2) {
        let t2;
        for (; null !== (t2 = this.getToken()); )
          if ("/" === t2)
            switch (t2 = this.getToken(), t2) {
              case "FontMatrix":
                const i2 = this.readNumberArray();
                e2.fontMatrix = i2;
                break;
              case "Encoding":
                const a2 = this.getToken();
                let n2;
                if (/^\d+$/.test(a2)) {
                  n2 = [];
                  const e3 = 0 | parseInt(a2, 10);
                  this.getToken();
                  for (let i3 = 0; i3 < e3; i3++) {
                    for (t2 = this.getToken(); "dup" !== t2 && "def" !== t2; )
                      if (t2 = this.getToken(), null === t2)
                        return;
                    if ("def" === t2)
                      break;
                    const e4 = this.readInt();
                    this.getToken();
                    const i4 = this.getToken();
                    n2[e4] = i4, this.getToken();
                  }
                } else
                  n2 = getEncoding(a2);
                e2.builtInEncoding = n2;
                break;
              case "FontBBox":
                const s2 = this.readNumberArray();
                e2.ascent = Math.max(s2[3], s2[1]), e2.descent = Math.min(s2[1], s2[3]), e2.ascentScaled = true;
            }
      }
    };
    __name(Type1Parser, "Type1Parser");
    __name(findBlock, "findBlock");
    Type1Font = class {
      constructor(e2, t2, i2) {
        let a2 = i2.length1;
        i2.length2;
        let n2 = t2.peekBytes(6);
        const s2 = 128 === n2[0] && 1 === n2[1];
        s2 && (t2.skip(6), a2 = n2[5] << 24 | n2[4] << 16 | n2[3] << 8 | n2[2]);
        const r2 = function(e3, t3) {
          const i3 = [101, 101, 120, 101, 99], a3 = e3.pos;
          let n3, s3, r3, o3;
          try {
            n3 = e3.getBytes(t3), s3 = n3.length;
          } catch {
          }
          if (s3 === t3 && (r3 = findBlock(n3, i3, t3 - 2 * i3.length), r3.found && r3.length === t3))
            return { stream: new Stream(n3), length: t3 };
          for (warn$1('Invalid "Length1" property in Type1 font -- trying to recover.'), e3.pos = a3; r3 = findBlock(e3.peekBytes(2048), i3, 0), 0 !== r3.length; )
            if (e3.pos += r3.length, r3.found) {
              o3 = e3.pos - a3;
              break;
            }
          return e3.pos = a3, o3 ? { stream: new Stream(e3.getBytes(o3)), length: o3 } : (warn$1('Unable to recover "Length1" property in Type1 font -- using as is.'), { stream: new Stream(e3.getBytes(t3)), length: t3 });
        }(t2, a2);
        new Type1Parser(r2.stream, false, xa).extractFontHeader(i2), s2 && (n2 = t2.getBytes(6), n2[5], n2[4], n2[3], n2[2]);
        const o2 = function(e3) {
          const t3 = e3.getBytes();
          if (0 === t3.length)
            throw new ti("getEexecBlock - no font program found.");
          return { stream: new Stream(t3), length: t3.length };
        }(t2), l3 = new Type1Parser(o2.stream, true, xa).extractFontProgram(i2);
        for (const e3 in l3.properties)
          i2[e3] = l3.properties[e3];
        const c2 = l3.charstrings, h2 = this.getType2Charstrings(c2), d2 = this.getType2Subrs(l3.subrs);
        this.charstrings = c2, this.data = this.wrap(e2, h2, this.charstrings, d2, i2), this.seacs = this.getSeacs(l3.charstrings);
      }
      get numGlyphs() {
        return this.charstrings.length + 1;
      }
      getCharset() {
        const e2 = [".notdef"];
        for (const { glyphName: t2 } of this.charstrings)
          e2.push(t2);
        return e2;
      }
      getGlyphMapping(e2) {
        const t2 = this.charstrings;
        if (e2.composite) {
          const i3 = /* @__PURE__ */ Object.create(null);
          for (let a3 = 0, n3 = t2.length; a3 < n3; a3++) {
            i3[e2.cMap.charCodeOf(a3)] = a3 + 1;
          }
          return i3;
        }
        const i2 = [".notdef"];
        let a2, n2;
        for (n2 = 0; n2 < t2.length; n2++)
          i2.push(t2[n2].glyphName);
        const s2 = e2.builtInEncoding;
        if (s2) {
          a2 = /* @__PURE__ */ Object.create(null);
          for (const e3 in s2)
            n2 = i2.indexOf(s2[e3]), n2 >= 0 && (a2[e3] = n2);
        }
        return type1FontGlyphMapping(e2, a2, i2);
      }
      hasGlyphId(e2) {
        if (e2 < 0 || e2 >= this.numGlyphs)
          return false;
        if (0 === e2)
          return true;
        return this.charstrings[e2 - 1].charstring.length > 0;
      }
      getSeacs(e2) {
        const t2 = [];
        for (let i2 = 0, a2 = e2.length; i2 < a2; i2++) {
          const a3 = e2[i2];
          a3.seac && (t2[i2 + 1] = a3.seac);
        }
        return t2;
      }
      getType2Charstrings(e2) {
        const t2 = [];
        for (const i2 of e2)
          t2.push(i2.charstring);
        return t2;
      }
      getType2Subrs(e2) {
        let t2 = 0;
        const i2 = e2.length;
        t2 = i2 < 1133 ? 107 : i2 < 33769 ? 1131 : 32768;
        const a2 = [];
        let n2;
        for (n2 = 0; n2 < t2; n2++)
          a2.push([11]);
        for (n2 = 0; n2 < i2; n2++)
          a2.push(e2[n2]);
        return a2;
      }
      wrap(e2, t2, i2, a2, n2) {
        const s2 = new CFF();
        s2.header = new CFFHeader(1, 0, 4, 4), s2.names = [e2];
        const r2 = new CFFTopDict();
        r2.setByName("version", 391), r2.setByName("Notice", 392), r2.setByName("FullName", 393), r2.setByName("FamilyName", 394), r2.setByName("Weight", 395), r2.setByName("Encoding", null), r2.setByName("FontMatrix", n2.fontMatrix), r2.setByName("FontBBox", n2.bbox), r2.setByName("charset", null), r2.setByName("CharStrings", null), r2.setByName("Private", null), s2.topDict = r2;
        const o2 = new CFFStrings();
        o2.add("Version 0.11"), o2.add("See original notice"), o2.add(e2), o2.add(e2), o2.add("Medium"), s2.strings = o2, s2.globalSubrIndex = new CFFIndex();
        const l3 = t2.length, c2 = [".notdef"];
        let h2, d2;
        for (h2 = 0; h2 < l3; h2++) {
          const e3 = i2[h2].glyphName;
          -1 === Ea.indexOf(e3) && o2.add(e3), c2.push(e3);
        }
        s2.charset = new CFFCharset(false, 0, c2);
        const u2 = new CFFIndex();
        for (u2.add([139, 14]), h2 = 0; h2 < l3; h2++)
          u2.add(t2[h2]);
        s2.charStrings = u2;
        const g2 = new CFFPrivateDict();
        g2.setByName("Subrs", null);
        const p2 = ["BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StemSnapH", "StemSnapV", "BlueShift", "BlueFuzz", "BlueScale", "LanguageGroup", "ExpansionFactor", "ForceBold", "StdHW", "StdVW"];
        for (h2 = 0, d2 = p2.length; h2 < d2; h2++) {
          const e3 = p2[h2];
          if (!(e3 in n2.privateData))
            continue;
          const t3 = n2.privateData[e3];
          if (Array.isArray(t3))
            for (let e4 = t3.length - 1; e4 > 0; e4--)
              t3[e4] -= t3[e4 - 1];
          g2.setByName(e3, t3);
        }
        s2.topDict.privateDict = g2;
        const f2 = new CFFIndex();
        for (h2 = 0, d2 = a2.length; h2 < d2; h2++)
          f2.add(a2[h2]);
        g2.subrsIndex = f2;
        return new CFFCompiler(s2).compile();
      }
    };
    __name(Type1Font, "Type1Font");
    rn = [[57344, 63743], [1048576, 1114109]];
    on2 = 1e3;
    ln = ["ascent", "bbox", "black", "bold", "charProcOperatorList", "cssFontInfo", "data", "defaultVMetrics", "defaultWidth", "descent", "disableFontFace", "fallbackName", "fontExtraProperties", "fontMatrix", "isInvalidPDFjsFont", "isType3Font", "italic", "loadedName", "mimetype", "missingFile", "name", "remeasure", "systemFontInfo", "vertical"];
    cn = ["cMap", "composite", "defaultEncoding", "differences", "isMonospace", "isSerifFont", "isSymbolicFont", "seacMap", "subtype", "toFontChar", "toUnicode", "type", "vmetrics", "widths"];
    __name(adjustWidths, "adjustWidths");
    __name(amendFallbackToUnicode, "amendFallbackToUnicode");
    fonts_Glyph = class {
      constructor(e2, t2, i2, a2, n2, s2, r2, o2, l3) {
        this.originalCharCode = e2, this.fontChar = t2, this.unicode = i2, this.accent = a2, this.width = n2, this.vmetric = s2, this.operatorListId = r2, this.isSpace = o2, this.isInFont = l3;
      }
      get category() {
        return shadow$1(this, "category", function(e2) {
          const t2 = Aa.get(e2);
          if (t2)
            return t2;
          const i2 = e2.match(wa), a2 = { isWhitespace: !!i2?.[1], isZeroWidthDiacritic: !!i2?.[2], isInvisibleFormatMark: !!i2?.[3] };
          return Aa.set(e2, a2), a2;
        }(this.unicode), true);
      }
    };
    __name(fonts_Glyph, "fonts_Glyph");
    __name(int16, "int16");
    __name(writeSignedInt16, "writeSignedInt16");
    __name(signedInt16, "signedInt16");
    __name(string16, "string16");
    __name(safeString16, "safeString16");
    __name(isTrueTypeCollectionFile, "isTrueTypeCollectionFile");
    __name(getFontFileType, "getFontFileType");
    __name(applyStandardFontGlyphMap, "applyStandardFontGlyphMap");
    __name(buildToFontChar, "buildToFontChar");
    __name(isMacNameRecord, "isMacNameRecord");
    __name(isWinNameRecord, "isWinNameRecord");
    __name(convertCidString, "convertCidString");
    __name(adjustMapping, "adjustMapping");
    __name(createCmapTable, "createCmapTable");
    __name(createOS2Table, "createOS2Table");
    __name(createPostTable, "createPostTable");
    __name(createPostscriptName, "createPostscriptName");
    __name(createNameTable, "createNameTable");
    Font = class {
      constructor(e2, t2, i2, a2) {
        this.name = e2, this.psName = null, this.mimetype = null, this.disableFontFace = a2.disableFontFace, this.fontExtraProperties = a2.fontExtraProperties, this.loadedName = i2.loadedName, this.isType3Font = i2.isType3Font, this.missingFile = false, this.cssFontInfo = i2.cssFontInfo, this._charsCache = /* @__PURE__ */ Object.create(null), this._glyphCache = /* @__PURE__ */ Object.create(null);
        let n2 = !!(i2.flags & va);
        if (!n2 && !i2.isSimulatedFlags) {
          const t3 = e2.replaceAll(/[,_]/g, "-").split("-", 1)[0], i3 = $a();
          for (const e3 of t3.split("+"))
            if (i3[e3]) {
              n2 = true;
              break;
            }
        }
        this.isSerifFont = n2, this.isSymbolicFont = !!(i2.flags & Ca), this.isMonospace = !!(i2.flags & Sa);
        let { type: s2, subtype: r2 } = i2;
        this.type = s2, this.subtype = r2, this.systemFontInfo = i2.systemFontInfo;
        const o2 = e2.match(/^InvalidPDFjsFont_(.*)_\d+$/);
        if (this.isInvalidPDFjsFont = !!o2, this.isInvalidPDFjsFont ? this.fallbackName = o2[1] : this.isMonospace ? this.fallbackName = "monospace" : this.isSerifFont ? this.fallbackName = "serif" : this.fallbackName = "sans-serif", this.systemFontInfo?.guessFallback && (this.systemFontInfo.guessFallback = false, this.systemFontInfo.css += `,${this.fallbackName}`), this.differences = i2.differences, this.widths = i2.widths, this.defaultWidth = i2.defaultWidth, this.composite = i2.composite, this.cMap = i2.cMap, this.capHeight = i2.capHeight / on2, this.ascent = i2.ascent / on2, this.descent = i2.descent / on2, this.lineHeight = this.ascent - this.descent, this.fontMatrix = i2.fontMatrix, this.bbox = i2.bbox, this.defaultEncoding = i2.defaultEncoding, this.toUnicode = i2.toUnicode, this.toFontChar = [], "Type3" === i2.type) {
          for (let e3 = 0; e3 < 256; e3++)
            this.toFontChar[e3] = this.differences[e3] || i2.defaultEncoding[e3];
          return;
        }
        if (this.cidEncoding = i2.cidEncoding || "", this.vertical = !!i2.vertical, this.vertical && (this.vmetrics = i2.vmetrics, this.defaultVMetrics = i2.defaultVMetrics), !t2 || t2.isEmpty)
          return t2 && warn$1('Font file is empty in "' + e2 + '" (' + this.loadedName + ")"), void this.fallbackToSystemFont(i2);
        let l3;
        [s2, r2] = getFontFileType(t2, i2), s2 === this.type && r2 === this.subtype || info$1(`Inconsistent font file Type/SubType, expected: ${this.type}/${this.subtype} but found: ${s2}/${r2}.`);
        try {
          switch (s2) {
            case "MMType1":
              info$1("MMType1 font (" + e2 + "), falling back to Type1.");
            case "Type1":
            case "CIDFontType0":
              this.mimetype = "font/opentype";
              const a3 = "Type1C" === r2 || "CIDFontType0C" === r2 ? new CFFFont(t2, i2) : new Type1Font(e2, t2, i2);
              adjustWidths(i2), l3 = this.convert(e2, a3, i2);
              break;
            case "OpenType":
            case "TrueType":
            case "CIDFontType2":
              this.mimetype = "font/opentype", l3 = this.checkAndRepair(e2, t2, i2), adjustWidths(i2), this.isOpenType && (s2 = "OpenType");
              break;
            default:
              throw new ti(`Font ${s2} is not supported`);
          }
        } catch (e3) {
          return warn$1(e3), void this.fallbackToSystemFont(i2);
        }
        amendFallbackToUnicode(i2), this.data = l3, this.type = s2, this.subtype = r2, this.fontMatrix = i2.fontMatrix, this.widths = i2.widths, this.defaultWidth = i2.defaultWidth, this.toUnicode = i2.toUnicode, this.seacMap = i2.seacMap;
      }
      get renderer() {
        return shadow$1(this, "renderer", FontRendererFactory.create(this, xa));
      }
      exportData() {
        const e2 = this.fontExtraProperties ? [...ln, ...cn] : ln, t2 = /* @__PURE__ */ Object.create(null);
        for (const i2 of e2) {
          const e3 = this[i2];
          void 0 !== e3 && (t2[i2] = e3);
        }
        return t2;
      }
      fallbackToSystemFont(e2) {
        this.missingFile = true;
        const { name: t2, type: i2 } = this;
        let a2 = normalizeFontName(t2);
        const n2 = La(), s2 = ja(), r2 = !!n2[a2], o2 = !(!s2[a2] || !n2[s2[a2]]);
        a2 = n2[a2] || s2[a2] || a2;
        const l3 = Ga()[a2];
        l3 && (isNaN(this.ascent) && (this.ascent = l3.ascent / on2), isNaN(this.descent) && (this.descent = l3.descent / on2), isNaN(this.capHeight) && (this.capHeight = l3.capHeight / on2)), this.bold = /bold/gi.test(a2), this.italic = /oblique|italic/gi.test(a2), this.black = /Black/g.test(t2);
        const c2 = /Narrow/g.test(t2);
        if (this.remeasure = (!r2 || c2) && Object.keys(this.widths).length > 0, (r2 || o2) && "CIDFontType2" === i2 && this.cidEncoding.startsWith("Identity-")) {
          const i3 = e2.cidToGidMap, a3 = [];
          if (applyStandardFontGlyphMap(a3, qa()), /Arial-?Black/i.test(t2) ? applyStandardFontGlyphMap(a3, Xa()) : /Calibri/i.test(t2) && applyStandardFontGlyphMap(a3, za()), i3) {
            for (const e3 in a3) {
              const t3 = a3[e3];
              void 0 !== i3[t3] && (a3[+e3] = i3[t3]);
            }
            i3.length !== this.toUnicode.length && e2.hasIncludedToUnicodeMap && this.toUnicode instanceof IdentityToUnicodeMap && this.toUnicode.forEach(function(e3, t3) {
              const n3 = a3[e3];
              void 0 === i3[n3] && (a3[+e3] = t3);
            });
          }
          this.toUnicode instanceof IdentityToUnicodeMap || this.toUnicode.forEach(function(e3, t3) {
            a3[+e3] = t3;
          }), this.toFontChar = a3, this.toUnicode = new ToUnicodeMap(a3);
        } else if (/Symbol/i.test(a2))
          this.toFontChar = buildToFontChar(ga, fa(), this.differences);
        else if (/Dingbats/i.test(a2))
          this.toFontChar = buildToFontChar(pa, ma(), this.differences);
        else if (r2 || o2) {
          const e3 = buildToFontChar(this.defaultEncoding, fa(), this.differences);
          "CIDFontType2" !== i2 || this.cidEncoding.startsWith("Identity-") || this.toUnicode instanceof IdentityToUnicodeMap || this.toUnicode.forEach(function(t3, i3) {
            e3[+t3] = i3;
          }), this.toFontChar = e3;
        } else {
          const e3 = fa(), i3 = [];
          this.toUnicode.forEach((t3, a3) => {
            if (!this.composite) {
              const i4 = getUnicodeForGlyph(this.differences[t3] || this.defaultEncoding[t3], e3);
              -1 !== i4 && (a3 = i4);
            }
            i3[+t3] = a3;
          }), this.composite && this.toUnicode instanceof IdentityToUnicodeMap && /Tahoma|Verdana/i.test(t2) && applyStandardFontGlyphMap(i3, qa()), this.toFontChar = i3;
        }
        amendFallbackToUnicode(e2), this.loadedName = a2.split("-", 1)[0];
      }
      checkAndRepair(e2, t2, i2) {
        const a2 = ["OS/2", "cmap", "head", "hhea", "hmtx", "maxp", "name", "post", "loca", "glyf", "fpgm", "prep", "cvt ", "CFF "];
        function readTables(e3, t3) {
          const i3 = /* @__PURE__ */ Object.create(null);
          i3["OS/2"] = null, i3.cmap = null, i3.head = null, i3.hhea = null, i3.hmtx = null, i3.maxp = null, i3.name = null, i3.post = null;
          for (let n3 = 0; n3 < t3; n3++) {
            const t4 = readTableEntry(e3);
            a2.includes(t4.tag) && (0 !== t4.length && (i3[t4.tag] = t4));
          }
          return i3;
        }
        __name(readTables, "readTables");
        function readTableEntry(e3) {
          const t3 = e3.getString(4), i3 = e3.getInt32() >>> 0, a3 = e3.getInt32() >>> 0, n3 = e3.getInt32() >>> 0, s3 = e3.pos;
          e3.pos = e3.start || 0, e3.skip(a3);
          const r3 = e3.getBytes(n3);
          return e3.pos = s3, "head" === t3 && (r3[8] = r3[9] = r3[10] = r3[11] = 0, r3[17] |= 32), { tag: t3, checksum: i3, length: n3, offset: a3, data: r3 };
        }
        __name(readTableEntry, "readTableEntry");
        function readOpenTypeHeader(e3) {
          return { version: e3.getString(4), numTables: e3.getUint16(), searchRange: e3.getUint16(), entrySelector: e3.getUint16(), rangeShift: e3.getUint16() };
        }
        __name(readOpenTypeHeader, "readOpenTypeHeader");
        function sanitizeGlyph(e3, t3, i3, a3, n3, s3) {
          const r3 = { length: 0, sizeOfInstructions: 0 };
          if (t3 < 0 || t3 >= e3.length || i3 > e3.length || i3 - t3 <= 12)
            return r3;
          const o3 = e3.subarray(t3, i3), l4 = signedInt16(o3[2], o3[3]), c3 = signedInt16(o3[4], o3[5]), h3 = signedInt16(o3[6], o3[7]), d3 = signedInt16(o3[8], o3[9]);
          l4 > h3 && (writeSignedInt16(o3, 2, h3), writeSignedInt16(o3, 6, l4)), c3 > d3 && (writeSignedInt16(o3, 4, d3), writeSignedInt16(o3, 8, c3));
          const u3 = signedInt16(o3[0], o3[1]);
          if (u3 < 0)
            return u3 < -1 || (a3.set(o3, n3), r3.length = o3.length), r3;
          let g3, p3 = 10, f3 = 0;
          for (g3 = 0; g3 < u3; g3++) {
            f3 = (o3[p3] << 8 | o3[p3 + 1]) + 1, p3 += 2;
          }
          const m3 = p3, b3 = o3[p3] << 8 | o3[p3 + 1];
          r3.sizeOfInstructions = b3, p3 += 2 + b3;
          const y3 = p3;
          let w3 = 0;
          for (g3 = 0; g3 < f3; g3++) {
            const e4 = o3[p3++];
            192 & e4 && (o3[p3 - 1] = 63 & e4);
            let t4 = 2;
            2 & e4 ? t4 = 1 : 16 & e4 && (t4 = 0);
            let i4 = 2;
            4 & e4 ? i4 = 1 : 32 & e4 && (i4 = 0);
            const a4 = t4 + i4;
            if (w3 += a4, 8 & e4) {
              const e5 = o3[p3++];
              0 === e5 && (o3[p3 - 1] ^= 8), g3 += e5, w3 += e5 * a4;
            }
          }
          if (0 === w3)
            return r3;
          let x3 = p3 + w3;
          return x3 > o3.length ? r3 : !s3 && b3 > 0 ? (a3.set(o3.subarray(0, m3), n3), a3.set([0, 0], n3 + m3), a3.set(o3.subarray(y3, x3), n3 + m3 + 2), x3 -= b3, o3.length - x3 > 3 && (x3 = x3 + 3 & -4), r3.length = x3, r3) : o3.length - x3 > 3 ? (x3 = x3 + 3 & -4, a3.set(o3.subarray(0, x3), n3), r3.length = x3, r3) : (a3.set(o3, n3), r3.length = o3.length, r3);
        }
        __name(sanitizeGlyph, "sanitizeGlyph");
        function readNameTable(e3) {
          const i3 = (t2.start || 0) + e3.offset;
          t2.pos = i3;
          const a3 = [[], []], n3 = [], s3 = e3.length, r3 = i3 + s3;
          if (0 !== t2.getUint16() || s3 < 6)
            return [a3, n3];
          const o3 = t2.getUint16(), l4 = t2.getUint16();
          let c3, h3;
          for (c3 = 0; c3 < o3 && t2.pos + 12 <= r3; c3++) {
            const e4 = { platform: t2.getUint16(), encoding: t2.getUint16(), language: t2.getUint16(), name: t2.getUint16(), length: t2.getUint16(), offset: t2.getUint16() };
            (isMacNameRecord(e4) || isWinNameRecord(e4)) && n3.push(e4);
          }
          for (c3 = 0, h3 = n3.length; c3 < h3; c3++) {
            const e4 = n3[c3];
            if (e4.length <= 0)
              continue;
            const s4 = i3 + l4 + e4.offset;
            if (s4 + e4.length > r3)
              continue;
            t2.pos = s4;
            const o4 = e4.name;
            if (e4.encoding) {
              let i4 = "";
              for (let a4 = 0, n4 = e4.length; a4 < n4; a4 += 2)
                i4 += String.fromCharCode(t2.getUint16());
              a3[1][o4] = i4;
            } else
              a3[0][o4] = t2.getString(e4.length);
          }
          return [a3, n3];
        }
        __name(readNameTable, "readNameTable");
        const n2 = [0, 0, 0, 0, 0, 0, 0, 0, -2, -2, -2, -2, 0, 0, -2, -5, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, -1, -1, 1, -1, -999, 0, 1, 0, -1, -2, 0, -1, -2, -1, -1, 0, -1, -1, 0, 0, -999, -999, -1, -1, -1, -1, -2, -999, -2, -2, -999, 0, -2, -2, 0, 0, -2, 0, -2, 0, 0, 0, -2, -1, -1, 1, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, 0, -999, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2, -999, -999, -999, -999, -999, -1, -1, -2, -2, 0, 0, 0, 0, -1, -1, -999, -2, -2, 0, 0, -1, -2, -2, 0, 0, 0, -1, -1, -1, -2];
        function sanitizeTTProgram(e3, t3) {
          let i3, a3, s3, r3, o3, l4 = e3.data, c3 = 0, h3 = 0, d3 = 0;
          const u3 = [], g3 = [], p3 = [];
          let f3 = t3.tooComplexToFollowFunctions, m3 = false, b3 = 0, y3 = 0;
          for (let e4 = l4.length; c3 < e4; ) {
            const e5 = l4[c3++];
            if (64 === e5)
              if (a3 = l4[c3++], m3 || y3)
                c3 += a3;
              else
                for (i3 = 0; i3 < a3; i3++)
                  u3.push(l4[c3++]);
            else if (65 === e5)
              if (a3 = l4[c3++], m3 || y3)
                c3 += 2 * a3;
              else
                for (i3 = 0; i3 < a3; i3++)
                  s3 = l4[c3++], u3.push(s3 << 8 | l4[c3++]);
            else if (176 == (248 & e5))
              if (a3 = e5 - 176 + 1, m3 || y3)
                c3 += a3;
              else
                for (i3 = 0; i3 < a3; i3++)
                  u3.push(l4[c3++]);
            else if (184 == (248 & e5))
              if (a3 = e5 - 184 + 1, m3 || y3)
                c3 += 2 * a3;
              else
                for (i3 = 0; i3 < a3; i3++)
                  s3 = l4[c3++], u3.push(signedInt16(s3, l4[c3++]));
            else if (43 !== e5 || f3)
              if (44 !== e5 || f3) {
                if (45 === e5)
                  if (m3)
                    m3 = false, h3 = c3;
                  else {
                    if (o3 = g3.pop(), !o3)
                      return warn$1("TT: ENDF bad stack"), void (t3.hintsValid = false);
                    r3 = p3.pop(), l4 = o3.data, c3 = o3.i, t3.functionsStackDeltas[r3] = u3.length - o3.stackTop;
                  }
                else if (137 === e5)
                  (m3 || y3) && (warn$1("TT: nested IDEFs not allowed"), f3 = true), m3 = true, d3 = c3;
                else if (88 === e5)
                  ++b3;
                else if (27 === e5)
                  y3 = b3;
                else if (89 === e5)
                  y3 === b3 && (y3 = 0), --b3;
                else if (28 === e5 && !m3 && !y3) {
                  const e6 = u3.at(-1);
                  e6 > 0 && (c3 += e6 - 1);
                }
              } else
                (m3 || y3) && (warn$1("TT: nested FDEFs not allowed"), f3 = true), m3 = true, d3 = c3, r3 = u3.pop(), t3.functionsDefined[r3] = { data: l4, i: c3 };
            else if (!m3 && !y3) {
              if (r3 = u3.at(-1), isNaN(r3))
                info$1("TT: CALL empty stack (or invalid entry).");
              else if (t3.functionsUsed[r3] = true, r3 in t3.functionsStackDeltas) {
                const e6 = u3.length + t3.functionsStackDeltas[r3];
                if (e6 < 0)
                  return warn$1("TT: CALL invalid functions stack delta."), void (t3.hintsValid = false);
                u3.length = e6;
              } else if (r3 in t3.functionsDefined && !p3.includes(r3)) {
                if (g3.push({ data: l4, i: c3, stackTop: u3.length - 1 }), p3.push(r3), o3 = t3.functionsDefined[r3], !o3)
                  return warn$1("TT: CALL non-existent function"), void (t3.hintsValid = false);
                l4 = o3.data, c3 = o3.i;
              }
            }
            if (!m3 && !y3) {
              let t4 = 0;
              for (e5 <= 142 ? t4 = n2[e5] : e5 >= 192 && e5 <= 223 ? t4 = -1 : e5 >= 224 && (t4 = -2), e5 >= 113 && e5 <= 117 && (a3 = u3.pop(), isNaN(a3) || (t4 = 2 * -a3)); t4 < 0 && u3.length > 0; )
                u3.pop(), t4++;
              for (; t4 > 0; )
                u3.push(NaN), t4--;
            }
          }
          t3.tooComplexToFollowFunctions = f3;
          const w3 = [l4];
          c3 > l4.length && w3.push(new Uint8Array(c3 - l4.length)), d3 > h3 && (warn$1("TT: complementing a missing function tail"), w3.push(new Uint8Array([34, 45]))), function(e4, t4) {
            if (t4.length > 1) {
              let i4, a4, n3 = 0;
              for (i4 = 0, a4 = t4.length; i4 < a4; i4++)
                n3 += t4[i4].length;
              n3 = n3 + 3 & -4;
              const s4 = new Uint8Array(n3);
              let r4 = 0;
              for (i4 = 0, a4 = t4.length; i4 < a4; i4++)
                s4.set(t4[i4], r4), r4 += t4[i4].length;
              e4.data = s4, e4.length = n3;
            }
          }(e3, w3);
        }
        __name(sanitizeTTProgram, "sanitizeTTProgram");
        let s2, r2, o2, l3;
        if (isTrueTypeCollectionFile(t2 = new Stream(new Uint8Array(t2.getBytes())))) {
          const e3 = function(e4, t3) {
            const { numFonts: i3, offsetTable: a3 } = function(e5) {
              const t4 = e5.getString(4);
              assert$1("ttcf" === t4, "Must be a TrueType Collection font.");
              const i4 = e5.getUint16(), a4 = e5.getUint16(), n4 = e5.getInt32() >>> 0, s4 = [];
              for (let t5 = 0; t5 < n4; t5++)
                s4.push(e5.getInt32() >>> 0);
              const r3 = { ttcTag: t4, majorVersion: i4, minorVersion: a4, numFonts: n4, offsetTable: s4 };
              switch (i4) {
                case 1:
                  return r3;
                case 2:
                  return r3.dsigTag = e5.getInt32() >>> 0, r3.dsigLength = e5.getInt32() >>> 0, r3.dsigOffset = e5.getInt32() >>> 0, r3;
              }
              throw new ti(`Invalid TrueType Collection majorVersion: ${i4}.`);
            }(e4), n3 = t3.split("+");
            let s3;
            for (let r3 = 0; r3 < i3; r3++) {
              e4.pos = (e4.start || 0) + a3[r3];
              const i4 = readOpenTypeHeader(e4), o3 = readTables(e4, i4.numTables);
              if (!o3.name)
                throw new ti('TrueType Collection font must contain a "name" table.');
              const [l4] = readNameTable(o3.name);
              for (let e5 = 0, a4 = l4.length; e5 < a4; e5++)
                for (let a5 = 0, r4 = l4[e5].length; a5 < r4; a5++) {
                  const r5 = l4[e5][a5]?.replaceAll(/\s/g, "");
                  if (r5) {
                    if (r5 === t3)
                      return { header: i4, tables: o3 };
                    if (!(n3.length < 2))
                      for (const e6 of n3)
                        r5 === e6 && (s3 = { name: e6, header: i4, tables: o3 });
                  }
                }
            }
            if (s3)
              return warn$1(`TrueType Collection does not contain "${t3}" font, falling back to "${s3.name}" font instead.`), { header: s3.header, tables: s3.tables };
            throw new ti(`TrueType Collection does not contain "${t3}" font.`);
          }(t2, this.name);
          s2 = e3.header, r2 = e3.tables;
        } else
          s2 = readOpenTypeHeader(t2), r2 = readTables(t2, s2.numTables);
        const c2 = !r2["CFF "];
        if (c2) {
          if (!r2.loca)
            throw new ti('Required "loca" table is not found');
          r2.glyf || (warn$1('Required "glyf" table is not found -- trying to recover.'), r2.glyf = { tag: "glyf", data: new Uint8Array(0) }), this.isOpenType = false;
        } else {
          const t3 = i2.composite && (i2.cidToGidMap?.length > 0 || !(i2.cMap instanceof IdentityCMap));
          if ("OTTO" === s2.version && !t3 || !r2.head || !r2.hhea || !r2.maxp || !r2.post)
            return l3 = new Stream(r2["CFF "].data), o2 = new CFFFont(l3, i2), this.convert(e2, o2, i2);
          delete r2.glyf, delete r2.loca, delete r2.fpgm, delete r2.prep, delete r2["cvt "], this.isOpenType = true;
        }
        if (!r2.maxp)
          throw new ti('Required "maxp" table is not found');
        t2.pos = (t2.start || 0) + r2.maxp.offset;
        let h2 = t2.getInt32();
        const d2 = t2.getUint16();
        if (65536 !== h2 && 20480 !== h2) {
          if (6 === r2.maxp.length)
            h2 = 20480;
          else {
            if (!(r2.maxp.length >= 32))
              throw new ti('"maxp" table has a wrong version number');
            h2 = 65536;
          }
          u2 = r2.maxp.data, p2 = h2, u2[(g2 = 0) + 3] = 255 & p2, u2[g2 + 2] = p2 >>> 8, u2[g2 + 1] = p2 >>> 16, u2[g2] = p2 >>> 24;
        }
        var u2, g2, p2;
        if (i2.scaleFactors?.length === d2 && c2) {
          const { scaleFactors: e3 } = i2, t3 = int16(r2.head.data[50], r2.head.data[51]), a3 = new GlyfTable({ glyfTable: r2.glyf.data, isGlyphLocationsLong: t3, locaTable: r2.loca.data, numGlyphs: d2 });
          a3.scale(e3);
          const { glyf: n3, loca: s3, isLocationLong: o3 } = a3.write();
          r2.glyf.data = n3, r2.loca.data = s3, o3 !== !!t3 && (r2.head.data[50] = 0, r2.head.data[51] = o3 ? 1 : 0);
          const l4 = r2.hmtx.data;
          for (let t4 = 0; t4 < d2; t4++) {
            const i3 = 4 * t4, a4 = Math.round(e3[t4] * int16(l4[i3], l4[i3 + 1]));
            l4[i3] = a4 >> 8 & 255, l4[i3 + 1] = 255 & a4;
            writeSignedInt16(l4, i3 + 2, Math.round(e3[t4] * signedInt16(l4[i3 + 2], l4[i3 + 3])));
          }
        }
        let f2 = d2 + 1, m2 = true;
        f2 > 65535 && (m2 = false, f2 = d2, warn$1("Not enough space in glyfs to duplicate first glyph."));
        let b2 = 0, y2 = 0;
        if (h2 >= 65536 && r2.maxp.length >= 32) {
          t2.pos += 8;
          t2.getUint16() > 2 && (r2.maxp.data[14] = 0, r2.maxp.data[15] = 2), t2.pos += 4, b2 = t2.getUint16(), t2.pos += 4, y2 = t2.getUint16();
        }
        r2.maxp.data[4] = f2 >> 8, r2.maxp.data[5] = 255 & f2;
        const w2 = function(e3, t3, i3, a3) {
          const n3 = { functionsDefined: [], functionsUsed: [], functionsStackDeltas: [], tooComplexToFollowFunctions: false, hintsValid: true };
          if (e3 && sanitizeTTProgram(e3, n3), t3 && sanitizeTTProgram(t3, n3), e3 && function(e4, t4) {
            if (!e4.tooComplexToFollowFunctions) {
              if (e4.functionsDefined.length > t4)
                return warn$1("TT: more functions defined than expected"), void (e4.hintsValid = false);
              for (let i4 = 0, a4 = e4.functionsUsed.length; i4 < a4; i4++) {
                if (i4 > t4)
                  return warn$1("TT: invalid function id: " + i4), void (e4.hintsValid = false);
                if (e4.functionsUsed[i4] && !e4.functionsDefined[i4])
                  return warn$1("TT: undefined function: " + i4), void (e4.hintsValid = false);
              }
            }
          }(n3, a3), i3 && 1 & i3.length) {
            const e4 = new Uint8Array(i3.length + 1);
            e4.set(i3.data), i3.data = e4;
          }
          return n3.hintsValid;
        }(r2.fpgm, r2.prep, r2["cvt "], b2);
        if (w2 || (delete r2.fpgm, delete r2.prep, delete r2["cvt "]), function(e3, t3, i3, a3, n3, s3) {
          if (!t3)
            return void (i3 && (i3.data = null));
          e3.pos = (e3.start || 0) + t3.offset, e3.pos += 4, e3.pos += 2, e3.pos += 2, e3.pos += 2, e3.pos += 2, e3.pos += 2, e3.pos += 2, e3.pos += 2, e3.pos += 2, e3.pos += 2;
          const r3 = e3.getUint16();
          e3.pos += 8, e3.pos += 2;
          let o3 = e3.getUint16();
          if (0 !== r3) {
            2 & int16(a3.data[44], a3.data[45]) || (t3.data[22] = 0, t3.data[23] = 0);
          }
          o3 > n3 && (info$1(`The numOfMetrics (${o3}) should not be greater than the numGlyphs (${n3}).`), o3 = n3, t3.data[34] = (65280 & o3) >> 8, t3.data[35] = 255 & o3);
          const l4 = n3 - o3 - (i3.length - 4 * o3 >> 1);
          if (l4 > 0) {
            const e4 = new Uint8Array(i3.length + 2 * l4);
            e4.set(i3.data), s3 && (e4[i3.length] = i3.data[2], e4[i3.length + 1] = i3.data[3]), i3.data = e4;
          }
        }(t2, r2.hhea, r2.hmtx, r2.head, f2, m2), !r2.head)
          throw new ti('Required "head" table is not found');
        !function(e3, t3, i3) {
          const a3 = e3.data, n3 = (s3 = a3[0], r3 = a3[1], o3 = a3[2], l4 = a3[3], (s3 << 24) + (r3 << 16) + (o3 << 8) + l4);
          var s3, r3, o3, l4;
          n3 >> 16 != 1 && (info$1("Attempting to fix invalid version in head table: " + n3), a3[0] = 0, a3[1] = 1, a3[2] = 0, a3[3] = 0);
          const c3 = int16(a3[50], a3[51]);
          if (c3 < 0 || c3 > 1) {
            info$1("Attempting to fix invalid indexToLocFormat in head table: " + c3);
            const e4 = t3 + 1;
            if (i3 === e4 << 1)
              a3[50] = 0, a3[51] = 0;
            else {
              if (i3 !== e4 << 2)
                throw new ti("Could not fix indexToLocFormat: " + c3);
              a3[50] = 0, a3[51] = 1;
            }
          }
        }(r2.head, d2, c2 ? r2.loca.length : 0);
        let x2 = /* @__PURE__ */ Object.create(null);
        if (c2) {
          const e3 = int16(r2.head.data[50], r2.head.data[51]), t3 = function(e4, t4, i3, a3, n3, s3, r3) {
            let o3, l4, c3;
            a3 ? (o3 = 4, l4 = /* @__PURE__ */ __name(function(e5, t5) {
              return e5[t5] << 24 | e5[t5 + 1] << 16 | e5[t5 + 2] << 8 | e5[t5 + 3];
            }, "l"), c3 = /* @__PURE__ */ __name(function(e5, t5, i4) {
              e5[t5] = i4 >>> 24 & 255, e5[t5 + 1] = i4 >> 16 & 255, e5[t5 + 2] = i4 >> 8 & 255, e5[t5 + 3] = 255 & i4;
            }, "c")) : (o3 = 2, l4 = /* @__PURE__ */ __name(function(e5, t5) {
              return e5[t5] << 9 | e5[t5 + 1] << 1;
            }, "l"), c3 = /* @__PURE__ */ __name(function(e5, t5, i4) {
              e5[t5] = i4 >> 9 & 255, e5[t5 + 1] = i4 >> 1 & 255;
            }, "c"));
            const h3 = s3 ? i3 + 1 : i3, d3 = o3 * (1 + h3), u3 = new Uint8Array(d3);
            u3.set(e4.data.subarray(0, d3)), e4.data = u3;
            const g3 = t4.data, p3 = g3.length, f3 = new Uint8Array(p3);
            let m3, b3;
            const y3 = [];
            for (m3 = 0, b3 = 0; m3 < i3 + 1; m3++, b3 += o3) {
              let e5 = l4(u3, b3);
              e5 > p3 && (e5 = p3), y3.push({ index: m3, offset: e5, endOffset: 0 });
            }
            for (y3.sort((e5, t5) => e5.offset - t5.offset), m3 = 0; m3 < i3; m3++)
              y3[m3].endOffset = y3[m3 + 1].offset;
            for (y3.sort((e5, t5) => e5.index - t5.index), m3 = 0; m3 < i3; m3++) {
              const { offset: e5, endOffset: t5 } = y3[m3];
              if (0 !== e5 || 0 !== t5)
                break;
              const i4 = y3[m3 + 1].offset;
              if (0 !== i4) {
                y3[m3].endOffset = i4;
                break;
              }
            }
            const w3 = y3.at(-2);
            0 !== w3.offset && 0 === w3.endOffset && (w3.endOffset = p3);
            const x3 = /* @__PURE__ */ Object.create(null);
            let S3 = 0;
            for (c3(u3, 0, S3), m3 = 0, b3 = o3; m3 < i3; m3++, b3 += o3) {
              const e5 = sanitizeGlyph(g3, y3[m3].offset, y3[m3].endOffset, f3, S3, n3), t5 = e5.length;
              0 === t5 && (x3[m3] = true), e5.sizeOfInstructions > r3 && (r3 = e5.sizeOfInstructions), S3 += t5, c3(u3, b3, S3);
            }
            if (0 === S3) {
              const e5 = new Uint8Array([0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 49, 0]);
              for (m3 = 0, b3 = o3; m3 < h3; m3++, b3 += o3)
                c3(u3, b3, e5.length);
              t4.data = e5;
            } else if (s3) {
              const i4 = l4(u3, o3);
              f3.length > i4 + S3 ? t4.data = f3.subarray(0, i4 + S3) : (t4.data = new Uint8Array(i4 + S3), t4.data.set(f3.subarray(0, S3))), t4.data.set(f3.subarray(0, i4), S3), c3(e4.data, u3.length - o3, S3 + i4);
            } else
              t4.data = f3.subarray(0, S3);
            return { missingGlyphs: x3, maxSizeOfInstructions: r3 };
          }(r2.loca, r2.glyf, d2, e3, w2, m2, y2);
          x2 = t3.missingGlyphs, h2 >= 65536 && r2.maxp.length >= 32 && (r2.maxp.data[26] = t3.maxSizeOfInstructions >> 8, r2.maxp.data[27] = 255 & t3.maxSizeOfInstructions);
        }
        if (!r2.hhea)
          throw new ti('Required "hhea" table is not found');
        0 === r2.hhea.data[10] && 0 === r2.hhea.data[11] && (r2.hhea.data[10] = 255, r2.hhea.data[11] = 255);
        const S2 = { unitsPerEm: int16(r2.head.data[18], r2.head.data[19]), yMax: signedInt16(r2.head.data[42], r2.head.data[43]), yMin: signedInt16(r2.head.data[38], r2.head.data[39]), ascent: signedInt16(r2.hhea.data[4], r2.hhea.data[5]), descent: signedInt16(r2.hhea.data[6], r2.hhea.data[7]), lineGap: signedInt16(r2.hhea.data[8], r2.hhea.data[9]) };
        this.ascent = S2.ascent / S2.unitsPerEm, this.descent = S2.descent / S2.unitsPerEm, this.lineGap = S2.lineGap / S2.unitsPerEm, this.cssFontInfo?.lineHeight ? (this.lineHeight = this.cssFontInfo.metrics.lineHeight, this.lineGap = this.cssFontInfo.metrics.lineGap) : this.lineHeight = this.ascent - this.descent + this.lineGap, r2.post && function(e3, i3, a3) {
          const n3 = (t2.start || 0) + e3.offset;
          t2.pos = n3;
          const s3 = n3 + e3.length, r3 = t2.getInt32();
          let o3;
          t2.skip(28);
          let l4, c3 = true;
          switch (r3) {
            case 65536:
              o3 = Ta;
              break;
            case 131072:
              const e4 = t2.getUint16();
              if (e4 !== a3) {
                c3 = false;
                break;
              }
              const n4 = [];
              for (l4 = 0; l4 < e4; ++l4) {
                const e5 = t2.getUint16();
                if (e5 >= 32768) {
                  c3 = false;
                  break;
                }
                n4.push(e5);
              }
              if (!c3)
                break;
              const h3 = [], d3 = [];
              for (; t2.pos < s3; ) {
                const e5 = t2.getByte();
                for (d3.length = e5, l4 = 0; l4 < e5; ++l4)
                  d3[l4] = String.fromCharCode(t2.getByte());
                h3.push(d3.join(""));
              }
              for (o3 = [], l4 = 0; l4 < e4; ++l4) {
                const e5 = n4[l4];
                e5 < 258 ? o3.push(Ta[e5]) : o3.push(h3[e5 - 258]);
              }
              break;
            case 196608:
              break;
            default:
              warn$1("Unknown/unsupported post table version " + r3), c3 = false, i3.defaultEncoding && (o3 = i3.defaultEncoding);
          }
          i3.glyphNames = o3;
        }(r2.post, i2, d2), r2.post = { tag: "post", data: createPostTable(i2) };
        const v2 = /* @__PURE__ */ Object.create(null);
        function hasGlyph(e3) {
          return !x2[e3];
        }
        __name(hasGlyph, "hasGlyph");
        if (i2.composite) {
          const e3 = i2.cidToGidMap || [], t3 = 0 === e3.length;
          i2.cMap.forEach(function(i3, a3) {
            if ("string" == typeof a3 && (a3 = convertCidString(i3, a3, true)), a3 > 65535)
              throw new ti("Max size of CID is 65,535");
            let n3 = -1;
            t3 ? n3 = a3 : void 0 !== e3[a3] && (n3 = e3[a3]), n3 >= 0 && n3 < d2 && hasGlyph(n3) && (v2[i3] = n3);
          });
        } else {
          const e3 = function(e4, t3, i3, a4) {
            if (!e4)
              return warn$1("No cmap table available."), { platformId: -1, encodingId: -1, mappings: [], hasShortCmap: false };
            let n4, s4 = (t3.start || 0) + e4.offset;
            t3.pos = s4, t3.skip(2);
            const r3 = t3.getUint16();
            let o4, l5 = false;
            for (let e5 = 0; e5 < r3; e5++) {
              const n5 = t3.getUint16(), s5 = t3.getUint16(), c4 = t3.getInt32() >>> 0;
              let h4 = false;
              if (o4?.platformId !== n5 || o4?.encodingId !== s5) {
                if (0 !== n5 || 0 !== s5 && 1 !== s5 && 3 !== s5)
                  if (1 === n5 && 0 === s5)
                    h4 = true;
                  else if (3 !== n5 || 1 !== s5 || !a4 && o4) {
                    if (i3 && 3 === n5 && 0 === s5) {
                      h4 = true;
                      let i4 = true;
                      if (e5 < r3 - 1) {
                        const e6 = t3.peekBytes(2);
                        int16(e6[0], e6[1]) < n5 && (i4 = false);
                      }
                      i4 && (l5 = true);
                    }
                  } else
                    h4 = true, i3 || (l5 = true);
                else
                  h4 = true;
                if (h4 && (o4 = { platformId: n5, encodingId: s5, offset: c4 }), l5)
                  break;
              }
            }
            if (o4 && (t3.pos = s4 + o4.offset), !o4 || -1 === t3.peekByte())
              return warn$1("Could not find a preferred cmap table."), { platformId: -1, encodingId: -1, mappings: [], hasShortCmap: false };
            const c3 = t3.getUint16();
            let h3 = false;
            const d3 = [];
            let u3, g3;
            if (0 === c3) {
              for (t3.skip(4), u3 = 0; u3 < 256; u3++) {
                const e5 = t3.getByte();
                e5 && d3.push({ charCode: u3, glyphId: e5 });
              }
              h3 = true;
            } else if (2 === c3) {
              t3.skip(4);
              const e5 = [];
              let i4 = 0;
              for (let a6 = 0; a6 < 256; a6++) {
                const a7 = t3.getUint16() >> 3;
                e5.push(a7), i4 = Math.max(a7, i4);
              }
              const a5 = [];
              for (let e6 = 0; e6 <= i4; e6++)
                a5.push({ firstCode: t3.getUint16(), entryCount: t3.getUint16(), idDelta: signedInt16(t3.getByte(), t3.getByte()), idRangePos: t3.pos + t3.getUint16() });
              for (let i5 = 0; i5 < 256; i5++)
                if (0 === e5[i5])
                  t3.pos = a5[0].idRangePos + 2 * i5, g3 = t3.getUint16(), d3.push({ charCode: i5, glyphId: g3 });
                else {
                  const n5 = a5[e5[i5]];
                  for (u3 = 0; u3 < n5.entryCount; u3++) {
                    const e6 = (i5 << 8) + u3 + n5.firstCode;
                    t3.pos = n5.idRangePos + 2 * u3, g3 = t3.getUint16(), 0 !== g3 && (g3 = (g3 + n5.idDelta) % 65536), d3.push({ charCode: e6, glyphId: g3 });
                  }
                }
            } else if (4 === c3) {
              t3.skip(4);
              const e5 = t3.getUint16() >> 1;
              t3.skip(6);
              const i4 = [];
              let a5;
              for (a5 = 0; a5 < e5; a5++)
                i4.push({ end: t3.getUint16() });
              for (t3.skip(2), a5 = 0; a5 < e5; a5++)
                i4[a5].start = t3.getUint16();
              for (a5 = 0; a5 < e5; a5++)
                i4[a5].delta = t3.getUint16();
              let r4, o5 = 0;
              for (a5 = 0; a5 < e5; a5++) {
                n4 = i4[a5];
                const s5 = t3.getUint16();
                s5 ? (r4 = (s5 >> 1) - (e5 - a5), n4.offsetIndex = r4, o5 = Math.max(o5, r4 + n4.end - n4.start + 1)) : n4.offsetIndex = -1;
              }
              const l6 = [];
              for (u3 = 0; u3 < o5; u3++)
                l6.push(t3.getUint16());
              for (a5 = 0; a5 < e5; a5++) {
                n4 = i4[a5], s4 = n4.start;
                const e6 = n4.end, t4 = n4.delta;
                for (r4 = n4.offsetIndex, u3 = s4; u3 <= e6; u3++)
                  65535 !== u3 && (g3 = r4 < 0 ? u3 : l6[r4 + u3 - s4], g3 = g3 + t4 & 65535, d3.push({ charCode: u3, glyphId: g3 }));
              }
            } else if (6 === c3) {
              t3.skip(4);
              const e5 = t3.getUint16(), i4 = t3.getUint16();
              for (u3 = 0; u3 < i4; u3++) {
                g3 = t3.getUint16();
                const i5 = e5 + u3;
                d3.push({ charCode: i5, glyphId: g3 });
              }
            } else {
              if (12 !== c3)
                return warn$1("cmap table has unsupported format: " + c3), { platformId: -1, encodingId: -1, mappings: [], hasShortCmap: false };
              {
                t3.skip(10);
                const e5 = t3.getInt32() >>> 0;
                for (u3 = 0; u3 < e5; u3++) {
                  const e6 = t3.getInt32() >>> 0, i4 = t3.getInt32() >>> 0;
                  let a5 = t3.getInt32() >>> 0;
                  for (let t4 = e6; t4 <= i4; t4++)
                    d3.push({ charCode: t4, glyphId: a5++ });
                }
              }
            }
            d3.sort((e5, t4) => e5.charCode - t4.charCode);
            const p3 = [], f3 = /* @__PURE__ */ new Set();
            for (const e5 of d3) {
              const { charCode: t4 } = e5;
              f3.has(t4) || (f3.add(t4), p3.push(e5));
            }
            return { platformId: o4.platformId, encodingId: o4.encodingId, mappings: p3, hasShortCmap: h3 };
          }(r2.cmap, t2, this.isSymbolicFont, i2.hasEncoding), a3 = e3.platformId, n3 = e3.encodingId, s3 = e3.mappings;
          let o3 = [], l4 = false;
          if (!i2.hasEncoding || "MacRomanEncoding" !== i2.baseEncodingName && "WinAnsiEncoding" !== i2.baseEncodingName || (o3 = getEncoding(i2.baseEncodingName)), i2.hasEncoding && !this.isSymbolicFont && (3 === a3 && 1 === n3 || 1 === a3 && 0 === n3)) {
            const e4 = fa();
            for (let t3 = 0; t3 < 256; t3++) {
              let r3;
              if (r3 = void 0 !== this.differences[t3] ? this.differences[t3] : o3.length && "" !== o3[t3] ? o3[t3] : da[t3], !r3)
                continue;
              const l5 = recoverGlyphName(r3, e4);
              let c3;
              if (3 === a3 && 1 === n3 ? c3 = e4[l5] : 1 === a3 && 0 === n3 && (c3 = ha.indexOf(l5)), void 0 === c3) {
                if (!i2.glyphNames && i2.hasIncludedToUnicodeMap && !(this.toUnicode instanceof IdentityToUnicodeMap)) {
                  const e5 = this.toUnicode.get(t3);
                  e5 && (c3 = e5.codePointAt(0));
                }
                if (void 0 === c3)
                  continue;
              }
              for (const e5 of s3)
                if (e5.charCode === c3) {
                  v2[t3] = e5.glyphId;
                  break;
                }
            }
          } else if (0 === a3) {
            for (const e4 of s3)
              v2[e4.charCode] = e4.glyphId;
            l4 = true;
          } else if (3 === a3 && 0 === n3)
            for (const e4 of s3) {
              let t3 = e4.charCode;
              t3 >= 61440 && t3 <= 61695 && (t3 &= 255), v2[t3] = e4.glyphId;
            }
          else
            for (const e4 of s3)
              v2[e4.charCode] = e4.glyphId;
          if (i2.glyphNames && (o3.length || this.differences.length))
            for (let e4 = 0; e4 < 256; ++e4) {
              if (!l4 && void 0 !== v2[e4])
                continue;
              const t3 = this.differences[e4] || o3[e4];
              if (!t3)
                continue;
              const a4 = i2.glyphNames.indexOf(t3);
              a4 > 0 && hasGlyph(a4) && (v2[e4] = a4);
            }
        }
        0 === v2.length && (v2[0] = 0);
        let C2 = f2 - 1;
        if (m2 || (C2 = 0), !i2.cssFontInfo) {
          const e3 = adjustMapping(v2, hasGlyph, C2, this.toUnicode);
          this.toFontChar = e3.toFontChar, r2.cmap = { tag: "cmap", data: createCmapTable(e3.charCodeToGlyphId, e3.toUnicodeExtraMap, f2) }, r2["OS/2"] && function(e4, t3) {
            t3.pos = (t3.start || 0) + e4.offset;
            const i3 = t3.getUint16();
            t3.skip(60);
            const a3 = t3.getUint16();
            return !(i3 < 4 && 768 & a3) && (!(t3.getUint16() > t3.getUint16()) && (t3.skip(6), 0 !== t3.getUint16() && (e4.data[8] = e4.data[9] = 0, true)));
          }(r2["OS/2"], t2) || (r2["OS/2"] = { tag: "OS/2", data: createOS2Table(i2, e3.charCodeToGlyphId, S2) });
        }
        if (!c2)
          try {
            l3 = new Stream(r2["CFF "].data);
            o2 = new CFFParser(l3, i2, xa).parse(), o2.duplicateFirstGlyph();
            const e3 = new CFFCompiler(o2);
            r2["CFF "].data = e3.compile();
          } catch {
            warn$1("Failed to compile font " + i2.loadedName);
          }
        if (r2.name) {
          const [t3, a3] = readNameTable(r2.name);
          r2.name.data = createNameTable(e2, t3), this.psName = t3[0][6] || null, i2.composite || function(e3, t4, i3) {
            if (e3.isInternalFont)
              return;
            if (e3.hasIncludedToUnicodeMap)
              return;
            if (e3.hasEncoding)
              return;
            if (e3.toUnicode instanceof IdentityToUnicodeMap)
              return;
            if (!t4)
              return;
            if (0 === i3.length)
              return;
            if (e3.defaultEncoding === ua)
              return;
            for (const e4 of i3)
              if (!isWinNameRecord(e4))
                return;
            const a4 = ua, n3 = [], s3 = fa();
            for (const e4 in a4) {
              const t5 = a4[e4];
              if ("" === t5)
                continue;
              const i4 = s3[t5];
              void 0 !== i4 && (n3[e4] = String.fromCharCode(i4));
            }
            n3.length > 0 && e3.toUnicode.amend(n3);
          }(i2, this.isSymbolicFont, a3);
        } else
          r2.name = { tag: "name", data: createNameTable(this.name) };
        const k2 = new OpenTypeFileBuilder(s2.version);
        for (const e3 in r2)
          k2.addTable(e3, r2[e3].data);
        return k2.toArray();
      }
      convert(e2, i2, a2) {
        a2.fixedPitch = false, a2.builtInEncoding && function(e3, t2) {
          if (e3.isInternalFont)
            return;
          if (e3.hasIncludedToUnicodeMap)
            return;
          if (t2 === e3.defaultEncoding)
            return;
          if (e3.toUnicode instanceof IdentityToUnicodeMap)
            return;
          const i3 = [], a3 = fa();
          for (const n3 in t2) {
            if (e3.hasEncoding && (e3.baseEncodingName || void 0 !== e3.differences[n3]))
              continue;
            const s3 = getUnicodeForGlyph(t2[n3], a3);
            -1 !== s3 && (i3[n3] = String.fromCharCode(s3));
          }
          i3.length > 0 && e3.toUnicode.amend(i3);
        }(a2, a2.builtInEncoding);
        let n2 = 1;
        i2 instanceof CFFFont && (n2 = i2.numGlyphs - 1);
        const s2 = i2.getGlyphMapping(a2);
        let r2 = null, o2 = s2, l3 = null;
        a2.cssFontInfo || (r2 = adjustMapping(s2, i2.hasGlyphId.bind(i2), n2, this.toUnicode), this.toFontChar = r2.toFontChar, o2 = r2.charCodeToGlyphId, l3 = r2.toUnicodeExtraMap);
        const c2 = i2.numGlyphs;
        function getCharCodes(e3, t2) {
          let i3 = null;
          for (const a3 in e3)
            t2 === e3[a3] && (i3 ||= []).push(0 | a3);
          return i3;
        }
        __name(getCharCodes, "getCharCodes");
        function createCharCode(e3, t2) {
          for (const i3 in e3)
            if (t2 === e3[i3])
              return 0 | i3;
          return r2.charCodeToGlyphId[r2.nextAvailableFontCharCode] = t2, r2.nextAvailableFontCharCode++;
        }
        __name(createCharCode, "createCharCode");
        const h2 = i2.seacs;
        if (r2 && h2?.length) {
          const e3 = a2.fontMatrix || t, n3 = i2.getCharset(), o3 = /* @__PURE__ */ Object.create(null);
          for (let t2 in h2) {
            t2 |= 0;
            const i3 = h2[t2], a3 = da[i3[2]], l4 = da[i3[3]], c3 = n3.indexOf(a3), d3 = n3.indexOf(l4);
            if (c3 < 0 || d3 < 0)
              continue;
            const u3 = { x: i3[0] * e3[0] + i3[1] * e3[2] + e3[4], y: i3[0] * e3[1] + i3[1] * e3[3] + e3[5] }, g2 = getCharCodes(s2, t2);
            if (g2)
              for (const e4 of g2) {
                const t3 = r2.charCodeToGlyphId, i4 = createCharCode(t3, c3), a4 = createCharCode(t3, d3);
                o3[e4] = { baseFontCharCode: i4, accentFontCharCode: a4, accentOffset: u3 };
              }
          }
          a2.seacMap = o3;
        }
        const d2 = a2.fontMatrix ? 1 / Math.max(...a2.fontMatrix.slice(0, 4).map(Math.abs)) : 1e3, u2 = new OpenTypeFileBuilder("OTTO");
        return u2.addTable("CFF ", i2.data), u2.addTable("OS/2", createOS2Table(a2, o2)), u2.addTable("cmap", createCmapTable(o2, l3, c2)), u2.addTable("head", "\0\0\0\0\0\0\0\0\0\0_<\xF5\0\0" + safeString16(d2) + "\0\0\0\0\x9E\v~'\0\0\0\0\x9E\v~'\0\0" + safeString16(a2.descent) + "\xFF" + safeString16(a2.ascent) + string16(a2.italicAngle ? 2 : 0) + "\0\0\0\0\0\0\0"), u2.addTable("hhea", "\0\0\0" + safeString16(a2.ascent) + safeString16(a2.descent) + "\0\0\xFF\xFF\0\0\0\0\0\0" + safeString16(a2.capHeight) + safeString16(Math.tan(a2.italicAngle) * a2.xHeight) + "\0\0\0\0\0\0\0\0\0\0\0\0" + string16(c2)), u2.addTable("hmtx", function() {
          const e3 = i2.charstrings, t2 = i2.cff ? i2.cff.widths : null;
          let a3 = "\0\0\0\0";
          for (let i3 = 1, n3 = c2; i3 < n3; i3++) {
            let n4 = 0;
            if (e3) {
              const t3 = e3[i3 - 1];
              n4 = "width" in t3 ? t3.width : 0;
            } else
              t2 && (n4 = Math.ceil(t2[i3] || 0));
            a3 += string16(n4) + string16(0);
          }
          return a3;
        }()), u2.addTable("maxp", "\0\0P\0" + string16(c2)), u2.addTable("name", createNameTable(e2)), u2.addTable("post", createPostTable(a2)), u2.toArray();
      }
      get _spaceWidth() {
        const e2 = ["space", "minus", "one", "i", "I"];
        let t2;
        for (const i2 of e2) {
          if (i2 in this.widths) {
            t2 = this.widths[i2];
            break;
          }
          const e3 = fa()[i2];
          let a2 = 0;
          if (this.composite && this.cMap.contains(e3) && (a2 = this.cMap.lookup(e3), "string" == typeof a2 && (a2 = convertCidString(e3, a2))), !a2 && this.toUnicode && (a2 = this.toUnicode.charCodeOf(e3)), a2 <= 0 && (a2 = e3), t2 = this.widths[a2], t2)
            break;
        }
        return shadow$1(this, "_spaceWidth", t2 || this.defaultWidth);
      }
      _charToGlyph(e2, t2 = false) {
        let i2, a2, n2, s2 = this._glyphCache[e2];
        if (s2?.isSpace === t2)
          return s2;
        let r2 = e2;
        this.cMap?.contains(e2) && (r2 = this.cMap.lookup(e2), "string" == typeof r2 && (r2 = convertCidString(e2, r2))), a2 = this.widths[r2], "number" != typeof a2 && (a2 = this.defaultWidth);
        const o2 = this.vmetrics?.[r2];
        let l3 = this.toUnicode.get(e2) || e2;
        "number" == typeof l3 && (l3 = String.fromCharCode(l3));
        let c2 = void 0 !== this.toFontChar[e2];
        if (i2 = this.toFontChar[e2] || e2, this.missingFile) {
          const t3 = this.differences[e2] || this.defaultEncoding[e2];
          ".notdef" !== t3 && "" !== t3 || "Type1" !== this.type || (i2 = 32, "" === t3 && (a2 ||= this._spaceWidth, l3 = String.fromCharCode(i2))), i2 = (h2 = i2) >= 65520 && h2 <= 65535 ? 0 : h2 >= 62976 && h2 <= 63743 ? ba()[h2] || h2 : 173 === h2 ? 45 : h2;
        }
        var h2;
        this.isType3Font && (n2 = i2);
        let d2 = null;
        if (this.seacMap?.[e2]) {
          c2 = true;
          const t3 = this.seacMap[e2];
          i2 = t3.baseFontCharCode, d2 = { fontChar: String.fromCodePoint(t3.accentFontCharCode), offset: t3.accentOffset };
        }
        let u2 = "";
        if ("number" == typeof i2 && (i2 <= 1114111 ? u2 = String.fromCodePoint(i2) : warn$1(`charToGlyph - invalid fontCharCode: ${i2}`)), this.missingFile && this.vertical && 1 === u2.length) {
          const e3 = Ia()[u2.charCodeAt(0)];
          e3 && (u2 = l3 = String.fromCharCode(e3));
        }
        return s2 = new fonts_Glyph(e2, u2, l3, d2, a2, o2, n2, t2, c2), this._glyphCache[e2] = s2;
      }
      charsToGlyphs(e2) {
        let t2 = this._charsCache[e2];
        if (t2)
          return t2;
        if (t2 = [], this.cMap) {
          const i2 = /* @__PURE__ */ Object.create(null), a2 = e2.length;
          let n2 = 0;
          for (; n2 < a2; ) {
            this.cMap.readCharCode(e2, n2, i2);
            const { charcode: a3, length: s2 } = i2;
            n2 += s2;
            const r2 = this._charToGlyph(a3, 1 === s2 && 32 === e2.charCodeAt(n2 - 1));
            t2.push(r2);
          }
        } else
          for (let i2 = 0, a2 = e2.length; i2 < a2; ++i2) {
            const a3 = e2.charCodeAt(i2), n2 = this._charToGlyph(a3, 32 === a3);
            t2.push(n2);
          }
        return this._charsCache[e2] = t2;
      }
      getCharPositions(e2) {
        const t2 = [];
        if (this.cMap) {
          const i2 = /* @__PURE__ */ Object.create(null);
          let a2 = 0;
          for (; a2 < e2.length; ) {
            this.cMap.readCharCode(e2, a2, i2);
            const n2 = i2.length;
            t2.push([a2, a2 + n2]), a2 += n2;
          }
        } else
          for (let i2 = 0, a2 = e2.length; i2 < a2; ++i2)
            t2.push([i2, i2 + 1]);
        return t2;
      }
      get glyphCacheValues() {
        return Object.values(this._glyphCache);
      }
      encodeString(e2) {
        const t2 = [], i2 = [], hasCurrentBufErrors = /* @__PURE__ */ __name(() => t2.length % 2 == 1, "hasCurrentBufErrors"), a2 = this.toUnicode instanceof IdentityToUnicodeMap ? (e3) => this.toUnicode.charCodeOf(e3) : (e3) => this.toUnicode.charCodeOf(String.fromCodePoint(e3));
        for (let n2 = 0, s2 = e2.length; n2 < s2; n2++) {
          const s3 = e2.codePointAt(n2);
          if (s3 > 55295 && (s3 < 57344 || s3 > 65533) && n2++, this.toUnicode) {
            const e3 = a2(s3);
            if (-1 !== e3) {
              hasCurrentBufErrors() && (t2.push(i2.join("")), i2.length = 0);
              for (let t3 = (this.cMap ? this.cMap.getCharCodeLength(e3) : 1) - 1; t3 >= 0; t3--)
                i2.push(String.fromCharCode(e3 >> 8 * t3 & 255));
              continue;
            }
          }
          hasCurrentBufErrors() || (t2.push(i2.join("")), i2.length = 0), i2.push(String.fromCodePoint(s3));
        }
        return t2.push(i2.join("")), t2;
      }
    };
    __name(Font, "Font");
    ErrorFont = class {
      constructor(e2) {
        this.error = e2, this.loadedName = "g_font_error", this.missingFile = true;
      }
      charsToGlyphs() {
        return [];
      }
      encodeString(e2) {
        return [e2];
      }
      exportData() {
        return { error: this.error };
      }
    };
    __name(ErrorFont, "ErrorFont");
    hn = 2;
    dn = 3;
    un = 4;
    gn = 5;
    pn = 6;
    fn = 7;
    Pattern = class {
      constructor() {
        unreachable$1("Cannot initialize Pattern.");
      }
      static parseShading(e2, t2, i2, a2, n2, s2) {
        const r2 = e2 instanceof BaseStream ? e2.dict : e2, o2 = r2.get("ShadingType");
        try {
          switch (o2) {
            case hn:
            case dn:
              return new RadialAxialShading(r2, t2, i2, a2, n2, s2);
            case un:
            case gn:
            case pn:
            case fn:
              return new MeshShading(e2, t2, i2, a2, n2, s2);
            default:
              throw new ti("Unsupported ShadingType: " + o2);
          }
        } catch (e3) {
          if (e3 instanceof MissingDataException)
            throw e3;
          return warn$1(e3), new DummyShading();
        }
      }
    };
    __name(Pattern, "Pattern");
    BaseShading = class {
      getIR() {
        unreachable$1("Abstract method `getIR` called.");
      }
    };
    __name(BaseShading, "BaseShading");
    __publicField(BaseShading, "SMALL_NUMBER", 1e-6);
    RadialAxialShading = class extends BaseShading {
      constructor(e2, t2, i2, a2, n2, s2) {
        super(), this.shadingType = e2.get("ShadingType");
        let r2 = 0;
        if (this.shadingType === hn ? r2 = 4 : this.shadingType === dn && (r2 = 6), this.coordsArr = e2.getArray("Coords"), !isNumberArray(this.coordsArr, r2))
          throw new ti("RadialAxialShading: Invalid /Coords array.");
        const o2 = ColorSpaceUtils.parse({ cs: e2.getRaw("CS") || e2.getRaw("ColorSpace"), xref: t2, resources: i2, pdfFunctionFactory: a2, globalColorSpaceCache: n2, localColorSpaceCache: s2 });
        this.bbox = lookupNormalRect(e2.getArray("BBox"), null);
        let l3 = 0, c2 = 1;
        const h2 = e2.getArray("Domain");
        isNumberArray(h2, 2) && ([l3, c2] = h2);
        let d2 = false, u2 = false;
        const g2 = e2.getArray("Extend");
        var p2, f2;
        if (p2 = g2, f2 = 2, Array.isArray(p2) && p2.length === f2 && p2.every((e3) => "boolean" == typeof e3) && ([d2, u2] = g2), !(this.shadingType !== dn || d2 && u2)) {
          const [e3, t3, i3, a3, n3, s3] = this.coordsArr, r3 = Math.hypot(e3 - a3, t3 - n3);
          i3 <= s3 + r3 && s3 <= i3 + r3 && warn$1("Unsupported radial gradient.");
        }
        this.extendStart = d2, this.extendEnd = u2;
        const m2 = e2.getRaw("Function"), b2 = a2.create(m2, true), y2 = (c2 - l3) / 840, w2 = this.colorStops = [];
        if (l3 >= c2 || y2 <= 0)
          return void info$1("Bad shading domain.");
        const x2 = new Float32Array(o2.numComps), S2 = new Float32Array(1);
        let v2 = 0;
        S2[0] = l3, b2(S2, 0, x2, 0);
        const C2 = new Uint8ClampedArray(3);
        o2.getRgb(x2, 0, C2);
        let [k2, T2, F2] = C2;
        w2.push([0, ni.makeHexColor(k2, T2, F2)]);
        let M2 = 1;
        S2[0] = l3 + y2, b2(S2, 0, x2, 0), o2.getRgb(x2, 0, C2);
        let [D2, E2, O2] = C2, _2 = D2 - k2 + 1, R2 = E2 - T2 + 1, N2 = O2 - F2 + 1, L2 = D2 - k2 - 1, U2 = E2 - T2 - 1, j2 = O2 - F2 - 1;
        for (let e3 = 2; e3 < 840; e3++) {
          S2[0] = l3 + e3 * y2, b2(S2, 0, x2, 0), o2.getRgb(x2, 0, C2);
          const [t3, i3, a3] = C2, n3 = e3 - v2;
          _2 = Math.min(_2, (t3 - k2 + 1) / n3), R2 = Math.min(R2, (i3 - T2 + 1) / n3), N2 = Math.min(N2, (a3 - F2 + 1) / n3), L2 = Math.max(L2, (t3 - k2 - 1) / n3), U2 = Math.max(U2, (i3 - T2 - 1) / n3), j2 = Math.max(j2, (a3 - F2 - 1) / n3);
          if (!(L2 <= _2 && U2 <= R2 && j2 <= N2)) {
            const e4 = ni.makeHexColor(D2, E2, O2);
            w2.push([M2 / 840, e4]), _2 = t3 - D2 + 1, R2 = i3 - E2 + 1, N2 = a3 - O2 + 1, L2 = t3 - D2 - 1, U2 = i3 - E2 - 1, j2 = a3 - O2 - 1, v2 = M2, k2 = D2, T2 = E2, F2 = O2;
          }
          M2 = e3, D2 = t3, E2 = i3, O2 = a3;
        }
        w2.push([1, ni.makeHexColor(D2, E2, O2)]);
        let $2 = "transparent";
        e2.has("Background") && ($2 = o2.getRgbHex(e2.get("Background"), 0)), d2 || (w2.unshift([0, $2]), w2[1][0] += BaseShading.SMALL_NUMBER), u2 || (w2.at(-1)[0] -= BaseShading.SMALL_NUMBER, w2.push([1, $2])), this.colorStops = w2;
      }
      getIR() {
        const { coordsArr: e2, shadingType: t2 } = this;
        let i2, a2, n2, s2, r2;
        return t2 === hn ? (a2 = [e2[0], e2[1]], n2 = [e2[2], e2[3]], s2 = null, r2 = null, i2 = "axial") : t2 === dn ? (a2 = [e2[0], e2[1]], n2 = [e2[3], e2[4]], s2 = e2[2], r2 = e2[5], i2 = "radial") : unreachable$1(`getPattern type unknown: ${t2}`), ["RadialAxial", i2, this.bbox, this.colorStops, a2, n2, s2, r2];
      }
    };
    __name(RadialAxialShading, "RadialAxialShading");
    MeshStreamReader = class {
      constructor(e2, t2) {
        this.stream = e2, this.context = t2, this.buffer = 0, this.bufferLength = 0;
        const i2 = t2.numComps;
        this.tmpCompsBuf = new Float32Array(i2);
        const a2 = t2.colorSpace.numComps;
        this.tmpCsCompsBuf = t2.colorFn ? new Float32Array(a2) : this.tmpCompsBuf;
      }
      get hasData() {
        if (this.stream.end)
          return this.stream.pos < this.stream.end;
        if (this.bufferLength > 0)
          return true;
        const e2 = this.stream.getByte();
        return !(e2 < 0) && (this.buffer = e2, this.bufferLength = 8, true);
      }
      readBits(e2) {
        const { stream: t2 } = this;
        let { buffer: i2, bufferLength: a2 } = this;
        if (32 === e2) {
          if (0 === a2)
            return t2.getInt32() >>> 0;
          i2 = i2 << 24 | t2.getByte() << 16 | t2.getByte() << 8 | t2.getByte();
          const e3 = t2.getByte();
          return this.buffer = e3 & (1 << a2) - 1, (i2 << 8 - a2 | (255 & e3) >> a2) >>> 0;
        }
        if (8 === e2 && 0 === a2)
          return t2.getByte();
        for (; a2 < e2; )
          i2 = i2 << 8 | t2.getByte(), a2 += 8;
        return a2 -= e2, this.bufferLength = a2, this.buffer = i2 & (1 << a2) - 1, i2 >> a2;
      }
      align() {
        this.buffer = 0, this.bufferLength = 0;
      }
      readFlag() {
        return this.readBits(this.context.bitsPerFlag);
      }
      readCoordinate() {
        const { bitsPerCoordinate: e2, decode: t2 } = this.context, i2 = this.readBits(e2), a2 = this.readBits(e2), n2 = e2 < 32 ? 1 / ((1 << e2) - 1) : 23283064365386963e-26;
        return [i2 * n2 * (t2[1] - t2[0]) + t2[0], a2 * n2 * (t2[3] - t2[2]) + t2[2]];
      }
      readComponents() {
        const { bitsPerComponent: e2, colorFn: t2, colorSpace: i2, decode: a2, numComps: n2 } = this.context, s2 = e2 < 32 ? 1 / ((1 << e2) - 1) : 23283064365386963e-26, r2 = this.tmpCompsBuf;
        for (let t3 = 0, i3 = 4; t3 < n2; t3++, i3 += 2) {
          const n3 = this.readBits(e2);
          r2[t3] = n3 * s2 * (a2[i3 + 1] - a2[i3]) + a2[i3];
        }
        const o2 = this.tmpCsCompsBuf;
        return t2?.(r2, 0, o2, 0), i2.getRgb(o2, 0);
      }
    };
    __name(MeshStreamReader, "MeshStreamReader");
    mn = /* @__PURE__ */ Object.create(null);
    __name(getB, "getB");
    _MeshShading = class extends BaseShading {
      constructor(e2, t2, i2, a2, n2, s2) {
        if (super(), !(e2 instanceof BaseStream))
          throw new ti("Mesh data is not a stream");
        const r2 = e2.dict;
        this.shadingType = r2.get("ShadingType"), this.bbox = lookupNormalRect(r2.getArray("BBox"), null);
        const o2 = ColorSpaceUtils.parse({ cs: r2.getRaw("CS") || r2.getRaw("ColorSpace"), xref: t2, resources: i2, pdfFunctionFactory: a2, globalColorSpaceCache: n2, localColorSpaceCache: s2 });
        this.background = r2.has("Background") ? o2.getRgb(r2.get("Background"), 0) : null;
        const l3 = r2.getRaw("Function"), c2 = l3 ? a2.create(l3, true) : null;
        this.coords = [], this.colors = [], this.figures = [];
        const h2 = { bitsPerCoordinate: r2.get("BitsPerCoordinate"), bitsPerComponent: r2.get("BitsPerComponent"), bitsPerFlag: r2.get("BitsPerFlag"), decode: r2.getArray("Decode"), colorFn: c2, colorSpace: o2, numComps: c2 ? 1 : o2.numComps }, d2 = new MeshStreamReader(e2, h2);
        let u2 = false;
        switch (this.shadingType) {
          case un:
            this._decodeType4Shading(d2);
            break;
          case gn:
            const e3 = 0 | r2.get("VerticesPerRow");
            if (e3 < 2)
              throw new ti("Invalid VerticesPerRow");
            this._decodeType5Shading(d2, e3);
            break;
          case pn:
            this._decodeType6Shading(d2), u2 = true;
            break;
          case fn:
            this._decodeType7Shading(d2), u2 = true;
            break;
          default:
            unreachable$1("Unsupported mesh type.");
        }
        if (u2) {
          this._updateBounds();
          for (let e3 = 0, t3 = this.figures.length; e3 < t3; e3++)
            this._buildFigureFromPatch(e3);
        }
        this._updateBounds(), this._packData();
      }
      _decodeType4Shading(e2) {
        const t2 = this.coords, i2 = this.colors, a2 = [];
        let n2 = 0;
        for (; e2.hasData; ) {
          const s2 = e2.readFlag(), r2 = e2.readCoordinate(), o2 = e2.readComponents();
          if (0 === n2) {
            if (!(0 <= s2 && s2 <= 2))
              throw new ti("Unknown type4 flag");
            switch (s2) {
              case 0:
                n2 = 3;
                break;
              case 1:
                a2.push(a2.at(-2), a2.at(-1)), n2 = 1;
                break;
              case 2:
                a2.push(a2.at(-3), a2.at(-1)), n2 = 1;
            }
          }
          a2.push(t2.length), t2.push(r2), i2.push(o2), n2--, e2.align();
        }
        this.figures.push({ type: "triangles", coords: new Int32Array(a2), colors: new Int32Array(a2) });
      }
      _decodeType5Shading(e2, t2) {
        const i2 = this.coords, a2 = this.colors, n2 = [];
        for (; e2.hasData; ) {
          const t3 = e2.readCoordinate(), s2 = e2.readComponents();
          n2.push(i2.length), i2.push(t3), a2.push(s2);
        }
        this.figures.push({ type: "lattice", coords: new Int32Array(n2), colors: new Int32Array(n2), verticesPerRow: t2 });
      }
      _decodeType6Shading(e2) {
        const t2 = this.coords, i2 = this.colors, a2 = new Int32Array(16), n2 = new Int32Array(4);
        for (; e2.hasData; ) {
          const s2 = e2.readFlag();
          if (!(0 <= s2 && s2 <= 3))
            throw new ti("Unknown type6 flag");
          const r2 = t2.length;
          for (let i3 = 0, a3 = 0 !== s2 ? 8 : 12; i3 < a3; i3++)
            t2.push(e2.readCoordinate());
          const o2 = i2.length;
          for (let t3 = 0, a3 = 0 !== s2 ? 2 : 4; t3 < a3; t3++)
            i2.push(e2.readComponents());
          let l3, c2, h2, d2;
          switch (s2) {
            case 0:
              a2[12] = r2 + 3, a2[13] = r2 + 4, a2[14] = r2 + 5, a2[15] = r2 + 6, a2[8] = r2 + 2, a2[11] = r2 + 7, a2[4] = r2 + 1, a2[7] = r2 + 8, a2[0] = r2, a2[1] = r2 + 11, a2[2] = r2 + 10, a2[3] = r2 + 9, n2[2] = o2 + 1, n2[3] = o2 + 2, n2[0] = o2, n2[1] = o2 + 3;
              break;
            case 1:
              l3 = a2[12], c2 = a2[13], h2 = a2[14], d2 = a2[15], a2[12] = d2, a2[13] = r2 + 0, a2[14] = r2 + 1, a2[15] = r2 + 2, a2[8] = h2, a2[11] = r2 + 3, a2[4] = c2, a2[7] = r2 + 4, a2[0] = l3, a2[1] = r2 + 7, a2[2] = r2 + 6, a2[3] = r2 + 5, l3 = n2[2], c2 = n2[3], n2[2] = c2, n2[3] = o2, n2[0] = l3, n2[1] = o2 + 1;
              break;
            case 2:
              l3 = a2[15], c2 = a2[11], a2[12] = a2[3], a2[13] = r2 + 0, a2[14] = r2 + 1, a2[15] = r2 + 2, a2[8] = a2[7], a2[11] = r2 + 3, a2[4] = c2, a2[7] = r2 + 4, a2[0] = l3, a2[1] = r2 + 7, a2[2] = r2 + 6, a2[3] = r2 + 5, l3 = n2[3], n2[2] = n2[1], n2[3] = o2, n2[0] = l3, n2[1] = o2 + 1;
              break;
            case 3:
              a2[12] = a2[0], a2[13] = r2 + 0, a2[14] = r2 + 1, a2[15] = r2 + 2, a2[8] = a2[1], a2[11] = r2 + 3, a2[4] = a2[2], a2[7] = r2 + 4, a2[0] = a2[3], a2[1] = r2 + 7, a2[2] = r2 + 6, a2[3] = r2 + 5, n2[2] = n2[0], n2[3] = o2, n2[0] = n2[1], n2[1] = o2 + 1;
          }
          a2[5] = t2.length, t2.push([(-4 * t2[a2[0]][0] - t2[a2[15]][0] + 6 * (t2[a2[4]][0] + t2[a2[1]][0]) - 2 * (t2[a2[12]][0] + t2[a2[3]][0]) + 3 * (t2[a2[13]][0] + t2[a2[7]][0])) / 9, (-4 * t2[a2[0]][1] - t2[a2[15]][1] + 6 * (t2[a2[4]][1] + t2[a2[1]][1]) - 2 * (t2[a2[12]][1] + t2[a2[3]][1]) + 3 * (t2[a2[13]][1] + t2[a2[7]][1])) / 9]), a2[6] = t2.length, t2.push([(-4 * t2[a2[3]][0] - t2[a2[12]][0] + 6 * (t2[a2[2]][0] + t2[a2[7]][0]) - 2 * (t2[a2[0]][0] + t2[a2[15]][0]) + 3 * (t2[a2[4]][0] + t2[a2[14]][0])) / 9, (-4 * t2[a2[3]][1] - t2[a2[12]][1] + 6 * (t2[a2[2]][1] + t2[a2[7]][1]) - 2 * (t2[a2[0]][1] + t2[a2[15]][1]) + 3 * (t2[a2[4]][1] + t2[a2[14]][1])) / 9]), a2[9] = t2.length, t2.push([(-4 * t2[a2[12]][0] - t2[a2[3]][0] + 6 * (t2[a2[8]][0] + t2[a2[13]][0]) - 2 * (t2[a2[0]][0] + t2[a2[15]][0]) + 3 * (t2[a2[11]][0] + t2[a2[1]][0])) / 9, (-4 * t2[a2[12]][1] - t2[a2[3]][1] + 6 * (t2[a2[8]][1] + t2[a2[13]][1]) - 2 * (t2[a2[0]][1] + t2[a2[15]][1]) + 3 * (t2[a2[11]][1] + t2[a2[1]][1])) / 9]), a2[10] = t2.length, t2.push([(-4 * t2[a2[15]][0] - t2[a2[0]][0] + 6 * (t2[a2[11]][0] + t2[a2[14]][0]) - 2 * (t2[a2[12]][0] + t2[a2[3]][0]) + 3 * (t2[a2[2]][0] + t2[a2[8]][0])) / 9, (-4 * t2[a2[15]][1] - t2[a2[0]][1] + 6 * (t2[a2[11]][1] + t2[a2[14]][1]) - 2 * (t2[a2[12]][1] + t2[a2[3]][1]) + 3 * (t2[a2[2]][1] + t2[a2[8]][1])) / 9]), this.figures.push({ type: "patch", coords: new Int32Array(a2), colors: new Int32Array(n2) });
        }
      }
      _decodeType7Shading(e2) {
        const t2 = this.coords, i2 = this.colors, a2 = new Int32Array(16), n2 = new Int32Array(4);
        for (; e2.hasData; ) {
          const s2 = e2.readFlag();
          if (!(0 <= s2 && s2 <= 3))
            throw new ti("Unknown type7 flag");
          const r2 = t2.length;
          for (let i3 = 0, a3 = 0 !== s2 ? 12 : 16; i3 < a3; i3++)
            t2.push(e2.readCoordinate());
          const o2 = i2.length;
          for (let t3 = 0, a3 = 0 !== s2 ? 2 : 4; t3 < a3; t3++)
            i2.push(e2.readComponents());
          let l3, c2, h2, d2;
          switch (s2) {
            case 0:
              a2[12] = r2 + 3, a2[13] = r2 + 4, a2[14] = r2 + 5, a2[15] = r2 + 6, a2[8] = r2 + 2, a2[9] = r2 + 13, a2[10] = r2 + 14, a2[11] = r2 + 7, a2[4] = r2 + 1, a2[5] = r2 + 12, a2[6] = r2 + 15, a2[7] = r2 + 8, a2[0] = r2, a2[1] = r2 + 11, a2[2] = r2 + 10, a2[3] = r2 + 9, n2[2] = o2 + 1, n2[3] = o2 + 2, n2[0] = o2, n2[1] = o2 + 3;
              break;
            case 1:
              l3 = a2[12], c2 = a2[13], h2 = a2[14], d2 = a2[15], a2[12] = d2, a2[13] = r2 + 0, a2[14] = r2 + 1, a2[15] = r2 + 2, a2[8] = h2, a2[9] = r2 + 9, a2[10] = r2 + 10, a2[11] = r2 + 3, a2[4] = c2, a2[5] = r2 + 8, a2[6] = r2 + 11, a2[7] = r2 + 4, a2[0] = l3, a2[1] = r2 + 7, a2[2] = r2 + 6, a2[3] = r2 + 5, l3 = n2[2], c2 = n2[3], n2[2] = c2, n2[3] = o2, n2[0] = l3, n2[1] = o2 + 1;
              break;
            case 2:
              l3 = a2[15], c2 = a2[11], a2[12] = a2[3], a2[13] = r2 + 0, a2[14] = r2 + 1, a2[15] = r2 + 2, a2[8] = a2[7], a2[9] = r2 + 9, a2[10] = r2 + 10, a2[11] = r2 + 3, a2[4] = c2, a2[5] = r2 + 8, a2[6] = r2 + 11, a2[7] = r2 + 4, a2[0] = l3, a2[1] = r2 + 7, a2[2] = r2 + 6, a2[3] = r2 + 5, l3 = n2[3], n2[2] = n2[1], n2[3] = o2, n2[0] = l3, n2[1] = o2 + 1;
              break;
            case 3:
              a2[12] = a2[0], a2[13] = r2 + 0, a2[14] = r2 + 1, a2[15] = r2 + 2, a2[8] = a2[1], a2[9] = r2 + 9, a2[10] = r2 + 10, a2[11] = r2 + 3, a2[4] = a2[2], a2[5] = r2 + 8, a2[6] = r2 + 11, a2[7] = r2 + 4, a2[0] = a2[3], a2[1] = r2 + 7, a2[2] = r2 + 6, a2[3] = r2 + 5, n2[2] = n2[0], n2[3] = o2, n2[0] = n2[1], n2[1] = o2 + 1;
          }
          this.figures.push({ type: "patch", coords: new Int32Array(a2), colors: new Int32Array(n2) });
        }
      }
      _buildFigureFromPatch(e2) {
        const t2 = this.figures[e2];
        assert$1("patch" === t2.type, "Unexpected patch mesh figure");
        const i2 = this.coords, a2 = this.colors, n2 = t2.coords, s2 = t2.colors, r2 = Math.min(i2[n2[0]][0], i2[n2[3]][0], i2[n2[12]][0], i2[n2[15]][0]), o2 = Math.min(i2[n2[0]][1], i2[n2[3]][1], i2[n2[12]][1], i2[n2[15]][1]), l3 = Math.max(i2[n2[0]][0], i2[n2[3]][0], i2[n2[12]][0], i2[n2[15]][0]), c2 = Math.max(i2[n2[0]][1], i2[n2[3]][1], i2[n2[12]][1], i2[n2[15]][1]);
        let h2 = Math.ceil((l3 - r2) * _MeshShading.TRIANGLE_DENSITY / (this.bounds[2] - this.bounds[0]));
        h2 = MathClamp$1(h2, _MeshShading.MIN_SPLIT_PATCH_CHUNKS_AMOUNT, _MeshShading.MAX_SPLIT_PATCH_CHUNKS_AMOUNT);
        let d2 = Math.ceil((c2 - o2) * _MeshShading.TRIANGLE_DENSITY / (this.bounds[3] - this.bounds[1]));
        d2 = MathClamp$1(d2, _MeshShading.MIN_SPLIT_PATCH_CHUNKS_AMOUNT, _MeshShading.MAX_SPLIT_PATCH_CHUNKS_AMOUNT);
        const u2 = h2 + 1, g2 = new Int32Array((d2 + 1) * u2), p2 = new Int32Array((d2 + 1) * u2);
        let f2 = 0;
        const m2 = new Uint8Array(3), b2 = new Uint8Array(3), y2 = a2[s2[0]], w2 = a2[s2[1]], x2 = a2[s2[2]], S2 = a2[s2[3]], v2 = getB(d2), C2 = getB(h2);
        for (let e3 = 0; e3 <= d2; e3++) {
          m2[0] = (y2[0] * (d2 - e3) + x2[0] * e3) / d2 | 0, m2[1] = (y2[1] * (d2 - e3) + x2[1] * e3) / d2 | 0, m2[2] = (y2[2] * (d2 - e3) + x2[2] * e3) / d2 | 0, b2[0] = (w2[0] * (d2 - e3) + S2[0] * e3) / d2 | 0, b2[1] = (w2[1] * (d2 - e3) + S2[1] * e3) / d2 | 0, b2[2] = (w2[2] * (d2 - e3) + S2[2] * e3) / d2 | 0;
          for (let t3 = 0; t3 <= h2; t3++, f2++) {
            if (!(0 !== e3 && e3 !== d2 || 0 !== t3 && t3 !== h2))
              continue;
            let s3 = 0, r3 = 0, o3 = 0;
            for (let a3 = 0; a3 <= 3; a3++)
              for (let l5 = 0; l5 <= 3; l5++, o3++) {
                const c3 = v2[e3][a3] * C2[t3][l5];
                s3 += i2[n2[o3]][0] * c3, r3 += i2[n2[o3]][1] * c3;
              }
            g2[f2] = i2.length, i2.push([s3, r3]), p2[f2] = a2.length;
            const l4 = new Uint8Array(3);
            l4[0] = (m2[0] * (h2 - t3) + b2[0] * t3) / h2 | 0, l4[1] = (m2[1] * (h2 - t3) + b2[1] * t3) / h2 | 0, l4[2] = (m2[2] * (h2 - t3) + b2[2] * t3) / h2 | 0, a2.push(l4);
          }
        }
        g2[0] = n2[0], p2[0] = s2[0], g2[h2] = n2[3], p2[h2] = s2[1], g2[u2 * d2] = n2[12], p2[u2 * d2] = s2[2], g2[u2 * d2 + h2] = n2[15], p2[u2 * d2 + h2] = s2[3], this.figures[e2] = { type: "lattice", coords: g2, colors: p2, verticesPerRow: u2 };
      }
      _updateBounds() {
        let e2 = this.coords[0][0], t2 = this.coords[0][1], i2 = e2, a2 = t2;
        for (let n2 = 1, s2 = this.coords.length; n2 < s2; n2++) {
          const s3 = this.coords[n2][0], r2 = this.coords[n2][1];
          e2 = e2 > s3 ? s3 : e2, t2 = t2 > r2 ? r2 : t2, i2 = i2 < s3 ? s3 : i2, a2 = a2 < r2 ? r2 : a2;
        }
        this.bounds = [e2, t2, i2, a2];
      }
      _packData() {
        let e2, t2, i2, a2;
        const n2 = this.coords, s2 = new Float32Array(2 * n2.length);
        for (e2 = 0, i2 = 0, t2 = n2.length; e2 < t2; e2++) {
          const t3 = n2[e2];
          s2[i2++] = t3[0], s2[i2++] = t3[1];
        }
        this.coords = s2;
        const r2 = this.colors, o2 = new Uint8Array(3 * r2.length);
        for (e2 = 0, i2 = 0, t2 = r2.length; e2 < t2; e2++) {
          const t3 = r2[e2];
          o2[i2++] = t3[0], o2[i2++] = t3[1], o2[i2++] = t3[2];
        }
        this.colors = o2;
        const l3 = this.figures;
        for (e2 = 0, t2 = l3.length; e2 < t2; e2++) {
          const t3 = l3[e2], n3 = t3.coords, s3 = t3.colors;
          for (i2 = 0, a2 = n3.length; i2 < a2; i2++)
            n3[i2] *= 2, s3[i2] *= 3;
        }
      }
      getIR() {
        const { bounds: e2 } = this;
        if (e2[2] - e2[0] === 0 || e2[3] - e2[1] === 0)
          throw new ti(`Invalid MeshShading bounds: [${e2}].`);
        return ["Mesh", this.shadingType, this.coords, this.colors, this.figures, e2, this.bbox, this.background];
      }
    };
    MeshShading = _MeshShading;
    __name(MeshShading, "MeshShading");
    __publicField(MeshShading, "MIN_SPLIT_PATCH_CHUNKS_AMOUNT", 3);
    __publicField(MeshShading, "MAX_SPLIT_PATCH_CHUNKS_AMOUNT", 20);
    __publicField(MeshShading, "TRIANGLE_DENSITY", 20);
    DummyShading = class extends BaseShading {
      getIR() {
        return ["Dummy"];
      }
    };
    __name(DummyShading, "DummyShading");
    __name(getTilingPatternIR, "getTilingPatternIR");
    bn = [1.3877, 1, 1, 1, 0.97801, 0.92482, 0.89552, 0.91133, 0.81988, 0.97566, 0.98152, 0.93548, 0.93548, 1.2798, 0.85284, 0.92794, 1, 0.96134, 1.54657, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.82845, 0.82845, 0.85284, 0.85284, 0.85284, 0.75859, 0.92138, 0.83908, 0.7762, 0.73293, 0.87289, 0.73133, 0.7514, 0.81921, 0.87356, 0.95958, 0.59526, 0.75727, 0.69225, 1.04924, 0.9121, 0.86943, 0.79795, 0.88198, 0.77958, 0.70864, 0.81055, 0.90399, 0.88653, 0.96017, 0.82577, 0.77892, 0.78257, 0.97507, 1.54657, 0.97507, 0.85284, 0.89552, 0.90176, 0.88762, 0.8785, 0.75241, 0.8785, 0.90518, 0.95015, 0.77618, 0.8785, 0.88401, 0.91916, 0.86304, 0.88401, 0.91488, 0.8785, 0.8801, 0.8785, 0.8785, 0.91343, 0.7173, 1.04106, 0.8785, 0.85075, 0.95794, 0.82616, 0.85162, 0.79492, 0.88331, 1.69808, 0.88331, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.7801, 0.89552, 1.24487, 1.13254, 1.12401, 0.96839, 0.85284, 0.68787, 0.70645, 0.85592, 0.90747, 1.01466, 1.0088, 0.90323, 1, 1.07463, 1, 0.91056, 0.75806, 1.19118, 0.96839, 0.78864, 0.82845, 0.84133, 0.75859, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.77539, 0.73293, 0.73133, 0.73133, 0.73133, 0.73133, 0.95958, 0.95958, 0.95958, 0.95958, 0.88506, 0.9121, 0.86943, 0.86943, 0.86943, 0.86943, 0.86943, 0.85284, 0.87508, 0.90399, 0.90399, 0.90399, 0.90399, 0.77892, 0.79795, 0.90807, 0.88762, 0.88762, 0.88762, 0.88762, 0.88762, 0.88762, 0.8715, 0.75241, 0.90518, 0.90518, 0.90518, 0.90518, 0.88401, 0.88401, 0.88401, 0.88401, 0.8785, 0.8785, 0.8801, 0.8801, 0.8801, 0.8801, 0.8801, 0.90747, 0.89049, 0.8785, 0.8785, 0.8785, 0.8785, 0.85162, 0.8785, 0.85162, 0.83908, 0.88762, 0.83908, 0.88762, 0.83908, 0.88762, 0.73293, 0.75241, 0.73293, 0.75241, 0.73293, 0.75241, 0.73293, 0.75241, 0.87289, 0.83016, 0.88506, 0.93125, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.81921, 0.77618, 0.81921, 0.77618, 0.81921, 0.77618, 1, 1, 0.87356, 0.8785, 0.91075, 0.89608, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.76229, 0.90167, 0.59526, 0.91916, 1, 1, 0.86304, 0.69225, 0.88401, 1, 1, 0.70424, 0.79468, 0.91926, 0.88175, 0.70823, 0.94903, 0.9121, 0.8785, 1, 1, 0.9121, 0.8785, 0.87802, 0.88656, 0.8785, 0.86943, 0.8801, 0.86943, 0.8801, 0.86943, 0.8801, 0.87402, 0.89291, 0.77958, 0.91343, 1, 1, 0.77958, 0.91343, 0.70864, 0.7173, 0.70864, 0.7173, 0.70864, 0.7173, 0.70864, 0.7173, 1, 1, 0.81055, 0.75841, 0.81055, 1.06452, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.96017, 0.95794, 0.77892, 0.85162, 0.77892, 0.78257, 0.79492, 0.78257, 0.79492, 0.78257, 0.79492, 0.9297, 0.56892, 0.83908, 0.88762, 0.77539, 0.8715, 0.87508, 0.89049, 1, 1, 0.81055, 1.04106, 1.20528, 1.20528, 1, 1.15543, 0.70674, 0.98387, 0.94721, 1.33431, 1.45894, 0.95161, 1.06303, 0.83908, 0.80352, 0.57184, 0.6965, 0.56289, 0.82001, 0.56029, 0.81235, 1.02988, 0.83908, 0.7762, 0.68156, 0.80367, 0.73133, 0.78257, 0.87356, 0.86943, 0.95958, 0.75727, 0.89019, 1.04924, 0.9121, 0.7648, 0.86943, 0.87356, 0.79795, 0.78275, 0.81055, 0.77892, 0.9762, 0.82577, 0.99819, 0.84896, 0.95958, 0.77892, 0.96108, 1.01407, 0.89049, 1.02988, 0.94211, 0.96108, 0.8936, 0.84021, 0.87842, 0.96399, 0.79109, 0.89049, 1.00813, 1.02988, 0.86077, 0.87445, 0.92099, 0.84723, 0.86513, 0.8801, 0.75638, 0.85714, 0.78216, 0.79586, 0.87965, 0.94211, 0.97747, 0.78287, 0.97926, 0.84971, 1.02988, 0.94211, 0.8801, 0.94211, 0.84971, 0.73133, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90264, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90518, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90548, 1, 1, 1, 1, 1, 1, 0.96017, 0.95794, 0.96017, 0.95794, 0.96017, 0.95794, 0.77892, 0.85162, 1, 1, 0.89552, 0.90527, 1, 0.90363, 0.92794, 0.92794, 0.92794, 0.92794, 0.87012, 0.87012, 0.87012, 0.89552, 0.89552, 1.42259, 0.71143, 1.06152, 1, 1, 1.03372, 1.03372, 0.97171, 1.4956, 2.2807, 0.93835, 0.83406, 0.91133, 0.84107, 0.91133, 1, 1, 1, 0.72021, 1, 1.23108, 0.83489, 0.88525, 0.88525, 0.81499, 0.90527, 1.81055, 0.90527, 1.81055, 1.31006, 1.53711, 0.94434, 1.08696, 1, 0.95018, 0.77192, 0.85284, 0.90747, 1.17534, 0.69825, 0.9716, 1.37077, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.08004, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90727, 0.90727, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    yn = { lineHeight: 1.2207, lineGap: 0.2207 };
    wn = [1.3877, 1, 1, 1, 0.97801, 0.92482, 0.89552, 0.91133, 0.81988, 0.97566, 0.98152, 0.93548, 0.93548, 1.2798, 0.85284, 0.92794, 1, 0.96134, 1.56239, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.82845, 0.82845, 0.85284, 0.85284, 0.85284, 0.75859, 0.92138, 0.83908, 0.7762, 0.71805, 0.87289, 0.73133, 0.7514, 0.81921, 0.87356, 0.95958, 0.59526, 0.75727, 0.69225, 1.04924, 0.90872, 0.85938, 0.79795, 0.87068, 0.77958, 0.69766, 0.81055, 0.90399, 0.88653, 0.96068, 0.82577, 0.77892, 0.78257, 0.97507, 1.529, 0.97507, 0.85284, 0.89552, 0.90176, 0.94908, 0.86411, 0.74012, 0.86411, 0.88323, 0.95015, 0.86411, 0.86331, 0.88401, 0.91916, 0.86304, 0.88401, 0.9039, 0.86331, 0.86331, 0.86411, 0.86411, 0.90464, 0.70852, 1.04106, 0.86331, 0.84372, 0.95794, 0.82616, 0.84548, 0.79492, 0.88331, 1.69808, 0.88331, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.7801, 0.89552, 1.24487, 1.13254, 1.19129, 0.96839, 0.85284, 0.68787, 0.70645, 0.85592, 0.90747, 1.01466, 1.0088, 0.90323, 1, 1.07463, 1, 0.91056, 0.75806, 1.19118, 0.96839, 0.78864, 0.82845, 0.84133, 0.75859, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.77539, 0.71805, 0.73133, 0.73133, 0.73133, 0.73133, 0.95958, 0.95958, 0.95958, 0.95958, 0.88506, 0.90872, 0.85938, 0.85938, 0.85938, 0.85938, 0.85938, 0.85284, 0.87068, 0.90399, 0.90399, 0.90399, 0.90399, 0.77892, 0.79795, 0.90807, 0.94908, 0.94908, 0.94908, 0.94908, 0.94908, 0.94908, 0.85887, 0.74012, 0.88323, 0.88323, 0.88323, 0.88323, 0.88401, 0.88401, 0.88401, 0.88401, 0.8785, 0.86331, 0.86331, 0.86331, 0.86331, 0.86331, 0.86331, 0.90747, 0.89049, 0.86331, 0.86331, 0.86331, 0.86331, 0.84548, 0.86411, 0.84548, 0.83908, 0.94908, 0.83908, 0.94908, 0.83908, 0.94908, 0.71805, 0.74012, 0.71805, 0.74012, 0.71805, 0.74012, 0.71805, 0.74012, 0.87289, 0.79538, 0.88506, 0.92726, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.81921, 0.86411, 0.81921, 0.86411, 0.81921, 0.86411, 1, 1, 0.87356, 0.86331, 0.91075, 0.8777, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.76467, 0.90167, 0.59526, 0.91916, 1, 1, 0.86304, 0.69225, 0.88401, 1, 1, 0.70424, 0.77312, 0.91926, 0.88175, 0.70823, 0.94903, 0.90872, 0.86331, 1, 1, 0.90872, 0.86331, 0.86906, 0.88116, 0.86331, 0.85938, 0.86331, 0.85938, 0.86331, 0.85938, 0.86331, 0.87402, 0.86549, 0.77958, 0.90464, 1, 1, 0.77958, 0.90464, 0.69766, 0.70852, 0.69766, 0.70852, 0.69766, 0.70852, 0.69766, 0.70852, 1, 1, 0.81055, 0.75841, 0.81055, 1.06452, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.96068, 0.95794, 0.77892, 0.84548, 0.77892, 0.78257, 0.79492, 0.78257, 0.79492, 0.78257, 0.79492, 0.9297, 0.56892, 0.83908, 0.94908, 0.77539, 0.85887, 0.87068, 0.89049, 1, 1, 0.81055, 1.04106, 1.20528, 1.20528, 1, 1.15543, 0.70088, 0.98387, 0.94721, 1.33431, 1.45894, 0.95161, 1.48387, 0.83908, 0.80352, 0.57118, 0.6965, 0.56347, 0.79179, 0.55853, 0.80346, 1.02988, 0.83908, 0.7762, 0.67174, 0.86036, 0.73133, 0.78257, 0.87356, 0.86441, 0.95958, 0.75727, 0.89019, 1.04924, 0.90872, 0.74889, 0.85938, 0.87891, 0.79795, 0.7957, 0.81055, 0.77892, 0.97447, 0.82577, 0.97466, 0.87179, 0.95958, 0.77892, 0.94252, 0.95612, 0.8753, 1.02988, 0.92733, 0.94252, 0.87411, 0.84021, 0.8728, 0.95612, 0.74081, 0.8753, 1.02189, 1.02988, 0.84814, 0.87445, 0.91822, 0.84723, 0.85668, 0.86331, 0.81344, 0.87581, 0.76422, 0.82046, 0.96057, 0.92733, 0.99375, 0.78022, 0.95452, 0.86015, 1.02988, 0.92733, 0.86331, 0.92733, 0.86015, 0.73133, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90631, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.88323, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.85174, 1, 1, 1, 1, 1, 1, 0.96068, 0.95794, 0.96068, 0.95794, 0.96068, 0.95794, 0.77892, 0.84548, 1, 1, 0.89552, 0.90527, 1, 0.90363, 0.92794, 0.92794, 0.92794, 0.89807, 0.87012, 0.87012, 0.87012, 0.89552, 0.89552, 1.42259, 0.71094, 1.06152, 1, 1, 1.03372, 1.03372, 0.97171, 1.4956, 2.2807, 0.92972, 0.83406, 0.91133, 0.83326, 0.91133, 1, 1, 1, 0.72021, 1, 1.23108, 0.83489, 0.88525, 0.88525, 0.81499, 0.90616, 1.81055, 0.90527, 1.81055, 1.3107, 1.53711, 0.94434, 1.08696, 1, 0.95018, 0.77192, 0.85284, 0.90747, 1.17534, 0.69825, 0.9716, 1.37077, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.08004, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90727, 0.90727, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    An = { lineHeight: 1.2207, lineGap: 0.2207 };
    xn = [1.3877, 1, 1, 1, 1.17223, 1.1293, 0.89552, 0.91133, 0.80395, 1.02269, 1.15601, 0.91056, 0.91056, 1.2798, 0.85284, 0.89807, 1, 0.90861, 1.39543, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.96309, 0.96309, 0.85284, 0.85284, 0.85284, 0.83319, 0.88071, 0.8675, 0.81552, 0.72346, 0.85193, 0.73206, 0.7522, 0.81105, 0.86275, 0.90685, 0.6377, 0.77892, 0.75593, 1.02638, 0.89249, 0.84118, 0.77452, 0.85374, 0.75186, 0.67789, 0.79776, 0.88844, 0.85066, 0.94309, 0.77818, 0.7306, 0.76659, 1.10369, 1.38313, 1.10369, 1.06139, 0.89552, 0.8739, 0.9245, 0.9245, 0.83203, 0.9245, 0.85865, 1.09842, 0.9245, 0.9245, 1.03297, 1.07692, 0.90918, 1.03297, 0.94959, 0.9245, 0.92274, 0.9245, 0.9245, 1.02933, 0.77832, 1.20562, 0.9245, 0.8916, 0.98986, 0.86621, 0.89453, 0.79004, 0.94152, 1.77256, 0.94152, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.91729, 0.89552, 1.17889, 1.13254, 1.16359, 0.92098, 0.85284, 0.68787, 0.71353, 0.84737, 0.90747, 1.0088, 1.0044, 0.87683, 1, 1.09091, 1, 0.92229, 0.739, 1.15642, 0.92098, 0.76288, 0.80504, 0.80972, 0.75859, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.76318, 0.72346, 0.73206, 0.73206, 0.73206, 0.73206, 0.90685, 0.90685, 0.90685, 0.90685, 0.86477, 0.89249, 0.84118, 0.84118, 0.84118, 0.84118, 0.84118, 0.85284, 0.84557, 0.88844, 0.88844, 0.88844, 0.88844, 0.7306, 0.77452, 0.86331, 0.9245, 0.9245, 0.9245, 0.9245, 0.9245, 0.9245, 0.84843, 0.83203, 0.85865, 0.85865, 0.85865, 0.85865, 0.82601, 0.82601, 0.82601, 0.82601, 0.94469, 0.9245, 0.92274, 0.92274, 0.92274, 0.92274, 0.92274, 0.90747, 0.86651, 0.9245, 0.9245, 0.9245, 0.9245, 0.89453, 0.9245, 0.89453, 0.8675, 0.9245, 0.8675, 0.9245, 0.8675, 0.9245, 0.72346, 0.83203, 0.72346, 0.83203, 0.72346, 0.83203, 0.72346, 0.83203, 0.85193, 0.8875, 0.86477, 0.99034, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.81105, 0.9245, 0.81105, 0.9245, 0.81105, 0.9245, 1, 1, 0.86275, 0.9245, 0.90872, 0.93591, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 1.03297, 0.90685, 0.82601, 0.77896, 1.05611, 0.6377, 1.07692, 1, 1, 0.90918, 0.75593, 1.03297, 1, 1, 0.76032, 0.9375, 0.98156, 0.93407, 0.77261, 1.11429, 0.89249, 0.9245, 1, 1, 0.89249, 0.9245, 0.92534, 0.86698, 0.9245, 0.84118, 0.92274, 0.84118, 0.92274, 0.84118, 0.92274, 0.8667, 0.86291, 0.75186, 1.02933, 1, 1, 0.75186, 1.02933, 0.67789, 0.77832, 0.67789, 0.77832, 0.67789, 0.77832, 0.67789, 0.77832, 1, 1, 0.79776, 0.97655, 0.79776, 1.23023, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.94309, 0.98986, 0.7306, 0.89453, 0.7306, 0.76659, 0.79004, 0.76659, 0.79004, 0.76659, 0.79004, 1.09231, 0.54873, 0.8675, 0.9245, 0.76318, 0.84843, 0.84557, 0.86651, 1, 1, 0.79776, 1.20562, 1.18622, 1.18622, 1, 1.1437, 0.67009, 0.96334, 0.93695, 1.35191, 1.40909, 0.95161, 1.48387, 0.8675, 0.90861, 0.6192, 0.7363, 0.64824, 0.82411, 0.56321, 0.85696, 1.23516, 0.8675, 0.81552, 0.7286, 0.84134, 0.73206, 0.76659, 0.86275, 0.84369, 0.90685, 0.77892, 0.85871, 1.02638, 0.89249, 0.75828, 0.84118, 0.85984, 0.77452, 0.76466, 0.79776, 0.7306, 0.90782, 0.77818, 0.903, 0.87291, 0.90685, 0.7306, 0.99058, 1.03667, 0.94635, 1.23516, 0.9849, 0.99058, 0.92393, 0.8916, 0.942, 1.03667, 0.75026, 0.94635, 1.0297, 1.23516, 0.90918, 0.94048, 0.98217, 0.89746, 0.84153, 0.92274, 0.82507, 0.88832, 0.84438, 0.88178, 1.03525, 0.9849, 1.00225, 0.78086, 0.97248, 0.89404, 1.23516, 0.9849, 0.92274, 0.9849, 0.89404, 0.73206, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89693, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.85865, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90933, 1, 1, 1, 1, 1, 1, 0.94309, 0.98986, 0.94309, 0.98986, 0.94309, 0.98986, 0.7306, 0.89453, 1, 1, 0.89552, 0.90527, 1, 0.90186, 1.12308, 1.12308, 1.12308, 1.12308, 1.2566, 1.2566, 1.2566, 0.89552, 0.89552, 1.42259, 0.68994, 1.03809, 1, 1, 1.0176, 1.0176, 1.11523, 1.4956, 2.01462, 0.97858, 0.82616, 0.91133, 0.83437, 0.91133, 1, 1, 1, 0.70508, 1, 1.23108, 0.79801, 0.84426, 0.84426, 0.774, 0.90572, 1.81055, 0.90749, 1.81055, 1.28809, 1.55469, 0.94434, 1.07806, 1, 0.97094, 0.7589, 0.85284, 0.90747, 1.19658, 0.69825, 0.97622, 1.33512, 0.90747, 0.90747, 0.85284, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.0336, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05859, 1.05859, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    Sn = { lineHeight: 1.2207, lineGap: 0.2207 };
    vn = [1.3877, 1, 1, 1, 1.17223, 1.1293, 0.89552, 0.91133, 0.80395, 1.02269, 1.15601, 0.91056, 0.91056, 1.2798, 0.85284, 0.89807, 1, 0.90861, 1.39016, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.96309, 0.96309, 0.85284, 0.85284, 0.85284, 0.83319, 0.88071, 0.8675, 0.81552, 0.73834, 0.85193, 0.73206, 0.7522, 0.81105, 0.86275, 0.90685, 0.6377, 0.77892, 0.75593, 1.02638, 0.89385, 0.85122, 0.77452, 0.86503, 0.75186, 0.68887, 0.79776, 0.88844, 0.85066, 0.94258, 0.77818, 0.7306, 0.76659, 1.10369, 1.39016, 1.10369, 1.06139, 0.89552, 0.8739, 0.86128, 0.94469, 0.8457, 0.94469, 0.89464, 1.09842, 0.84636, 0.94469, 1.03297, 1.07692, 0.90918, 1.03297, 0.95897, 0.94469, 0.9482, 0.94469, 0.94469, 1.04692, 0.78223, 1.20562, 0.94469, 0.90332, 0.98986, 0.86621, 0.90527, 0.79004, 0.94152, 1.77256, 0.94152, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.91729, 0.89552, 1.17889, 1.13254, 1.08707, 0.92098, 0.85284, 0.68787, 0.71353, 0.84737, 0.90747, 1.0088, 1.0044, 0.87683, 1, 1.09091, 1, 0.92229, 0.739, 1.15642, 0.92098, 0.76288, 0.80504, 0.80972, 0.75859, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.76318, 0.73834, 0.73206, 0.73206, 0.73206, 0.73206, 0.90685, 0.90685, 0.90685, 0.90685, 0.86477, 0.89385, 0.85122, 0.85122, 0.85122, 0.85122, 0.85122, 0.85284, 0.85311, 0.88844, 0.88844, 0.88844, 0.88844, 0.7306, 0.77452, 0.86331, 0.86128, 0.86128, 0.86128, 0.86128, 0.86128, 0.86128, 0.8693, 0.8457, 0.89464, 0.89464, 0.89464, 0.89464, 0.82601, 0.82601, 0.82601, 0.82601, 0.94469, 0.94469, 0.9482, 0.9482, 0.9482, 0.9482, 0.9482, 0.90747, 0.86651, 0.94469, 0.94469, 0.94469, 0.94469, 0.90527, 0.94469, 0.90527, 0.8675, 0.86128, 0.8675, 0.86128, 0.8675, 0.86128, 0.73834, 0.8457, 0.73834, 0.8457, 0.73834, 0.8457, 0.73834, 0.8457, 0.85193, 0.92454, 0.86477, 0.9921, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.81105, 0.84636, 0.81105, 0.84636, 0.81105, 0.84636, 1, 1, 0.86275, 0.94469, 0.90872, 0.95786, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 1.03297, 0.90685, 0.82601, 0.77741, 1.05611, 0.6377, 1.07692, 1, 1, 0.90918, 0.75593, 1.03297, 1, 1, 0.76032, 0.90452, 0.98156, 1.11842, 0.77261, 1.11429, 0.89385, 0.94469, 1, 1, 0.89385, 0.94469, 0.95877, 0.86901, 0.94469, 0.85122, 0.9482, 0.85122, 0.9482, 0.85122, 0.9482, 0.8667, 0.90016, 0.75186, 1.04692, 1, 1, 0.75186, 1.04692, 0.68887, 0.78223, 0.68887, 0.78223, 0.68887, 0.78223, 0.68887, 0.78223, 1, 1, 0.79776, 0.92188, 0.79776, 1.23023, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.94258, 0.98986, 0.7306, 0.90527, 0.7306, 0.76659, 0.79004, 0.76659, 0.79004, 0.76659, 0.79004, 1.09231, 0.54873, 0.8675, 0.86128, 0.76318, 0.8693, 0.85311, 0.86651, 1, 1, 0.79776, 1.20562, 1.18622, 1.18622, 1, 1.1437, 0.67742, 0.96334, 0.93695, 1.35191, 1.40909, 0.95161, 1.48387, 0.86686, 0.90861, 0.62267, 0.74359, 0.65649, 0.85498, 0.56963, 0.88254, 1.23516, 0.8675, 0.81552, 0.75443, 0.84503, 0.73206, 0.76659, 0.86275, 0.85122, 0.90685, 0.77892, 0.85746, 1.02638, 0.89385, 0.75657, 0.85122, 0.86275, 0.77452, 0.74171, 0.79776, 0.7306, 0.95165, 0.77818, 0.89772, 0.88831, 0.90685, 0.7306, 0.98142, 1.02191, 0.96576, 1.23516, 0.99018, 0.98142, 0.9236, 0.89258, 0.94035, 1.02191, 0.78848, 0.96576, 0.9561, 1.23516, 0.90918, 0.92578, 0.95424, 0.89746, 0.83969, 0.9482, 0.80113, 0.89442, 0.85208, 0.86155, 0.98022, 0.99018, 1.00452, 0.81209, 0.99247, 0.89181, 1.23516, 0.99018, 0.9482, 0.99018, 0.89181, 0.73206, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.88844, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89464, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.96766, 1, 1, 1, 1, 1, 1, 0.94258, 0.98986, 0.94258, 0.98986, 0.94258, 0.98986, 0.7306, 0.90527, 1, 1, 0.89552, 0.90527, 1, 0.90186, 1.12308, 1.12308, 1.12308, 1.12308, 1.2566, 1.2566, 1.2566, 0.89552, 0.89552, 1.42259, 0.69043, 1.03809, 1, 1, 1.0176, 1.0176, 1.11523, 1.4956, 2.01462, 0.99331, 0.82616, 0.91133, 0.84286, 0.91133, 1, 1, 1, 0.70508, 1, 1.23108, 0.79801, 0.84426, 0.84426, 0.774, 0.90527, 1.81055, 0.90527, 1.81055, 1.28809, 1.55469, 0.94434, 1.07806, 1, 0.97094, 0.7589, 0.85284, 0.90747, 1.19658, 0.69825, 0.97622, 1.33512, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.0336, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05859, 1.05859, 1, 1, 1, 1.07185, 0.99413, 0.96334, 1.08065, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    Cn = { lineHeight: 1.2207, lineGap: 0.2207 };
    kn = [0.76116, 1, 1, 1.0006, 0.99998, 0.99974, 0.99973, 0.99973, 0.99982, 0.99977, 1.00087, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.00003, 1.00003, 1.00003, 1.00026, 0.9999, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 0.99973, 0.99977, 1.00026, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 0.99998, 1.0006, 0.99998, 1.00003, 0.99973, 0.99998, 0.99973, 1.00026, 0.99973, 1.00026, 0.99973, 0.99998, 1.00026, 1.00026, 1.0006, 1.0006, 0.99973, 1.0006, 0.99982, 1.00026, 1.00026, 1.00026, 1.00026, 0.99959, 0.99973, 0.99998, 1.00026, 0.99973, 1.00022, 0.99973, 0.99973, 1, 0.99959, 1.00077, 0.99959, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.00077, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.99973, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.06409, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 0.99973, 1.00026, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 1.03374, 0.99977, 1.00026, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.00042, 0.99973, 0.99973, 1.0006, 0.99977, 0.99973, 0.99973, 1.00026, 1.0006, 1.00026, 1.0006, 1.00026, 1.03828, 1.00026, 0.99999, 1.00026, 1.0006, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.9993, 0.9998, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1, 1.00016, 0.99977, 0.99959, 0.99977, 0.99959, 0.99977, 0.99959, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00026, 0.99998, 1.00026, 0.8121, 1.00026, 0.99998, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.00016, 1.00022, 1.00001, 0.99973, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 1.0006, 0.99973, 0.99977, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 0.99973, 1.00026, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 1.00034, 0.99977, 1, 0.99997, 1.00026, 1.00078, 1.00036, 0.99973, 1.00013, 1.0006, 0.99977, 0.99977, 0.99988, 0.85148, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 0.99977, 1.00001, 0.99999, 0.99977, 1.00069, 1.00022, 0.99977, 1.00001, 0.99984, 1.00026, 1.00001, 1.00024, 1.00001, 0.9999, 1, 1.0006, 1.00001, 1.00041, 0.99962, 1.00026, 1.0006, 0.99995, 1.00041, 0.99942, 0.99973, 0.99927, 1.00082, 0.99902, 1.00026, 1.00087, 1.0006, 1.00069, 0.99973, 0.99867, 0.99973, 0.9993, 1.00026, 1.00049, 1.00056, 1, 0.99988, 0.99935, 0.99995, 0.99954, 1.00055, 0.99945, 1.00032, 1.0006, 0.99995, 1.00026, 0.99995, 1.00032, 1.00001, 1.00008, 0.99971, 1.00019, 0.9994, 1.00001, 1.0006, 1.00044, 0.99973, 1.00023, 1.00047, 1, 0.99942, 0.99561, 0.99989, 1.00035, 0.99977, 1.00035, 0.99977, 1.00019, 0.99944, 1.00001, 1.00021, 0.99926, 1.00035, 1.00035, 0.99942, 1.00048, 0.99999, 0.99977, 1.00022, 1.00035, 1.00001, 0.99977, 1.00026, 0.99989, 1.00057, 1.00001, 0.99936, 1.00052, 1.00012, 0.99996, 1.00043, 1, 1.00035, 0.9994, 0.99976, 1.00035, 0.99973, 1.00052, 1.00041, 1.00119, 1.00037, 0.99973, 1.00002, 0.99986, 1.00041, 1.00041, 0.99902, 0.9996, 1.00034, 0.99999, 1.00026, 0.99999, 1.00026, 0.99973, 1.00052, 0.99973, 1, 0.99973, 1.00041, 1.00075, 0.9994, 1.0003, 0.99999, 1, 1.00041, 0.99955, 1, 0.99915, 0.99973, 0.99973, 1.00026, 1.00119, 0.99955, 0.99973, 1.0006, 0.99911, 1.0006, 1.00026, 0.99972, 1.00026, 0.99902, 1.00041, 0.99973, 0.99999, 1, 1, 1.00038, 1.0005, 1.00016, 1.00022, 1.00016, 1.00022, 1.00016, 1.00022, 1.00001, 0.99973, 1, 1, 0.99973, 1, 1, 0.99955, 1.0006, 1.0006, 1.0006, 1.0006, 1, 1, 1, 0.99973, 0.99973, 0.99972, 1, 1, 1.00106, 0.99999, 0.99998, 0.99998, 0.99999, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 0.99971, 1.00047, 1.00023, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1, 1, 1, 1, 1, 1, 1, 0.99972, 1, 1.20985, 1.39713, 1.00003, 1.00031, 1.00015, 1, 0.99561, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.99972, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    Tn = { lineHeight: 1.2, lineGap: 0.2 };
    In = [0.76116, 1, 1, 1.0006, 0.99998, 0.99974, 0.99973, 0.99973, 0.99982, 0.99977, 1.00087, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.00003, 1.00003, 1.00003, 1.00026, 0.9999, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 0.99973, 0.99977, 1.00026, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 0.99998, 1.0006, 0.99998, 1.00003, 0.99973, 0.99998, 0.99973, 1.00026, 0.99973, 1.00026, 0.99973, 0.99998, 1.00026, 1.00026, 1.0006, 1.0006, 0.99973, 1.0006, 0.99982, 1.00026, 1.00026, 1.00026, 1.00026, 0.99959, 0.99973, 0.99998, 1.00026, 0.99973, 1.00022, 0.99973, 0.99973, 1, 0.99959, 1.00077, 0.99959, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.00077, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.99973, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.06409, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 0.99973, 1.00026, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 1.0044, 0.99977, 1.00026, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99971, 0.99973, 0.99973, 1.0006, 0.99977, 0.99973, 0.99973, 1.00026, 1.0006, 1.00026, 1.0006, 1.00026, 1.01011, 1.00026, 0.99999, 1.00026, 1.0006, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.9993, 0.9998, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1, 1.00016, 0.99977, 0.99959, 0.99977, 0.99959, 0.99977, 0.99959, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00026, 0.99998, 1.00026, 0.8121, 1.00026, 0.99998, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.00016, 1.00022, 1.00001, 0.99973, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 1.0006, 0.99973, 0.99977, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 0.99973, 1.00026, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99977, 1, 1, 1.00026, 0.99969, 0.99972, 0.99981, 0.9998, 1.0006, 0.99977, 0.99977, 1.00022, 0.91155, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 0.99977, 1.00001, 0.99999, 0.99977, 0.99966, 1.00022, 1.00032, 1.00001, 0.99944, 1.00026, 1.00001, 0.99968, 1.00001, 1.00047, 1, 1.0006, 1.00001, 0.99981, 1.00101, 1.00026, 1.0006, 0.99948, 0.99981, 1.00064, 0.99973, 0.99942, 1.00101, 1.00061, 1.00026, 1.00069, 1.0006, 1.00014, 0.99973, 1.01322, 0.99973, 1.00065, 1.00026, 1.00012, 0.99923, 1, 1.00064, 1.00076, 0.99948, 1.00055, 1.00063, 1.00007, 0.99943, 1.0006, 0.99948, 1.00026, 0.99948, 0.99943, 1.00001, 1.00001, 1.00029, 1.00038, 1.00035, 1.00001, 1.0006, 1.0006, 0.99973, 0.99978, 1.00001, 1.00057, 0.99989, 0.99967, 0.99964, 0.99967, 0.99977, 0.99999, 0.99977, 1.00038, 0.99977, 1.00001, 0.99973, 1.00066, 0.99967, 0.99967, 1.00041, 0.99998, 0.99999, 0.99977, 1.00022, 0.99967, 1.00001, 0.99977, 1.00026, 0.99964, 1.00031, 1.00001, 0.99999, 0.99999, 1, 1.00023, 1, 1, 0.99999, 1.00035, 1.00001, 0.99999, 0.99973, 0.99977, 0.99999, 1.00058, 0.99973, 0.99973, 0.99955, 0.9995, 1.00026, 1.00026, 1.00032, 0.99989, 1.00034, 0.99999, 1.00026, 1.00026, 1.00026, 0.99973, 0.45998, 0.99973, 1.00026, 0.99973, 1.00001, 0.99999, 0.99982, 0.99994, 0.99996, 1, 1.00042, 1.00044, 1.00029, 1.00023, 0.99973, 0.99973, 1.00026, 0.99949, 1.00002, 0.99973, 1.0006, 1.0006, 1.0006, 0.99975, 1.00026, 1.00026, 1.00032, 0.98685, 0.99973, 1.00026, 1, 1, 0.99966, 1.00044, 1.00016, 1.00022, 1.00016, 1.00022, 1.00016, 1.00022, 1.00001, 0.99973, 1, 1, 0.99973, 1, 1, 0.99955, 1.0006, 1.0006, 1.0006, 1.0006, 1, 1, 1, 0.99973, 0.99973, 0.99972, 1, 1, 1.00106, 0.99999, 0.99998, 0.99998, 0.99999, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1, 0.99973, 0.99971, 0.99978, 1, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1.00098, 1, 1, 1, 1.00049, 1, 1, 0.99972, 1, 1.20985, 1.39713, 1.00003, 1.00031, 1.00015, 1, 0.99561, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.99972, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    Fn = { lineHeight: 1.35, lineGap: 0.2 };
    Mn = [0.76116, 1, 1, 1.0006, 1.0006, 1.00006, 0.99973, 0.99973, 0.99982, 1.00001, 1.00043, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1, 1.00003, 1.00003, 1.00003, 0.99973, 0.99987, 1.00001, 1.00001, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 1, 1.00001, 0.99973, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 1.0006, 1.0006, 1.0006, 0.99949, 0.99973, 0.99998, 0.99973, 0.99973, 1, 0.99973, 0.99973, 1.0006, 0.99973, 0.99973, 0.99924, 0.99924, 1, 0.99924, 0.99999, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.0006, 0.99973, 1, 0.99977, 1, 1, 1, 1.00005, 1.0009, 1.00005, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.0009, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.9998, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 1, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.06409, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 1, 0.99973, 1, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1.0288, 0.99977, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99924, 1.0006, 1.0006, 0.99946, 1.00034, 1, 0.99924, 1.00001, 1, 1, 0.99973, 0.99924, 0.99973, 0.99924, 0.99973, 1.06311, 0.99973, 1.00024, 0.99973, 0.99924, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00041, 0.9998, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1, 1.00016, 0.99977, 0.99998, 0.99977, 0.99998, 0.99977, 0.99998, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00026, 1.0006, 1.00026, 0.89547, 1.00026, 1.0006, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00016, 0.99977, 1.00001, 1, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 0.99924, 0.99973, 1.00001, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 1, 1.00026, 1.0006, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 1.00001, 1, 1.00054, 0.99977, 1.00084, 1.00007, 0.99973, 1.00013, 0.99924, 1.00001, 1.00001, 0.99945, 0.91221, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 1.00001, 1.00001, 0.99999, 0.99977, 0.99933, 1.00022, 1.00054, 1.00001, 1.00065, 1.00026, 1.00001, 1.0001, 1.00001, 1.00052, 1, 1.0006, 1.00001, 0.99945, 0.99897, 0.99968, 0.99924, 1.00036, 0.99945, 0.99949, 1, 1.0006, 0.99897, 0.99918, 0.99968, 0.99911, 0.99924, 1, 0.99962, 1.01487, 1, 1.0005, 0.99973, 1.00012, 1.00043, 1, 0.99995, 0.99994, 1.00036, 0.99947, 1.00019, 1.00063, 1.00025, 0.99924, 1.00036, 0.99973, 1.00036, 1.00025, 1.00001, 1.00001, 1.00027, 1.0001, 1.00068, 1.00001, 1.0006, 1.0006, 1, 1.00008, 0.99957, 0.99972, 0.9994, 0.99954, 0.99975, 1.00051, 1.00001, 1.00019, 1.00001, 1.0001, 0.99986, 1.00001, 1.00001, 1.00038, 0.99954, 0.99954, 0.9994, 1.00066, 0.99999, 0.99977, 1.00022, 1.00054, 1.00001, 0.99977, 1.00026, 0.99975, 1.0001, 1.00001, 0.99993, 0.9995, 0.99955, 1.00016, 0.99978, 0.99974, 1.00019, 1.00022, 0.99955, 1.00053, 0.99973, 1.00089, 1.00005, 0.99967, 1.00048, 0.99973, 1.00002, 1.00034, 0.99973, 0.99973, 0.99964, 1.00006, 1.00066, 0.99947, 0.99973, 0.98894, 0.99973, 1, 0.44898, 1, 0.99946, 1, 1.00039, 1.00082, 0.99991, 0.99991, 0.99985, 1.00022, 1.00023, 1.00061, 1.00006, 0.99966, 0.99973, 0.99973, 0.99973, 1.00019, 1.0008, 1, 0.99924, 0.99924, 0.99924, 0.99983, 1.00044, 0.99973, 0.99964, 0.98332, 1, 0.99973, 1, 1, 0.99962, 0.99895, 1.00016, 0.99977, 1.00016, 0.99977, 1.00016, 0.99977, 1.00001, 1, 1, 1, 0.99973, 1, 1, 0.99955, 0.99924, 0.99924, 0.99924, 0.99924, 0.99998, 0.99998, 0.99998, 0.99973, 0.99973, 0.99972, 1, 1, 1.00267, 0.99999, 0.99998, 0.99998, 1, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 1.00423, 0.99925, 0.99999, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1.00049, 1, 1.00245, 1, 1, 1, 1, 0.96329, 1, 1.20985, 1.39713, 1.00003, 0.8254, 1.00015, 1, 1.00035, 1.00027, 1.00031, 1.00031, 1.00003, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.95317, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    Dn = { lineHeight: 1.35, lineGap: 0.2 };
    En = [0.76116, 1, 1, 1.0006, 1.0006, 1.00006, 0.99973, 0.99973, 0.99982, 1.00001, 1.00043, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1, 1.00003, 1.00003, 1.00003, 0.99973, 0.99987, 1.00001, 1.00001, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 1, 1.00001, 0.99973, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 1.0006, 1.0006, 1.0006, 0.99949, 0.99973, 0.99998, 0.99973, 0.99973, 1, 0.99973, 0.99973, 1.0006, 0.99973, 0.99973, 0.99924, 0.99924, 1, 0.99924, 0.99999, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.0006, 0.99973, 1, 0.99977, 1, 1, 1, 1.00005, 1.0009, 1.00005, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.0009, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.9998, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 1, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.06409, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 1, 0.99973, 1, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1.04596, 0.99977, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99924, 1.0006, 1.0006, 1.00019, 1.00034, 1, 0.99924, 1.00001, 1, 1, 0.99973, 0.99924, 0.99973, 0.99924, 0.99973, 1.02572, 0.99973, 1.00005, 0.99973, 0.99924, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99999, 0.9998, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1, 1.00016, 0.99977, 0.99998, 0.99977, 0.99998, 0.99977, 0.99998, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00026, 1.0006, 1.00026, 0.84533, 1.00026, 1.0006, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00016, 0.99977, 1.00001, 1, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 0.99924, 0.99973, 1.00001, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 1, 1.00026, 1.0006, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99928, 1, 0.99977, 1.00013, 1.00055, 0.99947, 0.99945, 0.99941, 0.99924, 1.00001, 1.00001, 1.0004, 0.91621, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 1.00001, 1.00005, 0.99999, 0.99977, 1.00015, 1.00022, 0.99977, 1.00001, 0.99973, 1.00026, 1.00001, 1.00019, 1.00001, 0.99946, 1, 1.0006, 1.00001, 0.99978, 1.00045, 0.99973, 0.99924, 1.00023, 0.99978, 0.99966, 1, 1.00065, 1.00045, 1.00019, 0.99973, 0.99973, 0.99924, 1, 1, 0.96499, 1, 1.00055, 0.99973, 1.00008, 1.00027, 1, 0.9997, 0.99995, 1.00023, 0.99933, 1.00019, 1.00015, 1.00031, 0.99924, 1.00023, 0.99973, 1.00023, 1.00031, 1.00001, 0.99928, 1.00029, 1.00092, 1.00035, 1.00001, 1.0006, 1.0006, 1, 0.99988, 0.99975, 1, 1.00082, 0.99561, 0.9996, 1.00035, 1.00001, 0.99962, 1.00001, 1.00092, 0.99964, 1.00001, 0.99963, 0.99999, 1.00035, 1.00035, 1.00082, 0.99962, 0.99999, 0.99977, 1.00022, 1.00035, 1.00001, 0.99977, 1.00026, 0.9996, 0.99967, 1.00001, 1.00034, 1.00074, 1.00054, 1.00053, 1.00063, 0.99971, 0.99962, 1.00035, 0.99975, 0.99977, 0.99973, 1.00043, 0.99953, 1.0007, 0.99915, 0.99973, 1.00008, 0.99892, 1.00073, 1.00073, 1.00114, 0.99915, 1.00073, 0.99955, 0.99973, 1.00092, 0.99973, 1, 0.99998, 1, 1.0003, 1, 1.00043, 1.00001, 0.99969, 1.0003, 1, 1.00035, 1.00001, 0.9995, 1, 1.00092, 0.99973, 0.99973, 0.99973, 1.0007, 0.9995, 1, 0.99924, 1.0006, 0.99924, 0.99972, 1.00062, 0.99973, 1.00114, 1.00073, 1, 0.99955, 1, 1, 1.00047, 0.99968, 1.00016, 0.99977, 1.00016, 0.99977, 1.00016, 0.99977, 1.00001, 1, 1, 1, 0.99973, 1, 1, 0.99955, 0.99924, 0.99924, 0.99924, 0.99924, 0.99998, 0.99998, 0.99998, 0.99973, 0.99973, 0.99972, 1, 1, 1.00267, 0.99999, 0.99998, 0.99998, 1, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 0.99971, 0.99925, 1.00023, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1, 1, 1, 1, 1, 1, 1, 0.96329, 1, 1.20985, 1.39713, 1.00003, 0.8254, 1.00015, 1, 1.00035, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.95317, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    On = { lineHeight: 1.2, lineGap: 0.2 };
    _n2 = [365, 0, 333, 278, 333, 474, 556, 556, 889, 722, 238, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 333, 333, 584, 584, 584, 611, 975, 722, 722, 722, 722, 667, 611, 778, 722, 278, 556, 722, 611, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 333, 278, 333, 584, 556, 333, 556, 611, 556, 611, 556, 333, 611, 611, 278, 278, 556, 278, 889, 611, 611, 611, 611, 389, 556, 333, 611, 556, 778, 556, 556, 500, 389, 280, 389, 584, 333, 556, 556, 556, 556, 280, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 556, 278, 333, 333, 365, 556, 834, 834, 834, 611, 722, 722, 722, 722, 722, 722, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 556, 556, 556, 556, 556, 278, 278, 278, 278, 611, 611, 611, 611, 611, 611, 611, 549, 611, 611, 611, 611, 611, 556, 611, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 719, 722, 611, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 611, 778, 611, 778, 611, 778, 611, 722, 611, 722, 611, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 785, 556, 556, 278, 722, 556, 556, 611, 278, 611, 278, 611, 385, 611, 479, 611, 278, 722, 611, 722, 611, 722, 611, 708, 723, 611, 778, 611, 778, 611, 778, 611, 1e3, 944, 722, 389, 722, 389, 722, 389, 667, 556, 667, 556, 667, 556, 667, 556, 611, 333, 611, 479, 611, 333, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 944, 778, 667, 556, 667, 611, 500, 611, 500, 611, 500, 278, 556, 722, 556, 1e3, 889, 778, 611, 667, 556, 611, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 465, 722, 333, 853, 906, 474, 825, 927, 838, 278, 722, 722, 601, 719, 667, 611, 722, 778, 278, 722, 667, 833, 722, 644, 778, 722, 667, 600, 611, 667, 821, 667, 809, 802, 278, 667, 615, 451, 611, 278, 582, 615, 610, 556, 606, 475, 460, 611, 541, 278, 558, 556, 612, 556, 445, 611, 766, 619, 520, 684, 446, 582, 715, 576, 753, 845, 278, 582, 611, 582, 845, 667, 669, 885, 567, 711, 667, 278, 276, 556, 1094, 1062, 875, 610, 722, 622, 719, 722, 719, 722, 567, 712, 667, 904, 626, 719, 719, 610, 702, 833, 722, 778, 719, 667, 722, 611, 622, 854, 667, 730, 703, 1005, 1019, 870, 979, 719, 711, 1031, 719, 556, 618, 615, 417, 635, 556, 709, 497, 615, 615, 500, 635, 740, 604, 611, 604, 611, 556, 490, 556, 875, 556, 615, 581, 833, 844, 729, 854, 615, 552, 854, 583, 556, 556, 611, 417, 552, 556, 278, 281, 278, 969, 906, 611, 500, 615, 556, 604, 778, 611, 487, 447, 944, 778, 944, 778, 944, 778, 667, 556, 333, 333, 556, 1e3, 1e3, 552, 278, 278, 278, 278, 500, 500, 500, 556, 556, 350, 1e3, 1e3, 240, 479, 333, 333, 604, 333, 167, 396, 556, 556, 1094, 556, 885, 489, 1115, 1e3, 768, 600, 834, 834, 834, 834, 1e3, 500, 1e3, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 722, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 611, 611, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 333, 333, 333, 333, 333, 333, 333, 333];
    Pn = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
    Rn = [365, 0, 333, 278, 333, 474, 556, 556, 889, 722, 238, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 333, 333, 584, 584, 584, 611, 975, 722, 722, 722, 722, 667, 611, 778, 722, 278, 556, 722, 611, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 333, 278, 333, 584, 556, 333, 556, 611, 556, 611, 556, 333, 611, 611, 278, 278, 556, 278, 889, 611, 611, 611, 611, 389, 556, 333, 611, 556, 778, 556, 556, 500, 389, 280, 389, 584, 333, 556, 556, 556, 556, 280, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 556, 278, 333, 333, 365, 556, 834, 834, 834, 611, 722, 722, 722, 722, 722, 722, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 556, 556, 556, 556, 556, 278, 278, 278, 278, 611, 611, 611, 611, 611, 611, 611, 549, 611, 611, 611, 611, 611, 556, 611, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 740, 722, 611, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 611, 778, 611, 778, 611, 778, 611, 722, 611, 722, 611, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 782, 556, 556, 278, 722, 556, 556, 611, 278, 611, 278, 611, 396, 611, 479, 611, 278, 722, 611, 722, 611, 722, 611, 708, 723, 611, 778, 611, 778, 611, 778, 611, 1e3, 944, 722, 389, 722, 389, 722, 389, 667, 556, 667, 556, 667, 556, 667, 556, 611, 333, 611, 479, 611, 333, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 944, 778, 667, 556, 667, 611, 500, 611, 500, 611, 500, 278, 556, 722, 556, 1e3, 889, 778, 611, 667, 556, 611, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 722, 333, 854, 906, 473, 844, 930, 847, 278, 722, 722, 610, 671, 667, 611, 722, 778, 278, 722, 667, 833, 722, 657, 778, 718, 667, 590, 611, 667, 822, 667, 829, 781, 278, 667, 620, 479, 611, 278, 591, 620, 621, 556, 610, 479, 492, 611, 558, 278, 566, 556, 603, 556, 450, 611, 712, 605, 532, 664, 409, 591, 704, 578, 773, 834, 278, 591, 611, 591, 834, 667, 667, 886, 614, 719, 667, 278, 278, 556, 1094, 1042, 854, 622, 719, 677, 719, 722, 708, 722, 614, 722, 667, 927, 643, 719, 719, 615, 687, 833, 722, 778, 719, 667, 722, 611, 677, 781, 667, 729, 708, 979, 989, 854, 1e3, 708, 719, 1042, 729, 556, 619, 604, 534, 618, 556, 736, 510, 611, 611, 507, 622, 740, 604, 611, 611, 611, 556, 889, 556, 885, 556, 646, 583, 889, 935, 707, 854, 594, 552, 865, 589, 556, 556, 611, 469, 563, 556, 278, 278, 278, 969, 906, 611, 507, 619, 556, 611, 778, 611, 575, 467, 944, 778, 944, 778, 944, 778, 667, 556, 333, 333, 556, 1e3, 1e3, 552, 278, 278, 278, 278, 500, 500, 500, 556, 556, 350, 1e3, 1e3, 240, 479, 333, 333, 604, 333, 167, 396, 556, 556, 1104, 556, 885, 516, 1146, 1e3, 768, 600, 834, 834, 834, 834, 999, 500, 1e3, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 722, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 611, 611, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 333, 333, 333, 333, 333, 333, 333, 333];
    Bn = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
    Nn = [365, 0, 333, 278, 278, 355, 556, 556, 889, 667, 191, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 278, 278, 584, 584, 584, 556, 1015, 667, 667, 722, 722, 667, 611, 778, 722, 278, 500, 667, 556, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 278, 278, 278, 469, 556, 333, 556, 556, 500, 556, 556, 278, 556, 556, 222, 222, 500, 222, 833, 556, 556, 556, 556, 333, 500, 278, 556, 500, 722, 500, 500, 500, 334, 260, 334, 584, 333, 556, 556, 556, 556, 260, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 537, 278, 333, 333, 365, 556, 834, 834, 834, 611, 667, 667, 667, 667, 667, 667, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 500, 556, 556, 556, 556, 278, 278, 278, 278, 556, 556, 556, 556, 556, 556, 556, 549, 611, 556, 556, 556, 556, 500, 556, 500, 667, 556, 667, 556, 667, 556, 722, 500, 722, 500, 722, 500, 722, 500, 722, 625, 722, 556, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 556, 778, 556, 778, 556, 778, 556, 722, 556, 722, 556, 278, 278, 278, 278, 278, 278, 278, 222, 278, 278, 733, 444, 500, 222, 667, 500, 500, 556, 222, 556, 222, 556, 281, 556, 400, 556, 222, 722, 556, 722, 556, 722, 556, 615, 723, 556, 778, 556, 778, 556, 778, 556, 1e3, 944, 722, 333, 722, 333, 722, 333, 667, 500, 667, 500, 667, 500, 667, 500, 611, 278, 611, 354, 611, 278, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 944, 722, 667, 500, 667, 611, 500, 611, 500, 611, 500, 222, 556, 667, 556, 1e3, 889, 778, 611, 667, 500, 611, 278, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 667, 278, 789, 846, 389, 794, 865, 775, 222, 667, 667, 570, 671, 667, 611, 722, 778, 278, 667, 667, 833, 722, 648, 778, 725, 667, 600, 611, 667, 837, 667, 831, 761, 278, 667, 570, 439, 555, 222, 550, 570, 571, 500, 556, 439, 463, 555, 542, 222, 500, 492, 548, 500, 447, 556, 670, 573, 486, 603, 374, 550, 652, 546, 728, 779, 222, 550, 556, 550, 779, 667, 667, 843, 544, 708, 667, 278, 278, 500, 1066, 982, 844, 589, 715, 639, 724, 667, 651, 667, 544, 704, 667, 917, 614, 715, 715, 589, 686, 833, 722, 778, 725, 667, 722, 611, 639, 795, 667, 727, 673, 920, 923, 805, 886, 651, 694, 1022, 682, 556, 562, 522, 493, 553, 556, 688, 465, 556, 556, 472, 564, 686, 550, 556, 556, 556, 500, 833, 500, 835, 500, 572, 518, 830, 851, 621, 736, 526, 492, 752, 534, 556, 556, 556, 378, 496, 500, 222, 222, 222, 910, 828, 556, 472, 565, 500, 556, 778, 556, 492, 339, 944, 722, 944, 722, 944, 722, 667, 500, 333, 333, 556, 1e3, 1e3, 552, 222, 222, 222, 222, 333, 333, 333, 556, 556, 350, 1e3, 1e3, 188, 354, 333, 333, 500, 333, 167, 365, 556, 556, 1094, 556, 885, 323, 1083, 1e3, 768, 600, 834, 834, 834, 834, 1e3, 500, 998, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 719, 274, 549, 549, 584, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 500, 500, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 294, 294, 324, 324, 316, 328, 398, 285];
    Ln = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
    Un = [365, 0, 333, 278, 278, 355, 556, 556, 889, 667, 191, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 278, 278, 584, 584, 584, 556, 1015, 667, 667, 722, 722, 667, 611, 778, 722, 278, 500, 667, 556, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 278, 278, 278, 469, 556, 333, 556, 556, 500, 556, 556, 278, 556, 556, 222, 222, 500, 222, 833, 556, 556, 556, 556, 333, 500, 278, 556, 500, 722, 500, 500, 500, 334, 260, 334, 584, 333, 556, 556, 556, 556, 260, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 537, 278, 333, 333, 365, 556, 834, 834, 834, 611, 667, 667, 667, 667, 667, 667, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 500, 556, 556, 556, 556, 278, 278, 278, 278, 556, 556, 556, 556, 556, 556, 556, 549, 611, 556, 556, 556, 556, 500, 556, 500, 667, 556, 667, 556, 667, 556, 722, 500, 722, 500, 722, 500, 722, 500, 722, 615, 722, 556, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 556, 778, 556, 778, 556, 778, 556, 722, 556, 722, 556, 278, 278, 278, 278, 278, 278, 278, 222, 278, 278, 735, 444, 500, 222, 667, 500, 500, 556, 222, 556, 222, 556, 292, 556, 334, 556, 222, 722, 556, 722, 556, 722, 556, 604, 723, 556, 778, 556, 778, 556, 778, 556, 1e3, 944, 722, 333, 722, 333, 722, 333, 667, 500, 667, 500, 667, 500, 667, 500, 611, 278, 611, 375, 611, 278, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 944, 722, 667, 500, 667, 611, 500, 611, 500, 611, 500, 222, 556, 667, 556, 1e3, 889, 778, 611, 667, 500, 611, 278, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 667, 278, 784, 838, 384, 774, 855, 752, 222, 667, 667, 551, 668, 667, 611, 722, 778, 278, 667, 668, 833, 722, 650, 778, 722, 667, 618, 611, 667, 798, 667, 835, 748, 278, 667, 578, 446, 556, 222, 547, 578, 575, 500, 557, 446, 441, 556, 556, 222, 500, 500, 576, 500, 448, 556, 690, 569, 482, 617, 395, 547, 648, 525, 713, 781, 222, 547, 556, 547, 781, 667, 667, 865, 542, 719, 667, 278, 278, 500, 1057, 1010, 854, 583, 722, 635, 719, 667, 656, 667, 542, 677, 667, 923, 604, 719, 719, 583, 656, 833, 722, 778, 719, 667, 722, 611, 635, 760, 667, 740, 667, 917, 938, 792, 885, 656, 719, 1010, 722, 556, 573, 531, 365, 583, 556, 669, 458, 559, 559, 438, 583, 688, 552, 556, 542, 556, 500, 458, 500, 823, 500, 573, 521, 802, 823, 625, 719, 521, 510, 750, 542, 556, 556, 556, 365, 510, 500, 222, 278, 222, 906, 812, 556, 438, 559, 500, 552, 778, 556, 489, 411, 944, 722, 944, 722, 944, 722, 667, 500, 333, 333, 556, 1e3, 1e3, 552, 222, 222, 222, 222, 333, 333, 333, 556, 556, 350, 1e3, 1e3, 188, 354, 333, 333, 500, 333, 167, 365, 556, 556, 1094, 556, 885, 323, 1073, 1e3, 768, 600, 834, 834, 834, 834, 1e3, 500, 1e3, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 719, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 500, 500, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 294, 294, 324, 324, 316, 328, 398, 285];
    jn = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
    $n = [1.36898, 1, 1, 0.72706, 0.80479, 0.83734, 0.98894, 0.99793, 0.9897, 0.93884, 0.86209, 0.94292, 0.94292, 1.16661, 1.02058, 0.93582, 0.96694, 0.93582, 1.19137, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.78076, 0.78076, 1.02058, 1.02058, 1.02058, 0.72851, 0.78966, 0.90838, 0.83637, 0.82391, 0.96376, 0.80061, 0.86275, 0.8768, 0.95407, 1.0258, 0.73901, 0.85022, 0.83655, 1.0156, 0.95546, 0.92179, 0.87107, 0.92179, 0.82114, 0.8096, 0.89713, 0.94438, 0.95353, 0.94083, 0.91905, 0.90406, 0.9446, 0.94292, 1.18777, 0.94292, 1.02058, 0.89903, 0.90088, 0.94938, 0.97898, 0.81093, 0.97571, 0.94938, 1.024, 0.9577, 0.95933, 0.98621, 1.0474, 0.97455, 0.98981, 0.9672, 0.95933, 0.9446, 0.97898, 0.97407, 0.97646, 0.78036, 1.10208, 0.95442, 0.95298, 0.97579, 0.9332, 0.94039, 0.938, 0.80687, 1.01149, 0.80687, 1.02058, 0.80479, 0.99793, 0.99793, 0.99793, 0.99793, 1.01149, 1.00872, 0.90088, 0.91882, 1.0213, 0.8361, 1.02058, 0.62295, 0.54324, 0.89022, 1.08595, 1, 1, 0.90088, 1, 0.97455, 0.93582, 0.90088, 1, 1.05686, 0.8361, 0.99642, 0.99642, 0.99642, 0.72851, 0.90838, 0.90838, 0.90838, 0.90838, 0.90838, 0.90838, 0.868, 0.82391, 0.80061, 0.80061, 0.80061, 0.80061, 1.0258, 1.0258, 1.0258, 1.0258, 0.97484, 0.95546, 0.92179, 0.92179, 0.92179, 0.92179, 0.92179, 1.02058, 0.92179, 0.94438, 0.94438, 0.94438, 0.94438, 0.90406, 0.86958, 0.98225, 0.94938, 0.94938, 0.94938, 0.94938, 0.94938, 0.94938, 0.9031, 0.81093, 0.94938, 0.94938, 0.94938, 0.94938, 0.98621, 0.98621, 0.98621, 0.98621, 0.93969, 0.95933, 0.9446, 0.9446, 0.9446, 0.9446, 0.9446, 1.08595, 0.9446, 0.95442, 0.95442, 0.95442, 0.95442, 0.94039, 0.97898, 0.94039, 0.90838, 0.94938, 0.90838, 0.94938, 0.90838, 0.94938, 0.82391, 0.81093, 0.82391, 0.81093, 0.82391, 0.81093, 0.82391, 0.81093, 0.96376, 0.84313, 0.97484, 0.97571, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.8768, 0.9577, 0.8768, 0.9577, 0.8768, 0.9577, 1, 1, 0.95407, 0.95933, 0.97069, 0.95933, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 0.887, 1.01591, 0.73901, 1.0474, 1, 1, 0.97455, 0.83655, 0.98981, 1, 1, 0.83655, 0.73977, 0.83655, 0.73903, 0.84638, 1.033, 0.95546, 0.95933, 1, 1, 0.95546, 0.95933, 0.8271, 0.95417, 0.95933, 0.92179, 0.9446, 0.92179, 0.9446, 0.92179, 0.9446, 0.936, 0.91964, 0.82114, 0.97646, 1, 1, 0.82114, 0.97646, 0.8096, 0.78036, 0.8096, 0.78036, 1, 1, 0.8096, 0.78036, 1, 1, 0.89713, 0.77452, 0.89713, 1.10208, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94083, 0.97579, 0.90406, 0.94039, 0.90406, 0.9446, 0.938, 0.9446, 0.938, 0.9446, 0.938, 1, 0.99793, 0.90838, 0.94938, 0.868, 0.9031, 0.92179, 0.9446, 1, 1, 0.89713, 1.10208, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90989, 0.9358, 0.91945, 0.83181, 0.75261, 0.87992, 0.82976, 0.96034, 0.83689, 0.97268, 1.0078, 0.90838, 0.83637, 0.8019, 0.90157, 0.80061, 0.9446, 0.95407, 0.92436, 1.0258, 0.85022, 0.97153, 1.0156, 0.95546, 0.89192, 0.92179, 0.92361, 0.87107, 0.96318, 0.89713, 0.93704, 0.95638, 0.91905, 0.91709, 0.92796, 1.0258, 0.93704, 0.94836, 1.0373, 0.95933, 1.0078, 0.95871, 0.94836, 0.96174, 0.92601, 0.9498, 0.98607, 0.95776, 0.95933, 1.05453, 1.0078, 0.98275, 0.9314, 0.95617, 0.91701, 1.05993, 0.9446, 0.78367, 0.9553, 1, 0.86832, 1.0128, 0.95871, 0.99394, 0.87548, 0.96361, 0.86774, 1.0078, 0.95871, 0.9446, 0.95871, 0.86774, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.94083, 0.97579, 0.94083, 0.97579, 0.94083, 0.97579, 0.90406, 0.94039, 0.96694, 1, 0.89903, 1, 1, 1, 0.93582, 0.93582, 0.93582, 1, 0.908, 0.908, 0.918, 0.94219, 0.94219, 0.96544, 1, 1.285, 1, 1, 0.81079, 0.81079, 1, 1, 0.74854, 1, 1, 1, 1, 0.99793, 1, 1, 1, 0.65, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.17173, 1, 0.80535, 0.76169, 1.02058, 1.0732, 1.05486, 1, 1, 1.30692, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.16161, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    Hn = { lineHeight: 1.2, lineGap: 0.2 };
    qn = [1.36898, 1, 1, 0.66227, 0.80779, 0.81625, 0.97276, 0.97276, 0.97733, 0.92222, 0.83266, 0.94292, 0.94292, 1.16148, 1.02058, 0.93582, 0.96694, 0.93582, 1.17337, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.78076, 0.78076, 1.02058, 1.02058, 1.02058, 0.71541, 0.76813, 0.85576, 0.80591, 0.80729, 0.94299, 0.77512, 0.83655, 0.86523, 0.92222, 0.98621, 0.71743, 0.81698, 0.79726, 0.98558, 0.92222, 0.90637, 0.83809, 0.90637, 0.80729, 0.76463, 0.86275, 0.90699, 0.91605, 0.9154, 0.85308, 0.85458, 0.90531, 0.94292, 1.21296, 0.94292, 1.02058, 0.89903, 1.18616, 0.99613, 0.91677, 0.78216, 0.91677, 0.90083, 0.98796, 0.9135, 0.92168, 0.95381, 0.98981, 0.95298, 0.95381, 0.93459, 0.92168, 0.91513, 0.92004, 0.91677, 0.95077, 0.748, 1.04502, 0.91677, 0.92061, 0.94236, 0.89544, 0.89364, 0.9, 0.80687, 0.8578, 0.80687, 1.02058, 0.80779, 0.97276, 0.97276, 0.97276, 0.97276, 0.8578, 0.99973, 1.18616, 0.91339, 1.08074, 0.82891, 1.02058, 0.55509, 0.71526, 0.89022, 1.08595, 1, 1, 1.18616, 1, 0.96736, 0.93582, 1.18616, 1, 1.04864, 0.82711, 0.99043, 0.99043, 0.99043, 0.71541, 0.85576, 0.85576, 0.85576, 0.85576, 0.85576, 0.85576, 0.845, 0.80729, 0.77512, 0.77512, 0.77512, 0.77512, 0.98621, 0.98621, 0.98621, 0.98621, 0.95961, 0.92222, 0.90637, 0.90637, 0.90637, 0.90637, 0.90637, 1.02058, 0.90251, 0.90699, 0.90699, 0.90699, 0.90699, 0.85458, 0.83659, 0.94951, 0.99613, 0.99613, 0.99613, 0.99613, 0.99613, 0.99613, 0.85811, 0.78216, 0.90083, 0.90083, 0.90083, 0.90083, 0.95381, 0.95381, 0.95381, 0.95381, 0.9135, 0.92168, 0.91513, 0.91513, 0.91513, 0.91513, 0.91513, 1.08595, 0.91677, 0.91677, 0.91677, 0.91677, 0.91677, 0.89364, 0.92332, 0.89364, 0.85576, 0.99613, 0.85576, 0.99613, 0.85576, 0.99613, 0.80729, 0.78216, 0.80729, 0.78216, 0.80729, 0.78216, 0.80729, 0.78216, 0.94299, 0.76783, 0.95961, 0.91677, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.86523, 0.9135, 0.86523, 0.9135, 0.86523, 0.9135, 1, 1, 0.92222, 0.92168, 0.92222, 0.92168, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.86036, 0.97096, 0.71743, 0.98981, 1, 1, 0.95298, 0.79726, 0.95381, 1, 1, 0.79726, 0.6894, 0.79726, 0.74321, 0.81691, 1.0006, 0.92222, 0.92168, 1, 1, 0.92222, 0.92168, 0.79464, 0.92098, 0.92168, 0.90637, 0.91513, 0.90637, 0.91513, 0.90637, 0.91513, 0.909, 0.87514, 0.80729, 0.95077, 1, 1, 0.80729, 0.95077, 0.76463, 0.748, 0.76463, 0.748, 1, 1, 0.76463, 0.748, 1, 1, 0.86275, 0.72651, 0.86275, 1.04502, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.9154, 0.94236, 0.85458, 0.89364, 0.85458, 0.90531, 0.9, 0.90531, 0.9, 0.90531, 0.9, 1, 0.97276, 0.85576, 0.99613, 0.845, 0.85811, 0.90251, 0.91677, 1, 1, 0.86275, 1.04502, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.00899, 1.30628, 0.85576, 0.80178, 0.66862, 0.7927, 0.69323, 0.88127, 0.72459, 0.89711, 0.95381, 0.85576, 0.80591, 0.7805, 0.94729, 0.77512, 0.90531, 0.92222, 0.90637, 0.98621, 0.81698, 0.92655, 0.98558, 0.92222, 0.85359, 0.90637, 0.90976, 0.83809, 0.94523, 0.86275, 0.83509, 0.93157, 0.85308, 0.83392, 0.92346, 0.98621, 0.83509, 0.92886, 0.91324, 0.92168, 0.95381, 0.90646, 0.92886, 0.90557, 0.86847, 0.90276, 0.91324, 0.86842, 0.92168, 0.99531, 0.95381, 0.9224, 0.85408, 0.92699, 0.86847, 1.0051, 0.91513, 0.80487, 0.93481, 1, 0.88159, 1.05214, 0.90646, 0.97355, 0.81539, 0.89398, 0.85923, 0.95381, 0.90646, 0.91513, 0.90646, 0.85923, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.9154, 0.94236, 0.9154, 0.94236, 0.9154, 0.94236, 0.85458, 0.89364, 0.96694, 1, 0.89903, 1, 1, 1, 0.91782, 0.91782, 0.91782, 1, 0.896, 0.896, 0.896, 0.9332, 0.9332, 0.95973, 1, 1.26, 1, 1, 0.80479, 0.80178, 1, 1, 0.85633, 1, 1, 1, 1, 0.97276, 1, 1, 1, 0.698, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.14542, 1, 0.79199, 0.78694, 1.02058, 1.03493, 1.05486, 1, 1, 1.23026, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.20006, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    Xn = { lineHeight: 1.2, lineGap: 0.2 };
    zn = [1.36898, 1, 1, 0.65507, 0.84943, 0.85639, 0.88465, 0.88465, 0.86936, 0.88307, 0.86948, 0.85283, 0.85283, 1.06383, 1.02058, 0.75945, 0.9219, 0.75945, 1.17337, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.75945, 0.75945, 1.02058, 1.02058, 1.02058, 0.69046, 0.70926, 0.85158, 0.77812, 0.76852, 0.89591, 0.70466, 0.76125, 0.80094, 0.86822, 0.83864, 0.728, 0.77212, 0.79475, 0.93637, 0.87514, 0.8588, 0.76013, 0.8588, 0.72421, 0.69866, 0.77598, 0.85991, 0.80811, 0.87832, 0.78112, 0.77512, 0.8562, 1.0222, 1.18417, 1.0222, 1.27014, 0.89903, 1.15012, 0.93859, 0.94399, 0.846, 0.94399, 0.81453, 1.0186, 0.94219, 0.96017, 1.03075, 1.02175, 0.912, 1.03075, 0.96998, 0.96017, 0.93859, 0.94399, 0.94399, 0.95493, 0.746, 1.12658, 0.94578, 0.91, 0.979, 0.882, 0.882, 0.83, 0.85034, 0.83537, 0.85034, 1.02058, 0.70869, 0.88465, 0.88465, 0.88465, 0.88465, 0.83537, 0.90083, 1.15012, 0.9161, 0.94565, 0.73541, 1.02058, 0.53609, 0.69353, 0.79519, 1.08595, 1, 1, 1.15012, 1, 0.91974, 0.75945, 1.15012, 1, 0.9446, 0.73361, 0.9005, 0.9005, 0.9005, 0.62864, 0.85158, 0.85158, 0.85158, 0.85158, 0.85158, 0.85158, 0.773, 0.76852, 0.70466, 0.70466, 0.70466, 0.70466, 0.83864, 0.83864, 0.83864, 0.83864, 0.90561, 0.87514, 0.8588, 0.8588, 0.8588, 0.8588, 0.8588, 1.02058, 0.85751, 0.85991, 0.85991, 0.85991, 0.85991, 0.77512, 0.76013, 0.88075, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 0.8075, 0.846, 0.81453, 0.81453, 0.81453, 0.81453, 0.82424, 0.82424, 0.82424, 0.82424, 0.9278, 0.96017, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 1.08595, 0.8562, 0.94578, 0.94578, 0.94578, 0.94578, 0.882, 0.94578, 0.882, 0.85158, 0.93859, 0.85158, 0.93859, 0.85158, 0.93859, 0.76852, 0.846, 0.76852, 0.846, 0.76852, 0.846, 0.76852, 0.846, 0.89591, 0.8544, 0.90561, 0.94399, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.80094, 0.94219, 0.80094, 0.94219, 0.80094, 0.94219, 1, 1, 0.86822, 0.96017, 0.86822, 0.96017, 0.83864, 0.82424, 0.83864, 0.82424, 0.83864, 0.82424, 0.83864, 1.03075, 0.83864, 0.82424, 0.81402, 1.02738, 0.728, 1.02175, 1, 1, 0.912, 0.79475, 1.03075, 1, 1, 0.79475, 0.83911, 0.79475, 0.66266, 0.80553, 1.06676, 0.87514, 0.96017, 1, 1, 0.87514, 0.96017, 0.86865, 0.87396, 0.96017, 0.8588, 0.93859, 0.8588, 0.93859, 0.8588, 0.93859, 0.867, 0.84759, 0.72421, 0.95493, 1, 1, 0.72421, 0.95493, 0.69866, 0.746, 0.69866, 0.746, 1, 1, 0.69866, 0.746, 1, 1, 0.77598, 0.88417, 0.77598, 1.12658, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.87832, 0.979, 0.77512, 0.882, 0.77512, 0.8562, 0.83, 0.8562, 0.83, 0.8562, 0.83, 1, 0.88465, 0.85158, 0.93859, 0.773, 0.8075, 0.85751, 0.8562, 1, 1, 0.77598, 1.12658, 1.15012, 1.15012, 1.15012, 1.15012, 1.15012, 1.15313, 1.15012, 1.15012, 1.15012, 1.08106, 1.03901, 0.85158, 0.77025, 0.62264, 0.7646, 0.65351, 0.86026, 0.69461, 0.89947, 1.03075, 0.85158, 0.77812, 0.76449, 0.88836, 0.70466, 0.8562, 0.86822, 0.8588, 0.83864, 0.77212, 0.85308, 0.93637, 0.87514, 0.82352, 0.8588, 0.85701, 0.76013, 0.89058, 0.77598, 0.8156, 0.82565, 0.78112, 0.77899, 0.89386, 0.83864, 0.8156, 0.9486, 0.92388, 0.96186, 1.03075, 0.91123, 0.9486, 0.93298, 0.878, 0.93942, 0.92388, 0.84596, 0.96186, 0.95119, 1.03075, 0.922, 0.88787, 0.95829, 0.88, 0.93559, 0.93859, 0.78815, 0.93758, 1, 0.89217, 1.03737, 0.91123, 0.93969, 0.77487, 0.85769, 0.86799, 1.03075, 0.91123, 0.93859, 0.91123, 0.86799, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.87832, 0.979, 0.87832, 0.979, 0.87832, 0.979, 0.77512, 0.882, 0.9219, 1, 0.89903, 1, 1, 1, 0.87321, 0.87321, 0.87321, 1, 1.027, 1.027, 1.027, 0.86847, 0.86847, 0.79121, 1, 1.124, 1, 1, 0.73572, 0.73572, 1, 1, 0.85034, 1, 1, 1, 1, 0.88465, 1, 1, 1, 0.669, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.04828, 1, 0.74948, 0.75187, 1.02058, 0.98391, 1.02119, 1, 1, 1.06233, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05233, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    Wn = { lineHeight: 1.2, lineGap: 0.2 };
    Gn = [1.36898, 1, 1, 0.76305, 0.82784, 0.94935, 0.89364, 0.92241, 0.89073, 0.90706, 0.98472, 0.85283, 0.85283, 1.0664, 1.02058, 0.74505, 0.9219, 0.74505, 1.23456, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.74505, 0.74505, 1.02058, 1.02058, 1.02058, 0.73002, 0.72601, 0.91755, 0.8126, 0.80314, 0.92222, 0.73764, 0.79726, 0.83051, 0.90284, 0.86023, 0.74, 0.8126, 0.84869, 0.96518, 0.91115, 0.8858, 0.79761, 0.8858, 0.74498, 0.73914, 0.81363, 0.89591, 0.83659, 0.89633, 0.85608, 0.8111, 0.90531, 1.0222, 1.22736, 1.0222, 1.27014, 0.89903, 0.90088, 0.86667, 1.0231, 0.896, 1.01411, 0.90083, 1.05099, 1.00512, 0.99793, 1.05326, 1.09377, 0.938, 1.06226, 1.00119, 0.99793, 0.98714, 1.0231, 1.01231, 0.98196, 0.792, 1.19137, 0.99074, 0.962, 1.01915, 0.926, 0.942, 0.856, 0.85034, 0.92006, 0.85034, 1.02058, 0.69067, 0.92241, 0.92241, 0.92241, 0.92241, 0.92006, 0.9332, 0.90088, 0.91882, 0.93484, 0.75339, 1.02058, 0.56866, 0.54324, 0.79519, 1.08595, 1, 1, 0.90088, 1, 0.95325, 0.74505, 0.90088, 1, 0.97198, 0.75339, 0.91009, 0.91009, 0.91009, 0.66466, 0.91755, 0.91755, 0.91755, 0.91755, 0.91755, 0.91755, 0.788, 0.80314, 0.73764, 0.73764, 0.73764, 0.73764, 0.86023, 0.86023, 0.86023, 0.86023, 0.92915, 0.91115, 0.8858, 0.8858, 0.8858, 0.8858, 0.8858, 1.02058, 0.8858, 0.89591, 0.89591, 0.89591, 0.89591, 0.8111, 0.79611, 0.89713, 0.86667, 0.86667, 0.86667, 0.86667, 0.86667, 0.86667, 0.86936, 0.896, 0.90083, 0.90083, 0.90083, 0.90083, 0.84224, 0.84224, 0.84224, 0.84224, 0.97276, 0.99793, 0.98714, 0.98714, 0.98714, 0.98714, 0.98714, 1.08595, 0.89876, 0.99074, 0.99074, 0.99074, 0.99074, 0.942, 1.0231, 0.942, 0.91755, 0.86667, 0.91755, 0.86667, 0.91755, 0.86667, 0.80314, 0.896, 0.80314, 0.896, 0.80314, 0.896, 0.80314, 0.896, 0.92222, 0.93372, 0.92915, 1.01411, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.83051, 1.00512, 0.83051, 1.00512, 0.83051, 1.00512, 1, 1, 0.90284, 0.99793, 0.90976, 0.99793, 0.86023, 0.84224, 0.86023, 0.84224, 0.86023, 0.84224, 0.86023, 1.05326, 0.86023, 0.84224, 0.82873, 1.07469, 0.74, 1.09377, 1, 1, 0.938, 0.84869, 1.06226, 1, 1, 0.84869, 0.83704, 0.84869, 0.81441, 0.85588, 1.08927, 0.91115, 0.99793, 1, 1, 0.91115, 0.99793, 0.91887, 0.90991, 0.99793, 0.8858, 0.98714, 0.8858, 0.98714, 0.8858, 0.98714, 0.894, 0.91434, 0.74498, 0.98196, 1, 1, 0.74498, 0.98196, 0.73914, 0.792, 0.73914, 0.792, 1, 1, 0.73914, 0.792, 1, 1, 0.81363, 0.904, 0.81363, 1.19137, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89633, 1.01915, 0.8111, 0.942, 0.8111, 0.90531, 0.856, 0.90531, 0.856, 0.90531, 0.856, 1, 0.92241, 0.91755, 0.86667, 0.788, 0.86936, 0.8858, 0.89876, 1, 1, 0.81363, 1.19137, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90388, 1.03901, 0.92138, 0.78105, 0.7154, 0.86169, 0.80513, 0.94007, 0.82528, 0.98612, 1.06226, 0.91755, 0.8126, 0.81884, 0.92819, 0.73764, 0.90531, 0.90284, 0.8858, 0.86023, 0.8126, 0.91172, 0.96518, 0.91115, 0.83089, 0.8858, 0.87791, 0.79761, 0.89297, 0.81363, 0.88157, 0.89992, 0.85608, 0.81992, 0.94307, 0.86023, 0.88157, 0.95308, 0.98699, 0.99793, 1.06226, 0.95817, 0.95308, 0.97358, 0.928, 0.98088, 0.98699, 0.92761, 0.99793, 0.96017, 1.06226, 0.986, 0.944, 0.95978, 0.938, 0.96705, 0.98714, 0.80442, 0.98972, 1, 0.89762, 1.04552, 0.95817, 0.99007, 0.87064, 0.91879, 0.88888, 1.06226, 0.95817, 0.98714, 0.95817, 0.88888, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89633, 1.01915, 0.89633, 1.01915, 0.89633, 1.01915, 0.8111, 0.942, 0.9219, 1, 0.89903, 1, 1, 1, 0.93173, 0.93173, 0.93173, 1, 1.06304, 1.06304, 1.06904, 0.89903, 0.89903, 0.80549, 1, 1.156, 1, 1, 0.76575, 0.76575, 1, 1, 0.72458, 1, 1, 1, 1, 0.92241, 1, 1, 1, 0.619, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.07257, 1, 0.74705, 0.71119, 1.02058, 1.024, 1.02119, 1, 1, 1.1536, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05638, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    Vn = { lineHeight: 1.2, lineGap: 0.2 };
    Kn = [1.76738, 1, 1, 0.99297, 0.9824, 1.04016, 1.06497, 1.03424, 0.97529, 1.17647, 1.23203, 1.1085, 1.1085, 1.16939, 1.2107, 0.9754, 1.21408, 0.9754, 1.59578, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 0.81378, 0.81378, 1.2107, 1.2107, 1.2107, 0.71703, 0.97847, 0.97363, 0.88776, 0.8641, 1.02096, 0.79795, 0.85132, 0.914, 1.06085, 1.1406, 0.8007, 0.89858, 0.83693, 1.14889, 1.09398, 0.97489, 0.92094, 0.97489, 0.90399, 0.84041, 0.95923, 1.00135, 1, 1.06467, 0.98243, 0.90996, 0.99361, 1.1085, 1.56942, 1.1085, 1.2107, 0.74627, 0.94282, 0.96752, 1.01519, 0.86304, 1.01359, 0.97278, 1.15103, 1.01359, 0.98561, 1.02285, 1.02285, 1.00527, 1.02285, 1.0302, 0.99041, 1.0008, 1.01519, 1.01359, 1.02258, 0.79104, 1.16862, 0.99041, 0.97454, 1.02511, 0.99298, 0.96752, 0.95801, 0.94856, 1.16579, 0.94856, 1.2107, 0.9824, 1.03424, 1.03424, 1, 1.03424, 1.16579, 0.8727, 1.3871, 1.18622, 1.10818, 1.04478, 1.2107, 1.18622, 0.75155, 0.94994, 1.28826, 1.21408, 1.21408, 0.91056, 1, 0.91572, 0.9754, 0.64663, 1.18328, 1.24866, 1.04478, 1.14169, 1.15749, 1.17389, 0.71703, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.93506, 0.8641, 0.79795, 0.79795, 0.79795, 0.79795, 1.1406, 1.1406, 1.1406, 1.1406, 1.02096, 1.09398, 0.97426, 0.97426, 0.97426, 0.97426, 0.97426, 1.2107, 0.97489, 1.00135, 1.00135, 1.00135, 1.00135, 0.90996, 0.92094, 1.02798, 0.96752, 0.96752, 0.96752, 0.96752, 0.96752, 0.96752, 0.93136, 0.86304, 0.97278, 0.97278, 0.97278, 0.97278, 1.02285, 1.02285, 1.02285, 1.02285, 0.97122, 0.99041, 1, 1, 1, 1, 1, 1.28826, 1.0008, 0.99041, 0.99041, 0.99041, 0.99041, 0.96752, 1.01519, 0.96752, 0.97363, 0.96752, 0.97363, 0.96752, 0.97363, 0.96752, 0.8641, 0.86304, 0.8641, 0.86304, 0.8641, 0.86304, 0.8641, 0.86304, 1.02096, 1.03057, 1.02096, 1.03517, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.914, 1.01359, 0.914, 1.01359, 0.914, 1.01359, 1, 1, 1.06085, 0.98561, 1.06085, 1.00879, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 0.97138, 1.08692, 0.8007, 1.02285, 1, 1, 1.00527, 0.83693, 1.02285, 1, 1, 0.83693, 0.9455, 0.83693, 0.90418, 0.83693, 1.13005, 1.09398, 0.99041, 1, 1, 1.09398, 0.99041, 0.96692, 1.09251, 0.99041, 0.97489, 1.0008, 0.97489, 1.0008, 0.97489, 1.0008, 0.93994, 0.97931, 0.90399, 1.02258, 1, 1, 0.90399, 1.02258, 0.84041, 0.79104, 0.84041, 0.79104, 0.84041, 0.79104, 0.84041, 0.79104, 1, 1, 0.95923, 1.07034, 0.95923, 1.16862, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.06467, 1.02511, 0.90996, 0.96752, 0.90996, 0.99361, 0.95801, 0.99361, 0.95801, 0.99361, 0.95801, 1.07733, 1.03424, 0.97363, 0.96752, 0.93506, 0.93136, 0.97489, 1.0008, 1, 1, 0.95923, 1.16862, 1.15103, 1.15103, 1.01173, 1.03959, 0.75953, 0.81378, 0.79912, 1.15103, 1.21994, 0.95161, 0.87815, 1.01149, 0.81525, 0.7676, 0.98167, 1.01134, 1.02546, 0.84097, 1.03089, 1.18102, 0.97363, 0.88776, 0.85134, 0.97826, 0.79795, 0.99361, 1.06085, 0.97489, 1.1406, 0.89858, 1.0388, 1.14889, 1.09398, 0.86039, 0.97489, 1.0595, 0.92094, 0.94793, 0.95923, 0.90996, 0.99346, 0.98243, 1.02112, 0.95493, 1.1406, 0.90996, 1.03574, 1.02597, 1.0008, 1.18102, 1.06628, 1.03574, 1.0192, 1.01932, 1.00886, 0.97531, 1.0106, 1.0008, 1.13189, 1.18102, 1.02277, 0.98683, 1.0016, 0.99561, 1.07237, 1.0008, 0.90434, 0.99921, 0.93803, 0.8965, 1.23085, 1.06628, 1.04983, 0.96268, 1.0499, 0.98439, 1.18102, 1.06628, 1.0008, 1.06628, 0.98439, 0.79795, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.09466, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.97278, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.02065, 1, 1, 1, 1, 1, 1, 1.06467, 1.02511, 1.06467, 1.02511, 1.06467, 1.02511, 0.90996, 0.96752, 1, 1.21408, 0.89903, 1, 1, 0.75155, 1.04394, 1.04394, 1.04394, 1.04394, 0.98633, 0.98633, 0.98633, 0.73047, 0.73047, 1.20642, 0.91211, 1.25635, 1.222, 1.02956, 1.03372, 1.03372, 0.96039, 1.24633, 1, 1.12454, 0.93503, 1.03424, 1.19687, 1.03424, 1, 1, 1, 0.771, 1, 1, 1.15749, 1.15749, 1.15749, 1.10948, 0.86279, 0.94434, 0.86279, 0.94434, 0.86182, 1, 1, 1.16897, 1, 0.96085, 0.90137, 1.2107, 1.18416, 1.13973, 0.69825, 0.9716, 2.10339, 1.29004, 1.29004, 1.21172, 1.29004, 1.29004, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18874, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.09193, 1.09193, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    Yn = { lineHeight: 1.33008, lineGap: 0 };
    Jn = [1.76738, 1, 1, 0.98946, 1.03959, 1.04016, 1.02809, 1.036, 0.97639, 1.10953, 1.23203, 1.11144, 1.11144, 1.16939, 1.21237, 0.9754, 1.21261, 0.9754, 1.59754, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 0.81378, 0.81378, 1.21237, 1.21237, 1.21237, 0.73541, 0.97847, 0.97363, 0.89723, 0.87897, 1.0426, 0.79429, 0.85292, 0.91149, 1.05815, 1.1406, 0.79631, 0.90128, 0.83853, 1.04396, 1.10615, 0.97552, 0.94436, 0.97552, 0.88641, 0.80527, 0.96083, 1.00135, 1, 1.06777, 0.9817, 0.91142, 0.99361, 1.11144, 1.57293, 1.11144, 1.21237, 0.74627, 1.31818, 1.06585, 0.97042, 0.83055, 0.97042, 0.93503, 1.1261, 0.97042, 0.97922, 1.14236, 0.94552, 1.01054, 1.14236, 1.02471, 0.97922, 0.94165, 0.97042, 0.97042, 1.0276, 0.78929, 1.1261, 0.97922, 0.95874, 1.02197, 0.98507, 0.96752, 0.97168, 0.95107, 1.16579, 0.95107, 1.21237, 1.03959, 1.036, 1.036, 1, 1.036, 1.16579, 0.87357, 1.31818, 1.18754, 1.26781, 1.05356, 1.21237, 1.18622, 0.79487, 0.94994, 1.29004, 1.24047, 1.24047, 1.31818, 1, 0.91484, 0.9754, 1.31818, 1.1349, 1.24866, 1.05356, 1.13934, 1.15574, 1.17389, 0.73541, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.94385, 0.87897, 0.79429, 0.79429, 0.79429, 0.79429, 1.1406, 1.1406, 1.1406, 1.1406, 1.0426, 1.10615, 0.97552, 0.97552, 0.97552, 0.97552, 0.97552, 1.21237, 0.97552, 1.00135, 1.00135, 1.00135, 1.00135, 0.91142, 0.94436, 0.98721, 1.06585, 1.06585, 1.06585, 1.06585, 1.06585, 1.06585, 0.96705, 0.83055, 0.93503, 0.93503, 0.93503, 0.93503, 1.14236, 1.14236, 1.14236, 1.14236, 0.93125, 0.97922, 0.94165, 0.94165, 0.94165, 0.94165, 0.94165, 1.29004, 0.94165, 0.97922, 0.97922, 0.97922, 0.97922, 0.96752, 0.97042, 0.96752, 0.97363, 1.06585, 0.97363, 1.06585, 0.97363, 1.06585, 0.87897, 0.83055, 0.87897, 0.83055, 0.87897, 0.83055, 0.87897, 0.83055, 1.0426, 1.0033, 1.0426, 0.97042, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.91149, 0.97042, 0.91149, 0.97042, 0.91149, 0.97042, 1, 1, 1.05815, 0.97922, 1.05815, 0.97922, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 0.97441, 1.04302, 0.79631, 1.01582, 1, 1, 1.01054, 0.83853, 1.14236, 1, 1, 0.83853, 1.09125, 0.83853, 0.90418, 0.83853, 1.19508, 1.10615, 0.97922, 1, 1, 1.10615, 0.97922, 1.01034, 1.10466, 0.97922, 0.97552, 0.94165, 0.97552, 0.94165, 0.97552, 0.94165, 0.91602, 0.91981, 0.88641, 1.0276, 1, 1, 0.88641, 1.0276, 0.80527, 0.78929, 0.80527, 0.78929, 0.80527, 0.78929, 0.80527, 0.78929, 1, 1, 0.96083, 1.05403, 0.95923, 1.16862, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.06777, 1.02197, 0.91142, 0.96752, 0.91142, 0.99361, 0.97168, 0.99361, 0.97168, 0.99361, 0.97168, 1.23199, 1.036, 0.97363, 1.06585, 0.94385, 0.96705, 0.97552, 0.94165, 1, 1, 0.96083, 1.1261, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 0.95161, 1.27126, 1.00811, 0.83284, 0.77702, 0.99137, 0.95253, 1.0347, 0.86142, 1.07205, 1.14236, 0.97363, 0.89723, 0.86869, 1.09818, 0.79429, 0.99361, 1.05815, 0.97552, 1.1406, 0.90128, 1.06662, 1.04396, 1.10615, 0.84918, 0.97552, 1.04694, 0.94436, 0.98015, 0.96083, 0.91142, 1.00356, 0.9817, 1.01945, 0.98999, 1.1406, 0.91142, 1.04961, 0.9898, 1.00639, 1.14236, 1.07514, 1.04961, 0.99607, 1.02897, 1.008, 0.9898, 0.95134, 1.00639, 1.11121, 1.14236, 1.00518, 0.97981, 1.02186, 1, 1.08578, 0.94165, 0.99314, 0.98387, 0.93028, 0.93377, 1.35125, 1.07514, 1.10687, 0.93491, 1.04232, 1.00351, 1.14236, 1.07514, 0.94165, 1.07514, 1.00351, 0.79429, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.09097, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.93503, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.96609, 1, 1, 1, 1, 1, 1, 1.06777, 1.02197, 1.06777, 1.02197, 1.06777, 1.02197, 0.91142, 0.96752, 1, 1.21261, 0.89903, 1, 1, 0.75155, 1.04745, 1.04745, 1.04745, 1.04394, 0.98633, 0.98633, 0.98633, 0.72959, 0.72959, 1.20502, 0.91406, 1.26514, 1.222, 1.02956, 1.03372, 1.03372, 0.96039, 1.24633, 1, 1.09125, 0.93327, 1.03336, 1.16541, 1.036, 1, 1, 1, 0.771, 1, 1, 1.15574, 1.15574, 1.15574, 1.15574, 0.86364, 0.94434, 0.86279, 0.94434, 0.86224, 1, 1, 1.16798, 1, 0.96085, 0.90068, 1.21237, 1.18416, 1.13904, 0.69825, 0.9716, 2.10339, 1.29004, 1.29004, 1.21339, 1.29004, 1.29004, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18775, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.13269, 1.13269, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    Zn = { lineHeight: 1.33008, lineGap: 0 };
    Qn = [1.76738, 1, 1, 0.98946, 1.14763, 1.05365, 1.06234, 0.96927, 0.92586, 1.15373, 1.18414, 0.91349, 0.91349, 1.07403, 1.17308, 0.78383, 1.20088, 0.78383, 1.42531, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.78383, 0.78383, 1.17308, 1.17308, 1.17308, 0.77349, 0.94565, 0.94729, 0.85944, 0.88506, 0.9858, 0.74817, 0.80016, 0.88449, 0.98039, 0.95782, 0.69238, 0.89898, 0.83231, 0.98183, 1.03989, 0.96924, 0.86237, 0.96924, 0.80595, 0.74524, 0.86091, 0.95402, 0.94143, 0.98448, 0.8858, 0.83089, 0.93285, 1.0949, 1.39016, 1.0949, 1.45994, 0.74627, 1.04839, 0.97454, 0.97454, 0.87207, 0.97454, 0.87533, 1.06151, 0.97454, 1.00176, 1.16484, 1.08132, 0.98047, 1.16484, 1.02989, 1.01054, 0.96225, 0.97454, 0.97454, 1.06598, 0.79004, 1.16344, 1.00351, 0.94629, 0.9973, 0.91016, 0.96777, 0.9043, 0.91082, 0.92481, 0.91082, 1.17308, 0.95748, 0.96927, 0.96927, 1, 0.96927, 0.92481, 0.80597, 1.04839, 1.23393, 1.1781, 0.9245, 1.17308, 1.20808, 0.63218, 0.94261, 1.24822, 1.09971, 1.09971, 1.04839, 1, 0.85273, 0.78032, 1.04839, 1.09971, 1.22326, 0.9245, 1.09836, 1.13525, 1.15222, 0.70424, 0.94729, 0.94729, 0.94729, 0.94729, 0.94729, 0.94729, 0.85498, 0.88506, 0.74817, 0.74817, 0.74817, 0.74817, 0.95782, 0.95782, 0.95782, 0.95782, 0.9858, 1.03989, 0.96924, 0.96924, 0.96924, 0.96924, 0.96924, 1.17308, 0.96924, 0.95402, 0.95402, 0.95402, 0.95402, 0.83089, 0.86237, 0.88409, 0.97454, 0.97454, 0.97454, 0.97454, 0.97454, 0.97454, 0.92916, 0.87207, 0.87533, 0.87533, 0.87533, 0.87533, 0.93146, 0.93146, 0.93146, 0.93146, 0.93854, 1.01054, 0.96225, 0.96225, 0.96225, 0.96225, 0.96225, 1.24822, 0.8761, 1.00351, 1.00351, 1.00351, 1.00351, 0.96777, 0.97454, 0.96777, 0.94729, 0.97454, 0.94729, 0.97454, 0.94729, 0.97454, 0.88506, 0.87207, 0.88506, 0.87207, 0.88506, 0.87207, 0.88506, 0.87207, 0.9858, 0.95391, 0.9858, 0.97454, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.88449, 0.97454, 0.88449, 0.97454, 0.88449, 0.97454, 1, 1, 0.98039, 1.00176, 0.98039, 1.00176, 0.95782, 0.93146, 0.95782, 0.93146, 0.95782, 0.93146, 0.95782, 1.16484, 0.95782, 0.93146, 0.84421, 1.12761, 0.69238, 1.08132, 1, 1, 0.98047, 0.83231, 1.16484, 1, 1, 0.84723, 1.04861, 0.84723, 0.78755, 0.83231, 1.23736, 1.03989, 1.01054, 1, 1, 1.03989, 1.01054, 0.9857, 1.03849, 1.01054, 0.96924, 0.96225, 0.96924, 0.96225, 0.96924, 0.96225, 0.92383, 0.90171, 0.80595, 1.06598, 1, 1, 0.80595, 1.06598, 0.74524, 0.79004, 0.74524, 0.79004, 0.74524, 0.79004, 0.74524, 0.79004, 1, 1, 0.86091, 1.02759, 0.85771, 1.16344, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.98448, 0.9973, 0.83089, 0.96777, 0.83089, 0.93285, 0.9043, 0.93285, 0.9043, 0.93285, 0.9043, 1.31868, 0.96927, 0.94729, 0.97454, 0.85498, 0.92916, 0.96924, 0.8761, 1, 1, 0.86091, 1.16344, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 0.81965, 0.81965, 0.94729, 0.78032, 0.71022, 0.90883, 0.84171, 0.99877, 0.77596, 1.05734, 1.2, 0.94729, 0.85944, 0.82791, 0.9607, 0.74817, 0.93285, 0.98039, 0.96924, 0.95782, 0.89898, 0.98316, 0.98183, 1.03989, 0.78614, 0.96924, 0.97642, 0.86237, 0.86075, 0.86091, 0.83089, 0.90082, 0.8858, 0.97296, 1.01284, 0.95782, 0.83089, 1.0976, 1.04, 1.03342, 1.2, 1.0675, 1.0976, 0.98205, 1.03809, 1.05097, 1.04, 0.95364, 1.03342, 1.05401, 1.2, 1.02148, 1.0119, 1.04724, 1.0127, 1.02732, 0.96225, 0.8965, 0.97783, 0.93574, 0.94818, 1.30679, 1.0675, 1.11826, 0.99821, 1.0557, 1.0326, 1.2, 1.0675, 0.96225, 1.0675, 1.0326, 0.74817, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.03754, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.87533, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.98705, 1, 1, 1, 1, 1, 1, 0.98448, 0.9973, 0.98448, 0.9973, 0.98448, 0.9973, 0.83089, 0.96777, 1, 1.20088, 0.89903, 1, 1, 0.75155, 0.94945, 0.94945, 0.94945, 0.94945, 1.12317, 1.12317, 1.12317, 0.67603, 0.67603, 1.15621, 0.73584, 1.21191, 1.22135, 1.06483, 0.94868, 0.94868, 0.95996, 1.24633, 1, 1.07497, 0.87709, 0.96927, 1.01473, 0.96927, 1, 1, 1, 0.77295, 1, 1, 1.09836, 1.09836, 1.09836, 1.01522, 0.86321, 0.94434, 0.8649, 0.94434, 0.86182, 1, 1, 1.083, 1, 0.91578, 0.86438, 1.17308, 1.18416, 1.14589, 0.69825, 0.97622, 1.96791, 1.24822, 1.24822, 1.17308, 1.24822, 1.24822, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.17984, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.10742, 1.10742, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    es = { lineHeight: 1.33008, lineGap: 0 };
    ts = [1.76738, 1, 1, 0.98594, 1.02285, 1.10454, 1.06234, 0.96927, 0.92037, 1.19985, 1.2046, 0.90616, 0.90616, 1.07152, 1.1714, 0.78032, 1.20088, 0.78032, 1.40246, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.78032, 0.78032, 1.1714, 1.1714, 1.1714, 0.80597, 0.94084, 0.96706, 0.85944, 0.85734, 0.97093, 0.75842, 0.79936, 0.88198, 0.9831, 0.95782, 0.71387, 0.86969, 0.84636, 1.07796, 1.03584, 0.96924, 0.83968, 0.96924, 0.82826, 0.79649, 0.85771, 0.95132, 0.93119, 0.98965, 0.88433, 0.8287, 0.93365, 1.08612, 1.3638, 1.08612, 1.45786, 0.74627, 0.80499, 0.91484, 1.05707, 0.92383, 1.05882, 0.9403, 1.12654, 1.05882, 1.01756, 1.09011, 1.09011, 0.99414, 1.09011, 1.034, 1.01756, 1.05356, 1.05707, 1.05882, 1.04399, 0.84863, 1.21968, 1.01756, 0.95801, 1.00068, 0.91797, 0.96777, 0.9043, 0.90351, 0.92105, 0.90351, 1.1714, 0.85337, 0.96927, 0.96927, 0.99912, 0.96927, 0.92105, 0.80597, 1.2434, 1.20808, 1.05937, 0.90957, 1.1714, 1.20808, 0.75155, 0.94261, 1.24644, 1.09971, 1.09971, 0.84751, 1, 0.85273, 0.78032, 0.61584, 1.05425, 1.17914, 0.90957, 1.08665, 1.11593, 1.14169, 0.73381, 0.96706, 0.96706, 0.96706, 0.96706, 0.96706, 0.96706, 0.86035, 0.85734, 0.75842, 0.75842, 0.75842, 0.75842, 0.95782, 0.95782, 0.95782, 0.95782, 0.97093, 1.03584, 0.96924, 0.96924, 0.96924, 0.96924, 0.96924, 1.1714, 0.96924, 0.95132, 0.95132, 0.95132, 0.95132, 0.8287, 0.83968, 0.89049, 0.91484, 0.91484, 0.91484, 0.91484, 0.91484, 0.91484, 0.93575, 0.92383, 0.9403, 0.9403, 0.9403, 0.9403, 0.8717, 0.8717, 0.8717, 0.8717, 1.00527, 1.01756, 1.05356, 1.05356, 1.05356, 1.05356, 1.05356, 1.24644, 0.95923, 1.01756, 1.01756, 1.01756, 1.01756, 0.96777, 1.05707, 0.96777, 0.96706, 0.91484, 0.96706, 0.91484, 0.96706, 0.91484, 0.85734, 0.92383, 0.85734, 0.92383, 0.85734, 0.92383, 0.85734, 0.92383, 0.97093, 1.0969, 0.97093, 1.05882, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.88198, 1.05882, 0.88198, 1.05882, 0.88198, 1.05882, 1, 1, 0.9831, 1.01756, 0.9831, 1.01756, 0.95782, 0.8717, 0.95782, 0.8717, 0.95782, 0.8717, 0.95782, 1.09011, 0.95782, 0.8717, 0.84784, 1.11551, 0.71387, 1.09011, 1, 1, 0.99414, 0.84636, 1.09011, 1, 1, 0.84636, 1.0536, 0.84636, 0.94298, 0.84636, 1.23297, 1.03584, 1.01756, 1, 1, 1.03584, 1.01756, 1.00323, 1.03444, 1.01756, 0.96924, 1.05356, 0.96924, 1.05356, 0.96924, 1.05356, 0.93066, 0.98293, 0.82826, 1.04399, 1, 1, 0.82826, 1.04399, 0.79649, 0.84863, 0.79649, 0.84863, 0.79649, 0.84863, 0.79649, 0.84863, 1, 1, 0.85771, 1.17318, 0.85771, 1.21968, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.98965, 1.00068, 0.8287, 0.96777, 0.8287, 0.93365, 0.9043, 0.93365, 0.9043, 0.93365, 0.9043, 1.08571, 0.96927, 0.96706, 0.91484, 0.86035, 0.93575, 0.96924, 0.95923, 1, 1, 0.85771, 1.21968, 1.11437, 1.11437, 0.93109, 0.91202, 0.60411, 0.84164, 0.55572, 1.01173, 0.97361, 0.81818, 0.81818, 0.96635, 0.78032, 0.72727, 0.92366, 0.98601, 1.03405, 0.77968, 1.09799, 1.2, 0.96706, 0.85944, 0.85638, 0.96491, 0.75842, 0.93365, 0.9831, 0.96924, 0.95782, 0.86969, 0.94152, 1.07796, 1.03584, 0.78437, 0.96924, 0.98715, 0.83968, 0.83491, 0.85771, 0.8287, 0.94492, 0.88433, 0.9287, 1.0098, 0.95782, 0.8287, 1.0625, 0.98248, 1.03424, 1.2, 1.01071, 1.0625, 0.95246, 1.03809, 1.04912, 0.98248, 1.00221, 1.03424, 1.05443, 1.2, 1.04785, 0.99609, 1.00169, 1.05176, 0.99346, 1.05356, 0.9087, 1.03004, 0.95542, 0.93117, 1.23362, 1.01071, 1.07831, 1.02512, 1.05205, 1.03502, 1.2, 1.01071, 1.05356, 1.01071, 1.03502, 0.75842, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.03719, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.9403, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.04021, 1, 1, 1, 1, 1, 1, 0.98965, 1.00068, 0.98965, 1.00068, 0.98965, 1.00068, 0.8287, 0.96777, 1, 1.20088, 0.89903, 1, 1, 0.75155, 1.03077, 1.03077, 1.03077, 1.03077, 1.13196, 1.13196, 1.13196, 0.67428, 0.67428, 1.16039, 0.73291, 1.20996, 1.22135, 1.06483, 0.94868, 0.94868, 0.95996, 1.24633, 1, 1.07497, 0.87796, 0.96927, 1.01518, 0.96927, 1, 1, 1, 0.77295, 1, 1, 1.10539, 1.10539, 1.11358, 1.06967, 0.86279, 0.94434, 0.86279, 0.94434, 0.86182, 1, 1, 1.083, 1, 0.91578, 0.86507, 1.1714, 1.18416, 1.14589, 0.69825, 0.97622, 1.9697, 1.24822, 1.24822, 1.17238, 1.24822, 1.24822, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18083, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.10938, 1.10938, 1, 1, 1, 1.05425, 1.09971, 1.09971, 1.09971, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    is = { lineHeight: 1.33008, lineGap: 0 };
    as = getLookupTableFactory(function(e2) {
      e2["MyriadPro-Regular"] = e2["PdfJS-Fallback-Regular"] = { name: "LiberationSans-Regular", factors: Gn, baseWidths: Un, baseMapping: jn, metrics: Vn }, e2["MyriadPro-Bold"] = e2["PdfJS-Fallback-Bold"] = { name: "LiberationSans-Bold", factors: $n, baseWidths: _n2, baseMapping: Pn, metrics: Hn }, e2["MyriadPro-It"] = e2["MyriadPro-Italic"] = e2["PdfJS-Fallback-Italic"] = { name: "LiberationSans-Italic", factors: zn, baseWidths: Nn, baseMapping: Ln, metrics: Wn }, e2["MyriadPro-BoldIt"] = e2["MyriadPro-BoldItalic"] = e2["PdfJS-Fallback-BoldItalic"] = { name: "LiberationSans-BoldItalic", factors: qn, baseWidths: Rn, baseMapping: Bn, metrics: Xn }, e2.ArialMT = e2.Arial = e2["Arial-Regular"] = { name: "LiberationSans-Regular", baseWidths: Un, baseMapping: jn }, e2["Arial-BoldMT"] = e2["Arial-Bold"] = { name: "LiberationSans-Bold", baseWidths: _n2, baseMapping: Pn }, e2["Arial-ItalicMT"] = e2["Arial-Italic"] = { name: "LiberationSans-Italic", baseWidths: Nn, baseMapping: Ln }, e2["Arial-BoldItalicMT"] = e2["Arial-BoldItalic"] = { name: "LiberationSans-BoldItalic", baseWidths: Rn, baseMapping: Bn }, e2["Calibri-Regular"] = { name: "LiberationSans-Regular", factors: vn, baseWidths: Un, baseMapping: jn, metrics: Cn }, e2["Calibri-Bold"] = { name: "LiberationSans-Bold", factors: bn, baseWidths: _n2, baseMapping: Pn, metrics: yn }, e2["Calibri-Italic"] = { name: "LiberationSans-Italic", factors: xn, baseWidths: Nn, baseMapping: Ln, metrics: Sn }, e2["Calibri-BoldItalic"] = { name: "LiberationSans-BoldItalic", factors: wn, baseWidths: Rn, baseMapping: Bn, metrics: An }, e2["Segoeui-Regular"] = { name: "LiberationSans-Regular", factors: ts, baseWidths: Un, baseMapping: jn, metrics: is }, e2["Segoeui-Bold"] = { name: "LiberationSans-Bold", factors: Kn, baseWidths: _n2, baseMapping: Pn, metrics: Yn }, e2["Segoeui-Italic"] = { name: "LiberationSans-Italic", factors: Qn, baseWidths: Nn, baseMapping: Ln, metrics: es }, e2["Segoeui-BoldItalic"] = { name: "LiberationSans-BoldItalic", factors: Jn, baseWidths: Rn, baseMapping: Bn, metrics: Zn }, e2["Helvetica-Regular"] = e2.Helvetica = { name: "LiberationSans-Regular", factors: En, baseWidths: Un, baseMapping: jn, metrics: On }, e2["Helvetica-Bold"] = { name: "LiberationSans-Bold", factors: kn, baseWidths: _n2, baseMapping: Pn, metrics: Tn }, e2["Helvetica-Italic"] = { name: "LiberationSans-Italic", factors: Mn, baseWidths: Nn, baseMapping: Ln, metrics: Dn }, e2["Helvetica-BoldItalic"] = { name: "LiberationSans-BoldItalic", factors: In, baseWidths: Rn, baseMapping: Bn, metrics: Fn };
    });
    __name(getXfaFontName, "getXfaFontName");
    __name(getXfaFontDict, "getXfaFontDict");
    PostScriptParser = class {
      constructor(e2) {
        this.lexer = e2, this.operators = [], this.token = null, this.prev = null;
      }
      nextToken() {
        this.prev = this.token, this.token = this.lexer.getToken();
      }
      accept(e2) {
        return this.token.type === e2 && (this.nextToken(), true);
      }
      expect(e2) {
        if (this.accept(e2))
          return true;
        throw new ti(`Unexpected symbol: found ${this.token.type} expected ${e2}.`);
      }
      parse() {
        return this.nextToken(), this.expect(ns.LBRACE), this.parseBlock(), this.expect(ns.RBRACE), this.operators;
      }
      parseBlock() {
        for (; ; )
          if (this.accept(ns.NUMBER))
            this.operators.push(this.prev.value);
          else if (this.accept(ns.OPERATOR))
            this.operators.push(this.prev.value);
          else {
            if (!this.accept(ns.LBRACE))
              return;
            this.parseCondition();
          }
      }
      parseCondition() {
        const e2 = this.operators.length;
        if (this.operators.push(null, null), this.parseBlock(), this.expect(ns.RBRACE), this.accept(ns.IF))
          this.operators[e2] = this.operators.length, this.operators[e2 + 1] = "jz";
        else {
          if (!this.accept(ns.LBRACE))
            throw new ti("PS Function: error parsing conditional.");
          {
            const t2 = this.operators.length;
            this.operators.push(null, null);
            const i2 = this.operators.length;
            this.parseBlock(), this.expect(ns.RBRACE), this.expect(ns.IFELSE), this.operators[t2] = this.operators.length, this.operators[t2 + 1] = "j", this.operators[e2] = i2, this.operators[e2 + 1] = "jz";
          }
        }
      }
    };
    __name(PostScriptParser, "PostScriptParser");
    ns = { LBRACE: 0, RBRACE: 1, NUMBER: 2, OPERATOR: 3, IF: 4, IFELSE: 5 };
    PostScriptToken = class {
      static get opCache() {
        return shadow$1(this, "opCache", /* @__PURE__ */ Object.create(null));
      }
      constructor(e2, t2) {
        this.type = e2, this.value = t2;
      }
      static getOperator(e2) {
        return PostScriptToken.opCache[e2] ||= new PostScriptToken(ns.OPERATOR, e2);
      }
      static get LBRACE() {
        return shadow$1(this, "LBRACE", new PostScriptToken(ns.LBRACE, "{"));
      }
      static get RBRACE() {
        return shadow$1(this, "RBRACE", new PostScriptToken(ns.RBRACE, "}"));
      }
      static get IF() {
        return shadow$1(this, "IF", new PostScriptToken(ns.IF, "IF"));
      }
      static get IFELSE() {
        return shadow$1(this, "IFELSE", new PostScriptToken(ns.IFELSE, "IFELSE"));
      }
    };
    __name(PostScriptToken, "PostScriptToken");
    PostScriptLexer = class {
      constructor(e2) {
        this.stream = e2, this.nextChar(), this.strBuf = [];
      }
      nextChar() {
        return this.currentChar = this.stream.getByte();
      }
      getToken() {
        let e2 = false, t2 = this.currentChar;
        for (; ; ) {
          if (t2 < 0)
            return ci;
          if (e2)
            10 !== t2 && 13 !== t2 || (e2 = false);
          else if (37 === t2)
            e2 = true;
          else if (!isWhiteSpace(t2))
            break;
          t2 = this.nextChar();
        }
        switch (0 | t2) {
          case 48:
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
          case 43:
          case 45:
          case 46:
            return new PostScriptToken(ns.NUMBER, this.getNumber());
          case 123:
            return this.nextChar(), PostScriptToken.LBRACE;
          case 125:
            return this.nextChar(), PostScriptToken.RBRACE;
        }
        const i2 = this.strBuf;
        for (i2.length = 0, i2[0] = String.fromCharCode(t2); (t2 = this.nextChar()) >= 0 && (t2 >= 65 && t2 <= 90 || t2 >= 97 && t2 <= 122); )
          i2.push(String.fromCharCode(t2));
        const a2 = i2.join("");
        switch (a2.toLowerCase()) {
          case "if":
            return PostScriptToken.IF;
          case "ifelse":
            return PostScriptToken.IFELSE;
          default:
            return PostScriptToken.getOperator(a2);
        }
      }
      getNumber() {
        let e2 = this.currentChar;
        const t2 = this.strBuf;
        for (t2.length = 0, t2[0] = String.fromCharCode(e2); (e2 = this.nextChar()) >= 0 && (e2 >= 48 && e2 <= 57 || 45 === e2 || 46 === e2); )
          t2.push(String.fromCharCode(e2));
        const i2 = parseFloat(t2.join(""));
        if (isNaN(i2))
          throw new ti(`Invalid floating point number: ${i2}`);
        return i2;
      }
    };
    __name(PostScriptLexer, "PostScriptLexer");
    BaseLocalCache = class {
      constructor(e2) {
        this._onlyRefs = true === e2?.onlyRefs, this._onlyRefs || (this._nameRefMap = /* @__PURE__ */ new Map(), this._imageMap = /* @__PURE__ */ new Map()), this._imageCache = new RefSetCache();
      }
      getByName(e2) {
        this._onlyRefs && unreachable$1("Should not call `getByName` method.");
        const t2 = this._nameRefMap.get(e2);
        return t2 ? this.getByRef(t2) : this._imageMap.get(e2) || null;
      }
      getByRef(e2) {
        return this._imageCache.get(e2) || null;
      }
      set(e2, t2, i2) {
        unreachable$1("Abstract method `set` called.");
      }
    };
    __name(BaseLocalCache, "BaseLocalCache");
    LocalImageCache = class extends BaseLocalCache {
      set(e2, t2 = null, i2) {
        if ("string" != typeof e2)
          throw new Error('LocalImageCache.set - expected "name" argument.');
        if (t2) {
          if (this._imageCache.has(t2))
            return;
          return this._nameRefMap.set(e2, t2), void this._imageCache.put(t2, i2);
        }
        this._imageMap.has(e2) || this._imageMap.set(e2, i2);
      }
    };
    __name(LocalImageCache, "LocalImageCache");
    LocalColorSpaceCache = class extends BaseLocalCache {
      set(e2 = null, t2 = null, i2) {
        if ("string" != typeof e2 && !t2)
          throw new Error('LocalColorSpaceCache.set - expected "name" and/or "ref" argument.');
        if (t2) {
          if (this._imageCache.has(t2))
            return;
          return null !== e2 && this._nameRefMap.set(e2, t2), void this._imageCache.put(t2, i2);
        }
        this._imageMap.has(e2) || this._imageMap.set(e2, i2);
      }
    };
    __name(LocalColorSpaceCache, "LocalColorSpaceCache");
    LocalFunctionCache = class extends BaseLocalCache {
      constructor(e2) {
        super({ onlyRefs: true });
      }
      set(e2 = null, t2, i2) {
        if (!t2)
          throw new Error('LocalFunctionCache.set - expected "ref" argument.');
        this._imageCache.has(t2) || this._imageCache.put(t2, i2);
      }
    };
    __name(LocalFunctionCache, "LocalFunctionCache");
    LocalGStateCache = class extends BaseLocalCache {
      set(e2, t2 = null, i2) {
        if ("string" != typeof e2)
          throw new Error('LocalGStateCache.set - expected "name" argument.');
        if (t2) {
          if (this._imageCache.has(t2))
            return;
          return this._nameRefMap.set(e2, t2), void this._imageCache.put(t2, i2);
        }
        this._imageMap.has(e2) || this._imageMap.set(e2, i2);
      }
    };
    __name(LocalGStateCache, "LocalGStateCache");
    LocalTilingPatternCache = class extends BaseLocalCache {
      constructor(e2) {
        super({ onlyRefs: true });
      }
      set(e2 = null, t2, i2) {
        if (!t2)
          throw new Error('LocalTilingPatternCache.set - expected "ref" argument.');
        this._imageCache.has(t2) || this._imageCache.put(t2, i2);
      }
    };
    __name(LocalTilingPatternCache, "LocalTilingPatternCache");
    RegionalImageCache = class extends BaseLocalCache {
      constructor(e2) {
        super({ onlyRefs: true });
      }
      set(e2 = null, t2, i2) {
        if (!t2)
          throw new Error('RegionalImageCache.set - expected "ref" argument.');
        this._imageCache.has(t2) || this._imageCache.put(t2, i2);
      }
    };
    __name(RegionalImageCache, "RegionalImageCache");
    GlobalColorSpaceCache = class extends BaseLocalCache {
      constructor(e2) {
        super({ onlyRefs: true });
      }
      set(e2 = null, t2, i2) {
        if (!t2)
          throw new Error('GlobalColorSpaceCache.set - expected "ref" argument.');
        this._imageCache.has(t2) || this._imageCache.put(t2, i2);
      }
      clear() {
        this._imageCache.clear();
      }
    };
    __name(GlobalColorSpaceCache, "GlobalColorSpaceCache");
    _GlobalImageCache = class {
      constructor() {
        __privateAdd(this, _X);
        __privateAdd(this, _z);
        __privateAdd(this, _q, new RefSet());
        this._refCache = new RefSetCache(), this._imageCache = new RefSetCache();
      }
      shouldCache(e2, t2) {
        let i2 = this._refCache.get(e2);
        return i2 || (i2 = /* @__PURE__ */ new Set(), this._refCache.put(e2, i2)), i2.add(t2), !(i2.size < _GlobalImageCache.NUM_PAGES_THRESHOLD) && !(!this._imageCache.has(e2) && __privateGet(this, _z, z_get));
      }
      addDecodeFailed(e2) {
        __privateGet(this, _q).put(e2);
      }
      hasDecodeFailed(e2) {
        return __privateGet(this, _q).has(e2);
      }
      addByteSize(e2, t2) {
        const i2 = this._imageCache.get(e2);
        i2 && (i2.byteSize || (i2.byteSize = t2));
      }
      getData(e2, t2) {
        const i2 = this._refCache.get(e2);
        if (!i2)
          return null;
        if (i2.size < _GlobalImageCache.NUM_PAGES_THRESHOLD)
          return null;
        const a2 = this._imageCache.get(e2);
        return a2 ? (i2.add(t2), a2) : null;
      }
      setData(e2, t2) {
        if (!this._refCache.has(e2))
          throw new Error('GlobalImageCache.setData - expected "shouldCache" to have been called.');
        this._imageCache.has(e2) || (__privateGet(this, _z, z_get) ? warn$1("GlobalImageCache.setData - cache limit reached.") : this._imageCache.put(e2, t2));
      }
      clear(e2 = false) {
        e2 || (__privateGet(this, _q).clear(), this._refCache.clear()), this._imageCache.clear();
      }
    };
    GlobalImageCache = _GlobalImageCache;
    __name(GlobalImageCache, "GlobalImageCache");
    _q = new WeakMap();
    _X = new WeakSet();
    X_get = /* @__PURE__ */ __name(function() {
      let e2 = 0;
      for (const t2 of this._imageCache)
        e2 += t2.byteSize;
      return e2;
    }, "#X");
    _z = new WeakSet();
    z_get = /* @__PURE__ */ __name(function() {
      return !(this._imageCache.size < _GlobalImageCache.MIN_IMAGES_TO_CACHE) && !(__privateGet(this, _X, X_get) < _GlobalImageCache.MAX_BYTE_SIZE);
    }, "#z");
    __publicField(GlobalImageCache, "NUM_PAGES_THRESHOLD", 2);
    __publicField(GlobalImageCache, "MIN_IMAGES_TO_CACHE", 10);
    __publicField(GlobalImageCache, "MAX_BYTE_SIZE", 5e7);
    PDFFunctionFactory = class {
      constructor({ xref: e2, isEvalSupported: t2 = true }) {
        this.xref = e2, this.isEvalSupported = false !== t2;
      }
      create(e2, t2 = false) {
        let i2, a2;
        if (e2 instanceof Ref ? i2 = e2 : e2 instanceof Dict ? i2 = e2.objId : e2 instanceof BaseStream && (i2 = e2.dict?.objId), i2) {
          const e3 = this._localFunctionCache.getByRef(i2);
          if (e3)
            return e3;
        }
        const n2 = this.xref.fetchIfRef(e2);
        if (Array.isArray(n2)) {
          if (!t2)
            throw new Error('PDFFunctionFactory.create - expected "parseArray" argument.');
          a2 = PDFFunction.parseArray(this, n2);
        } else
          a2 = PDFFunction.parse(this, n2);
        return i2 && this._localFunctionCache.set(null, i2, a2), a2;
      }
      get _localFunctionCache() {
        return shadow$1(this, "_localFunctionCache", new LocalFunctionCache());
      }
    };
    __name(PDFFunctionFactory, "PDFFunctionFactory");
    __name(toNumberArray, "toNumberArray");
    PDFFunction = class {
      static getSampleArray(e2, t2, i2, a2) {
        let n2, s2, r2 = 1;
        for (n2 = 0, s2 = e2.length; n2 < s2; n2++)
          r2 *= e2[n2];
        r2 *= t2;
        const o2 = new Array(r2);
        let l3 = 0, c2 = 0;
        const h2 = 1 / (2 ** i2 - 1), d2 = a2.getBytes((r2 * i2 + 7) / 8);
        let u2 = 0;
        for (n2 = 0; n2 < r2; n2++) {
          for (; l3 < i2; )
            c2 <<= 8, c2 |= d2[u2++], l3 += 8;
          l3 -= i2, o2[n2] = (c2 >> l3) * h2, c2 &= (1 << l3) - 1;
        }
        return o2;
      }
      static parse(e2, t2) {
        const i2 = t2.dict || t2;
        switch (i2.get("FunctionType")) {
          case 0:
            return this.constructSampled(e2, t2, i2);
          case 1:
            break;
          case 2:
            return this.constructInterpolated(e2, i2);
          case 3:
            return this.constructStiched(e2, i2);
          case 4:
            return this.constructPostScript(e2, t2, i2);
        }
        throw new ti("Unknown type of function");
      }
      static parseArray(e2, t2) {
        const { xref: i2 } = e2, a2 = [];
        for (const n2 of t2)
          a2.push(this.parse(e2, i2.fetchIfRef(n2)));
        return function(e3, t3, i3, n2) {
          for (let s2 = 0, r2 = a2.length; s2 < r2; s2++)
            a2[s2](e3, t3, i3, n2 + s2);
        };
      }
      static constructSampled(e2, t2, i2) {
        function toMultiArray(e3) {
          const t3 = e3.length, i3 = [];
          let a3 = 0;
          for (let n3 = 0; n3 < t3; n3 += 2)
            i3[a3++] = [e3[n3], e3[n3 + 1]];
          return i3;
        }
        __name(toMultiArray, "toMultiArray");
        function interpolate(e3, t3, i3, a3, n3) {
          return a3 + (n3 - a3) / (i3 - t3) * (e3 - t3);
        }
        __name(interpolate, "interpolate");
        let a2 = toNumberArray(i2.getArray("Domain")), n2 = toNumberArray(i2.getArray("Range"));
        if (!a2 || !n2)
          throw new ti("No domain or range");
        const s2 = a2.length / 2, r2 = n2.length / 2;
        a2 = toMultiArray(a2), n2 = toMultiArray(n2);
        const o2 = toNumberArray(i2.getArray("Size")), l3 = i2.get("BitsPerSample"), c2 = i2.get("Order") || 1;
        1 !== c2 && info$1("No support for cubic spline interpolation: " + c2);
        let h2 = toNumberArray(i2.getArray("Encode"));
        if (h2)
          h2 = toMultiArray(h2);
        else {
          h2 = [];
          for (let e3 = 0; e3 < s2; ++e3)
            h2.push([0, o2[e3] - 1]);
        }
        let d2 = toNumberArray(i2.getArray("Decode"));
        d2 = d2 ? toMultiArray(d2) : n2;
        const u2 = this.getSampleArray(o2, r2, l3, t2);
        return function(e3, t3, i3, l4) {
          const c3 = 1 << s2, g2 = new Float64Array(c3).fill(1), p2 = new Uint32Array(c3);
          let f2, m2, b2 = r2, y2 = 1;
          for (f2 = 0; f2 < s2; ++f2) {
            const i4 = a2[f2][0], n3 = a2[f2][1];
            let s3 = interpolate(MathClamp$1(e3[t3 + f2], i4, n3), i4, n3, h2[f2][0], h2[f2][1]);
            const r3 = o2[f2];
            s3 = MathClamp$1(s3, 0, r3 - 1);
            const l5 = s3 < r3 - 1 ? Math.floor(s3) : s3 - 1, d3 = l5 + 1 - s3, u3 = s3 - l5, w2 = l5 * b2, x2 = w2 + b2;
            for (m2 = 0; m2 < c3; m2++)
              m2 & y2 ? (g2[m2] *= u3, p2[m2] += x2) : (g2[m2] *= d3, p2[m2] += w2);
            b2 *= r3, y2 <<= 1;
          }
          for (m2 = 0; m2 < r2; ++m2) {
            let e4 = 0;
            for (f2 = 0; f2 < c3; f2++)
              e4 += u2[p2[f2] + m2] * g2[f2];
            e4 = interpolate(e4, 0, 1, d2[m2][0], d2[m2][1]), i3[l4 + m2] = MathClamp$1(e4, n2[m2][0], n2[m2][1]);
          }
        };
      }
      static constructInterpolated(e2, t2) {
        const i2 = toNumberArray(t2.getArray("C0")) || [0], a2 = toNumberArray(t2.getArray("C1")) || [1], n2 = t2.get("N"), s2 = [];
        for (let e3 = 0, t3 = i2.length; e3 < t3; ++e3)
          s2.push(a2[e3] - i2[e3]);
        const r2 = s2.length;
        return function(e3, t3, a3, o2) {
          const l3 = 1 === n2 ? e3[t3] : e3[t3] ** n2;
          for (let e4 = 0; e4 < r2; ++e4)
            a3[o2 + e4] = i2[e4] + l3 * s2[e4];
        };
      }
      static constructStiched(e2, t2) {
        const i2 = toNumberArray(t2.getArray("Domain"));
        if (!i2)
          throw new ti("No domain");
        if (1 !== i2.length / 2)
          throw new ti("Bad domain for stiched function");
        const { xref: a2 } = e2, n2 = [];
        for (const i3 of t2.get("Functions"))
          n2.push(this.parse(e2, a2.fetchIfRef(i3)));
        const s2 = toNumberArray(t2.getArray("Bounds")), r2 = toNumberArray(t2.getArray("Encode")), o2 = new Float32Array(1);
        return function(e3, t3, a3, l3) {
          const c2 = MathClamp$1(e3[t3], i2[0], i2[1]), h2 = s2.length;
          let d2;
          for (d2 = 0; d2 < h2 && !(c2 < s2[d2]); ++d2)
            ;
          let u2 = i2[0];
          d2 > 0 && (u2 = s2[d2 - 1]);
          let g2 = i2[1];
          d2 < s2.length && (g2 = s2[d2]);
          const p2 = r2[2 * d2], f2 = r2[2 * d2 + 1];
          o2[0] = u2 === g2 ? p2 : p2 + (c2 - u2) * (f2 - p2) / (g2 - u2), n2[d2](o2, 0, a3, l3);
        };
      }
      static constructPostScript(e2, t2, i2) {
        const a2 = toNumberArray(i2.getArray("Domain")), n2 = toNumberArray(i2.getArray("Range"));
        if (!a2)
          throw new ti("No domain.");
        if (!n2)
          throw new ti("No range.");
        const s2 = new PostScriptLexer(t2), r2 = new PostScriptParser(s2).parse();
        if (e2.isEvalSupported && FeatureTest.isEvalSupported) {
          const e3 = new PostScriptCompiler().compile(r2, a2, n2);
          if (e3)
            return new Function("src", "srcOffset", "dest", "destOffset", e3);
        }
        info$1("Unable to compile PS function");
        const o2 = n2.length >> 1, l3 = a2.length >> 1, c2 = new PostScriptEvaluator(r2), h2 = /* @__PURE__ */ Object.create(null);
        let d2 = 8192;
        const u2 = new Float32Array(l3);
        return function(e3, t3, i3, a3) {
          let s3, r3, g2 = "";
          const p2 = u2;
          for (s3 = 0; s3 < l3; s3++)
            r3 = e3[t3 + s3], p2[s3] = r3, g2 += r3 + "_";
          const f2 = h2[g2];
          if (void 0 !== f2)
            return void i3.set(f2, a3);
          const m2 = new Float32Array(o2), b2 = c2.execute(p2), y2 = b2.length - o2;
          for (s3 = 0; s3 < o2; s3++) {
            r3 = b2[y2 + s3];
            let e4 = n2[2 * s3];
            r3 < e4 ? r3 = e4 : (e4 = n2[2 * s3 + 1], r3 > e4 && (r3 = e4)), m2[s3] = r3;
          }
          d2 > 0 && (d2--, h2[g2] = m2), i3.set(m2, a3);
        };
      }
    };
    __name(PDFFunction, "PDFFunction");
    __name(isPDFFunction, "isPDFFunction");
    _PostScriptStack = class {
      constructor(e2) {
        this.stack = e2 ? Array.from(e2) : [];
      }
      push(e2) {
        if (this.stack.length >= _PostScriptStack.MAX_STACK_SIZE)
          throw new Error("PostScript function stack overflow.");
        this.stack.push(e2);
      }
      pop() {
        if (this.stack.length <= 0)
          throw new Error("PostScript function stack underflow.");
        return this.stack.pop();
      }
      copy(e2) {
        if (this.stack.length + e2 >= _PostScriptStack.MAX_STACK_SIZE)
          throw new Error("PostScript function stack overflow.");
        const t2 = this.stack;
        for (let i2 = t2.length - e2, a2 = e2 - 1; a2 >= 0; a2--, i2++)
          t2.push(t2[i2]);
      }
      index(e2) {
        this.push(this.stack[this.stack.length - e2 - 1]);
      }
      roll(e2, t2) {
        const i2 = this.stack, a2 = i2.length - e2, n2 = i2.length - 1, s2 = a2 + (t2 - Math.floor(t2 / e2) * e2);
        for (let e3 = a2, t3 = n2; e3 < t3; e3++, t3--) {
          const a3 = i2[e3];
          i2[e3] = i2[t3], i2[t3] = a3;
        }
        for (let e3 = a2, t3 = s2 - 1; e3 < t3; e3++, t3--) {
          const a3 = i2[e3];
          i2[e3] = i2[t3], i2[t3] = a3;
        }
        for (let e3 = s2, t3 = n2; e3 < t3; e3++, t3--) {
          const a3 = i2[e3];
          i2[e3] = i2[t3], i2[t3] = a3;
        }
      }
    };
    PostScriptStack = _PostScriptStack;
    __name(PostScriptStack, "PostScriptStack");
    __publicField(PostScriptStack, "MAX_STACK_SIZE", 100);
    PostScriptEvaluator = class {
      constructor(e2) {
        this.operators = e2;
      }
      execute(e2) {
        const t2 = new PostScriptStack(e2);
        let i2 = 0;
        const a2 = this.operators, n2 = a2.length;
        let s2, r2, o2;
        for (; i2 < n2; )
          if (s2 = a2[i2++], "number" != typeof s2)
            switch (s2) {
              case "jz":
                o2 = t2.pop(), r2 = t2.pop(), r2 || (i2 = o2);
                break;
              case "j":
                r2 = t2.pop(), i2 = r2;
                break;
              case "abs":
                r2 = t2.pop(), t2.push(Math.abs(r2));
                break;
              case "add":
                o2 = t2.pop(), r2 = t2.pop(), t2.push(r2 + o2);
                break;
              case "and":
                o2 = t2.pop(), r2 = t2.pop(), "boolean" == typeof r2 && "boolean" == typeof o2 ? t2.push(r2 && o2) : t2.push(r2 & o2);
                break;
              case "atan":
                o2 = t2.pop(), r2 = t2.pop(), r2 = Math.atan2(r2, o2) / Math.PI * 180, r2 < 0 && (r2 += 360), t2.push(r2);
                break;
              case "bitshift":
                o2 = t2.pop(), r2 = t2.pop(), r2 > 0 ? t2.push(r2 << o2) : t2.push(r2 >> o2);
                break;
              case "ceiling":
                r2 = t2.pop(), t2.push(Math.ceil(r2));
                break;
              case "copy":
                r2 = t2.pop(), t2.copy(r2);
                break;
              case "cos":
                r2 = t2.pop(), t2.push(Math.cos(r2 % 360 / 180 * Math.PI));
                break;
              case "cvi":
                r2 = 0 | t2.pop(), t2.push(r2);
                break;
              case "cvr":
                break;
              case "div":
                o2 = t2.pop(), r2 = t2.pop(), t2.push(r2 / o2);
                break;
              case "dup":
                t2.copy(1);
                break;
              case "eq":
                o2 = t2.pop(), r2 = t2.pop(), t2.push(r2 === o2);
                break;
              case "exch":
                t2.roll(2, 1);
                break;
              case "exp":
                o2 = t2.pop(), r2 = t2.pop(), t2.push(r2 ** o2);
                break;
              case "false":
                t2.push(false);
                break;
              case "floor":
                r2 = t2.pop(), t2.push(Math.floor(r2));
                break;
              case "ge":
                o2 = t2.pop(), r2 = t2.pop(), t2.push(r2 >= o2);
                break;
              case "gt":
                o2 = t2.pop(), r2 = t2.pop(), t2.push(r2 > o2);
                break;
              case "idiv":
                o2 = t2.pop(), r2 = t2.pop(), t2.push(r2 / o2 | 0);
                break;
              case "index":
                r2 = t2.pop(), t2.index(r2);
                break;
              case "le":
                o2 = t2.pop(), r2 = t2.pop(), t2.push(r2 <= o2);
                break;
              case "ln":
                r2 = t2.pop(), t2.push(Math.log(r2));
                break;
              case "log":
                r2 = t2.pop(), t2.push(Math.log10(r2));
                break;
              case "lt":
                o2 = t2.pop(), r2 = t2.pop(), t2.push(r2 < o2);
                break;
              case "mod":
                o2 = t2.pop(), r2 = t2.pop(), t2.push(r2 % o2);
                break;
              case "mul":
                o2 = t2.pop(), r2 = t2.pop(), t2.push(r2 * o2);
                break;
              case "ne":
                o2 = t2.pop(), r2 = t2.pop(), t2.push(r2 !== o2);
                break;
              case "neg":
                r2 = t2.pop(), t2.push(-r2);
                break;
              case "not":
                r2 = t2.pop(), "boolean" == typeof r2 ? t2.push(!r2) : t2.push(~r2);
                break;
              case "or":
                o2 = t2.pop(), r2 = t2.pop(), "boolean" == typeof r2 && "boolean" == typeof o2 ? t2.push(r2 || o2) : t2.push(r2 | o2);
                break;
              case "pop":
                t2.pop();
                break;
              case "roll":
                o2 = t2.pop(), r2 = t2.pop(), t2.roll(r2, o2);
                break;
              case "round":
                r2 = t2.pop(), t2.push(Math.round(r2));
                break;
              case "sin":
                r2 = t2.pop(), t2.push(Math.sin(r2 % 360 / 180 * Math.PI));
                break;
              case "sqrt":
                r2 = t2.pop(), t2.push(Math.sqrt(r2));
                break;
              case "sub":
                o2 = t2.pop(), r2 = t2.pop(), t2.push(r2 - o2);
                break;
              case "true":
                t2.push(true);
                break;
              case "truncate":
                r2 = t2.pop(), r2 = r2 < 0 ? Math.ceil(r2) : Math.floor(r2), t2.push(r2);
                break;
              case "xor":
                o2 = t2.pop(), r2 = t2.pop(), "boolean" == typeof r2 && "boolean" == typeof o2 ? t2.push(r2 !== o2) : t2.push(r2 ^ o2);
                break;
              default:
                throw new ti(`Unknown operator ${s2}`);
            }
          else
            t2.push(s2);
        return t2.stack;
      }
    };
    __name(PostScriptEvaluator, "PostScriptEvaluator");
    AstNode = class {
      constructor(e2) {
        this.type = e2;
      }
      visit(e2) {
        unreachable$1("abstract method");
      }
    };
    __name(AstNode, "AstNode");
    AstArgument = class extends AstNode {
      constructor(e2, t2, i2) {
        super("args"), this.index = e2, this.min = t2, this.max = i2;
      }
      visit(e2) {
        e2.visitArgument(this);
      }
    };
    __name(AstArgument, "AstArgument");
    AstLiteral = class extends AstNode {
      constructor(e2) {
        super("literal"), this.number = e2, this.min = e2, this.max = e2;
      }
      visit(e2) {
        e2.visitLiteral(this);
      }
    };
    __name(AstLiteral, "AstLiteral");
    AstBinaryOperation = class extends AstNode {
      constructor(e2, t2, i2, a2, n2) {
        super("binary"), this.op = e2, this.arg1 = t2, this.arg2 = i2, this.min = a2, this.max = n2;
      }
      visit(e2) {
        e2.visitBinaryOperation(this);
      }
    };
    __name(AstBinaryOperation, "AstBinaryOperation");
    AstMin = class extends AstNode {
      constructor(e2, t2) {
        super("max"), this.arg = e2, this.min = e2.min, this.max = t2;
      }
      visit(e2) {
        e2.visitMin(this);
      }
    };
    __name(AstMin, "AstMin");
    AstVariable = class extends AstNode {
      constructor(e2, t2, i2) {
        super("var"), this.index = e2, this.min = t2, this.max = i2;
      }
      visit(e2) {
        e2.visitVariable(this);
      }
    };
    __name(AstVariable, "AstVariable");
    AstVariableDefinition = class extends AstNode {
      constructor(e2, t2) {
        super("definition"), this.variable = e2, this.arg = t2;
      }
      visit(e2) {
        e2.visitVariableDefinition(this);
      }
    };
    __name(AstVariableDefinition, "AstVariableDefinition");
    ExpressionBuilderVisitor = class {
      constructor() {
        this.parts = [];
      }
      visitArgument(e2) {
        this.parts.push("Math.max(", e2.min, ", Math.min(", e2.max, ", src[srcOffset + ", e2.index, "]))");
      }
      visitVariable(e2) {
        this.parts.push("v", e2.index);
      }
      visitLiteral(e2) {
        this.parts.push(e2.number);
      }
      visitBinaryOperation(e2) {
        this.parts.push("("), e2.arg1.visit(this), this.parts.push(" ", e2.op, " "), e2.arg2.visit(this), this.parts.push(")");
      }
      visitVariableDefinition(e2) {
        this.parts.push("var "), e2.variable.visit(this), this.parts.push(" = "), e2.arg.visit(this), this.parts.push(";");
      }
      visitMin(e2) {
        this.parts.push("Math.min("), e2.arg.visit(this), this.parts.push(", ", e2.max, ")");
      }
      toString() {
        return this.parts.join("");
      }
    };
    __name(ExpressionBuilderVisitor, "ExpressionBuilderVisitor");
    __name(buildAddOperation, "buildAddOperation");
    __name(buildMulOperation, "buildMulOperation");
    __name(buildSubOperation, "buildSubOperation");
    __name(buildMinOperation, "buildMinOperation");
    PostScriptCompiler = class {
      compile(e2, t2, i2) {
        const a2 = [], n2 = [], s2 = t2.length >> 1, r2 = i2.length >> 1;
        let o2, l3, c2, h2, d2, u2, g2, p2, f2 = 0;
        for (let e3 = 0; e3 < s2; e3++)
          a2.push(new AstArgument(e3, t2[2 * e3], t2[2 * e3 + 1]));
        for (let t3 = 0, i3 = e2.length; t3 < i3; t3++)
          if (p2 = e2[t3], "number" != typeof p2)
            switch (p2) {
              case "add":
                if (a2.length < 2)
                  return null;
                h2 = a2.pop(), c2 = a2.pop(), a2.push(buildAddOperation(c2, h2));
                break;
              case "cvr":
                if (a2.length < 1)
                  return null;
                break;
              case "mul":
                if (a2.length < 2)
                  return null;
                h2 = a2.pop(), c2 = a2.pop(), a2.push(buildMulOperation(c2, h2));
                break;
              case "sub":
                if (a2.length < 2)
                  return null;
                h2 = a2.pop(), c2 = a2.pop(), a2.push(buildSubOperation(c2, h2));
                break;
              case "exch":
                if (a2.length < 2)
                  return null;
                d2 = a2.pop(), u2 = a2.pop(), a2.push(d2, u2);
                break;
              case "pop":
                if (a2.length < 1)
                  return null;
                a2.pop();
                break;
              case "index":
                if (a2.length < 1)
                  return null;
                if (c2 = a2.pop(), "literal" !== c2.type)
                  return null;
                if (o2 = c2.number, o2 < 0 || !Number.isInteger(o2) || a2.length < o2)
                  return null;
                if (d2 = a2[a2.length - o2 - 1], "literal" === d2.type || "var" === d2.type) {
                  a2.push(d2);
                  break;
                }
                g2 = new AstVariable(f2++, d2.min, d2.max), a2[a2.length - o2 - 1] = g2, a2.push(g2), n2.push(new AstVariableDefinition(g2, d2));
                break;
              case "dup":
                if (a2.length < 1)
                  return null;
                if ("number" == typeof e2[t3 + 1] && "gt" === e2[t3 + 2] && e2[t3 + 3] === t3 + 7 && "jz" === e2[t3 + 4] && "pop" === e2[t3 + 5] && e2[t3 + 6] === e2[t3 + 1]) {
                  c2 = a2.pop(), a2.push(buildMinOperation(c2, e2[t3 + 1])), t3 += 6;
                  break;
                }
                if (d2 = a2.at(-1), "literal" === d2.type || "var" === d2.type) {
                  a2.push(d2);
                  break;
                }
                g2 = new AstVariable(f2++, d2.min, d2.max), a2[a2.length - 1] = g2, a2.push(g2), n2.push(new AstVariableDefinition(g2, d2));
                break;
              case "roll":
                if (a2.length < 2)
                  return null;
                if (h2 = a2.pop(), c2 = a2.pop(), "literal" !== h2.type || "literal" !== c2.type)
                  return null;
                if (l3 = h2.number, o2 = c2.number, o2 <= 0 || !Number.isInteger(o2) || !Number.isInteger(l3) || a2.length < o2)
                  return null;
                if (l3 = (l3 % o2 + o2) % o2, 0 === l3)
                  break;
                a2.push(...a2.splice(a2.length - o2, o2 - l3));
                break;
              default:
                return null;
            }
          else
            a2.push(new AstLiteral(p2));
        if (a2.length !== r2)
          return null;
        const m2 = [];
        for (const e3 of n2) {
          const t3 = new ExpressionBuilderVisitor();
          e3.visit(t3), m2.push(t3.toString());
        }
        for (let e3 = 0, t3 = a2.length; e3 < t3; e3++) {
          const t4 = a2[e3], n3 = new ExpressionBuilderVisitor();
          t4.visit(n3);
          const s3 = i2[2 * e3], r3 = i2[2 * e3 + 1], o3 = [n3.toString()];
          s3 > t4.min && (o3.unshift("Math.max(", s3, ", "), o3.push(")")), r3 < t4.max && (o3.unshift("Math.min(", r3, ", "), o3.push(")")), o3.unshift("dest[destOffset + ", e3, "] = "), o3.push(";"), m2.push(o3.join(""));
        }
        return m2.join("\n");
      }
    };
    __name(PostScriptCompiler, "PostScriptCompiler");
    ss = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "ON", "ON", "ET", "ET", "ET", "ON", "ON", "ON", "ON", "ON", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "ON", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "ON", "ON", "ON", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "ON", "ET", "ET", "ET", "ET", "ON", "ON", "ON", "ON", "L", "ON", "ON", "BN", "ON", "ON", "ET", "ET", "EN", "EN", "ON", "L", "ON", "ON", "ON", "EN", "L", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "L", "L", "L", "L", "L", "L", "L", "L"];
    rs = ["AN", "AN", "AN", "AN", "AN", "AN", "ON", "ON", "AL", "ET", "ET", "AL", "CS", "AL", "ON", "ON", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "ON", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "ON", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL"];
    __name(isOdd, "isOdd");
    __name(isEven, "isEven");
    __name(findUnequal, "findUnequal");
    __name(reverseValues, "reverseValues");
    __name(createBidiText, "createBidiText");
    os = [];
    ls = [];
    __name(bidi, "bidi");
    cs = { style: "normal", weight: "normal" };
    hs = { style: "normal", weight: "bold" };
    ds = { style: "italic", weight: "normal" };
    us = { style: "italic", weight: "bold" };
    gs = /* @__PURE__ */ new Map([["Times-Roman", { local: ["Times New Roman", "Times-Roman", "Times", "Liberation Serif", "Nimbus Roman", "Nimbus Roman L", "Tinos", "Thorndale", "TeX Gyre Termes", "FreeSerif", "Linux Libertine O", "Libertinus Serif", "DejaVu Serif", "Bitstream Vera Serif", "Ubuntu"], style: cs, ultimate: "serif" }], ["Times-Bold", { alias: "Times-Roman", style: hs, ultimate: "serif" }], ["Times-Italic", { alias: "Times-Roman", style: ds, ultimate: "serif" }], ["Times-BoldItalic", { alias: "Times-Roman", style: us, ultimate: "serif" }], ["Helvetica", { local: ["Helvetica", "Helvetica Neue", "Arial", "Arial Nova", "Liberation Sans", "Arimo", "Nimbus Sans", "Nimbus Sans L", "A030", "TeX Gyre Heros", "FreeSans", "DejaVu Sans", "Albany", "Bitstream Vera Sans", "Arial Unicode MS", "Microsoft Sans Serif", "Apple Symbols", "Cantarell"], path: "LiberationSans-Regular.ttf", style: cs, ultimate: "sans-serif" }], ["Helvetica-Bold", { alias: "Helvetica", path: "LiberationSans-Bold.ttf", style: hs, ultimate: "sans-serif" }], ["Helvetica-Oblique", { alias: "Helvetica", path: "LiberationSans-Italic.ttf", style: ds, ultimate: "sans-serif" }], ["Helvetica-BoldOblique", { alias: "Helvetica", path: "LiberationSans-BoldItalic.ttf", style: us, ultimate: "sans-serif" }], ["Courier", { local: ["Courier", "Courier New", "Liberation Mono", "Nimbus Mono", "Nimbus Mono L", "Cousine", "Cumberland", "TeX Gyre Cursor", "FreeMono", "Linux Libertine Mono O", "Libertinus Mono"], style: cs, ultimate: "monospace" }], ["Courier-Bold", { alias: "Courier", style: hs, ultimate: "monospace" }], ["Courier-Oblique", { alias: "Courier", style: ds, ultimate: "monospace" }], ["Courier-BoldOblique", { alias: "Courier", style: us, ultimate: "monospace" }], ["ArialBlack", { local: ["Arial Black"], style: { style: "normal", weight: "900" }, fallback: "Helvetica-Bold" }], ["ArialBlack-Bold", { alias: "ArialBlack" }], ["ArialBlack-Italic", { alias: "ArialBlack", style: { style: "italic", weight: "900" }, fallback: "Helvetica-BoldOblique" }], ["ArialBlack-BoldItalic", { alias: "ArialBlack-Italic" }], ["ArialNarrow", { local: ["Arial Narrow", "Liberation Sans Narrow", "Helvetica Condensed", "Nimbus Sans Narrow", "TeX Gyre Heros Cn"], style: cs, fallback: "Helvetica" }], ["ArialNarrow-Bold", { alias: "ArialNarrow", style: hs, fallback: "Helvetica-Bold" }], ["ArialNarrow-Italic", { alias: "ArialNarrow", style: ds, fallback: "Helvetica-Oblique" }], ["ArialNarrow-BoldItalic", { alias: "ArialNarrow", style: us, fallback: "Helvetica-BoldOblique" }], ["Calibri", { local: ["Calibri", "Carlito"], style: cs, fallback: "Helvetica" }], ["Calibri-Bold", { alias: "Calibri", style: hs, fallback: "Helvetica-Bold" }], ["Calibri-Italic", { alias: "Calibri", style: ds, fallback: "Helvetica-Oblique" }], ["Calibri-BoldItalic", { alias: "Calibri", style: us, fallback: "Helvetica-BoldOblique" }], ["Wingdings", { local: ["Wingdings", "URW Dingbats"], style: cs }], ["Wingdings-Regular", { alias: "Wingdings" }], ["Wingdings-Bold", { alias: "Wingdings" }]]);
    ps = /* @__PURE__ */ new Map([["Arial-Black", "ArialBlack"]]);
    __name(getFamilyName, "getFamilyName");
    __name(generateFont, "generateFont");
    __name(getFontSubstitution, "getFontSubstitution");
    fs = 3285377520;
    ms = 4294901760;
    bs = 65535;
    ys = /* @__PURE__ */ __name(class {
      constructor(e2) {
        this.h1 = e2 ? 4294967295 & e2 : fs, this.h2 = e2 ? 4294967295 & e2 : fs;
      }
      update(e2) {
        let t2, i2;
        if ("string" == typeof e2) {
          t2 = new Uint8Array(2 * e2.length), i2 = 0;
          for (let a3 = 0, n3 = e2.length; a3 < n3; a3++) {
            const n4 = e2.charCodeAt(a3);
            n4 <= 255 ? t2[i2++] = n4 : (t2[i2++] = n4 >>> 8, t2[i2++] = 255 & n4);
          }
        } else {
          if (!ArrayBuffer.isView(e2))
            throw new Error("Invalid data format, must be a string or TypedArray.");
          t2 = e2.slice(), i2 = t2.byteLength;
        }
        const a2 = i2 >> 2, n2 = i2 - 4 * a2, s2 = new Uint32Array(t2.buffer, 0, a2);
        let r2 = 0, o2 = 0, l3 = this.h1, c2 = this.h2;
        const h2 = 3432918353, d2 = 461845907, u2 = 11601, g2 = 13715;
        for (let e3 = 0; e3 < a2; e3++)
          1 & e3 ? (r2 = s2[e3], r2 = r2 * h2 & ms | r2 * u2 & bs, r2 = r2 << 15 | r2 >>> 17, r2 = r2 * d2 & ms | r2 * g2 & bs, l3 ^= r2, l3 = l3 << 13 | l3 >>> 19, l3 = 5 * l3 + 3864292196) : (o2 = s2[e3], o2 = o2 * h2 & ms | o2 * u2 & bs, o2 = o2 << 15 | o2 >>> 17, o2 = o2 * d2 & ms | o2 * g2 & bs, c2 ^= o2, c2 = c2 << 13 | c2 >>> 19, c2 = 5 * c2 + 3864292196);
        switch (r2 = 0, n2) {
          case 3:
            r2 ^= t2[4 * a2 + 2] << 16;
          case 2:
            r2 ^= t2[4 * a2 + 1] << 8;
          case 1:
            r2 ^= t2[4 * a2], r2 = r2 * h2 & ms | r2 * u2 & bs, r2 = r2 << 15 | r2 >>> 17, r2 = r2 * d2 & ms | r2 * g2 & bs, 1 & a2 ? l3 ^= r2 : c2 ^= r2;
        }
        this.h1 = l3, this.h2 = c2;
      }
      hexdigest() {
        let e2 = this.h1, t2 = this.h2;
        return e2 ^= t2 >>> 1, e2 = 3981806797 * e2 & ms | 36045 * e2 & bs, t2 = 4283543511 * t2 & ms | (2950163797 * (t2 << 16 | e2 >>> 16) & ms) >>> 16, e2 ^= t2 >>> 1, e2 = 444984403 * e2 & ms | 60499 * e2 & bs, t2 = 3301882366 * t2 & ms | (3120437893 * (t2 << 16 | e2 >>> 16) & ms) >>> 16, e2 ^= t2 >>> 1, (e2 >>> 0).toString(16).padStart(8, "0") + (t2 >>> 0).toString(16).padStart(8, "0");
      }
    }, "ys");
    __name(resizeImageMask, "resizeImageMask");
    PDFImage = class {
      constructor({ xref: e2, res: t2, image: i2, isInline: a2 = false, smask: n2 = null, mask: s2 = null, isMask: r2 = false, pdfFunctionFactory: o2, globalColorSpaceCache: l3, localColorSpaceCache: c2 }) {
        this.image = i2;
        const h2 = i2.dict, d2 = h2.get("F", "Filter");
        let u2;
        if (d2 instanceof Name)
          u2 = d2.name;
        else if (Array.isArray(d2)) {
          const t3 = e2.fetchIfRef(d2[0]);
          t3 instanceof Name && (u2 = t3.name);
        }
        switch (u2) {
          case "JPXDecode":
            ({ width: i2.width, height: i2.height, componentsCount: i2.numComps, bitsPerComponent: i2.bitsPerComponent } = JpxImage.parseImageProperties(i2.stream)), i2.stream.reset();
            const e3 = ImageResizer.getReducePowerForJPX(i2.width, i2.height, i2.numComps);
            if (this.jpxDecoderOptions = { numComponents: 0, isIndexedColormap: false, smaskInData: h2.has("SMaskInData"), reducePower: e3 }, e3) {
              const t3 = 2 ** e3;
              i2.width = Math.ceil(i2.width / t3), i2.height = Math.ceil(i2.height / t3);
            }
            break;
          case "JBIG2Decode":
            i2.bitsPerComponent = 1, i2.numComps = 1;
        }
        let g2 = h2.get("W", "Width"), p2 = h2.get("H", "Height");
        if (Number.isInteger(i2.width) && i2.width > 0 && Number.isInteger(i2.height) && i2.height > 0 && (i2.width !== g2 || i2.height !== p2))
          warn$1("PDFImage - using the Width/Height of the image data, rather than the image dictionary."), g2 = i2.width, p2 = i2.height;
        else {
          const e3 = "number" == typeof g2 && g2 > 0, t3 = "number" == typeof p2 && p2 > 0;
          if (!e3 || !t3) {
            if (!i2.fallbackDims)
              throw new ti(`Invalid image width: ${g2} or height: ${p2}`);
            warn$1("PDFImage - using the Width/Height of the parent image, for SMask/Mask data."), e3 || (g2 = i2.fallbackDims.width), t3 || (p2 = i2.fallbackDims.height);
          }
        }
        this.width = g2, this.height = p2, this.interpolate = h2.get("I", "Interpolate"), this.imageMask = h2.get("IM", "ImageMask") || false, this.matte = h2.get("Matte") || false;
        let f2 = i2.bitsPerComponent;
        if (!f2 && (f2 = h2.get("BPC", "BitsPerComponent"), !f2)) {
          if (!this.imageMask)
            throw new ti(`Bits per component missing in image: ${this.imageMask}`);
          f2 = 1;
        }
        if (this.bpc = f2, !this.imageMask) {
          let n3 = h2.getRaw("CS") || h2.getRaw("ColorSpace");
          const s3 = !!n3;
          if (s3)
            this.jpxDecoderOptions?.smaskInData && (n3 = Name.get("DeviceRGBA"));
          else if (this.jpxDecoderOptions)
            n3 = Name.get("DeviceRGBA");
          else
            switch (i2.numComps) {
              case 1:
                n3 = Name.get("DeviceGray");
                break;
              case 3:
                n3 = Name.get("DeviceRGB");
                break;
              case 4:
                n3 = Name.get("DeviceCMYK");
                break;
              default:
                throw new Error(`Images with ${i2.numComps} color components not supported.`);
            }
          this.colorSpace = ColorSpaceUtils.parse({ cs: n3, xref: e2, resources: a2 ? t2 : null, pdfFunctionFactory: o2, globalColorSpaceCache: l3, localColorSpaceCache: c2 }), this.numComps = this.colorSpace.numComps, this.jpxDecoderOptions && (this.jpxDecoderOptions.numComponents = s3 ? this.numComps : 0, this.jpxDecoderOptions.isIndexedColormap = "Indexed" === this.colorSpace.name);
        }
        if (this.decode = h2.getArray("D", "Decode"), this.needsDecode = false, this.decode && (this.colorSpace && !this.colorSpace.isDefaultDecode(this.decode, f2) || r2 && !ColorSpace.isDefaultDecode(this.decode, 1))) {
          this.needsDecode = true;
          const e3 = (1 << f2) - 1;
          this.decodeCoefficients = [], this.decodeAddends = [];
          const t3 = "Indexed" === this.colorSpace?.name;
          for (let i3 = 0, a3 = 0; i3 < this.decode.length; i3 += 2, ++a3) {
            const n3 = this.decode[i3], s3 = this.decode[i3 + 1];
            this.decodeCoefficients[a3] = t3 ? (s3 - n3) / e3 : s3 - n3, this.decodeAddends[a3] = t3 ? n3 : e3 * n3;
          }
        }
        if (n2)
          n2.fallbackDims ??= { width: g2, height: p2 }, this.smask = new PDFImage({ xref: e2, res: t2, image: n2, isInline: a2, pdfFunctionFactory: o2, globalColorSpaceCache: l3, localColorSpaceCache: c2 });
        else if (s2)
          if (s2 instanceof BaseStream) {
            s2.dict.get("IM", "ImageMask") ? (s2.fallbackDims ??= { width: g2, height: p2 }, this.mask = new PDFImage({ xref: e2, res: t2, image: s2, isInline: a2, isMask: true, pdfFunctionFactory: o2, globalColorSpaceCache: l3, localColorSpaceCache: c2 })) : warn$1("Ignoring /Mask in image without /ImageMask.");
          } else
            this.mask = s2;
      }
      static async buildImage({ xref: e2, res: t2, image: i2, isInline: a2 = false, pdfFunctionFactory: n2, globalColorSpaceCache: s2, localColorSpaceCache: r2 }) {
        const o2 = i2;
        let l3 = null, c2 = null;
        const h2 = i2.dict.get("SMask"), d2 = i2.dict.get("Mask");
        return h2 ? h2 instanceof BaseStream ? l3 = h2 : warn$1("Unsupported /SMask format.") : d2 && (d2 instanceof BaseStream || Array.isArray(d2) ? c2 = d2 : warn$1("Unsupported /Mask format.")), new PDFImage({ xref: e2, res: t2, image: o2, isInline: a2, smask: l3, mask: c2, pdfFunctionFactory: n2, globalColorSpaceCache: s2, localColorSpaceCache: r2 });
      }
      static async createMask({ image: e2, isOffscreenCanvasSupported: t2 = false }) {
        const { dict: i2 } = e2, a2 = i2.get("W", "Width"), n2 = i2.get("H", "Height"), s2 = i2.get("I", "Interpolate"), r2 = i2.getArray("D", "Decode"), o2 = r2?.[0] > 0, l3 = (a2 + 7 >> 3) * n2, c2 = e2.getBytes(l3), h2 = 1 === a2 && 1 === n2 && o2 === (0 === c2.length || !!(128 & c2[0]));
        if (h2)
          return { isSingleOpaquePixel: h2 };
        if (t2) {
          if (ImageResizer.needsToBeResized(a2, n2)) {
            const e4 = new Uint8ClampedArray(a2 * n2 * 4);
            return convertBlackAndWhiteToRGBA$1({ src: c2, dest: e4, width: a2, height: n2, nonBlackColor: 0, inverseDecode: o2 }), ImageResizer.createImage({ kind: k, data: e4, width: a2, height: n2, interpolate: s2 });
          }
          const e3 = new OffscreenCanvas(a2, n2), t3 = e3.getContext("2d"), i3 = t3.createImageData(a2, n2);
          convertBlackAndWhiteToRGBA$1({ src: c2, dest: i3.data, width: a2, height: n2, nonBlackColor: 0, inverseDecode: o2 }), t3.putImageData(i3, 0, 0);
          return { data: null, width: a2, height: n2, interpolate: s2, bitmap: e3.transferToImageBitmap() };
        }
        const d2 = c2.byteLength;
        let u2;
        if (e2 instanceof DecodeStream && (!o2 || l3 === d2) ? u2 = c2 : o2 ? (u2 = new Uint8Array(l3), u2.set(c2), u2.fill(255, d2)) : u2 = new Uint8Array(c2), o2)
          for (let e3 = 0; e3 < d2; e3++)
            u2[e3] ^= 255;
        return { data: u2, width: a2, height: n2, interpolate: s2 };
      }
      get drawWidth() {
        return Math.max(this.width, this.smask?.width || 0, this.mask?.width || 0);
      }
      get drawHeight() {
        return Math.max(this.height, this.smask?.height || 0, this.mask?.height || 0);
      }
      decodeBuffer(e2) {
        const t2 = this.bpc, i2 = this.numComps, a2 = this.decodeAddends, n2 = this.decodeCoefficients, s2 = (1 << t2) - 1;
        let r2, o2;
        if (1 === t2) {
          for (r2 = 0, o2 = e2.length; r2 < o2; r2++)
            e2[r2] = +!e2[r2];
          return;
        }
        let l3 = 0;
        for (r2 = 0, o2 = this.width * this.height; r2 < o2; r2++)
          for (let t3 = 0; t3 < i2; t3++)
            e2[l3] = MathClamp$1(a2[t3] + e2[l3] * n2[t3], 0, s2), l3++;
      }
      getComponents(e2) {
        const t2 = this.bpc;
        if (8 === t2)
          return e2;
        const i2 = this.width, a2 = this.height, n2 = this.numComps, s2 = i2 * a2 * n2;
        let r2, o2 = 0;
        r2 = t2 <= 8 ? new Uint8Array(s2) : t2 <= 16 ? new Uint16Array(s2) : new Uint32Array(s2);
        const l3 = i2 * n2, c2 = (1 << t2) - 1;
        let h2, d2, u2 = 0;
        if (1 === t2) {
          let t3, i3, n3;
          for (let s3 = 0; s3 < a2; s3++) {
            for (i3 = u2 + (-8 & l3), n3 = u2 + l3; u2 < i3; )
              d2 = e2[o2++], r2[u2] = d2 >> 7 & 1, r2[u2 + 1] = d2 >> 6 & 1, r2[u2 + 2] = d2 >> 5 & 1, r2[u2 + 3] = d2 >> 4 & 1, r2[u2 + 4] = d2 >> 3 & 1, r2[u2 + 5] = d2 >> 2 & 1, r2[u2 + 6] = d2 >> 1 & 1, r2[u2 + 7] = 1 & d2, u2 += 8;
            if (u2 < n3)
              for (d2 = e2[o2++], t3 = 128; u2 < n3; )
                r2[u2++] = +!!(d2 & t3), t3 >>= 1;
          }
        } else {
          let i3 = 0;
          for (d2 = 0, u2 = 0, h2 = s2; u2 < h2; ++u2) {
            for (u2 % l3 === 0 && (d2 = 0, i3 = 0); i3 < t2; )
              d2 = d2 << 8 | e2[o2++], i3 += 8;
            const a3 = i3 - t2;
            let n3 = d2 >> a3;
            n3 < 0 ? n3 = 0 : n3 > c2 && (n3 = c2), r2[u2] = n3, d2 &= (1 << a3) - 1, i3 = a3;
          }
        }
        return r2;
      }
      async fillOpacity(e2, t2, i2, a2, n2) {
        const s2 = this.smask, r2 = this.mask;
        let o2, l3, c2, h2, d2, u2;
        if (s2)
          l3 = s2.width, c2 = s2.height, o2 = new Uint8ClampedArray(l3 * c2), await s2.fillGrayBuffer(o2), l3 === t2 && c2 === i2 || (o2 = resizeImageMask(o2, s2.bpc, l3, c2, t2, i2));
        else if (r2)
          if (r2 instanceof PDFImage) {
            for (l3 = r2.width, c2 = r2.height, o2 = new Uint8ClampedArray(l3 * c2), r2.numComps = 1, await r2.fillGrayBuffer(o2), h2 = 0, d2 = l3 * c2; h2 < d2; ++h2)
              o2[h2] = 255 - o2[h2];
            l3 === t2 && c2 === i2 || (o2 = resizeImageMask(o2, r2.bpc, l3, c2, t2, i2));
          } else {
            if (!Array.isArray(r2))
              throw new ti("Unknown mask format.");
            {
              o2 = new Uint8ClampedArray(t2 * i2);
              const e3 = this.numComps;
              for (h2 = 0, d2 = t2 * i2; h2 < d2; ++h2) {
                let t3 = 0;
                const i3 = h2 * e3;
                for (u2 = 0; u2 < e3; ++u2) {
                  const e4 = n2[i3 + u2], a3 = 2 * u2;
                  if (e4 < r2[a3] || e4 > r2[a3 + 1]) {
                    t3 = 255;
                    break;
                  }
                }
                o2[h2] = t3;
              }
            }
          }
        if (o2)
          for (h2 = 0, u2 = 3, d2 = t2 * a2; h2 < d2; ++h2, u2 += 4)
            e2[u2] = o2[h2];
        else
          for (h2 = 0, u2 = 3, d2 = t2 * a2; h2 < d2; ++h2, u2 += 4)
            e2[u2] = 255;
      }
      undoPreblend(e2, t2, i2) {
        const a2 = this.smask?.matte;
        if (!a2)
          return;
        const n2 = this.colorSpace.getRgb(a2, 0), s2 = n2[0], r2 = n2[1], o2 = n2[2], l3 = t2 * i2 * 4;
        for (let t3 = 0; t3 < l3; t3 += 4) {
          const i3 = e2[t3 + 3];
          if (0 === i3) {
            e2[t3] = 255, e2[t3 + 1] = 255, e2[t3 + 2] = 255;
            continue;
          }
          const a3 = 255 / i3;
          e2[t3] = (e2[t3] - s2) * a3 + s2, e2[t3 + 1] = (e2[t3 + 1] - r2) * a3 + r2, e2[t3 + 2] = (e2[t3 + 2] - o2) * a3 + o2;
        }
      }
      async createImageData(e2 = false, t2 = false) {
        const i2 = this.drawWidth, a2 = this.drawHeight, n2 = { width: i2, height: a2, interpolate: this.interpolate, kind: 0, data: null }, s2 = this.numComps, r2 = this.width, o2 = this.height, l3 = this.bpc, c2 = r2 * s2 * l3 + 7 >> 3, h2 = t2 && ImageResizer.needsToBeResized(i2, a2);
        if (!this.smask && !this.mask && "DeviceRGBA" === this.colorSpace.name) {
          n2.kind = k;
          const e3 = n2.data = await this.getImageBytes(o2 * r2 * 4, {});
          return t2 ? h2 ? ImageResizer.createImage(n2, false) : this.createBitmap(k, i2, a2, e3) : n2;
        }
        if (!e2) {
          let e3;
          if ("DeviceGray" === this.colorSpace.name && 1 === l3 ? e3 = v : "DeviceRGB" !== this.colorSpace.name || 8 !== l3 || this.needsDecode || (e3 = C), e3 && !this.smask && !this.mask && i2 === r2 && a2 === o2) {
            const s3 = await this.#W(r2, o2);
            if (s3)
              return s3;
            const l4 = await this.getImageBytes(o2 * c2, {});
            if (t2)
              return h2 ? ImageResizer.createImage({ data: l4, kind: e3, width: i2, height: a2, interpolate: this.interpolate }, this.needsDecode) : this.createBitmap(e3, r2, o2, l4);
            if (n2.kind = e3, n2.data = l4, this.needsDecode) {
              assert$1(e3 === v, "PDFImage.createImageData: The image must be grayscale.");
              const t3 = n2.data;
              for (let e4 = 0, i3 = t3.length; e4 < i3; e4++)
                t3[e4] ^= 255;
            }
            return n2;
          }
          if (this.image instanceof JpegStream && !this.smask && !this.mask && !this.needsDecode) {
            let e4 = o2 * c2;
            if (t2 && !h2) {
              let t3 = false;
              switch (this.colorSpace.name) {
                case "DeviceGray":
                  e4 *= 4, t3 = true;
                  break;
                case "DeviceRGB":
                  e4 = e4 / 3 * 4, t3 = true;
                  break;
                case "DeviceCMYK":
                  t3 = true;
              }
              if (t3) {
                const t4 = await this.#W(i2, a2);
                if (t4)
                  return t4;
                const n3 = await this.getImageBytes(e4, { drawWidth: i2, drawHeight: a2, forceRGBA: true });
                return this.createBitmap(k, i2, a2, n3);
              }
            } else
              switch (this.colorSpace.name) {
                case "DeviceGray":
                  e4 *= 3;
                case "DeviceRGB":
                case "DeviceCMYK":
                  return n2.kind = C, n2.data = await this.getImageBytes(e4, { drawWidth: i2, drawHeight: a2, forceRGB: true }), h2 ? ImageResizer.createImage(n2) : n2;
              }
          }
        }
        const d2 = await this.getImageBytes(o2 * c2, { internal: true }), u2 = 0 | d2.length / c2 * a2 / o2, g2 = this.getComponents(d2);
        let p2, f2, m2, b2, y2, w2;
        if (t2 && !h2 && (m2 = new OffscreenCanvas(i2, a2), b2 = m2.getContext("2d"), y2 = b2.createImageData(i2, a2), w2 = y2.data), n2.kind = k, e2 || this.smask || this.mask)
          t2 && !h2 || (w2 = new Uint8ClampedArray(i2 * a2 * 4)), p2 = 1, f2 = true, await this.fillOpacity(w2, i2, a2, u2, g2);
        else {
          if (!t2 || h2)
            n2.kind = C, w2 = new Uint8ClampedArray(i2 * a2 * 3), p2 = 0;
          else {
            new Uint32Array(w2.buffer).fill(FeatureTest.isLittleEndian ? 4278190080 : 255), p2 = 1;
          }
          f2 = false;
        }
        if (this.needsDecode && this.decodeBuffer(g2), this.colorSpace.fillRgb(w2, r2, o2, i2, a2, u2, l3, g2, p2), f2 && this.undoPreblend(w2, i2, u2), t2 && !h2) {
          b2.putImageData(y2, 0, 0);
          return { data: null, width: i2, height: a2, bitmap: m2.transferToImageBitmap(), interpolate: this.interpolate };
        }
        return n2.data = w2, h2 ? ImageResizer.createImage(n2) : n2;
      }
      async fillGrayBuffer(e2) {
        const t2 = this.numComps;
        if (1 !== t2)
          throw new ti(`Reading gray scale from a color image: ${t2}`);
        const i2 = this.width, a2 = this.height, n2 = this.bpc, s2 = i2 * t2 * n2 + 7 >> 3, r2 = await this.getImageBytes(a2 * s2, { internal: true }), o2 = this.getComponents(r2);
        let l3, c2;
        if (1 === n2) {
          if (c2 = i2 * a2, this.needsDecode)
            for (l3 = 0; l3 < c2; ++l3)
              e2[l3] = o2[l3] - 1 & 255;
          else
            for (l3 = 0; l3 < c2; ++l3)
              e2[l3] = 255 & -o2[l3];
          return;
        }
        this.needsDecode && this.decodeBuffer(o2), c2 = i2 * a2;
        const h2 = 255 / ((1 << n2) - 1);
        for (l3 = 0; l3 < c2; ++l3)
          e2[l3] = h2 * o2[l3];
      }
      createBitmap(e2, t2, i2, a2) {
        const n2 = new OffscreenCanvas(t2, i2), s2 = n2.getContext("2d");
        let r2;
        e2 === k ? r2 = new ImageData(a2, t2, i2) : (r2 = s2.createImageData(t2, i2), convertToRGBA({ kind: e2, src: a2, dest: new Uint32Array(r2.data.buffer), width: t2, height: i2, inverseDecode: this.needsDecode })), s2.putImageData(r2, 0, 0);
        return { data: null, width: t2, height: i2, bitmap: n2.transferToImageBitmap(), interpolate: this.interpolate };
      }
      async #W(e2, t2) {
        const i2 = await this.image.getTransferableImage();
        return i2 ? { data: null, width: e2, height: t2, bitmap: i2, interpolate: this.interpolate } : null;
      }
      async getImageBytes(e2, { drawWidth: t2, drawHeight: i2, forceRGBA: a2 = false, forceRGB: n2 = false, internal: s2 = false }) {
        this.image.reset(), this.image.drawWidth = t2 || this.width, this.image.drawHeight = i2 || this.height, this.image.forceRGBA = !!a2, this.image.forceRGB = !!n2;
        const r2 = await this.image.getImageData(e2, this.jpxDecoderOptions);
        return s2 || this.image instanceof DecodeStream ? r2 : (assert$1(r2 instanceof Uint8Array, 'PDFImage.getImageBytes: Unsupported "imageBytes" type.'), new Uint8Array(r2));
      }
    };
    __name(PDFImage, "PDFImage");
    ws = Object.freeze({ maxImageSize: -1, disableFontFace: false, ignoreErrors: false, isEvalSupported: true, isOffscreenCanvasSupported: false, isImageDecoderSupported: false, canvasMaxAreaInBytes: -1, fontExtraProperties: false, useSystemFonts: true, useWasm: true, useWorkerFetch: true, cMapUrl: null, iccUrl: null, standardFontDataUrl: null, wasmUrl: null });
    As = 1;
    xs = 2;
    Ss = Promise.resolve();
    __name(normalizeBlendMode, "normalizeBlendMode");
    __name(addCachedImageOps, "addCachedImageOps");
    _TimeSlotManager = class {
      constructor() {
        this.reset();
      }
      check() {
        return !(++this.checked < _TimeSlotManager.CHECK_TIME_EVERY) && (this.checked = 0, this.endTime <= Date.now());
      }
      reset() {
        this.endTime = Date.now() + _TimeSlotManager.TIME_SLOT_DURATION_MS, this.checked = 0;
      }
    };
    TimeSlotManager = _TimeSlotManager;
    __name(TimeSlotManager, "TimeSlotManager");
    __publicField(TimeSlotManager, "TIME_SLOT_DURATION_MS", 20);
    __publicField(TimeSlotManager, "CHECK_TIME_EVERY", 100);
    PartialEvaluator = class {
      constructor({ xref: e2, handler: t2, pageIndex: i2, idFactory: a2, fontCache: n2, builtInCMapCache: s2, standardFontDataCache: r2, globalColorSpaceCache: o2, globalImageCache: l3, systemFontCache: c2, options: h2 = null }) {
        this.xref = e2, this.handler = t2, this.pageIndex = i2, this.idFactory = a2, this.fontCache = n2, this.builtInCMapCache = s2, this.standardFontDataCache = r2, this.globalColorSpaceCache = o2, this.globalImageCache = l3, this.systemFontCache = c2, this.options = h2 || ws, this.type3FontRefs = null, this._regionalImageCache = new RegionalImageCache(), this._fetchBuiltInCMapBound = this.fetchBuiltInCMap.bind(this);
      }
      get _pdfFunctionFactory() {
        return shadow$1(this, "_pdfFunctionFactory", new PDFFunctionFactory({ xref: this.xref, isEvalSupported: this.options.isEvalSupported }));
      }
      get parsingType3Font() {
        return !!this.type3FontRefs;
      }
      clone(e2 = null) {
        const t2 = Object.create(this);
        return t2.options = Object.assign(/* @__PURE__ */ Object.create(null), this.options, e2), t2;
      }
      hasBlendModes(e2, t2) {
        if (!(e2 instanceof Dict))
          return false;
        if (e2.objId && t2.has(e2.objId))
          return false;
        const i2 = new RefSet(t2);
        e2.objId && i2.put(e2.objId);
        const a2 = [e2], n2 = this.xref;
        for (; a2.length; ) {
          const e3 = a2.shift(), t3 = e3.get("ExtGState");
          if (t3 instanceof Dict)
            for (let e4 of t3.getRawValues()) {
              if (e4 instanceof Ref) {
                if (i2.has(e4))
                  continue;
                try {
                  e4 = n2.fetch(e4);
                } catch (t5) {
                  i2.put(e4), info$1(`hasBlendModes - ignoring ExtGState: "${t5}".`);
                  continue;
                }
              }
              if (!(e4 instanceof Dict))
                continue;
              e4.objId && i2.put(e4.objId);
              const t4 = e4.get("BM");
              if (t4 instanceof Name) {
                if ("Normal" !== t4.name)
                  return true;
              } else if (void 0 !== t4 && Array.isArray(t4)) {
                for (const e5 of t4)
                  if (e5 instanceof Name && "Normal" !== e5.name)
                    return true;
              }
            }
          const s2 = e3.get("XObject");
          if (s2 instanceof Dict)
            for (let e4 of s2.getRawValues()) {
              if (e4 instanceof Ref) {
                if (i2.has(e4))
                  continue;
                try {
                  e4 = n2.fetch(e4);
                } catch (t5) {
                  i2.put(e4), info$1(`hasBlendModes - ignoring XObject: "${t5}".`);
                  continue;
                }
              }
              if (!(e4 instanceof BaseStream))
                continue;
              e4.dict.objId && i2.put(e4.dict.objId);
              const t4 = e4.dict.get("Resources");
              t4 instanceof Dict && (t4.objId && i2.has(t4.objId) || (a2.push(t4), t4.objId && i2.put(t4.objId)));
            }
        }
        for (const e3 of i2)
          t2.put(e3);
        return false;
      }
      async fetchBuiltInCMap(e2) {
        const t2 = this.builtInCMapCache.get(e2);
        if (t2)
          return t2;
        let i2;
        return i2 = this.options.useWorkerFetch ? { cMapData: await fetchBinaryData(`${this.options.cMapUrl}${e2}.bcmap`), isCompressed: true } : await this.handler.sendWithPromise("FetchBinaryData", { type: "cMapReaderFactory", name: e2 }), this.builtInCMapCache.set(e2, i2), i2;
      }
      async fetchStandardFontData(e2) {
        const t2 = this.standardFontDataCache.get(e2);
        if (t2)
          return new Stream(t2);
        if (this.options.useSystemFonts && "Symbol" !== e2 && "ZapfDingbats" !== e2)
          return null;
        const i2 = Ua()[e2];
        let a2;
        try {
          a2 = this.options.useWorkerFetch ? await fetchBinaryData(`${this.options.standardFontDataUrl}${i2}`) : await this.handler.sendWithPromise("FetchBinaryData", { type: "standardFontDataFactory", filename: i2 });
        } catch (e3) {
          return warn$1(e3), null;
        }
        return this.standardFontDataCache.set(e2, a2), new Stream(a2);
      }
      async buildFormXObject(e2, t2, i2, a2, n2, s2, r2, o2) {
        const { dict: l3 } = t2, c2 = lookupMatrix(l3.getArray("Matrix"), null), h2 = lookupNormalRect(l3.getArray("BBox"), null);
        let d2, u2;
        l3.has("OC") && (d2 = await this.parseMarkedContentProps(l3.get("OC"), e2)), void 0 !== d2 && a2.addOp(xt, ["OC", d2]);
        const g2 = l3.get("Group");
        if (g2) {
          u2 = { matrix: c2, bbox: h2, smask: i2, isolated: false, knockout: false };
          let t3 = null;
          if (isName(g2.get("S"), "Transparency") && (u2.isolated = g2.get("I") || false, u2.knockout = g2.get("K") || false, g2.has("CS"))) {
            const i3 = this._getColorSpace(g2.getRaw("CS"), e2, r2);
            t3 = i3 instanceof ColorSpace ? i3 : await this._handleColorSpace(i3);
          }
          i2?.backdrop && (t3 ||= ColorSpaceUtils.rgb, i2.backdrop = t3.getRgbHex(i2.backdrop, 0)), a2.addOp(It, [u2]);
        }
        const p2 = [c2 && new Float32Array(c2), !g2 && h2 && new Float32Array(h2) || null];
        a2.addOp(kt, p2);
        const f2 = l3.get("Resources");
        await this.getOperatorList({ stream: t2, task: n2, resources: f2 instanceof Dict ? f2 : e2, operatorList: a2, initialState: s2, prevRefs: o2 }), a2.addOp(Tt, []), g2 && a2.addOp(Ft, [u2]), void 0 !== d2 && a2.addOp(St, []);
      }
      _sendImgData(e2, t2, i2 = false) {
        const a2 = t2 ? [t2.bitmap || t2.data.buffer] : null;
        return this.parsingType3Font || i2 ? this.handler.send("commonobj", [e2, "Image", t2], a2) : this.handler.send("obj", [e2, this.pageIndex, "Image", t2], a2);
      }
      async buildPaintImageXObject({ resources: e2, image: t2, isInline: i2 = false, operatorList: a2, cacheKey: n2, localImageCache: s2, localColorSpaceCache: r2 }) {
        const { maxImageSize: o2, ignoreErrors: l3, isOffscreenCanvasSupported: c2 } = this.options, { dict: h2 } = t2, d2 = h2.objId, u2 = h2.get("W", "Width"), g2 = h2.get("H", "Height");
        if (!u2 || "number" != typeof u2 || !g2 || "number" != typeof g2)
          return void warn$1("Image dimensions are missing, or not numbers.");
        if (-1 !== o2 && u2 * g2 > o2) {
          const e3 = "Image exceeded maximum allowed size and was removed.";
          if (!l3)
            throw new Error(e3);
          return void warn$1(e3);
        }
        let p2;
        h2.has("OC") && (p2 = await this.parseMarkedContentProps(h2.get("OC"), e2));
        let f2, m2, b2;
        if (h2.get("IM", "ImageMask") || false) {
          if (f2 = await PDFImage.createMask({ image: t2, isOffscreenCanvasSupported: c2 && !this.parsingType3Font }), f2.isSingleOpaquePixel) {
            if (m2 = Lt, b2 = [], a2.addImageOps(m2, b2, p2), n2) {
              const e4 = { fn: m2, args: b2, optionalContent: p2 };
              s2.set(n2, d2, e4), d2 && this._regionalImageCache.set(null, d2, e4);
            }
            return;
          }
          if (this.parsingType3Font)
            return b2 = function({ data: e4, width: t3, height: i3 }) {
              if (t3 > 1e3 || i3 > 1e3)
                return null;
              const a3 = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]), n3 = t3 + 1, s3 = new Uint8Array(n3 * (i3 + 1));
              let r3, o3, l4;
              const c3 = t3 + 7 & -8, h3 = new Uint8Array(c3 * i3);
              let d3 = 0;
              for (const t4 of e4) {
                let e5 = 128;
                for (; e5 > 0; )
                  h3[d3++] = t4 & e5 ? 0 : 255, e5 >>= 1;
              }
              let u3 = 0;
              for (d3 = 0, 0 !== h3[d3] && (s3[0] = 1, ++u3), o3 = 1; o3 < t3; o3++)
                h3[d3] !== h3[d3 + 1] && (s3[o3] = h3[d3] ? 2 : 1, ++u3), d3++;
              for (0 !== h3[d3] && (s3[o3] = 2, ++u3), r3 = 1; r3 < i3; r3++) {
                d3 = r3 * c3, l4 = r3 * n3, h3[d3 - c3] !== h3[d3] && (s3[l4] = h3[d3] ? 1 : 8, ++u3);
                let e5 = (h3[d3] ? 4 : 0) + (h3[d3 - c3] ? 8 : 0);
                for (o3 = 1; o3 < t3; o3++)
                  e5 = (e5 >> 2) + (h3[d3 + 1] ? 4 : 0) + (h3[d3 - c3 + 1] ? 8 : 0), a3[e5] && (s3[l4 + o3] = a3[e5], ++u3), d3++;
                if (h3[d3 - c3] !== h3[d3] && (s3[l4 + o3] = h3[d3] ? 2 : 4, ++u3), u3 > 1e3)
                  return null;
              }
              for (d3 = c3 * (i3 - 1), l4 = r3 * n3, 0 !== h3[d3] && (s3[l4] = 8, ++u3), o3 = 1; o3 < t3; o3++)
                h3[d3] !== h3[d3 + 1] && (s3[l4 + o3] = h3[d3] ? 4 : 8, ++u3), d3++;
              if (0 !== h3[d3] && (s3[l4 + o3] = 4, ++u3), u3 > 1e3)
                return null;
              const g3 = new Int32Array([0, n3, -1, 0, -n3, 0, 0, 0, 1]), p3 = [], { a: f3, b: m3, c: b3, d: y3, e: w3, f: x3 } = new DOMMatrix().scaleSelf(1 / t3, -1 / i3).translateSelf(0, -i3);
              for (r3 = 0; u3 && r3 <= i3; r3++) {
                let e5 = r3 * n3;
                const i4 = e5 + t3;
                for (; e5 < i4 && !s3[e5]; )
                  e5++;
                if (e5 === i4)
                  continue;
                let a4 = e5 % n3, o4 = r3;
                p3.push(qt, f3 * a4 + b3 * o4 + w3, m3 * a4 + y3 * o4 + x3);
                const l5 = e5;
                let c4 = s3[e5];
                do {
                  const t4 = g3[c4];
                  do {
                    e5 += t4;
                  } while (!s3[e5]);
                  const i5 = s3[e5];
                  5 !== i5 && 10 !== i5 ? (c4 = i5, s3[e5] = 0) : (c4 = i5 & 51 * c4 >> 4, s3[e5] &= c4 >> 2 | c4 << 2), a4 = e5 % n3, o4 = e5 / n3 | 0, p3.push(Xt, f3 * a4 + b3 * o4 + w3, m3 * a4 + y3 * o4 + x3), s3[e5] || --u3;
                } while (l5 !== e5);
                --r3;
              }
              return [Ht, [new Float32Array(p3)], new Float32Array([0, 0, t3, i3])];
            }(f2), b2 ? void a2.addImageOps(Ut, b2, p2) : (warn$1("Cannot compile Type3 glyph."), void a2.addImageOps(Et, [f2], p2));
          const e3 = `mask_${this.idFactory.createObjId()}`;
          if (a2.addDependency(e3), f2.dataLen = f2.bitmap ? f2.width * f2.height * 4 : f2.data.length, this._sendImgData(e3, f2), m2 = Et, b2 = [{ data: e3, width: f2.width, height: f2.height, interpolate: f2.interpolate, count: 1 }], a2.addImageOps(m2, b2, p2), n2) {
            const t3 = { objId: e3, fn: m2, args: b2, optionalContent: p2 };
            s2.set(n2, d2, t3), d2 && this._regionalImageCache.set(null, d2, t3);
          }
          return;
        }
        const y2 = h2.has("SMask") || h2.has("Mask");
        if (i2 && u2 + g2 < 200 && !y2) {
          try {
            const n3 = new PDFImage({ xref: this.xref, res: e2, image: t2, isInline: i2, pdfFunctionFactory: this._pdfFunctionFactory, globalColorSpaceCache: this.globalColorSpaceCache, localColorSpaceCache: r2 });
            f2 = await n3.createImageData(true, false), a2.addImageOps(Pt, [f2], p2);
          } catch (e3) {
            const t3 = `Unable to decode inline image: "${e3}".`;
            if (!l3)
              throw new Error(t3);
            warn$1(t3);
          }
          return;
        }
        let w2 = `img_${this.idFactory.createObjId()}`, x2 = false, S2 = null;
        if (this.parsingType3Font ? w2 = `${this.idFactory.getDocId()}_type3_${w2}` : n2 && d2 && (x2 = this.globalImageCache.shouldCache(d2, this.pageIndex), x2 && (assert$1(!i2, "Cannot cache an inline image globally."), w2 = `${this.idFactory.getDocId()}_${w2}`)), a2.addDependency(w2), m2 = _t, b2 = [w2, u2, g2], a2.addImageOps(m2, b2, p2, y2), x2) {
          if (S2 = { objId: w2, fn: m2, args: b2, optionalContent: p2, hasMask: y2, byteSize: 0 }, this.globalImageCache.hasDecodeFailed(d2))
            return this.globalImageCache.setData(d2, S2), void this._sendImgData(w2, null, x2);
          if (u2 * g2 > 25e4 || y2) {
            const e3 = await this.handler.sendWithPromise("commonobj", [w2, "CopyLocalImage", { imageRef: d2 }]);
            if (e3)
              return this.globalImageCache.setData(d2, S2), void this.globalImageCache.addByteSize(d2, e3);
          }
        }
        if (PDFImage.buildImage({ xref: this.xref, res: e2, image: t2, isInline: i2, pdfFunctionFactory: this._pdfFunctionFactory, globalColorSpaceCache: this.globalColorSpaceCache, localColorSpaceCache: r2 }).then(async (e3) => (f2 = await e3.createImageData(false, c2), f2.dataLen = f2.bitmap ? f2.width * f2.height * 4 : f2.data.length, f2.ref = d2, x2 && this.globalImageCache.addByteSize(d2, f2.dataLen), this._sendImgData(w2, f2, x2))).catch((e3) => (warn$1(`Unable to decode image "${w2}": "${e3}".`), d2 && this.globalImageCache.addDecodeFailed(d2), this._sendImgData(w2, null, x2))), n2) {
          const e3 = { objId: w2, fn: m2, args: b2, optionalContent: p2, hasMask: y2 };
          s2.set(n2, d2, e3), d2 && (this._regionalImageCache.set(null, d2, e3), x2 && (assert$1(S2, "The global cache-data must be available."), this.globalImageCache.setData(d2, S2)));
        }
      }
      handleSMask(e2, t2, i2, a2, n2, s2, r2) {
        const o2 = e2.get("G"), l3 = { subtype: e2.get("S").name, backdrop: e2.get("BC") }, c2 = e2.get("TR");
        if (isPDFFunction(c2)) {
          const e3 = this._pdfFunctionFactory.create(c2), t3 = new Uint8Array(256), i3 = new Float32Array(1);
          for (let a3 = 0; a3 < 256; a3++)
            i3[0] = a3 / 255, e3(i3, 0, i3, 0), t3[a3] = 255 * i3[0] | 0;
          l3.transferMap = t3;
        }
        return this.buildFormXObject(t2, o2, l3, i2, a2, n2.state.clone({ newPath: true }), s2, r2);
      }
      handleTransferFunction(e2) {
        let t2;
        if (Array.isArray(e2))
          t2 = e2;
        else {
          if (!isPDFFunction(e2))
            return null;
          t2 = [e2];
        }
        const i2 = [];
        let a2 = 0, n2 = 0;
        for (const e3 of t2) {
          const t3 = this.xref.fetchIfRef(e3);
          if (a2++, isName(t3, "Identity")) {
            i2.push(null);
            continue;
          }
          if (!isPDFFunction(t3))
            return null;
          const s2 = this._pdfFunctionFactory.create(t3), r2 = new Uint8Array(256), o2 = new Float32Array(1);
          for (let e4 = 0; e4 < 256; e4++)
            o2[0] = e4 / 255, s2(o2, 0, o2, 0), r2[e4] = 255 * o2[0] | 0;
          i2.push(r2), n2++;
        }
        return 1 !== a2 && 4 !== a2 || 0 === n2 ? null : i2;
      }
      handleTilingType(e2, t2, i2, a2, n2, s2, r2, o2) {
        const l3 = new OperatorList(), c2 = Dict.merge({ xref: this.xref, dictArray: [n2.get("Resources"), i2] });
        return this.getOperatorList({ stream: a2, task: r2, resources: c2, operatorList: l3 }).then(function() {
          const i3 = l3.getIR(), a3 = getTilingPatternIR(i3, n2, t2);
          s2.addDependencies(l3.dependencies), s2.addOp(e2, a3), n2.objId && o2.set(null, n2.objId, { operatorListIR: i3, dict: n2 });
        }).catch((e3) => {
          if (!(e3 instanceof ii)) {
            if (!this.options.ignoreErrors)
              throw e3;
            warn$1(`handleTilingType - ignoring pattern: "${e3}".`);
          }
        });
      }
      async handleSetFont(e2, t2, i2, a2, n2, s2, r2 = null, o2 = null) {
        const l3 = t2?.[0] instanceof Name ? t2[0].name : null, c2 = await this.loadFont(l3, i2, e2, n2, r2, o2);
        return c2.font.isType3Font && a2.addDependencies(c2.type3Dependencies), s2.font = c2.font, c2.send(this.handler), c2.loadedName;
      }
      handleText(e2, t2) {
        const i2 = t2.font, a2 = i2.charsToGlyphs(e2);
        if (i2.data) {
          (!!(t2.textRenderingMode & S) || "Pattern" === t2.fillColorSpace.name || i2.disableFontFace) && PartialEvaluator.buildFontPaths(i2, a2, this.handler, this.options);
        }
        return a2;
      }
      ensureStateFont(e2) {
        if (e2.font)
          return;
        const t2 = new ti("Missing setFont (Tf) operator before text rendering operator.");
        if (!this.options.ignoreErrors)
          throw t2;
        warn$1(`ensureStateFont: "${t2}".`);
      }
      async setGState({ resources: e2, gState: t2, operatorList: i2, cacheKey: a2, task: n2, stateManager: s2, localGStateCache: r2, localColorSpaceCache: o2, seenRefs: l3 }) {
        const c2 = t2.objId;
        let h2 = true;
        const d2 = [];
        let u2 = Promise.resolve();
        for (const [a3, r3] of t2)
          switch (a3) {
            case "Type":
              break;
            case "LW":
              if ("number" != typeof r3) {
                warn$1(`Invalid LW (line width): ${r3}`);
                break;
              }
              d2.push([a3, Math.abs(r3)]);
              break;
            case "LC":
            case "LJ":
            case "ML":
            case "D":
            case "RI":
            case "FL":
            case "CA":
            case "ca":
              d2.push([a3, r3]);
              break;
            case "Font":
              h2 = false, u2 = u2.then(() => this.handleSetFont(e2, null, r3[0], i2, n2, s2.state).then(function(e3) {
                i2.addDependency(e3), d2.push([a3, [e3, r3[1]]]);
              }));
              break;
            case "BM":
              d2.push([a3, normalizeBlendMode(r3)]);
              break;
            case "SMask":
              if (isName(r3, "None")) {
                d2.push([a3, false]);
                break;
              }
              r3 instanceof Dict ? (h2 = false, u2 = u2.then(() => this.handleSMask(r3, e2, i2, n2, s2, o2, l3)), d2.push([a3, true])) : warn$1("Unsupported SMask type");
              break;
            case "TR":
              const t3 = this.handleTransferFunction(r3);
              d2.push([a3, t3]);
              break;
            case "OP":
            case "op":
            case "OPM":
            case "BG":
            case "BG2":
            case "UCR":
            case "UCR2":
            case "TR2":
            case "HT":
            case "SM":
            case "SA":
            case "AIS":
            case "TK":
              info$1("graphic state operator " + a3);
              break;
            default:
              info$1("Unknown graphic state operator " + a3);
          }
        await u2, d2.length > 0 && i2.addOp(pe, [d2]), h2 && r2.set(a2, c2, d2);
      }
      loadFont(e2, t2, i2, a2, n2 = null, s2 = null) {
        const errorFont = /* @__PURE__ */ __name(async () => new TranslatedFont({ loadedName: "g_font_error", font: new ErrorFont(`Font "${e2}" is not available.`), dict: t2 }), "errorFont");
        let r2;
        if (t2)
          t2 instanceof Ref && (r2 = t2);
        else {
          const t3 = i2.get("Font");
          t3 && (r2 = t3.getRaw(e2));
        }
        if (r2) {
          if (this.type3FontRefs?.has(r2))
            return errorFont();
          if (this.fontCache.has(r2))
            return this.fontCache.get(r2);
          try {
            t2 = this.xref.fetchIfRef(r2);
          } catch (e3) {
            warn$1(`loadFont - lookup failed: "${e3}".`);
          }
        }
        if (!(t2 instanceof Dict)) {
          if (!this.options.ignoreErrors && !this.parsingType3Font)
            return warn$1(`Font "${e2}" is not available.`), errorFont();
          warn$1(`Font "${e2}" is not available -- attempting to fallback to a default font.`), t2 = n2 || PartialEvaluator.fallbackFontDict;
        }
        if (t2.cacheKey && this.fontCache.has(t2.cacheKey))
          return this.fontCache.get(t2.cacheKey);
        const { promise: o2, resolve: l3 } = Promise.withResolvers();
        let c2;
        try {
          c2 = this.preEvaluateFont(t2), c2.cssFontInfo = s2;
        } catch (e3) {
          return warn$1(`loadFont - preEvaluateFont failed: "${e3}".`), errorFont();
        }
        const { descriptor: h2, hash: d2 } = c2, u2 = r2 instanceof Ref;
        let g2;
        if (d2 && h2 instanceof Dict) {
          const e3 = h2.fontAliases ||= /* @__PURE__ */ Object.create(null);
          if (e3[d2]) {
            const t3 = e3[d2].aliasRef;
            if (u2 && t3 && this.fontCache.has(t3))
              return this.fontCache.putAlias(r2, t3), this.fontCache.get(r2);
          } else
            e3[d2] = { fontID: this.idFactory.createFontId() };
          u2 && (e3[d2].aliasRef = r2), g2 = e3[d2].fontID;
        } else
          g2 = this.idFactory.createFontId();
        return assert$1(g2?.startsWith("f"), 'The "fontID" must be (correctly) defined.'), u2 ? this.fontCache.put(r2, o2) : (t2.cacheKey = `cacheKey_${g2}`, this.fontCache.put(t2.cacheKey, o2)), t2.loadedName = `${this.idFactory.getDocId()}_${g2}`, this.translateFont(c2).then(async (e3) => {
          const n3 = new TranslatedFont({ loadedName: t2.loadedName, font: e3, dict: t2 });
          if (e3.isType3Font)
            try {
              await n3.loadType3Data(this, i2, a2);
            } catch (e4) {
              throw new Error(`Type3 font load error: ${e4}`);
            }
          l3(n3);
        }).catch((e3) => {
          warn$1(`loadFont - translateFont failed: "${e3}".`), l3(new TranslatedFont({ loadedName: t2.loadedName, font: new ErrorFont(e3?.message), dict: t2 }));
        }), o2;
      }
      buildPath(e2, t2, i2) {
        const { pathMinMax: a2, pathBuffer: n2 } = i2;
        switch (0 | e2) {
          case Ce: {
            const e3 = i2.currentPointX = t2[0], s2 = i2.currentPointY = t2[1], r2 = t2[2], o2 = t2[3], l3 = e3 + r2, c2 = s2 + o2;
            0 === r2 || 0 === o2 ? n2.push(qt, e3, s2, Xt, l3, c2, Wt) : n2.push(qt, e3, s2, Xt, l3, s2, Xt, l3, c2, Xt, e3, c2, Wt), ni.rectBoundingBox(e3, s2, l3, c2, a2);
            break;
          }
          case ye: {
            const e3 = i2.currentPointX = t2[0], s2 = i2.currentPointY = t2[1];
            n2.push(qt, e3, s2), ni.pointBoundingBox(e3, s2, a2);
            break;
          }
          case we: {
            const e3 = i2.currentPointX = t2[0], s2 = i2.currentPointY = t2[1];
            n2.push(Xt, e3, s2), ni.pointBoundingBox(e3, s2, a2);
            break;
          }
          case Ae: {
            const e3 = i2.currentPointX, s2 = i2.currentPointY, [r2, o2, l3, c2, h2, d2] = t2;
            i2.currentPointX = h2, i2.currentPointY = d2, n2.push(zt, r2, o2, l3, c2, h2, d2), ni.bezierBoundingBox(e3, s2, r2, o2, l3, c2, h2, d2, a2);
            break;
          }
          case xe: {
            const e3 = i2.currentPointX, s2 = i2.currentPointY, [r2, o2, l3, c2] = t2;
            i2.currentPointX = l3, i2.currentPointY = c2, n2.push(zt, e3, s2, r2, o2, l3, c2), ni.bezierBoundingBox(e3, s2, e3, s2, r2, o2, l3, c2, a2);
            break;
          }
          case Se: {
            const e3 = i2.currentPointX, s2 = i2.currentPointY, [r2, o2, l3, c2] = t2;
            i2.currentPointX = l3, i2.currentPointY = c2, n2.push(zt, r2, o2, l3, c2, l3, c2), ni.bezierBoundingBox(e3, s2, r2, o2, l3, c2, l3, c2, a2);
            break;
          }
          case ve:
            n2.push(Wt);
        }
      }
      _getColorSpace(e2, t2, i2) {
        return ColorSpaceUtils.parse({ cs: e2, xref: this.xref, resources: t2, pdfFunctionFactory: this._pdfFunctionFactory, globalColorSpaceCache: this.globalColorSpaceCache, localColorSpaceCache: i2, asyncIfNotCached: true });
      }
      async _handleColorSpace(e2) {
        try {
          return await e2;
        } catch (e3) {
          if (e3 instanceof ii)
            return null;
          if (this.options.ignoreErrors)
            return warn$1(`_handleColorSpace - ignoring ColorSpace: "${e3}".`), null;
          throw e3;
        }
      }
      parseShading({ shading: e2, resources: t2, localColorSpaceCache: i2, localShadingPatternCache: a2 }) {
        let n2, s2 = a2.get(e2);
        if (s2)
          return s2;
        try {
          n2 = Pattern.parseShading(e2, this.xref, t2, this._pdfFunctionFactory, this.globalColorSpaceCache, i2).getIR();
        } catch (t3) {
          if (t3 instanceof ii)
            return null;
          if (this.options.ignoreErrors)
            return warn$1(`parseShading - ignoring shading: "${t3}".`), a2.set(e2, null), null;
          throw t3;
        }
        return s2 = `pattern_${this.idFactory.createObjId()}`, this.parsingType3Font && (s2 = `${this.idFactory.getDocId()}_type3_${s2}`), a2.set(e2, s2), this.parsingType3Font ? this.handler.send("commonobj", [s2, "Pattern", n2]) : this.handler.send("obj", [s2, this.pageIndex, "Pattern", n2]), s2;
      }
      handleColorN(e2, t2, i2, a2, n2, s2, r2, o2, l3, c2) {
        const h2 = i2.pop();
        if (h2 instanceof Name) {
          const d2 = n2.getRaw(h2.name), u2 = d2 instanceof Ref && l3.getByRef(d2);
          if (u2)
            try {
              const n3 = a2.base ? a2.base.getRgbHex(i2, 0) : null, s3 = getTilingPatternIR(u2.operatorListIR, u2.dict, n3);
              return void e2.addOp(t2, s3);
            } catch {
            }
          const g2 = this.xref.fetchIfRef(d2);
          if (g2) {
            const n3 = g2 instanceof BaseStream ? g2.dict : g2, h3 = n3.get("PatternType");
            if (h3 === As) {
              const o3 = a2.base ? a2.base.getRgbHex(i2, 0) : null;
              return this.handleTilingType(t2, o3, s2, g2, n3, e2, r2, l3);
            }
            if (h3 === xs) {
              const i3 = n3.get("Shading"), a3 = this.parseShading({ shading: i3, resources: s2, localColorSpaceCache: o2, localShadingPatternCache: c2 });
              if (a3) {
                const i4 = lookupMatrix(n3.getArray("Matrix"), null);
                e2.addOp(t2, ["Shading", a3, i4]);
              }
              return;
            }
            throw new ti(`Unknown PatternType: ${h3}`);
          }
        }
        throw new ti(`Unknown PatternName: ${h2}`);
      }
      _parseVisibilityExpression(e2, t2, i2) {
        if (++t2 > 10)
          return void warn$1("Visibility expression is too deeply nested");
        const a2 = e2.length, n2 = this.xref.fetchIfRef(e2[0]);
        if (!(a2 < 2) && n2 instanceof Name) {
          switch (n2.name) {
            case "And":
            case "Or":
            case "Not":
              i2.push(n2.name);
              break;
            default:
              return void warn$1(`Invalid operator ${n2.name} in visibility expression`);
          }
          for (let n3 = 1; n3 < a2; n3++) {
            const a3 = e2[n3], s2 = this.xref.fetchIfRef(a3);
            if (Array.isArray(s2)) {
              const e3 = [];
              i2.push(e3), this._parseVisibilityExpression(s2, t2, e3);
            } else
              a3 instanceof Ref && i2.push(a3.toString());
          }
        } else
          warn$1("Invalid visibility expression");
      }
      async parseMarkedContentProps(e2, t2) {
        let i2;
        if (e2 instanceof Name) {
          i2 = t2.get("Properties").get(e2.name);
        } else {
          if (!(e2 instanceof Dict))
            throw new ti("Optional content properties malformed.");
          i2 = e2;
        }
        const a2 = i2.get("Type")?.name;
        if ("OCG" === a2)
          return { type: a2, id: i2.objId };
        if ("OCMD" === a2) {
          const e3 = i2.get("VE");
          if (Array.isArray(e3)) {
            const t4 = [];
            if (this._parseVisibilityExpression(e3, 0, t4), t4.length > 0)
              return { type: "OCMD", expression: t4 };
          }
          const t3 = i2.get("OCGs");
          if (Array.isArray(t3) || t3 instanceof Dict) {
            const e4 = [];
            if (Array.isArray(t3))
              for (const i3 of t3)
                e4.push(i3.toString());
            else
              e4.push(t3.objId);
            return { type: a2, ids: e4, policy: i2.get("P") instanceof Name ? i2.get("P").name : null, expression: null };
          }
          if (t3 instanceof Ref)
            return { type: a2, id: t3.toString() };
        }
        return null;
      }
      getOperatorList({ stream: e2, task: t2, resources: i2, operatorList: a2, initialState: n2 = null, fallbackFontDict: s2 = null, prevRefs: r2 = null }) {
        const o2 = e2.dict?.objId, l3 = new RefSet(r2);
        if (o2) {
          if (r2?.has(o2))
            throw new Error(`getOperatorList - ignoring circular reference: ${o2}`);
          l3.put(o2);
        }
        if (i2 ||= Dict.empty, n2 ||= new EvalState(), !a2)
          throw new Error('getOperatorList: missing "operatorList" parameter');
        const c2 = this, h2 = this.xref, d2 = new LocalImageCache(), u2 = new LocalColorSpaceCache(), g2 = new LocalGStateCache(), p2 = new LocalTilingPatternCache(), f2 = /* @__PURE__ */ new Map(), m2 = i2.get("XObject") || Dict.empty, b2 = i2.get("Pattern") || Dict.empty, y2 = new StateManager(n2), w2 = new EvaluatorPreprocessor(e2, h2, y2), x2 = new TimeSlotManager();
        function closePendingRestoreOPS(e3) {
          for (let e4 = 0, t3 = w2.savedStatesDepth; e4 < t3; e4++)
            a2.addOp(me, []);
        }
        __name(closePendingRestoreOPS, "closePendingRestoreOPS");
        return new Promise(/* @__PURE__ */ __name(function promiseBody(e3, n3) {
          const next = /* @__PURE__ */ __name(function(t3) {
            Promise.all([t3, a2.ready]).then(function() {
              try {
                promiseBody(e3, n3);
              } catch (e4) {
                n3(e4);
              }
            }, n3);
          }, "next");
          t2.ensureNotTerminated(), x2.reset();
          const r3 = {};
          let o3, S2, v2, C2, k2, T2;
          for (; !(o3 = x2.check()) && (r3.args = null, w2.read(r3)); ) {
            let e4 = r3.args, n4 = r3.fn;
            switch (0 | n4) {
              case bt:
                if (T2 = e4[0] instanceof Name, k2 = e4[0].name, T2) {
                  const t3 = d2.getByName(k2);
                  if (t3) {
                    addCachedImageOps(a2, t3), e4 = null;
                    continue;
                  }
                }
                return void next(new Promise(function(e5, n5) {
                  if (!T2)
                    throw new ti("XObject must be referred to by name.");
                  let s3 = m2.getRaw(k2);
                  if (s3 instanceof Ref) {
                    const t3 = d2.getByRef(s3) || c2._regionalImageCache.getByRef(s3) || c2.globalImageCache.getData(s3, c2.pageIndex);
                    if (t3)
                      return addCachedImageOps(a2, t3), void e5();
                    s3 = h2.fetch(s3);
                  }
                  if (!(s3 instanceof BaseStream))
                    throw new ti("XObject should be a stream");
                  const r5 = s3.dict.get("Subtype");
                  if (!(r5 instanceof Name))
                    throw new ti("XObject should have a Name subtype");
                  if ("Form" === r5.name)
                    return y2.save(), void c2.buildFormXObject(i2, s3, null, a2, t2, y2.state.clone({ newPath: true }), u2, l3).then(function() {
                      y2.restore(), e5();
                    }, n5);
                  if ("Image" !== r5.name) {
                    if ("PS" !== r5.name)
                      throw new ti(`Unhandled XObject subtype ${r5.name}`);
                    info$1("Ignored XObject subtype PS"), e5();
                  } else
                    c2.buildPaintImageXObject({ resources: i2, image: s3, operatorList: a2, cacheKey: k2, localImageCache: d2, localColorSpaceCache: u2 }).then(e5, n5);
                }).catch(function(e5) {
                  if (!(e5 instanceof ii)) {
                    if (!c2.options.ignoreErrors)
                      throw e5;
                    warn$1(`getOperatorList - ignoring XObject: "${e5}".`);
                  }
                }));
              case He:
                const r4 = e4[1];
                return void next(c2.handleSetFont(i2, e4, null, a2, t2, y2.state, s2).then(function(e5) {
                  a2.addDependency(e5), a2.addOp(He, [e5, r4]);
                }));
              case mt:
                const o4 = e4[0].cacheKey;
                if (o4) {
                  const t3 = d2.getByName(o4);
                  if (t3) {
                    addCachedImageOps(a2, t3), e4 = null;
                    continue;
                  }
                }
                return void next(c2.buildPaintImageXObject({ resources: i2, image: e4[0], isInline: true, operatorList: a2, cacheKey: o4, localImageCache: d2, localColorSpaceCache: u2 }));
              case Ke:
                if (!y2.state.font) {
                  c2.ensureStateFont(y2.state);
                  continue;
                }
                e4[0] = c2.handleText(e4[0], y2.state);
                break;
              case Ye:
                if (!y2.state.font) {
                  c2.ensureStateFont(y2.state);
                  continue;
                }
                const w3 = [], x3 = y2.state;
                for (const t3 of e4[0])
                  "string" == typeof t3 ? w3.push(...c2.handleText(t3, x3)) : "number" == typeof t3 && w3.push(t3);
                e4[0] = w3, n4 = Ke;
                break;
              case Je:
                if (!y2.state.font) {
                  c2.ensureStateFont(y2.state);
                  continue;
                }
                a2.addOp(Ve), e4[0] = c2.handleText(e4[0], y2.state), n4 = Ke;
                break;
              case Ze:
                if (!y2.state.font) {
                  c2.ensureStateFont(y2.state);
                  continue;
                }
                a2.addOp(Ve), a2.addOp(Ue, [e4.shift()]), a2.addOp(Le, [e4.shift()]), e4[0] = c2.handleText(e4[0], y2.state), n4 = Ke;
                break;
              case qe:
                y2.state.textRenderingMode = e4[0];
                break;
              case it: {
                const t3 = c2._getColorSpace(e4[0], i2, u2);
                if (t3 instanceof ColorSpace) {
                  y2.state.fillColorSpace = t3;
                  continue;
                }
                return void next(c2._handleColorSpace(t3).then((e5) => {
                  y2.state.fillColorSpace = e5 || ColorSpaceUtils.gray;
                }));
              }
              case tt: {
                const t3 = c2._getColorSpace(e4[0], i2, u2);
                if (t3 instanceof ColorSpace) {
                  y2.state.strokeColorSpace = t3;
                  continue;
                }
                return void next(c2._handleColorSpace(t3).then((e5) => {
                  y2.state.strokeColorSpace = e5 || ColorSpaceUtils.gray;
                }));
              }
              case st:
                C2 = y2.state.fillColorSpace, e4 = [C2.getRgbHex(e4, 0)], n4 = ht;
                break;
              case at:
                C2 = y2.state.strokeColorSpace, e4 = [C2.getRgbHex(e4, 0)], n4 = ct;
                break;
              case lt:
                y2.state.fillColorSpace = ColorSpaceUtils.gray, e4 = [ColorSpaceUtils.gray.getRgbHex(e4, 0)], n4 = ht;
                break;
              case ot:
                y2.state.strokeColorSpace = ColorSpaceUtils.gray, e4 = [ColorSpaceUtils.gray.getRgbHex(e4, 0)], n4 = ct;
                break;
              case ut:
                y2.state.fillColorSpace = ColorSpaceUtils.cmyk, e4 = [ColorSpaceUtils.cmyk.getRgbHex(e4, 0)], n4 = ht;
                break;
              case dt:
                y2.state.strokeColorSpace = ColorSpaceUtils.cmyk, e4 = [ColorSpaceUtils.cmyk.getRgbHex(e4, 0)], n4 = ct;
                break;
              case ht:
                y2.state.fillColorSpace = ColorSpaceUtils.rgb, e4 = [ColorSpaceUtils.rgb.getRgbHex(e4, 0)];
                break;
              case ct:
                y2.state.strokeColorSpace = ColorSpaceUtils.rgb, e4 = [ColorSpaceUtils.rgb.getRgbHex(e4, 0)];
                break;
              case rt:
                if (C2 = y2.state.patternFillColorSpace, !C2) {
                  if (isNumberArray(e4, null)) {
                    e4 = [ColorSpaceUtils.gray.getRgbHex(e4, 0)], n4 = ht;
                    break;
                  }
                  e4 = [], n4 = $t;
                  break;
                }
                if ("Pattern" === C2.name)
                  return void next(c2.handleColorN(a2, rt, e4, C2, b2, i2, t2, u2, p2, f2));
                e4 = [C2.getRgbHex(e4, 0)], n4 = ht;
                break;
              case nt:
                if (C2 = y2.state.patternStrokeColorSpace, !C2) {
                  if (isNumberArray(e4, null)) {
                    e4 = [ColorSpaceUtils.gray.getRgbHex(e4, 0)], n4 = ct;
                    break;
                  }
                  e4 = [], n4 = jt;
                  break;
                }
                if ("Pattern" === C2.name)
                  return void next(c2.handleColorN(a2, nt, e4, C2, b2, i2, t2, u2, p2, f2));
                e4 = [C2.getRgbHex(e4, 0)], n4 = ct;
                break;
              case gt:
                let F2;
                try {
                  const t3 = i2.get("Shading");
                  if (!t3)
                    throw new ti("No shading resource found");
                  if (F2 = t3.get(e4[0].name), !F2)
                    throw new ti("No shading object found");
                } catch (e5) {
                  if (e5 instanceof ii)
                    continue;
                  if (c2.options.ignoreErrors) {
                    warn$1(`getOperatorList - ignoring Shading: "${e5}".`);
                    continue;
                  }
                  throw e5;
                }
                const M2 = c2.parseShading({ shading: F2, resources: i2, localColorSpaceCache: u2, localShadingPatternCache: f2 });
                if (!M2)
                  continue;
                e4 = [M2], n4 = gt;
                break;
              case pe:
                if (T2 = e4[0] instanceof Name, k2 = e4[0].name, T2) {
                  const t3 = g2.getByName(k2);
                  if (t3) {
                    t3.length > 0 && a2.addOp(pe, [t3]), e4 = null;
                    continue;
                  }
                }
                return void next(new Promise(function(e5, n5) {
                  if (!T2)
                    throw new ti("GState must be referred to by name.");
                  const s3 = i2.get("ExtGState");
                  if (!(s3 instanceof Dict))
                    throw new ti("ExtGState should be a dictionary.");
                  const r5 = s3.get(k2);
                  if (!(r5 instanceof Dict))
                    throw new ti("GState should be a dictionary.");
                  c2.setGState({ resources: i2, gState: r5, operatorList: a2, cacheKey: k2, task: t2, stateManager: y2, localGStateCache: g2, localColorSpaceCache: u2, seenRefs: l3 }).then(e5, n5);
                }).catch(function(e5) {
                  if (!(e5 instanceof ii)) {
                    if (!c2.options.ignoreErrors)
                      throw e5;
                    warn$1(`getOperatorList - ignoring ExtGState: "${e5}".`);
                  }
                }));
              case oe: {
                const [t3] = e4;
                if ("number" != typeof t3) {
                  warn$1(`Invalid setLineWidth: ${t3}`);
                  continue;
                }
                e4[0] = Math.abs(t3);
                break;
              }
              case de: {
                const t3 = e4[1];
                if ("number" != typeof t3) {
                  warn$1(`Invalid setDash: ${t3}`);
                  continue;
                }
                const i3 = e4[0];
                if (!Array.isArray(i3)) {
                  warn$1(`Invalid setDash: ${i3}`);
                  continue;
                }
                i3.some((e5) => "number" != typeof e5) && (e4[0] = i3.filter((e5) => "number" == typeof e5));
                break;
              }
              case ye:
              case we:
              case Ae:
              case xe:
              case Se:
              case ve:
              case Ce:
                c2.buildPath(n4, e4, y2.state);
                continue;
              case ke:
              case Te:
              case Ie:
              case Fe:
              case Me:
              case De:
              case Ee:
              case Oe:
              case _e: {
                const { state: { pathBuffer: e5, pathMinMax: t3 } } = y2;
                n4 !== Te && n4 !== Ee && n4 !== Oe || e5.push(Wt), 0 === e5.length ? a2.addOp(Ut, [n4, [null], null]) : (a2.addOp(Ut, [n4, [new Float32Array(e5)], t3.slice()]), e5.length = 0, t3.set([1 / 0, 1 / 0, -1 / 0, -1 / 0], 0));
                continue;
              }
              case Ge:
                a2.addOp(n4, [new Float32Array(e4)]);
                continue;
              case yt:
              case wt:
              case vt:
              case Ct:
                continue;
              case xt:
                if (!(e4[0] instanceof Name)) {
                  warn$1(`Expected name for beginMarkedContentProps arg0=${e4[0]}`), a2.addOp(xt, ["OC", null]);
                  continue;
                }
                if ("OC" === e4[0].name)
                  return void next(c2.parseMarkedContentProps(e4[1], i2).then((e5) => {
                    a2.addOp(xt, ["OC", e5]);
                  }).catch((e5) => {
                    if (!(e5 instanceof ii)) {
                      if (c2.options.ignoreErrors)
                        return warn$1(`getOperatorList - ignoring beginMarkedContentProps: "${e5}".`), void a2.addOp(xt, ["OC", null]);
                      throw e5;
                    }
                  }));
                e4 = [e4[0].name, e4[1] instanceof Dict ? e4[1].get("MCID") : null];
                break;
              default:
                if (null !== e4) {
                  for (S2 = 0, v2 = e4.length; S2 < v2 && !(e4[S2] instanceof Dict); S2++)
                    ;
                  if (S2 < v2) {
                    warn$1("getOperatorList - ignoring operator: " + n4);
                    continue;
                  }
                }
            }
            a2.addOp(n4, e4);
          }
          o3 ? next(Ss) : (closePendingRestoreOPS(), e3());
        }, "promiseBody")).catch((e3) => {
          if (!(e3 instanceof ii)) {
            if (this.options.ignoreErrors)
              return warn$1(`getOperatorList - ignoring errors during "${t2.name}" task: "${e3}".`), void closePendingRestoreOPS();
            throw e3;
          }
        });
      }
      getTextContent({ stream: e2, task: i2, resources: a2, stateManager: n2 = null, includeMarkedContent: s2 = false, sink: r2, seenStyles: o2 = /* @__PURE__ */ new Set(), viewBox: l3, lang: c2 = null, markedContentData: h2 = null, disableNormalization: d2 = false, keepWhiteSpace: u2 = false, prevRefs: g2 = null, intersector: p2 = null }) {
        const f2 = e2.dict?.objId, m2 = new RefSet(g2);
        if (f2) {
          if (g2?.has(f2))
            throw new Error(`getTextContent - ignoring circular reference: ${f2}`);
          m2.put(f2);
        }
        a2 ||= Dict.empty, n2 ||= new StateManager(new TextState()), s2 && (h2 ||= { level: 0 });
        const b2 = { items: [], styles: /* @__PURE__ */ Object.create(null), lang: c2 }, y2 = { initialized: false, str: [], totalWidth: 0, totalHeight: 0, width: 0, height: 0, vertical: false, prevTransform: null, textAdvanceScale: 0, spaceInFlowMin: 0, spaceInFlowMax: 0, trackingSpaceMin: 1 / 0, negativeSpaceMax: -1 / 0, notASpace: -1 / 0, transform: null, fontName: null, hasEOL: false }, w2 = [" ", " "];
        let x2 = 0;
        function saveLastChar(e3) {
          const t2 = (x2 + 1) % 2, i3 = " " !== w2[x2] && " " === w2[t2];
          return w2[x2] = e3, x2 = t2, !u2 && i3;
        }
        __name(saveLastChar, "saveLastChar");
        function shouldAddWhitepsace() {
          return !u2 && " " !== w2[x2] && " " === w2[(x2 + 1) % 2];
        }
        __name(shouldAddWhitepsace, "shouldAddWhitepsace");
        function resetLastChars() {
          w2[0] = w2[1] = " ", x2 = 0;
        }
        __name(resetLastChars, "resetLastChars");
        const S2 = this, v2 = this.xref, C2 = [];
        let k2 = null;
        const T2 = new LocalImageCache(), F2 = new LocalGStateCache(), M2 = new EvaluatorPreprocessor(e2, v2, n2);
        let D2;
        function pushWhitespace({ width: e3 = 0, height: t2 = 0, transform: i3 = y2.prevTransform, fontName: a3 = y2.fontName }) {
          p2?.addExtraChar(" "), b2.items.push({ str: " ", dir: "ltr", width: e3, height: t2, transform: i3, fontName: a3, hasEOL: false });
        }
        __name(pushWhitespace, "pushWhitespace");
        function getCurrentTextTransform() {
          const e3 = D2.font, i3 = [D2.fontSize * D2.textHScale, 0, 0, D2.fontSize, 0, D2.textRise];
          if (e3.isType3Font && (D2.fontSize <= 1 || e3.isCharBBox) && !isArrayEqual(D2.fontMatrix, t)) {
            const t2 = e3.bbox[3] - e3.bbox[1];
            t2 > 0 && (i3[3] *= t2 * D2.fontMatrix[3]);
          }
          return ni.transform(D2.ctm, ni.transform(D2.textMatrix, i3));
        }
        __name(getCurrentTextTransform, "getCurrentTextTransform");
        function ensureTextContentItem() {
          if (y2.initialized)
            return y2;
          const { font: e3, loadedName: t2 } = D2;
          if (!o2.has(t2) && (o2.add(t2), b2.styles[t2] = { fontFamily: e3.fallbackName, ascent: e3.ascent, descent: e3.descent, vertical: e3.vertical }, S2.options.fontExtraProperties && e3.systemFontInfo)) {
            const i4 = b2.styles[t2];
            i4.fontSubstitution = e3.systemFontInfo.css, i4.fontSubstitutionLoadedName = e3.systemFontInfo.loadedName;
          }
          y2.fontName = t2;
          const i3 = y2.transform = getCurrentTextTransform();
          e3.vertical ? (y2.width = y2.totalWidth = Math.hypot(i3[0], i3[1]), y2.height = y2.totalHeight = 0, y2.vertical = true) : (y2.width = y2.totalWidth = 0, y2.height = y2.totalHeight = Math.hypot(i3[2], i3[3]), y2.vertical = false);
          const a3 = Math.hypot(D2.textLineMatrix[0], D2.textLineMatrix[1]), n3 = Math.hypot(D2.ctm[0], D2.ctm[1]);
          y2.textAdvanceScale = n3 * a3;
          const { fontSize: s3 } = D2;
          return y2.trackingSpaceMin = 0.102 * s3, y2.notASpace = 0.03 * s3, y2.negativeSpaceMax = -0.2 * s3, y2.spaceInFlowMin = 0.102 * s3, y2.spaceInFlowMax = 0.6 * s3, y2.hasEOL = false, y2.initialized = true, y2;
        }
        __name(ensureTextContentItem, "ensureTextContentItem");
        function updateAdvanceScale() {
          if (!y2.initialized)
            return;
          const e3 = Math.hypot(D2.textLineMatrix[0], D2.textLineMatrix[1]), t2 = Math.hypot(D2.ctm[0], D2.ctm[1]) * e3;
          t2 !== y2.textAdvanceScale && (y2.vertical ? (y2.totalHeight += y2.height * y2.textAdvanceScale, y2.height = 0) : (y2.totalWidth += y2.width * y2.textAdvanceScale, y2.width = 0), y2.textAdvanceScale = t2);
        }
        __name(updateAdvanceScale, "updateAdvanceScale");
        function runBidiTransform(e3) {
          let t2 = e3.str.join("");
          var i3;
          d2 || (i3 = t2, ri || (ri = /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu, oi = /* @__PURE__ */ new Map([["\uFB05", "\u017Ft"]])), t2 = i3.replaceAll(ri, (e4, t3, i4) => t3 ? t3.normalize("NFKC") : oi.get(i4)));
          const a3 = bidi(t2, -1, e3.vertical);
          return { str: a3.str, dir: a3.dir, width: Math.abs(e3.totalWidth), height: Math.abs(e3.totalHeight), transform: e3.transform, fontName: e3.fontName, hasEOL: e3.hasEOL };
        }
        __name(runBidiTransform, "runBidiTransform");
        async function handleSetFont(e3, n3) {
          const s3 = await S2.loadFont(e3, n3, a2, i2);
          D2.loadedName = s3.loadedName, D2.font = s3.font, D2.fontMatrix = s3.font.fontMatrix || t;
        }
        __name(handleSetFont, "handleSetFont");
        function applyInverseRotation(e3, t2, i3) {
          const a3 = Math.hypot(i3[0], i3[1]);
          return [(i3[0] * e3 + i3[1] * t2) / a3, (i3[2] * e3 + i3[3] * t2) / a3];
        }
        __name(applyInverseRotation, "applyInverseRotation");
        function compareWithLastPosition(e3) {
          const t2 = getCurrentTextTransform();
          let i3 = t2[4], a3 = t2[5];
          if (D2.font?.vertical) {
            if (i3 < l3[0] || i3 > l3[2] || a3 + e3 < l3[1] || a3 > l3[3])
              return false;
          } else if (i3 + e3 < l3[0] || i3 > l3[2] || a3 < l3[1] || a3 > l3[3])
            return false;
          if (!D2.font || !y2.prevTransform)
            return true;
          let n3 = y2.prevTransform[4], s3 = y2.prevTransform[5];
          if (n3 === i3 && s3 === a3)
            return true;
          let r3 = -1;
          switch (t2[0] && 0 === t2[1] && 0 === t2[2] ? r3 = t2[0] > 0 ? 0 : 180 : t2[1] && 0 === t2[0] && 0 === t2[3] && (r3 = t2[1] > 0 ? 90 : 270), r3) {
            case 0:
              break;
            case 90:
              [i3, a3] = [a3, i3], [n3, s3] = [s3, n3];
              break;
            case 180:
              [i3, a3, n3, s3] = [-i3, -a3, -n3, -s3];
              break;
            case 270:
              [i3, a3] = [-a3, -i3], [n3, s3] = [-s3, -n3];
              break;
            default:
              [i3, a3] = applyInverseRotation(i3, a3, t2), [n3, s3] = applyInverseRotation(n3, s3, y2.prevTransform);
          }
          if (D2.font.vertical) {
            const e4 = (s3 - a3) / y2.textAdvanceScale, t3 = i3 - n3, r4 = Math.sign(y2.height);
            return e4 < r4 * y2.negativeSpaceMax ? Math.abs(t3) > 0.5 * y2.width ? (appendEOL(), true) : (resetLastChars(), flushTextContentItem(), true) : Math.abs(t3) > y2.width ? (appendEOL(), true) : (e4 <= r4 * y2.notASpace && resetLastChars(), e4 <= r4 * y2.trackingSpaceMin ? shouldAddWhitepsace() ? (resetLastChars(), flushTextContentItem(), pushWhitespace({ height: Math.abs(e4) })) : y2.height += e4 : addFakeSpaces(e4, y2.prevTransform, r4) || (0 === y2.str.length ? (resetLastChars(), pushWhitespace({ height: Math.abs(e4) })) : y2.height += e4), Math.abs(t3) > 0.25 * y2.width && flushTextContentItem(), true);
          }
          const o3 = (i3 - n3) / y2.textAdvanceScale, c3 = a3 - s3, h3 = Math.sign(y2.width);
          return o3 < h3 * y2.negativeSpaceMax ? Math.abs(c3) > 0.5 * y2.height ? (appendEOL(), true) : (resetLastChars(), flushTextContentItem(), true) : Math.abs(c3) > y2.height ? (appendEOL(), true) : (o3 <= h3 * y2.notASpace && resetLastChars(), o3 <= h3 * y2.trackingSpaceMin ? shouldAddWhitepsace() ? (resetLastChars(), flushTextContentItem(), pushWhitespace({ width: Math.abs(o3) })) : y2.width += o3 : addFakeSpaces(o3, y2.prevTransform, h3) || (0 === y2.str.length ? (resetLastChars(), pushWhitespace({ width: Math.abs(o3) })) : y2.width += o3), Math.abs(c3) > 0.25 * y2.height && flushTextContentItem(), true);
        }
        __name(compareWithLastPosition, "compareWithLastPosition");
        function buildTextContentItem({ chars: e3, extraSpacing: t2 }) {
          const i3 = D2.font;
          if (!e3) {
            const e4 = D2.charSpacing + t2;
            return e4 && (i3.vertical ? D2.translateTextMatrix(0, -e4) : D2.translateTextMatrix(e4 * D2.textHScale, 0)), void (u2 && compareWithLastPosition(0));
          }
          const a3 = i3.charsToGlyphs(e3), n3 = D2.fontMatrix[0] * D2.fontSize;
          for (let e4 = 0, s3 = a3.length; e4 < s3; e4++) {
            const r3 = a3[e4], { category: o3 } = r3;
            if (o3.isInvisibleFormatMark)
              continue;
            let l4 = D2.charSpacing + (e4 + 1 === s3 ? t2 : 0), c3 = r3.width;
            i3.vertical && (c3 = r3.vmetric ? r3.vmetric[0] : -c3);
            let h3 = c3 * n3;
            if (!u2 && o3.isWhitespace) {
              i3.vertical ? (l4 += -h3 + D2.wordSpacing, D2.translateTextMatrix(0, -l4)) : (l4 += h3 + D2.wordSpacing, D2.translateTextMatrix(l4 * D2.textHScale, 0)), saveLastChar(" ");
              continue;
            }
            if (!o3.isZeroWidthDiacritic && !compareWithLastPosition(h3)) {
              i3.vertical ? D2.translateTextMatrix(0, h3) : D2.translateTextMatrix(h3 * D2.textHScale, 0);
              continue;
            }
            const d3 = ensureTextContentItem();
            o3.isZeroWidthDiacritic && (h3 = 0), i3.vertical ? (p2?.addGlyph(getCurrentTextTransform(), 0, h3, r3.unicode), D2.translateTextMatrix(0, h3), h3 = Math.abs(h3), d3.height += h3) : (h3 *= D2.textHScale, p2?.addGlyph(getCurrentTextTransform(), h3, 0, r3.unicode), D2.translateTextMatrix(h3, 0), d3.width += h3), h3 && (d3.prevTransform = getCurrentTextTransform());
            const g3 = r3.unicode;
            saveLastChar(g3) && (d3.str.push(" "), p2?.addExtraChar(" ")), p2 || d3.str.push(g3), l4 && (i3.vertical ? D2.translateTextMatrix(0, -l4) : D2.translateTextMatrix(l4 * D2.textHScale, 0));
          }
        }
        __name(buildTextContentItem, "buildTextContentItem");
        function appendEOL() {
          p2?.addExtraChar("\n"), resetLastChars(), y2.initialized ? (y2.hasEOL = true, flushTextContentItem()) : b2.items.push({ str: "", dir: "ltr", width: 0, height: 0, transform: getCurrentTextTransform(), fontName: D2.loadedName, hasEOL: true });
        }
        __name(appendEOL, "appendEOL");
        function addFakeSpaces(e3, t2, i3) {
          if (i3 * y2.spaceInFlowMin <= e3 && e3 <= i3 * y2.spaceInFlowMax)
            return y2.initialized && (resetLastChars(), y2.str.push(" "), p2?.addExtraChar(" ")), false;
          const a3 = y2.fontName;
          let n3 = 0;
          return y2.vertical && (n3 = e3, e3 = 0), flushTextContentItem(), resetLastChars(), pushWhitespace({ width: Math.abs(e3), height: Math.abs(n3), transform: t2 || getCurrentTextTransform(), fontName: a3 }), true;
        }
        __name(addFakeSpaces, "addFakeSpaces");
        function flushTextContentItem() {
          y2.initialized && y2.str && (y2.vertical ? y2.totalHeight += y2.height * y2.textAdvanceScale : y2.totalWidth += y2.width * y2.textAdvanceScale, b2.items.push(runBidiTransform(y2)), y2.initialized = false, y2.str.length = 0);
        }
        __name(flushTextContentItem, "flushTextContentItem");
        function enqueueChunk(e3 = false) {
          const t2 = b2.items.length;
          0 !== t2 && (e3 && t2 < 10 || (r2?.enqueue(b2, t2), b2.items = [], b2.styles = /* @__PURE__ */ Object.create(null)));
        }
        __name(enqueueChunk, "enqueueChunk");
        const E2 = new TimeSlotManager();
        return new Promise(/* @__PURE__ */ __name(function promiseBody(e3, t2) {
          const next = /* @__PURE__ */ __name(function(i3) {
            enqueueChunk(true), Promise.all([i3, r2?.ready]).then(function() {
              try {
                promiseBody(e3, t2);
              } catch (e4) {
                t2(e4);
              }
            }, t2);
          }, "next");
          i2.ensureNotTerminated(), E2.reset();
          const g3 = {};
          let p3, f3, y3, w3 = [];
          for (; !(p3 = E2.check()) && (w3.length = 0, g3.args = w3, M2.read(g3)); ) {
            const e4 = D2;
            D2 = n2.state;
            const t3 = g3.fn;
            switch (w3 = g3.args, 0 | t3) {
              case He:
                const t4 = w3[0].name, g4 = w3[1];
                if (D2.font && t4 === D2.fontName && g4 === D2.fontSize)
                  break;
                return flushTextContentItem(), D2.fontName = t4, D2.fontSize = g4, void next(handleSetFont(t4, null));
              case Xe:
                D2.textRise = w3[0];
                break;
              case je:
                D2.textHScale = w3[0] / 100;
                break;
              case $e:
                D2.leading = w3[0];
                break;
              case ze:
                D2.translateTextLineMatrix(w3[0], w3[1]), D2.textMatrix = D2.textLineMatrix.slice();
                break;
              case We:
                D2.leading = -w3[1], D2.translateTextLineMatrix(w3[0], w3[1]), D2.textMatrix = D2.textLineMatrix.slice();
                break;
              case Ve:
                D2.carriageReturn();
                break;
              case Ge:
                D2.setTextMatrix(w3[0], w3[1], w3[2], w3[3], w3[4], w3[5]), D2.setTextLineMatrix(w3[0], w3[1], w3[2], w3[3], w3[4], w3[5]), updateAdvanceScale();
                break;
              case Le:
                D2.charSpacing = w3[0];
                break;
              case Ue:
                D2.wordSpacing = w3[0];
                break;
              case Be:
                D2.textMatrix = fi.slice(), D2.textLineMatrix = fi.slice();
                break;
              case Ye:
                if (!n2.state.font) {
                  S2.ensureStateFont(n2.state);
                  continue;
                }
                const p4 = (D2.font.vertical ? 1 : -1) * D2.fontSize / 1e3, x3 = w3[0];
                for (let e5 = 0, t5 = x3.length; e5 < t5; e5++) {
                  const t6 = x3[e5];
                  if ("string" == typeof t6)
                    C2.push(t6);
                  else if ("number" == typeof t6 && 0 !== t6) {
                    const e6 = C2.join("");
                    C2.length = 0, buildTextContentItem({ chars: e6, extraSpacing: t6 * p4 });
                  }
                }
                if (C2.length > 0) {
                  const e5 = C2.join("");
                  C2.length = 0, buildTextContentItem({ chars: e5, extraSpacing: 0 });
                }
                break;
              case Ke:
                if (!n2.state.font) {
                  S2.ensureStateFont(n2.state);
                  continue;
                }
                buildTextContentItem({ chars: w3[0], extraSpacing: 0 });
                break;
              case Je:
                if (!n2.state.font) {
                  S2.ensureStateFont(n2.state);
                  continue;
                }
                D2.carriageReturn(), buildTextContentItem({ chars: w3[0], extraSpacing: 0 });
                break;
              case Ze:
                if (!n2.state.font) {
                  S2.ensureStateFont(n2.state);
                  continue;
                }
                D2.wordSpacing = w3[0], D2.charSpacing = w3[1], D2.carriageReturn(), buildTextContentItem({ chars: w3[2], extraSpacing: 0 });
                break;
              case bt:
                if (flushTextContentItem(), k2 ??= a2.get("XObject") || Dict.empty, y3 = w3[0] instanceof Name, f3 = w3[0].name, y3 && T2.getByName(f3))
                  break;
                return void next(new Promise(function(e5, t5) {
                  if (!y3)
                    throw new ti("XObject must be referred to by name.");
                  let g5 = k2.getRaw(f3);
                  if (g5 instanceof Ref) {
                    if (T2.getByRef(g5))
                      return void e5();
                    if (S2.globalImageCache.getData(g5, S2.pageIndex))
                      return void e5();
                    g5 = v2.fetch(g5);
                  }
                  if (!(g5 instanceof BaseStream))
                    throw new ti("XObject should be a stream");
                  const { dict: p5 } = g5, b3 = p5.get("Subtype");
                  if (!(b3 instanceof Name))
                    throw new ti("XObject should have a Name subtype");
                  if ("Form" !== b3.name)
                    return T2.set(f3, p5.objId, true), void e5();
                  const w4 = n2.state.clone(), x4 = new StateManager(w4), C3 = lookupMatrix(p5.getArray("Matrix"), null);
                  C3 && x4.transform(C3);
                  const F3 = p5.get("Resources");
                  enqueueChunk();
                  const M3 = { enqueueInvoked: false, enqueue(e6, t6) {
                    this.enqueueInvoked = true, r2.enqueue(e6, t6);
                  }, get desiredSize() {
                    return r2.desiredSize ?? 0;
                  }, get ready() {
                    return r2.ready;
                  } };
                  S2.getTextContent({ stream: g5, task: i2, resources: F3 instanceof Dict ? F3 : a2, stateManager: x4, includeMarkedContent: s2, sink: r2 && M3, seenStyles: o2, viewBox: l3, lang: c2, markedContentData: h2, disableNormalization: d2, keepWhiteSpace: u2, prevRefs: m2 }).then(function() {
                    M3.enqueueInvoked || T2.set(f3, p5.objId, true), e5();
                  }, t5);
                }).catch(function(e5) {
                  if (!(e5 instanceof ii)) {
                    if (!S2.options.ignoreErrors)
                      throw e5;
                    warn$1(`getTextContent - ignoring XObject: "${e5}".`);
                  }
                }));
              case pe:
                if (y3 = w3[0] instanceof Name, f3 = w3[0].name, y3 && F2.getByName(f3))
                  break;
                return void next(new Promise(function(e5, t5) {
                  if (!y3)
                    throw new ti("GState must be referred to by name.");
                  const i3 = a2.get("ExtGState");
                  if (!(i3 instanceof Dict))
                    throw new ti("ExtGState should be a dictionary.");
                  const n3 = i3.get(f3);
                  if (!(n3 instanceof Dict))
                    throw new ti("GState should be a dictionary.");
                  const s3 = n3.get("Font");
                  if (!s3)
                    return F2.set(f3, n3.objId, true), void e5();
                  flushTextContentItem(), D2.fontName = null, D2.fontSize = s3[1], handleSetFont(null, s3[0]).then(e5, t5);
                }).catch(function(e5) {
                  if (!(e5 instanceof ii)) {
                    if (!S2.options.ignoreErrors)
                      throw e5;
                    warn$1(`getTextContent - ignoring ExtGState: "${e5}".`);
                  }
                }));
              case At:
                flushTextContentItem(), s2 && (h2.level++, b2.items.push({ type: "beginMarkedContent", tag: w3[0] instanceof Name ? w3[0].name : null }));
                break;
              case xt:
                if (flushTextContentItem(), s2) {
                  h2.level++;
                  let e5 = null;
                  w3[1] instanceof Dict && (e5 = w3[1].get("MCID")), b2.items.push({ type: "beginMarkedContentProps", id: Number.isInteger(e5) ? `${S2.idFactory.getPageObjId()}_mc${e5}` : null, tag: w3[0] instanceof Name ? w3[0].name : null });
                }
                break;
              case St:
                if (flushTextContentItem(), s2) {
                  if (0 === h2.level)
                    break;
                  h2.level--, b2.items.push({ type: "endMarkedContent" });
                }
                break;
              case me:
                !e4 || e4.font === D2.font && e4.fontSize === D2.fontSize && e4.fontName === D2.fontName || flushTextContentItem();
            }
            if (b2.items.length >= (r2?.desiredSize ?? 1)) {
              p3 = true;
              break;
            }
          }
          p3 ? next(Ss) : (flushTextContentItem(), enqueueChunk(), e3());
        }, "promiseBody")).catch((e3) => {
          if (!(e3 instanceof ii)) {
            if (this.options.ignoreErrors)
              return warn$1(`getTextContent - ignoring errors during "${i2.name}" task: "${e3}".`), flushTextContentItem(), void enqueueChunk();
            throw e3;
          }
        });
      }
      async extractDataStructures(e2, t2) {
        const i2 = this.xref;
        let a2;
        const n2 = this.readToUnicode(t2.toUnicode);
        if (t2.composite) {
          const i3 = e2.get("CIDSystemInfo");
          i3 instanceof Dict && (t2.cidSystemInfo = { registry: stringToPDFString(i3.get("Registry")), ordering: stringToPDFString(i3.get("Ordering")), supplement: i3.get("Supplement") });
          try {
            const t3 = e2.get("CIDToGIDMap");
            t3 instanceof BaseStream && (a2 = t3.getBytes());
          } catch (e3) {
            if (!this.options.ignoreErrors)
              throw e3;
            warn$1(`extractDataStructures - ignoring CIDToGIDMap data: "${e3}".`);
          }
        }
        const s2 = [];
        let r2, o2 = null;
        if (e2.has("Encoding")) {
          if (r2 = e2.get("Encoding"), r2 instanceof Dict) {
            if (o2 = r2.get("BaseEncoding"), o2 = o2 instanceof Name ? o2.name : null, r2.has("Differences")) {
              const e3 = r2.get("Differences");
              let t3 = 0;
              for (const a3 of e3) {
                const e4 = i2.fetchIfRef(a3);
                if ("number" == typeof e4)
                  t3 = e4;
                else {
                  if (!(e4 instanceof Name))
                    throw new ti(`Invalid entry in 'Differences' array: ${e4}`);
                  s2[t3++] = e4.name;
                }
              }
            }
          } else if (r2 instanceof Name)
            o2 = r2.name;
          else {
            const e3 = "Encoding is not a Name nor a Dict";
            if (!this.options.ignoreErrors)
              throw new ti(e3);
            warn$1(e3);
          }
          "MacRomanEncoding" !== o2 && "MacExpertEncoding" !== o2 && "WinAnsiEncoding" !== o2 && (o2 = null);
        }
        const l3 = !t2.file || t2.isInternalFont, c2 = Ha()[t2.name];
        if (o2 && l3 && c2 && (o2 = null), o2)
          t2.defaultEncoding = getEncoding(o2);
        else {
          const e3 = !!(t2.flags & Ca), i3 = !!(t2.flags & ka);
          r2 = da, "TrueType" !== t2.type || i3 || (r2 = ua), (e3 || c2) && (r2 = ha, l3 && (/Symbol/i.test(t2.name) ? r2 = ga : /Dingbats/i.test(t2.name) ? r2 = pa : /Wingdings/i.test(t2.name) && (r2 = ua))), t2.defaultEncoding = r2;
        }
        t2.differences = s2, t2.baseEncodingName = o2, t2.hasEncoding = !!o2 || s2.length > 0, t2.dict = e2, t2.toUnicode = await n2;
        const h2 = await this.buildToUnicode(t2);
        return t2.toUnicode = h2, a2 && (t2.cidToGidMap = this.readCidToGidMap(a2, h2)), t2;
      }
      _simpleFontToUnicode(e2, t2 = false) {
        assert$1(!e2.composite, "Must be a simple font.");
        const i2 = [], a2 = e2.defaultEncoding.slice(), n2 = e2.baseEncodingName, s2 = e2.differences;
        for (const e3 in s2) {
          const t3 = s2[e3];
          ".notdef" !== t3 && (a2[e3] = t3);
        }
        const r2 = fa();
        for (const s3 in a2) {
          let o2 = a2[s3];
          if ("" === o2)
            continue;
          let l3 = r2[o2];
          if (void 0 !== l3) {
            i2[s3] = String.fromCharCode(l3);
            continue;
          }
          let c2 = 0;
          switch (o2[0]) {
            case "G":
              3 === o2.length && (c2 = parseInt(o2.substring(1), 16));
              break;
            case "g":
              5 === o2.length && (c2 = parseInt(o2.substring(1), 16));
              break;
            case "C":
            case "c":
              if (o2.length >= 3 && o2.length <= 4) {
                const i3 = o2.substring(1);
                if (t2) {
                  c2 = parseInt(i3, 16);
                  break;
                }
                if (c2 = +i3, Number.isNaN(c2) && Number.isInteger(parseInt(i3, 16)))
                  return this._simpleFontToUnicode(e2, true);
              }
              break;
            case "u":
              l3 = getUnicodeForGlyph(o2, r2), -1 !== l3 && (c2 = l3);
              break;
            default:
              switch (o2) {
                case "f_h":
                case "f_t":
                case "T_h":
                  i2[s3] = o2.replaceAll("_", "");
                  continue;
              }
          }
          if (c2 > 0 && c2 <= 1114111 && Number.isInteger(c2)) {
            if (n2 && c2 === +s3) {
              const e3 = getEncoding(n2);
              if (e3 && (o2 = e3[s3])) {
                i2[s3] = String.fromCharCode(r2[o2]);
                continue;
              }
            }
            i2[s3] = String.fromCodePoint(c2);
          }
        }
        return i2;
      }
      async buildToUnicode(e2) {
        if (e2.hasIncludedToUnicodeMap = e2.toUnicode?.length > 0, e2.hasIncludedToUnicodeMap)
          return !e2.composite && e2.hasEncoding && (e2.fallbackToUnicode = this._simpleFontToUnicode(e2)), e2.toUnicode;
        if (!e2.composite)
          return new ToUnicodeMap(this._simpleFontToUnicode(e2));
        if (e2.composite && (e2.cMap.builtInCMap && !(e2.cMap instanceof IdentityCMap) || "Adobe" === e2.cidSystemInfo?.registry && ("GB1" === e2.cidSystemInfo.ordering || "CNS1" === e2.cidSystemInfo.ordering || "Japan1" === e2.cidSystemInfo.ordering || "Korea1" === e2.cidSystemInfo.ordering))) {
          const { registry: t2, ordering: i2 } = e2.cidSystemInfo, a2 = Name.get(`${t2}-${i2}-UCS2`), n2 = await CMapFactory.create({ encoding: a2, fetchBuiltInCMap: this._fetchBuiltInCMapBound, useCMap: null }), s2 = [], r2 = [];
          return e2.cMap.forEach(function(e3, t3) {
            if (t3 > 65535)
              throw new ti("Max size of CID is 65,535");
            const i3 = n2.lookup(t3);
            if (i3) {
              r2.length = 0;
              for (let e4 = 0, t4 = i3.length; e4 < t4; e4 += 2)
                r2.push((i3.charCodeAt(e4) << 8) + i3.charCodeAt(e4 + 1));
              s2[e3] = String.fromCharCode(...r2);
            }
          }), new ToUnicodeMap(s2);
        }
        return new IdentityToUnicodeMap(e2.firstChar, e2.lastChar);
      }
      async readToUnicode(e2) {
        if (!e2)
          return null;
        if (e2 instanceof Name) {
          const t2 = await CMapFactory.create({ encoding: e2, fetchBuiltInCMap: this._fetchBuiltInCMapBound, useCMap: null });
          return t2 instanceof IdentityCMap ? new IdentityToUnicodeMap(0, 65535) : new ToUnicodeMap(t2.getMap());
        }
        if (e2 instanceof BaseStream)
          try {
            const t2 = await CMapFactory.create({ encoding: e2, fetchBuiltInCMap: this._fetchBuiltInCMapBound, useCMap: null });
            if (t2 instanceof IdentityCMap)
              return new IdentityToUnicodeMap(0, 65535);
            const i2 = new Array(t2.length);
            return t2.forEach(function(e3, t3) {
              if ("number" == typeof t3)
                return void (i2[e3] = String.fromCodePoint(t3));
              t3.length % 2 != 0 && (t3 = "\0" + t3);
              const a2 = [];
              for (let e4 = 0; e4 < t3.length; e4 += 2) {
                const i3 = t3.charCodeAt(e4) << 8 | t3.charCodeAt(e4 + 1);
                if (55296 != (63488 & i3)) {
                  a2.push(i3);
                  continue;
                }
                e4 += 2;
                const n2 = t3.charCodeAt(e4) << 8 | t3.charCodeAt(e4 + 1);
                a2.push(((1023 & i3) << 10) + (1023 & n2) + 65536);
              }
              i2[e3] = String.fromCodePoint(...a2);
            }), new ToUnicodeMap(i2);
          } catch (e3) {
            if (e3 instanceof ii)
              return null;
            if (this.options.ignoreErrors)
              return warn$1(`readToUnicode - ignoring ToUnicode data: "${e3}".`), null;
            throw e3;
          }
        return null;
      }
      readCidToGidMap(e2, t2) {
        const i2 = [];
        for (let a2 = 0, n2 = e2.length; a2 < n2; a2++) {
          const n3 = e2[a2++] << 8 | e2[a2], s2 = a2 >> 1;
          (0 !== n3 || t2.has(s2)) && (i2[s2] = n3);
        }
        return i2;
      }
      extractWidths(e2, t2, i2) {
        const a2 = this.xref;
        let n2 = [], s2 = 0;
        const r2 = [];
        let o2;
        if (i2.composite) {
          const t3 = e2.get("DW");
          s2 = "number" == typeof t3 ? Math.ceil(t3) : 1e3;
          const l4 = e2.get("W");
          if (Array.isArray(l4))
            for (let e3 = 0, t4 = l4.length; e3 < t4; e3++) {
              let t5 = a2.fetchIfRef(l4[e3++]);
              if (!Number.isInteger(t5))
                break;
              const i3 = a2.fetchIfRef(l4[e3]);
              if (Array.isArray(i3))
                for (const e4 of i3) {
                  const i4 = a2.fetchIfRef(e4);
                  "number" == typeof i4 && (n2[t5] = i4), t5++;
                }
              else {
                if (!Number.isInteger(i3))
                  break;
                {
                  const s3 = a2.fetchIfRef(l4[++e3]);
                  if ("number" != typeof s3)
                    continue;
                  for (let e4 = t5; e4 <= i3; e4++)
                    n2[e4] = s3;
                }
              }
            }
          if (i2.vertical) {
            const t4 = e2.getArray("DW2");
            let i3 = isNumberArray(t4, 2) ? t4 : [880, -1e3];
            if (o2 = [i3[1], 0.5 * s2, i3[0]], i3 = e2.get("W2"), Array.isArray(i3))
              for (let e3 = 0, t5 = i3.length; e3 < t5; e3++) {
                let t6 = a2.fetchIfRef(i3[e3++]);
                if (!Number.isInteger(t6))
                  break;
                const n3 = a2.fetchIfRef(i3[e3]);
                if (Array.isArray(n3))
                  for (let e4 = 0, i4 = n3.length; e4 < i4; e4++) {
                    const i5 = [a2.fetchIfRef(n3[e4++]), a2.fetchIfRef(n3[e4++]), a2.fetchIfRef(n3[e4])];
                    isNumberArray(i5, null) && (r2[t6] = i5), t6++;
                  }
                else {
                  if (!Number.isInteger(n3))
                    break;
                  {
                    const s3 = [a2.fetchIfRef(i3[++e3]), a2.fetchIfRef(i3[++e3]), a2.fetchIfRef(i3[++e3])];
                    if (!isNumberArray(s3, null))
                      continue;
                    for (let e4 = t6; e4 <= n3; e4++)
                      r2[e4] = s3;
                  }
                }
              }
          }
        } else {
          const r3 = e2.get("Widths");
          if (Array.isArray(r3)) {
            let e3 = i2.firstChar;
            for (const t3 of r3) {
              const i3 = a2.fetchIfRef(t3);
              "number" == typeof i3 && (n2[e3] = i3), e3++;
            }
            const o3 = t2.get("MissingWidth");
            s2 = "number" == typeof o3 ? o3 : 0;
          } else {
            const t3 = e2.get("BaseFont");
            if (t3 instanceof Name) {
              const e3 = this.getBaseFontMetrics(t3.name);
              n2 = this.buildCharCodeToWidth(e3.widths, i2), s2 = e3.defaultWidth;
            }
          }
        }
        let l3 = true, c2 = s2;
        for (const e3 in n2) {
          const t3 = n2[e3];
          if (t3)
            if (c2) {
              if (c2 !== t3) {
                l3 = false;
                break;
              }
            } else
              c2 = t3;
        }
        l3 ? i2.flags |= Sa : i2.flags &= -2, i2.defaultWidth = s2, i2.widths = n2, i2.defaultVMetrics = o2, i2.vmetrics = r2;
      }
      isSerifFont(e2) {
        const t2 = e2.split("-", 1)[0];
        return t2 in $a() || /serif/gi.test(t2);
      }
      getBaseFontMetrics(e2) {
        let t2 = 0, i2 = /* @__PURE__ */ Object.create(null), a2 = false;
        let n2 = La()[e2] || e2;
        const s2 = Wa();
        n2 in s2 || (n2 = this.isSerifFont(e2) ? "Times-Roman" : "Helvetica");
        const r2 = s2[n2];
        return "number" == typeof r2 ? (t2 = r2, a2 = true) : i2 = r2(), { defaultWidth: t2, monospace: a2, widths: i2 };
      }
      buildCharCodeToWidth(e2, t2) {
        const i2 = /* @__PURE__ */ Object.create(null), a2 = t2.differences, n2 = t2.defaultEncoding;
        for (let t3 = 0; t3 < 256; t3++)
          t3 in a2 && e2[a2[t3]] ? i2[t3] = e2[a2[t3]] : t3 in n2 && e2[n2[t3]] && (i2[t3] = e2[n2[t3]]);
        return i2;
      }
      preEvaluateFont(e2) {
        const t2 = e2;
        let i2 = e2.get("Subtype");
        if (!(i2 instanceof Name))
          throw new ti("invalid font Subtype");
        let a2, n2 = false;
        if ("Type0" === i2.name) {
          const t3 = e2.get("DescendantFonts");
          if (!t3)
            throw new ti("Descendant fonts are not specified");
          if (!((e2 = Array.isArray(t3) ? this.xref.fetchIfRef(t3[0]) : t3) instanceof Dict))
            throw new ti("Descendant font is not a dictionary.");
          if (i2 = e2.get("Subtype"), !(i2 instanceof Name))
            throw new ti("invalid font Subtype");
          n2 = true;
        }
        let s2 = e2.get("FirstChar");
        Number.isInteger(s2) || (s2 = 0);
        let r2 = e2.get("LastChar");
        Number.isInteger(r2) || (r2 = n2 ? 65535 : 255);
        const o2 = e2.get("FontDescriptor"), l3 = e2.get("ToUnicode") || t2.get("ToUnicode");
        if (o2) {
          a2 = new ys();
          const i3 = t2.getRaw("Encoding");
          if (i3 instanceof Name)
            a2.update(i3.name);
          else if (i3 instanceof Ref)
            a2.update(i3.toString());
          else if (i3 instanceof Dict) {
            for (const e3 of i3.getRawValues())
              if (e3 instanceof Name)
                a2.update(e3.name);
              else if (e3 instanceof Ref)
                a2.update(e3.toString());
              else if (Array.isArray(e3)) {
                const t3 = e3.length, i4 = new Array(t3);
                for (let a3 = 0; a3 < t3; a3++) {
                  const t4 = e3[a3];
                  t4 instanceof Name ? i4[a3] = t4.name : ("number" == typeof t4 || t4 instanceof Ref) && (i4[a3] = t4.toString());
                }
                a2.update(i4.join());
              }
          }
          if (a2.update(`${s2}-${r2}`), l3 instanceof BaseStream) {
            const e3 = l3.str || l3, t3 = e3.buffer ? new Uint8Array(e3.buffer.buffer, 0, e3.bufferLength) : new Uint8Array(e3.bytes.buffer, e3.start, e3.end - e3.start);
            a2.update(t3);
          } else
            l3 instanceof Name && a2.update(l3.name);
          const o3 = e2.get("Widths") || t2.get("Widths");
          if (Array.isArray(o3)) {
            const e3 = [];
            for (const t3 of o3)
              ("number" == typeof t3 || t3 instanceof Ref) && e3.push(t3.toString());
            a2.update(e3.join());
          }
          if (n2) {
            a2.update("compositeFont");
            const i4 = e2.get("W") || t2.get("W");
            if (Array.isArray(i4)) {
              const e3 = [];
              for (const t3 of i4)
                if ("number" == typeof t3 || t3 instanceof Ref)
                  e3.push(t3.toString());
                else if (Array.isArray(t3)) {
                  const i5 = [];
                  for (const e4 of t3)
                    ("number" == typeof e4 || e4 instanceof Ref) && i5.push(e4.toString());
                  e3.push(`[${i5.join()}]`);
                }
              a2.update(e3.join());
            }
            const n3 = e2.getRaw("CIDToGIDMap") || t2.getRaw("CIDToGIDMap");
            n3 instanceof Name ? a2.update(n3.name) : n3 instanceof Ref ? a2.update(n3.toString()) : n3 instanceof BaseStream && a2.update(n3.peekBytes());
          }
        }
        return { descriptor: o2, dict: e2, baseDict: t2, composite: n2, type: i2.name, firstChar: s2, lastChar: r2, toUnicode: l3, hash: a2 ? a2.hexdigest() : "" };
      }
      async translateFont({ descriptor: e2, dict: i2, baseDict: a2, composite: n2, type: s2, firstChar: r2, lastChar: o2, toUnicode: l3, cssFontInfo: c2 }) {
        const h2 = "Type3" === s2;
        if (!e2) {
          if (!h2) {
            let e3 = i2.get("BaseFont");
            if (!(e3 instanceof Name))
              throw new ti("Base font is not specified");
            e3 = e3.name.replaceAll(/[,_]/g, "-");
            const t2 = this.getBaseFontMetrics(e3), n3 = e3.split("-", 1)[0], c3 = (this.isSerifFont(n3) ? va : 0) | (t2.monospace ? Sa : 0) | (Ha()[n3] ? Ca : ka), d3 = { type: s2, name: e3, loadedName: a2.loadedName, systemFontInfo: null, widths: t2.widths, defaultWidth: t2.defaultWidth, isSimulatedFlags: true, flags: c3, firstChar: r2, lastChar: o2, toUnicode: l3, xHeight: 0, capHeight: 0, italicAngle: 0, isType3Font: h2 }, u3 = i2.get("Widths"), g3 = getStandardFontName(e3);
            let p3 = null;
            g3 && (p3 = await this.fetchStandardFontData(g3), d3.isInternalFont = !!p3), !d3.isInternalFont && this.options.useSystemFonts && (d3.systemFontInfo = getFontSubstitution(this.systemFontCache, this.idFactory, this.options.standardFontDataUrl, e3, g3, s2));
            const f3 = await this.extractDataStructures(i2, d3);
            if (Array.isArray(u3)) {
              const e4 = [];
              let t3 = r2;
              for (const i3 of u3) {
                const a3 = this.xref.fetchIfRef(i3);
                "number" == typeof a3 && (e4[t3] = a3), t3++;
              }
              f3.widths = e4;
            } else
              f3.widths = this.buildCharCodeToWidth(t2.widths, f3);
            return new Font(e3, p3, f3, this.options);
          }
          e2 = Dict.empty;
        }
        let d2 = e2.get("FontName"), u2 = i2.get("BaseFont");
        "string" == typeof d2 && (d2 = Name.get(d2)), "string" == typeof u2 && (u2 = Name.get(u2));
        const g2 = d2?.name, p2 = u2?.name;
        if (h2 ? g2 || (d2 = Name.get(s2)) : g2 !== p2 && (info$1(`The FontDescriptor's FontName is "${g2}" but should be the same as the Font's BaseFont "${p2}".`), g2 && p2 && (p2.startsWith(g2) || !isKnownFontName(g2) && isKnownFontName(p2)) && (d2 = null), d2 ||= u2), !(d2 instanceof Name))
          throw new ti("invalid font name");
        let f2, m2, b2, y2, w2;
        try {
          if (f2 = e2.get("FontFile", "FontFile2", "FontFile3"), f2) {
            if (!(f2 instanceof BaseStream))
              throw new ti("FontFile should be a stream");
            if (f2.isEmpty)
              throw new ti("FontFile is empty");
          }
        } catch (e3) {
          if (!this.options.ignoreErrors)
            throw e3;
          warn$1(`translateFont - fetching "${d2.name}" font file: "${e3}".`), f2 = null;
        }
        let x2 = false, S2 = null, v2 = null;
        if (f2) {
          if (f2.dict) {
            const e3 = f2.dict.get("Subtype");
            e3 instanceof Name && (m2 = e3.name), b2 = f2.dict.get("Length1"), y2 = f2.dict.get("Length2"), w2 = f2.dict.get("Length3");
          }
        } else if (c2) {
          const e3 = getXfaFontName(d2.name);
          e3 && (c2.fontFamily = `${c2.fontFamily}-PdfJS-XFA`, c2.metrics = e3.metrics || null, S2 = e3.factors || null, f2 = await this.fetchStandardFontData(e3.name), x2 = !!f2, a2 = i2 = getXfaFontDict(d2.name), n2 = true);
        } else if (!h2) {
          const e3 = getStandardFontName(d2.name);
          e3 && (f2 = await this.fetchStandardFontData(e3), x2 = !!f2), !x2 && this.options.useSystemFonts && (v2 = getFontSubstitution(this.systemFontCache, this.idFactory, this.options.standardFontDataUrl, d2.name, e3, s2));
        }
        const C2 = lookupMatrix(i2.getArray("FontMatrix"), t), k2 = lookupNormalRect(e2.getArray("FontBBox") || i2.getArray("FontBBox"), h2 ? [0, 0, 0, 0] : void 0);
        let T2 = e2.get("Ascent");
        "number" != typeof T2 && (T2 = void 0);
        let F2 = e2.get("Descent");
        "number" != typeof F2 && (F2 = void 0);
        let M2 = e2.get("XHeight");
        "number" != typeof M2 && (M2 = 0);
        let D2 = e2.get("CapHeight");
        "number" != typeof D2 && (D2 = 0);
        let E2 = e2.get("Flags");
        Number.isInteger(E2) || (E2 = 0);
        let O2 = e2.get("ItalicAngle");
        "number" != typeof O2 && (O2 = 0);
        const _2 = { type: s2, name: d2.name, subtype: m2, file: f2, length1: b2, length2: y2, length3: w2, isInternalFont: x2, loadedName: a2.loadedName, composite: n2, fixedPitch: false, fontMatrix: C2, firstChar: r2, lastChar: o2, toUnicode: l3, bbox: k2, ascent: T2, descent: F2, xHeight: M2, capHeight: D2, flags: E2, italicAngle: O2, isType3Font: h2, cssFontInfo: c2, scaleFactors: S2, systemFontInfo: v2 };
        if (n2) {
          const e3 = a2.get("Encoding");
          e3 instanceof Name && (_2.cidEncoding = e3.name);
          const t2 = await CMapFactory.create({ encoding: e3, fetchBuiltInCMap: this._fetchBuiltInCMapBound, useCMap: null });
          _2.cMap = t2, _2.vertical = _2.cMap.vertical;
        }
        const R2 = await this.extractDataStructures(i2, _2);
        return this.extractWidths(i2, e2, R2), new Font(d2.name, f2, R2, this.options);
      }
      static buildFontPaths(e2, t2, i2, a2) {
        function buildPath(t3) {
          const n2 = `${e2.loadedName}_path_${t3}`;
          try {
            if (e2.renderer.hasBuiltPath(t3))
              return;
            i2.send("commonobj", [n2, "FontPath", e2.renderer.getPathJs(t3)]);
          } catch (e3) {
            if (a2.ignoreErrors)
              return void warn$1(`buildFontPaths - ignoring ${n2} glyph: "${e3}".`);
            throw e3;
          }
        }
        __name(buildPath, "buildPath");
        for (const e3 of t2) {
          buildPath(e3.fontChar);
          const t3 = e3.accent;
          t3?.fontChar && buildPath(t3.fontChar);
        }
      }
      static get fallbackFontDict() {
        const e2 = new Dict();
        return e2.set("BaseFont", Name.get("Helvetica")), e2.set("Type", Name.get("FallbackType")), e2.set("Subtype", Name.get("FallbackType")), e2.set("Encoding", Name.get("WinAnsiEncoding")), shadow$1(this, "fallbackFontDict", e2);
      }
    };
    __name(PartialEvaluator, "PartialEvaluator");
    TranslatedFont = class {
      #G = false;
      #V = null;
      constructor({ loadedName: e2, font: t2, dict: i2 }) {
        this.loadedName = e2, this.font = t2, this.dict = i2, this.type3Dependencies = t2.isType3Font ? /* @__PURE__ */ new Set() : null;
      }
      send(e2) {
        this.#G || (this.#G = true, e2.send("commonobj", [this.loadedName, "Font", this.font.exportData()]));
      }
      fallback(e2, t2) {
        this.font.data && (this.font.disableFontFace = true, PartialEvaluator.buildFontPaths(this.font, this.font.glyphCacheValues, e2, t2));
      }
      loadType3Data(e2, t2, i2) {
        if (this.#V)
          return this.#V;
        const { font: a2, type3Dependencies: n2 } = this;
        assert$1(a2.isType3Font, "Must be a Type3 font.");
        const s2 = e2.clone({ ignoreErrors: false }), r2 = new RefSet(e2.type3FontRefs);
        this.dict.objId && !r2.has(this.dict.objId) && r2.put(this.dict.objId), s2.type3FontRefs = r2;
        let o2 = Promise.resolve();
        const l3 = this.dict.get("CharProcs"), c2 = this.dict.get("Resources") || t2, h2 = /* @__PURE__ */ Object.create(null), [d2, u2, g2, p2] = a2.bbox, f2 = g2 - d2, m2 = p2 - u2, b2 = Math.hypot(f2, m2);
        for (const e3 of l3.getKeys())
          o2 = o2.then(() => {
            const t3 = l3.get(e3), a3 = new OperatorList();
            return s2.getOperatorList({ stream: t3, task: i2, resources: c2, operatorList: a3 }).then(() => {
              switch (a3.fnArray[0]) {
                case et:
                  this.#K(a3, b2);
                  break;
                case Qe:
                  b2 || this.#Y(a3);
              }
              h2[e3] = a3.getIR();
              for (const e4 of a3.dependencies)
                n2.add(e4);
            }).catch(function(t4) {
              warn$1(`Type3 font resource "${e3}" is not available.`);
              const i3 = new OperatorList();
              h2[e3] = i3.getIR();
            });
          });
        return this.#V = o2.then(() => {
          a2.charProcOperatorList = h2, this._bbox && (a2.isCharBBox = true, a2.bbox = this._bbox);
        }), this.#V;
      }
      #K(e2, t2 = NaN) {
        const i2 = ni.normalizeRect(e2.argsArray[0].slice(2)), a2 = i2[2] - i2[0], n2 = i2[3] - i2[1], s2 = Math.hypot(a2, n2);
        0 === a2 || 0 === n2 ? (e2.fnArray.splice(0, 1), e2.argsArray.splice(0, 1)) : (0 === t2 || Math.round(s2 / t2) >= 10) && (this._bbox ??= [1 / 0, 1 / 0, -1 / 0, -1 / 0], ni.rectBoundingBox(...i2, this._bbox));
        let r2 = 0, o2 = e2.length;
        for (; r2 < o2; ) {
          switch (e2.fnArray[r2]) {
            case et:
              break;
            case tt:
            case it:
            case at:
            case nt:
            case st:
            case rt:
            case ot:
            case lt:
            case ct:
            case ht:
            case dt:
            case ut:
            case gt:
            case ue:
              e2.fnArray.splice(r2, 1), e2.argsArray.splice(r2, 1), o2--;
              continue;
            case pe:
              const [t3] = e2.argsArray[r2];
              let i3 = 0, a3 = t3.length;
              for (; i3 < a3; ) {
                const [e3] = t3[i3];
                switch (e3) {
                  case "TR":
                  case "TR2":
                  case "HT":
                  case "BG":
                  case "BG2":
                  case "UCR":
                  case "UCR2":
                    t3.splice(i3, 1), a3--;
                    continue;
                }
                i3++;
              }
          }
          r2++;
        }
      }
      #Y(e2) {
        let t2 = 1;
        const i2 = e2.length;
        for (; t2 < i2; ) {
          if (e2.fnArray[t2] === Ut) {
            const i3 = e2.argsArray[t2][2];
            this._bbox ??= [1 / 0, 1 / 0, -1 / 0, -1 / 0], ni.rectBoundingBox(...i3, this._bbox);
          }
          t2++;
        }
      }
    };
    __name(TranslatedFont, "TranslatedFont");
    StateManager = class {
      constructor(e2 = new EvalState()) {
        this.state = e2, this.stateStack = [];
      }
      save() {
        const e2 = this.state;
        this.stateStack.push(this.state), this.state = e2.clone();
      }
      restore() {
        const e2 = this.stateStack.pop();
        e2 && (this.state = e2);
      }
      transform(e2) {
        this.state.ctm = ni.transform(this.state.ctm, e2);
      }
    };
    __name(StateManager, "StateManager");
    TextState = class {
      constructor() {
        this.ctm = new Float32Array(fi), this.fontName = null, this.fontSize = 0, this.loadedName = null, this.font = null, this.fontMatrix = t, this.textMatrix = fi.slice(), this.textLineMatrix = fi.slice(), this.charSpacing = 0, this.wordSpacing = 0, this.leading = 0, this.textHScale = 1, this.textRise = 0;
      }
      setTextMatrix(e2, t2, i2, a2, n2, s2) {
        const r2 = this.textMatrix;
        r2[0] = e2, r2[1] = t2, r2[2] = i2, r2[3] = a2, r2[4] = n2, r2[5] = s2;
      }
      setTextLineMatrix(e2, t2, i2, a2, n2, s2) {
        const r2 = this.textLineMatrix;
        r2[0] = e2, r2[1] = t2, r2[2] = i2, r2[3] = a2, r2[4] = n2, r2[5] = s2;
      }
      translateTextMatrix(e2, t2) {
        const i2 = this.textMatrix;
        i2[4] = i2[0] * e2 + i2[2] * t2 + i2[4], i2[5] = i2[1] * e2 + i2[3] * t2 + i2[5];
      }
      translateTextLineMatrix(e2, t2) {
        const i2 = this.textLineMatrix;
        i2[4] = i2[0] * e2 + i2[2] * t2 + i2[4], i2[5] = i2[1] * e2 + i2[3] * t2 + i2[5];
      }
      carriageReturn() {
        this.translateTextLineMatrix(0, -this.leading), this.textMatrix = this.textLineMatrix.slice();
      }
      clone() {
        const e2 = Object.create(this);
        return e2.textMatrix = this.textMatrix.slice(), e2.textLineMatrix = this.textLineMatrix.slice(), e2.fontMatrix = this.fontMatrix.slice(), e2;
      }
    };
    __name(TextState, "TextState");
    EvalState = class {
      constructor() {
        this.ctm = new Float32Array(fi), this.font = null, this.textRenderingMode = x, this._fillColorSpace = this._strokeColorSpace = ColorSpaceUtils.gray, this.patternFillColorSpace = null, this.patternStrokeColorSpace = null, this.currentPointX = this.currentPointY = 0, this.pathMinMax = new Float32Array([1 / 0, 1 / 0, -1 / 0, -1 / 0]), this.pathBuffer = [];
      }
      get fillColorSpace() {
        return this._fillColorSpace;
      }
      set fillColorSpace(e2) {
        this._fillColorSpace = this.patternFillColorSpace = e2;
      }
      get strokeColorSpace() {
        return this._strokeColorSpace;
      }
      set strokeColorSpace(e2) {
        this._strokeColorSpace = this.patternStrokeColorSpace = e2;
      }
      clone({ newPath: e2 = false } = {}) {
        const t2 = Object.create(this);
        return e2 && (t2.pathBuffer = [], t2.pathMinMax = new Float32Array([1 / 0, 1 / 0, -1 / 0, -1 / 0])), t2;
      }
    };
    __name(EvalState, "EvalState");
    _EvaluatorPreprocessor = class {
      static get opMap() {
        return shadow$1(this, "opMap", Object.assign(/* @__PURE__ */ Object.create(null), { w: { id: oe, numArgs: 1, variableArgs: false }, J: { id: le, numArgs: 1, variableArgs: false }, j: { id: ce, numArgs: 1, variableArgs: false }, M: { id: he, numArgs: 1, variableArgs: false }, d: { id: de, numArgs: 2, variableArgs: false }, ri: { id: ue, numArgs: 1, variableArgs: false }, i: { id: ge, numArgs: 1, variableArgs: false }, gs: { id: pe, numArgs: 1, variableArgs: false }, q: { id: fe, numArgs: 0, variableArgs: false }, Q: { id: me, numArgs: 0, variableArgs: false }, cm: { id: be, numArgs: 6, variableArgs: false }, m: { id: ye, numArgs: 2, variableArgs: false }, l: { id: we, numArgs: 2, variableArgs: false }, c: { id: Ae, numArgs: 6, variableArgs: false }, v: { id: xe, numArgs: 4, variableArgs: false }, y: { id: Se, numArgs: 4, variableArgs: false }, h: { id: ve, numArgs: 0, variableArgs: false }, re: { id: Ce, numArgs: 4, variableArgs: false }, S: { id: ke, numArgs: 0, variableArgs: false }, s: { id: Te, numArgs: 0, variableArgs: false }, f: { id: Ie, numArgs: 0, variableArgs: false }, F: { id: Ie, numArgs: 0, variableArgs: false }, "f*": { id: Fe, numArgs: 0, variableArgs: false }, B: { id: Me, numArgs: 0, variableArgs: false }, "B*": { id: De, numArgs: 0, variableArgs: false }, b: { id: Ee, numArgs: 0, variableArgs: false }, "b*": { id: Oe, numArgs: 0, variableArgs: false }, n: { id: _e, numArgs: 0, variableArgs: false }, W: { id: Pe, numArgs: 0, variableArgs: false }, "W*": { id: Re, numArgs: 0, variableArgs: false }, BT: { id: Be, numArgs: 0, variableArgs: false }, ET: { id: Ne, numArgs: 0, variableArgs: false }, Tc: { id: Le, numArgs: 1, variableArgs: false }, Tw: { id: Ue, numArgs: 1, variableArgs: false }, Tz: { id: je, numArgs: 1, variableArgs: false }, TL: { id: $e, numArgs: 1, variableArgs: false }, Tf: { id: He, numArgs: 2, variableArgs: false }, Tr: { id: qe, numArgs: 1, variableArgs: false }, Ts: { id: Xe, numArgs: 1, variableArgs: false }, Td: { id: ze, numArgs: 2, variableArgs: false }, TD: { id: We, numArgs: 2, variableArgs: false }, Tm: { id: Ge, numArgs: 6, variableArgs: false }, "T*": { id: Ve, numArgs: 0, variableArgs: false }, Tj: { id: Ke, numArgs: 1, variableArgs: false }, TJ: { id: Ye, numArgs: 1, variableArgs: false }, "'": { id: Je, numArgs: 1, variableArgs: false }, '"': { id: Ze, numArgs: 3, variableArgs: false }, d0: { id: Qe, numArgs: 2, variableArgs: false }, d1: { id: et, numArgs: 6, variableArgs: false }, CS: { id: tt, numArgs: 1, variableArgs: false }, cs: { id: it, numArgs: 1, variableArgs: false }, SC: { id: at, numArgs: 4, variableArgs: true }, SCN: { id: nt, numArgs: 33, variableArgs: true }, sc: { id: st, numArgs: 4, variableArgs: true }, scn: { id: rt, numArgs: 33, variableArgs: true }, G: { id: ot, numArgs: 1, variableArgs: false }, g: { id: lt, numArgs: 1, variableArgs: false }, RG: { id: ct, numArgs: 3, variableArgs: false }, rg: { id: ht, numArgs: 3, variableArgs: false }, K: { id: dt, numArgs: 4, variableArgs: false }, k: { id: ut, numArgs: 4, variableArgs: false }, sh: { id: gt, numArgs: 1, variableArgs: false }, BI: { id: pt, numArgs: 0, variableArgs: false }, ID: { id: ft, numArgs: 0, variableArgs: false }, EI: { id: mt, numArgs: 1, variableArgs: false }, Do: { id: bt, numArgs: 1, variableArgs: false }, MP: { id: yt, numArgs: 1, variableArgs: false }, DP: { id: wt, numArgs: 2, variableArgs: false }, BMC: { id: At, numArgs: 1, variableArgs: false }, BDC: { id: xt, numArgs: 2, variableArgs: false }, EMC: { id: St, numArgs: 0, variableArgs: false }, BX: { id: vt, numArgs: 0, variableArgs: false }, EX: { id: Ct, numArgs: 0, variableArgs: false }, BM: null, BD: null, true: null, fa: null, fal: null, fals: null, false: null, nu: null, nul: null, null: null }));
      }
      constructor(e2, t2, i2 = new StateManager()) {
        this.parser = new Parser({ lexer: new Lexer(e2, _EvaluatorPreprocessor.opMap), xref: t2 }), this.stateManager = i2, this.nonProcessedArgs = [], this._isPathOp = false, this._numInvalidPathOPS = 0;
      }
      get savedStatesDepth() {
        return this.stateManager.stateStack.length;
      }
      read(e2) {
        let t2 = e2.args;
        for (; ; ) {
          const i2 = this.parser.getObj();
          if (i2 instanceof Cmd) {
            const a2 = i2.cmd, n2 = _EvaluatorPreprocessor.opMap[a2];
            if (!n2) {
              warn$1(`Unknown command "${a2}".`);
              continue;
            }
            const s2 = n2.id, r2 = n2.numArgs;
            let o2 = null !== t2 ? t2.length : 0;
            if (this._isPathOp || (this._numInvalidPathOPS = 0), this._isPathOp = s2 >= ye && s2 <= _e, n2.variableArgs)
              o2 > r2 && info$1(`Command ${a2}: expected [0, ${r2}] args, but received ${o2} args.`);
            else {
              if (o2 !== r2) {
                const e3 = this.nonProcessedArgs;
                for (; o2 > r2; )
                  e3.push(t2.shift()), o2--;
                for (; o2 < r2 && 0 !== e3.length; )
                  null === t2 && (t2 = []), t2.unshift(e3.pop()), o2++;
              }
              if (o2 < r2) {
                const e3 = `command ${a2}: expected ${r2} args, but received ${o2} args.`;
                if (this._isPathOp && ++this._numInvalidPathOPS > _EvaluatorPreprocessor.MAX_INVALID_PATH_OPS)
                  throw new ti(`Invalid ${e3}`);
                warn$1(`Skipping ${e3}`), null !== t2 && (t2.length = 0);
                continue;
              }
            }
            return this.preprocessCommand(s2, t2), e2.fn = s2, e2.args = t2, true;
          }
          if (i2 === ci)
            return false;
          if (null !== i2 && (null === t2 && (t2 = []), t2.push(i2), t2.length > 33))
            throw new ti("Too many arguments");
        }
      }
      preprocessCommand(e2, t2) {
        switch (0 | e2) {
          case fe:
            this.stateManager.save();
            break;
          case me:
            this.stateManager.restore();
            break;
          case be:
            this.stateManager.transform(t2);
        }
      }
    };
    EvaluatorPreprocessor = _EvaluatorPreprocessor;
    __name(EvaluatorPreprocessor, "EvaluatorPreprocessor");
    __publicField(EvaluatorPreprocessor, "MAX_INVALID_PATH_OPS", 10);
    DefaultAppearanceEvaluator = class extends EvaluatorPreprocessor {
      constructor(e2) {
        super(new StringStream(e2));
      }
      parse() {
        const e2 = { fn: 0, args: [] }, t2 = { fontSize: 0, fontName: "", fontColor: new Uint8ClampedArray(3) };
        try {
          for (; e2.args.length = 0, this.read(e2); ) {
            if (0 !== this.savedStatesDepth)
              continue;
            const { fn: i2, args: a2 } = e2;
            switch (0 | i2) {
              case He:
                const [e3, i3] = a2;
                e3 instanceof Name && (t2.fontName = e3.name), "number" == typeof i3 && i3 > 0 && (t2.fontSize = i3);
                break;
              case ht:
                ColorSpaceUtils.rgb.getRgbItem(a2, 0, t2.fontColor, 0);
                break;
              case lt:
                ColorSpaceUtils.gray.getRgbItem(a2, 0, t2.fontColor, 0);
                break;
              case ut:
                ColorSpaceUtils.cmyk.getRgbItem(a2, 0, t2.fontColor, 0);
            }
          }
        } catch (e3) {
          warn$1(`parseDefaultAppearance - ignoring errors: "${e3}".`);
        }
        return t2;
      }
    };
    __name(DefaultAppearanceEvaluator, "DefaultAppearanceEvaluator");
    __name(parseDefaultAppearance, "parseDefaultAppearance");
    AppearanceStreamEvaluator = class extends EvaluatorPreprocessor {
      constructor(e2, t2, i2, a2) {
        super(e2), this.stream = e2, this.evaluatorOptions = t2, this.xref = i2, this.globalColorSpaceCache = a2, this.resources = e2.dict?.get("Resources");
      }
      parse() {
        const e2 = { fn: 0, args: [] };
        let t2 = { scaleFactor: 1, fontSize: 0, fontName: "", fontColor: new Uint8ClampedArray(3), fillColorSpace: ColorSpaceUtils.gray }, i2 = false;
        const a2 = [];
        try {
          for (; e2.args.length = 0, !i2 && this.read(e2); ) {
            const { fn: n2, args: s2 } = e2;
            switch (0 | n2) {
              case fe:
                a2.push({ scaleFactor: t2.scaleFactor, fontSize: t2.fontSize, fontName: t2.fontName, fontColor: t2.fontColor.slice(), fillColorSpace: t2.fillColorSpace });
                break;
              case me:
                t2 = a2.pop() || t2;
                break;
              case Ge:
                t2.scaleFactor *= Math.hypot(s2[0], s2[1]);
                break;
              case He:
                const [e3, n3] = s2;
                e3 instanceof Name && (t2.fontName = e3.name), "number" == typeof n3 && n3 > 0 && (t2.fontSize = n3 * t2.scaleFactor);
                break;
              case it:
                t2.fillColorSpace = ColorSpaceUtils.parse({ cs: s2[0], xref: this.xref, resources: this.resources, pdfFunctionFactory: this._pdfFunctionFactory, globalColorSpaceCache: this.globalColorSpaceCache, localColorSpaceCache: this._localColorSpaceCache });
                break;
              case st:
                t2.fillColorSpace.getRgbItem(s2, 0, t2.fontColor, 0);
                break;
              case ht:
                ColorSpaceUtils.rgb.getRgbItem(s2, 0, t2.fontColor, 0);
                break;
              case lt:
                ColorSpaceUtils.gray.getRgbItem(s2, 0, t2.fontColor, 0);
                break;
              case ut:
                ColorSpaceUtils.cmyk.getRgbItem(s2, 0, t2.fontColor, 0);
                break;
              case Ke:
              case Ye:
              case Je:
              case Ze:
                i2 = true;
            }
          }
        } catch (e3) {
          warn$1(`parseAppearanceStream - ignoring errors: "${e3}".`);
        }
        return this.stream.reset(), delete t2.scaleFactor, delete t2.fillColorSpace, t2;
      }
      get _localColorSpaceCache() {
        return shadow$1(this, "_localColorSpaceCache", new LocalColorSpaceCache());
      }
      get _pdfFunctionFactory() {
        return shadow$1(this, "_pdfFunctionFactory", new PDFFunctionFactory({ xref: this.xref, isEvalSupported: this.evaluatorOptions.isEvalSupported }));
      }
    };
    __name(AppearanceStreamEvaluator, "AppearanceStreamEvaluator");
    __name(getPdfColor, "getPdfColor");
    FakeUnicodeFont = class {
      constructor(e2, t2) {
        this.xref = e2, this.widths = null, this.firstChar = 1 / 0, this.lastChar = -1 / 0, this.fontFamily = t2;
        const i2 = new OffscreenCanvas(1, 1);
        this.ctxMeasure = i2.getContext("2d", { willReadFrequently: true }), FakeUnicodeFont._fontNameId || (FakeUnicodeFont._fontNameId = 1), this.fontName = Name.get(`InvalidPDFjsFont_${t2}_${FakeUnicodeFont._fontNameId++}`);
      }
      get fontDescriptorRef() {
        if (!FakeUnicodeFont._fontDescriptorRef) {
          const e2 = new Dict(this.xref);
          e2.setIfName("Type", "FontDescriptor"), e2.set("FontName", this.fontName), e2.set("FontFamily", "MyriadPro Regular"), e2.set("FontBBox", [0, 0, 0, 0]), e2.setIfName("FontStretch", "Normal"), e2.set("FontWeight", 400), e2.set("ItalicAngle", 0), FakeUnicodeFont._fontDescriptorRef = this.xref.getNewPersistentRef(e2);
        }
        return FakeUnicodeFont._fontDescriptorRef;
      }
      get descendantFontRef() {
        const e2 = new Dict(this.xref);
        e2.set("BaseFont", this.fontName), e2.setIfName("Type", "Font"), e2.setIfName("Subtype", "CIDFontType0"), e2.setIfName("CIDToGIDMap", "Identity"), e2.set("FirstChar", this.firstChar), e2.set("LastChar", this.lastChar), e2.set("FontDescriptor", this.fontDescriptorRef), e2.set("DW", 1e3);
        const t2 = [], i2 = [...this.widths.entries()].sort();
        let a2 = null, n2 = null;
        for (const [e3, s3] of i2)
          a2 ? e3 === a2 + n2.length ? n2.push(s3) : (t2.push(a2, n2), a2 = e3, n2 = [s3]) : (a2 = e3, n2 = [s3]);
        a2 && t2.push(a2, n2), e2.set("W", t2);
        const s2 = new Dict(this.xref);
        return s2.set("Ordering", "Identity"), s2.set("Registry", "Adobe"), s2.set("Supplement", 0), e2.set("CIDSystemInfo", s2), this.xref.getNewPersistentRef(e2);
      }
      get baseFontRef() {
        const e2 = new Dict(this.xref);
        return e2.set("BaseFont", this.fontName), e2.setIfName("Type", "Font"), e2.setIfName("Subtype", "Type0"), e2.setIfName("Encoding", "Identity-H"), e2.set("DescendantFonts", [this.descendantFontRef]), e2.setIfName("ToUnicode", "Identity-H"), this.xref.getNewPersistentRef(e2);
      }
      get resources() {
        const e2 = new Dict(this.xref), t2 = new Dict(this.xref);
        return t2.set(this.fontName.name, this.baseFontRef), e2.set("Font", t2), e2;
      }
      _createContext() {
        return this.widths = /* @__PURE__ */ new Map(), this.ctxMeasure.font = `1000px ${this.fontFamily}`, this.ctxMeasure;
      }
      createFontResources(e2) {
        const t2 = this._createContext();
        for (const i2 of e2.split(/\r\n?|\n/))
          for (const e3 of i2.split("")) {
            const i3 = e3.charCodeAt(0);
            if (this.widths.has(i3))
              continue;
            const a2 = t2.measureText(e3), n2 = Math.ceil(a2.width);
            this.widths.set(i3, n2), this.firstChar = Math.min(i3, this.firstChar), this.lastChar = Math.max(i3, this.lastChar);
          }
        return this.resources;
      }
      static getFirstPositionInfo(e2, t2, n2) {
        const [s2, r2, o2, l3] = e2;
        let c2 = o2 - s2, h2 = l3 - r2;
        t2 % 180 != 0 && ([c2, h2] = [h2, c2]);
        const d2 = i * n2;
        return { coords: [0, h2 + a * n2 - d2], bbox: [0, 0, c2, h2], matrix: 0 !== t2 ? getRotationMatrix(t2, h2, d2) : void 0 };
      }
      createAppearance(e2, t2, n2, s2, r2, o2) {
        const l3 = this._createContext(), c2 = [];
        let h2 = -1 / 0;
        for (const t3 of e2.split(/\r\n?|\n/)) {
          c2.push(t3);
          const e3 = l3.measureText(t3).width;
          h2 = Math.max(h2, e3);
          for (const e4 of codePointIter(t3)) {
            const t4 = String.fromCodePoint(e4);
            let i2 = this.widths.get(e4);
            if (void 0 === i2) {
              const a2 = l3.measureText(t4);
              i2 = Math.ceil(a2.width), this.widths.set(e4, i2), this.firstChar = Math.min(e4, this.firstChar), this.lastChar = Math.max(e4, this.lastChar);
            }
          }
        }
        h2 *= s2 / 1e3;
        const [d2, u2, g2, p2] = t2;
        let f2 = g2 - d2, m2 = p2 - u2;
        n2 % 180 != 0 && ([f2, m2] = [m2, f2]);
        let b2 = 1;
        h2 > f2 && (b2 = f2 / h2);
        let y2 = 1;
        const w2 = i * s2, x2 = a * s2, S2 = w2 * c2.length;
        S2 > m2 && (y2 = m2 / S2);
        const v2 = s2 * Math.min(b2, y2), C2 = ["q", `0 0 ${numberToString(f2)} ${numberToString(m2)} re W n`, "BT", `1 0 0 1 0 ${numberToString(m2 + x2)} Tm 0 Tc ${getPdfColor(r2, true)}`, `/${this.fontName.name} ${numberToString(v2)} Tf`], { resources: k2 } = this;
        if (1 !== (o2 = "number" == typeof o2 && o2 >= 0 && o2 <= 1 ? o2 : 1)) {
          C2.push("/R0 gs");
          const e3 = new Dict(this.xref), t3 = new Dict(this.xref);
          t3.set("ca", o2), t3.set("CA", o2), t3.setIfName("Type", "ExtGState"), e3.set("R0", t3), k2.set("ExtGState", e3);
        }
        const T2 = numberToString(w2);
        for (const e3 of c2)
          C2.push(`0 -${T2} Td <${stringToUTF16HexString(e3)}> Tj`);
        C2.push("ET", "Q");
        const F2 = C2.join("\n"), M2 = new Dict(this.xref);
        if (M2.setIfName("Subtype", "Form"), M2.setIfName("Type", "XObject"), M2.set("BBox", [0, 0, f2, m2]), M2.set("Length", F2.length), M2.set("Resources", k2), n2) {
          const e3 = getRotationMatrix(n2, f2, m2);
          M2.set("Matrix", e3);
        }
        const D2 = new StringStream(F2);
        return D2.dict = M2, D2;
      }
    };
    __name(FakeUnicodeFont, "FakeUnicodeFont");
    vs = ["m/d", "m/d/yy", "mm/dd/yy", "mm/yy", "d-mmm", "d-mmm-yy", "dd-mmm-yy", "yy-mm-dd", "mmm-yy", "mmmm-yy", "mmm d, yyyy", "mmmm d, yyyy", "m/d/yy h:MM tt", "m/d/yy HH:MM"];
    Cs = ["HH:MM", "h:MM tt", "HH:MM:ss", "h:MM:ss tt"];
    NameOrNumberTree = class {
      constructor(e2, t2, i2) {
        this.root = e2, this.xref = t2, this._type = i2;
      }
      getAll() {
        const e2 = /* @__PURE__ */ new Map();
        if (!this.root)
          return e2;
        const t2 = this.xref, i2 = new RefSet();
        i2.put(this.root);
        const a2 = [this.root];
        for (; a2.length > 0; ) {
          const n2 = t2.fetchIfRef(a2.shift());
          if (!(n2 instanceof Dict))
            continue;
          if (n2.has("Kids")) {
            const e3 = n2.get("Kids");
            if (!Array.isArray(e3))
              continue;
            for (const t3 of e3) {
              if (i2.has(t3))
                throw new ti(`Duplicate entry in "${this._type}" tree.`);
              a2.push(t3), i2.put(t3);
            }
            continue;
          }
          const s2 = n2.get(this._type);
          if (Array.isArray(s2))
            for (let i3 = 0, a3 = s2.length; i3 < a3; i3 += 2)
              e2.set(t2.fetchIfRef(s2[i3]), t2.fetchIfRef(s2[i3 + 1]));
        }
        return e2;
      }
      getRaw(e2) {
        if (!this.root)
          return null;
        const t2 = this.xref;
        let i2 = t2.fetchIfRef(this.root), a2 = 0;
        for (; i2.has("Kids"); ) {
          if (++a2 > 10)
            return warn$1(`Search depth limit reached for "${this._type}" tree.`), null;
          const n3 = i2.get("Kids");
          if (!Array.isArray(n3))
            return null;
          let s2 = 0, r2 = n3.length - 1;
          for (; s2 <= r2; ) {
            const a3 = s2 + r2 >> 1, o2 = t2.fetchIfRef(n3[a3]), l3 = o2.get("Limits");
            if (e2 < t2.fetchIfRef(l3[0]))
              r2 = a3 - 1;
            else {
              if (!(e2 > t2.fetchIfRef(l3[1]))) {
                i2 = o2;
                break;
              }
              s2 = a3 + 1;
            }
          }
          if (s2 > r2)
            return null;
        }
        const n2 = i2.get(this._type);
        if (Array.isArray(n2)) {
          let i3 = 0, a3 = n2.length - 2;
          for (; i3 <= a3; ) {
            const s2 = i3 + a3 >> 1, r2 = s2 + (1 & s2), o2 = t2.fetchIfRef(n2[r2]);
            if (e2 < o2)
              a3 = r2 - 2;
            else {
              if (!(e2 > o2))
                return n2[r2 + 1];
              i3 = r2 + 2;
            }
          }
        }
        return null;
      }
      get(e2) {
        return this.xref.fetchIfRef(this.getRaw(e2));
      }
    };
    __name(NameOrNumberTree, "NameOrNumberTree");
    NameTree = class extends NameOrNumberTree {
      constructor(e2, t2) {
        super(e2, t2, "Names");
      }
    };
    __name(NameTree, "NameTree");
    NumberTree = class extends NameOrNumberTree {
      constructor(e2, t2) {
        super(e2, t2, "Nums");
      }
    };
    __name(NumberTree, "NumberTree");
    __name(clearGlobalCaches, "clearGlobalCaches");
    __name(pickPlatformItem, "pickPlatformItem");
    FileSpec = class {
      #J = false;
      constructor(e2, t2, i2 = false) {
        e2 instanceof Dict && (this.xref = t2, this.root = e2, e2.has("FS") && (this.fs = e2.get("FS")), e2.has("RF") && warn$1("Related file specifications are not supported"), i2 || (e2.has("EF") ? this.#J = true : warn$1("Non-embedded file specifications are not supported")));
      }
      get filename() {
        let e2 = "";
        const t2 = pickPlatformItem(this.root);
        return t2 && "string" == typeof t2 && (e2 = stringToPDFString(t2, true).replaceAll("\\\\", "\\").replaceAll("\\/", "/").replaceAll("\\", "/")), shadow$1(this, "filename", e2 || "unnamed");
      }
      get content() {
        if (!this.#J)
          return null;
        this._contentRef ||= pickPlatformItem(this.root?.get("EF"));
        let e2 = null;
        if (this._contentRef) {
          const t2 = this.xref.fetchIfRef(this._contentRef);
          t2 instanceof BaseStream ? e2 = t2.getBytes() : warn$1("Embedded file specification points to non-existing/invalid content");
        } else
          warn$1("Embedded file specification does not have any content");
        return e2;
      }
      get description() {
        let e2 = "";
        const t2 = this.root?.get("Desc");
        return t2 && "string" == typeof t2 && (e2 = stringToPDFString(t2)), shadow$1(this, "description", e2);
      }
      get serializable() {
        return { rawFilename: this.filename, filename: (e2 = this.filename, e2.substring(e2.lastIndexOf("/") + 1)), content: this.content, description: this.description };
        var e2;
      }
    };
    __name(FileSpec, "FileSpec");
    ks = 0;
    Ts = -2;
    Is = -3;
    Fs = -4;
    Ms = -5;
    Ds = -6;
    Es = -9;
    __name(isWhitespace, "isWhitespace");
    XMLParserBase = class {
      _resolveEntities(e2) {
        return e2.replaceAll(/&([^;]+);/g, (e3, t2) => {
          if ("#x" === t2.substring(0, 2))
            return String.fromCodePoint(parseInt(t2.substring(2), 16));
          if ("#" === t2.substring(0, 1))
            return String.fromCodePoint(parseInt(t2.substring(1), 10));
          switch (t2) {
            case "lt":
              return "<";
            case "gt":
              return ">";
            case "amp":
              return "&";
            case "quot":
              return '"';
            case "apos":
              return "'";
          }
          return this.onResolveEntity(t2);
        });
      }
      _parseContent(e2, t2) {
        const i2 = [];
        let a2 = t2;
        function skipWs() {
          for (; a2 < e2.length && isWhitespace(e2, a2); )
            ++a2;
        }
        __name(skipWs, "skipWs");
        for (; a2 < e2.length && !isWhitespace(e2, a2) && ">" !== e2[a2] && "/" !== e2[a2]; )
          ++a2;
        const n2 = e2.substring(t2, a2);
        for (skipWs(); a2 < e2.length && ">" !== e2[a2] && "/" !== e2[a2] && "?" !== e2[a2]; ) {
          skipWs();
          let t3 = "", n3 = "";
          for (; a2 < e2.length && !isWhitespace(e2, a2) && "=" !== e2[a2]; )
            t3 += e2[a2], ++a2;
          if (skipWs(), "=" !== e2[a2])
            return null;
          ++a2, skipWs();
          const s2 = e2[a2];
          if ('"' !== s2 && "'" !== s2)
            return null;
          const r2 = e2.indexOf(s2, ++a2);
          if (r2 < 0)
            return null;
          n3 = e2.substring(a2, r2), i2.push({ name: t3, value: this._resolveEntities(n3) }), a2 = r2 + 1, skipWs();
        }
        return { name: n2, attributes: i2, parsed: a2 - t2 };
      }
      _parseProcessingInstruction(e2, t2) {
        let i2 = t2;
        for (; i2 < e2.length && !isWhitespace(e2, i2) && ">" !== e2[i2] && "?" !== e2[i2] && "/" !== e2[i2]; )
          ++i2;
        const a2 = e2.substring(t2, i2);
        !function() {
          for (; i2 < e2.length && isWhitespace(e2, i2); )
            ++i2;
        }();
        const n2 = i2;
        for (; i2 < e2.length && ("?" !== e2[i2] || ">" !== e2[i2 + 1]); )
          ++i2;
        return { name: a2, value: e2.substring(n2, i2), parsed: i2 - t2 };
      }
      parseXml(e2) {
        let t2 = 0;
        for (; t2 < e2.length; ) {
          let i2 = t2;
          if ("<" === e2[t2]) {
            ++i2;
            let t3;
            switch (e2[i2]) {
              case "/":
                if (++i2, t3 = e2.indexOf(">", i2), t3 < 0)
                  return void this.onError(Es);
                this.onEndElement(e2.substring(i2, t3)), i2 = t3 + 1;
                break;
              case "?":
                ++i2;
                const a2 = this._parseProcessingInstruction(e2, i2);
                if ("?>" !== e2.substring(i2 + a2.parsed, i2 + a2.parsed + 2))
                  return void this.onError(Is);
                this.onPi(a2.name, a2.value), i2 += a2.parsed + 2;
                break;
              case "!":
                if ("--" === e2.substring(i2 + 1, i2 + 3)) {
                  if (t3 = e2.indexOf("-->", i2 + 3), t3 < 0)
                    return void this.onError(Ms);
                  this.onComment(e2.substring(i2 + 3, t3)), i2 = t3 + 3;
                } else if ("[CDATA[" === e2.substring(i2 + 1, i2 + 8)) {
                  if (t3 = e2.indexOf("]]>", i2 + 8), t3 < 0)
                    return void this.onError(Ts);
                  this.onCdata(e2.substring(i2 + 8, t3)), i2 = t3 + 3;
                } else {
                  if ("DOCTYPE" !== e2.substring(i2 + 1, i2 + 8))
                    return void this.onError(Ds);
                  {
                    const a3 = e2.indexOf("[", i2 + 8);
                    let n3 = false;
                    if (t3 = e2.indexOf(">", i2 + 8), t3 < 0)
                      return void this.onError(Fs);
                    if (a3 > 0 && t3 > a3) {
                      if (t3 = e2.indexOf("]>", i2 + 8), t3 < 0)
                        return void this.onError(Fs);
                      n3 = true;
                    }
                    const s3 = e2.substring(i2 + 8, t3 + (n3 ? 1 : 0));
                    this.onDoctype(s3), i2 = t3 + (n3 ? 2 : 1);
                  }
                }
                break;
              default:
                const n2 = this._parseContent(e2, i2);
                if (null === n2)
                  return void this.onError(Ds);
                let s2 = false;
                if ("/>" === e2.substring(i2 + n2.parsed, i2 + n2.parsed + 2))
                  s2 = true;
                else if (">" !== e2.substring(i2 + n2.parsed, i2 + n2.parsed + 1))
                  return void this.onError(Es);
                this.onBeginElement(n2.name, n2.attributes, s2), i2 += n2.parsed + (s2 ? 2 : 1);
            }
          } else {
            for (; i2 < e2.length && "<" !== e2[i2]; )
              i2++;
            const a2 = e2.substring(t2, i2);
            this.onText(this._resolveEntities(a2));
          }
          t2 = i2;
        }
      }
      onResolveEntity(e2) {
        return `&${e2};`;
      }
      onPi(e2, t2) {
      }
      onComment(e2) {
      }
      onCdata(e2) {
      }
      onDoctype(e2) {
      }
      onText(e2) {
      }
      onBeginElement(e2, t2, i2) {
      }
      onEndElement(e2) {
      }
      onError(e2) {
      }
    };
    __name(XMLParserBase, "XMLParserBase");
    SimpleDOMNode = class {
      constructor(e2, t2) {
        this.nodeName = e2, this.nodeValue = t2, Object.defineProperty(this, "parentNode", { value: null, writable: true });
      }
      get firstChild() {
        return this.childNodes?.[0];
      }
      get nextSibling() {
        const e2 = this.parentNode.childNodes;
        if (!e2)
          return;
        const t2 = e2.indexOf(this);
        return -1 !== t2 ? e2[t2 + 1] : void 0;
      }
      get textContent() {
        return this.childNodes ? this.childNodes.map((e2) => e2.textContent).join("") : this.nodeValue || "";
      }
      get children() {
        return this.childNodes || [];
      }
      hasChildNodes() {
        return this.childNodes?.length > 0;
      }
      searchNode(e2, t2) {
        if (t2 >= e2.length)
          return this;
        const i2 = e2[t2];
        if (i2.name.startsWith("#") && t2 < e2.length - 1)
          return this.searchNode(e2, t2 + 1);
        const a2 = [];
        let n2 = this;
        for (; ; ) {
          if (i2.name === n2.nodeName) {
            if (0 !== i2.pos) {
              if (0 === a2.length)
                return null;
              {
                const [s2] = a2.pop();
                let r2 = 0;
                for (const a3 of s2.childNodes)
                  if (i2.name === a3.nodeName) {
                    if (r2 === i2.pos)
                      return a3.searchNode(e2, t2 + 1);
                    r2++;
                  }
                return n2.searchNode(e2, t2 + 1);
              }
            }
            {
              const i3 = n2.searchNode(e2, t2 + 1);
              if (null !== i3)
                return i3;
            }
          }
          if (n2.childNodes?.length > 0)
            a2.push([n2, 0]), n2 = n2.childNodes[0];
          else {
            if (0 === a2.length)
              return null;
            for (; 0 !== a2.length; ) {
              const [e3, t3] = a2.pop(), i3 = t3 + 1;
              if (i3 < e3.childNodes.length) {
                a2.push([e3, i3]), n2 = e3.childNodes[i3];
                break;
              }
            }
            if (0 === a2.length)
              return null;
          }
        }
      }
      dump(e2) {
        if ("#text" !== this.nodeName) {
          if (e2.push(`<${this.nodeName}`), this.attributes)
            for (const t2 of this.attributes)
              e2.push(` ${t2.name}="${encodeToXmlString(t2.value)}"`);
          if (this.hasChildNodes()) {
            e2.push(">");
            for (const t2 of this.childNodes)
              t2.dump(e2);
            e2.push(`</${this.nodeName}>`);
          } else
            this.nodeValue ? e2.push(`>${encodeToXmlString(this.nodeValue)}</${this.nodeName}>`) : e2.push("/>");
        } else
          e2.push(encodeToXmlString(this.nodeValue));
      }
    };
    __name(SimpleDOMNode, "SimpleDOMNode");
    SimpleXMLParser = class extends XMLParserBase {
      constructor({ hasAttributes: e2 = false, lowerCaseName: t2 = false }) {
        super(), this._currentFragment = null, this._stack = null, this._errorCode = ks, this._hasAttributes = e2, this._lowerCaseName = t2;
      }
      parseFromString(e2) {
        if (this._currentFragment = [], this._stack = [], this._errorCode = ks, this.parseXml(e2), this._errorCode !== ks)
          return;
        const [t2] = this._currentFragment;
        return t2 ? { documentElement: t2 } : void 0;
      }
      onText(e2) {
        if (function(e3) {
          for (let t3 = 0, i2 = e3.length; t3 < i2; t3++)
            if (!isWhitespace(e3, t3))
              return false;
          return true;
        }(e2))
          return;
        const t2 = new SimpleDOMNode("#text", e2);
        this._currentFragment.push(t2);
      }
      onCdata(e2) {
        const t2 = new SimpleDOMNode("#text", e2);
        this._currentFragment.push(t2);
      }
      onBeginElement(e2, t2, i2) {
        this._lowerCaseName && (e2 = e2.toLowerCase());
        const a2 = new SimpleDOMNode(e2);
        a2.childNodes = [], this._hasAttributes && (a2.attributes = t2), this._currentFragment.push(a2), i2 || (this._stack.push(this._currentFragment), this._currentFragment = a2.childNodes);
      }
      onEndElement(e2) {
        this._currentFragment = this._stack.pop() || [];
        const t2 = this._currentFragment.at(-1);
        if (!t2)
          return null;
        for (const e3 of t2.childNodes)
          e3.parentNode = t2;
        return t2;
      }
      onError(e2) {
        this._errorCode = e2;
      }
    };
    __name(SimpleXMLParser, "SimpleXMLParser");
    MetadataParser = class {
      constructor(e2) {
        e2 = this._repair(e2);
        const t2 = new SimpleXMLParser({ lowerCaseName: true }).parseFromString(e2);
        this._metadataMap = /* @__PURE__ */ new Map(), this._data = e2, t2 && this._parse(t2);
      }
      _repair(e2) {
        return e2.replace(/^[^<]+/, "").replaceAll(/>\\376\\377([^<]+)/g, function(e3, t2) {
          const i2 = t2.replaceAll(/\\([0-3])([0-7])([0-7])/g, function(e4, t3, i3, a3) {
            return String.fromCharCode(64 * t3 + 8 * i3 + 1 * a3);
          }).replaceAll(/&(amp|apos|gt|lt|quot);/g, function(e4, t3) {
            switch (t3) {
              case "amp":
                return "&";
              case "apos":
                return "'";
              case "gt":
                return ">";
              case "lt":
                return "<";
              case "quot":
                return '"';
            }
            throw new Error(`_repair: ${t3} isn't defined.`);
          }), a2 = [">"];
          for (let e4 = 0, t3 = i2.length; e4 < t3; e4 += 2) {
            const t4 = 256 * i2.charCodeAt(e4) + i2.charCodeAt(e4 + 1);
            t4 >= 32 && t4 < 127 && 60 !== t4 && 62 !== t4 && 38 !== t4 ? a2.push(String.fromCharCode(t4)) : a2.push("&#x" + (65536 + t4).toString(16).substring(1) + ";");
          }
          return a2.join("");
        });
      }
      _getSequence(e2) {
        const t2 = e2.nodeName;
        return "rdf:bag" !== t2 && "rdf:seq" !== t2 && "rdf:alt" !== t2 ? null : e2.childNodes.filter((e3) => "rdf:li" === e3.nodeName);
      }
      _parseArray(e2) {
        if (!e2.hasChildNodes())
          return;
        const [t2] = e2.childNodes, i2 = this._getSequence(t2) || [];
        this._metadataMap.set(e2.nodeName, i2.map((e3) => e3.textContent.trim()));
      }
      _parse(e2) {
        let t2 = e2.documentElement;
        if ("rdf:rdf" !== t2.nodeName)
          for (t2 = t2.firstChild; t2 && "rdf:rdf" !== t2.nodeName; )
            t2 = t2.nextSibling;
        if (t2 && "rdf:rdf" === t2.nodeName && t2.hasChildNodes()) {
          for (const e3 of t2.childNodes)
            if ("rdf:description" === e3.nodeName)
              for (const t3 of e3.childNodes) {
                const e4 = t3.nodeName;
                switch (e4) {
                  case "#text":
                    continue;
                  case "dc:creator":
                  case "dc:subject":
                    this._parseArray(t3);
                    continue;
                }
                this._metadataMap.set(e4, t3.textContent.trim());
              }
        }
      }
      get serializable() {
        return { parsedData: this._metadataMap, rawData: this._data };
      }
    };
    __name(MetadataParser, "MetadataParser");
    Os = 1;
    _s2 = 2;
    Rs = 3;
    Bs = 4;
    Ns = 5;
    _StructTreeRoot = class {
      constructor(e2, t2, i2) {
        __privateAdd(this, _Z);
        this.xref = e2, this.dict = t2, this.ref = i2 instanceof Ref ? i2 : null, this.roleMap = /* @__PURE__ */ new Map(), this.structParentIds = null;
      }
      init() {
        this.readRoleMap();
      }
      addAnnotationIdToPage(e2, t2) {
        __privateMethod(this, _Z, Z_fn).call(this, e2, t2, Bs);
      }
      readRoleMap() {
        const e2 = this.dict.get("RoleMap");
        if (e2 instanceof Dict)
          for (const [t2, i2] of e2)
            i2 instanceof Name && this.roleMap.set(t2, i2.name);
      }
      static async canCreateStructureTree({ catalogRef: e2, pdfManager: t2, newAnnotationsByPage: i2 }) {
        if (!(e2 instanceof Ref))
          return warn$1("Cannot save the struct tree: no catalog reference."), false;
        let a2 = 0, n2 = true;
        for (const [e3, s2] of i2) {
          const { ref: i3 } = await t2.getPage(e3);
          if (!(i3 instanceof Ref)) {
            warn$1(`Cannot save the struct tree: page ${e3} has no ref.`), n2 = true;
            break;
          }
          for (const e4 of s2)
            e4.accessibilityData?.type && (e4.parentTreeId = a2++, n2 = false);
        }
        if (n2) {
          for (const e3 of i2.values())
            for (const t3 of e3)
              delete t3.parentTreeId;
          return false;
        }
        return true;
      }
      static async createStructureTree({ newAnnotationsByPage: e2, xref: t2, catalogRef: i2, pdfManager: a2, changes: n2 }) {
        const s2 = await a2.ensureCatalog("cloneDict"), r2 = new RefSetCache();
        r2.put(i2, s2);
        const o2 = t2.getNewTemporaryRef();
        s2.set("StructTreeRoot", o2);
        const l3 = new Dict(t2);
        l3.set("Type", Name.get("StructTreeRoot"));
        const c2 = t2.getNewTemporaryRef();
        l3.set("ParentTree", c2);
        const h2 = [];
        l3.set("K", h2), r2.put(o2, l3);
        const d2 = new Dict(t2), u2 = [];
        d2.set("Nums", u2);
        const g2 = await __privateMethod(this, _Q, Q_fn).call(this, { newAnnotationsByPage: e2, structTreeRootRef: o2, structTreeRoot: null, kids: h2, nums: u2, xref: t2, pdfManager: a2, changes: n2, cache: r2 });
        l3.set("ParentTreeNextKey", g2), r2.put(c2, d2);
        for (const [e3, t3] of r2.items())
          n2.put(e3, { data: t3 });
      }
      async canUpdateStructTree({ pdfManager: e2, newAnnotationsByPage: t2 }) {
        var _a4;
        if (!this.ref)
          return warn$1("Cannot update the struct tree: no root reference."), false;
        let i2 = this.dict.get("ParentTreeNextKey");
        if (!Number.isInteger(i2) || i2 < 0)
          return warn$1("Cannot update the struct tree: invalid next key."), false;
        const a2 = this.dict.get("ParentTree");
        if (!(a2 instanceof Dict))
          return warn$1("Cannot update the struct tree: ParentTree isn't a dict."), false;
        const n2 = a2.get("Nums");
        if (!Array.isArray(n2))
          return warn$1("Cannot update the struct tree: nums isn't an array."), false;
        const s2 = new NumberTree(a2, this.xref);
        for (const i3 of t2.keys()) {
          const { pageDict: t3 } = await e2.getPage(i3);
          if (!t3.has("StructParents"))
            continue;
          const a3 = t3.get("StructParents");
          if (!Number.isInteger(a3) || !Array.isArray(s2.get(a3)))
            return warn$1(`Cannot save the struct tree: page ${i3} has a wrong id.`), false;
        }
        let r2 = true;
        for (const [a3, n3] of t2) {
          const { pageDict: t3 } = await e2.getPage(a3);
          __privateMethod(_a4 = _StructTreeRoot, _ee, ee_fn).call(_a4, { elements: n3, xref: this.xref, pageDict: t3, numberTree: s2 });
          for (const e3 of n3)
            e3.accessibilityData?.type && (e3.accessibilityData.structParent >= 0 || (e3.parentTreeId = i2++), r2 = false);
        }
        if (r2) {
          for (const e3 of t2.values())
            for (const t3 of e3)
              delete t3.parentTreeId, delete t3.structTreeParent;
          return false;
        }
        return true;
      }
      async updateStructureTree({ newAnnotationsByPage: e2, pdfManager: t2, changes: i2 }) {
        var _a4;
        const { ref: a2, xref: n2 } = this, s2 = this.dict.clone(), r2 = new RefSetCache();
        r2.put(a2, s2);
        let o2, l3 = s2.getRaw("ParentTree");
        l3 instanceof Ref ? o2 = n2.fetch(l3) : (o2 = l3, l3 = n2.getNewTemporaryRef(), s2.set("ParentTree", l3)), o2 = o2.clone(), r2.put(l3, o2);
        let c2 = o2.getRaw("Nums"), h2 = null;
        c2 instanceof Ref && (h2 = c2, c2 = n2.fetch(h2)), c2 = c2.slice(), h2 || o2.set("Nums", c2);
        const d2 = await __privateMethod(_a4 = _StructTreeRoot, _Q, Q_fn).call(_a4, { newAnnotationsByPage: e2, structTreeRootRef: a2, structTreeRoot: this, kids: null, nums: c2, xref: n2, pdfManager: t2, changes: i2, cache: r2 });
        if (-1 !== d2) {
          s2.set("ParentTreeNextKey", d2), h2 && r2.put(h2, c2);
          for (const [e3, t3] of r2.items())
            i2.put(e3, { data: t3 });
        }
      }
    };
    StructTreeRoot = _StructTreeRoot;
    __name(StructTreeRoot, "StructTreeRoot");
    _Z = new WeakSet();
    Z_fn = /* @__PURE__ */ __name(function(e2, t2, i2) {
      if (!(e2 instanceof Ref) || t2 < 0)
        return;
      this.structParentIds ||= new RefSetCache();
      let a2 = this.structParentIds.get(e2);
      a2 || (a2 = [], this.structParentIds.put(e2, a2)), a2.push([t2, i2]);
    }, "#Z");
    _Q = new WeakSet();
    Q_fn = /* @__PURE__ */ __name(async function({ newAnnotationsByPage: e2, structTreeRootRef: t2, structTreeRoot: i2, kids: a2, nums: n2, xref: s2, pdfManager: r2, changes: o2, cache: l3 }) {
      var _a4, _b2;
      const c2 = Name.get("OBJR");
      let h2, d2 = -1;
      for (const [u2, g2] of e2) {
        const e3 = await r2.getPage(u2), { ref: p2 } = e3, f2 = p2 instanceof Ref;
        for (const { accessibilityData: r3, ref: m2, parentTreeId: b2, structTreeParent: y2 } of g2) {
          if (!r3?.type)
            continue;
          const { structParent: g3 } = r3;
          if (i2 && Number.isInteger(g3) && g3 >= 0) {
            let t3 = (h2 ||= /* @__PURE__ */ new Map()).get(u2);
            if (void 0 === t3) {
              t3 = new StructTreePage(i2, e3.pageDict).collectObjects(p2), h2.set(u2, t3);
            }
            const a3 = t3?.get(g3);
            if (a3) {
              const e4 = s2.fetch(a3).clone();
              __privateMethod(_a4 = _StructTreeRoot, _te, te_fn).call(_a4, e4, r3), o2.put(a3, { data: e4 });
              continue;
            }
          }
          d2 = Math.max(d2, b2);
          const w2 = s2.getNewTemporaryRef(), x2 = new Dict(s2);
          __privateMethod(_b2 = _StructTreeRoot, _te, te_fn).call(_b2, x2, r3), await __privateMethod(this, _ie, ie_fn).call(this, { structTreeParent: y2, tagDict: x2, newTagRef: w2, structTreeRootRef: t2, fallbackKids: a2, xref: s2, cache: l3 });
          const S2 = new Dict(s2);
          x2.set("K", S2), S2.set("Type", c2), f2 && S2.set("Pg", p2), S2.set("Obj", m2), l3.put(w2, x2), n2.push(b2, w2);
        }
      }
      return d2 + 1;
    }, "#Q");
    _te = new WeakSet();
    te_fn = /* @__PURE__ */ __name(function(e2, { type: t2, title: i2, lang: a2, alt: n2, expanded: s2, actualText: r2 }) {
      e2.set("S", Name.get(t2)), i2 && e2.set("T", stringToAsciiOrUTF16BE(i2)), a2 && e2.set("Lang", stringToAsciiOrUTF16BE(a2)), n2 && e2.set("Alt", stringToAsciiOrUTF16BE(n2)), s2 && e2.set("E", stringToAsciiOrUTF16BE(s2)), r2 && e2.set("ActualText", stringToAsciiOrUTF16BE(r2));
    }, "#te");
    _ee = new WeakSet();
    ee_fn = /* @__PURE__ */ __name(function({ elements: e2, xref: t2, pageDict: i2, numberTree: a2 }) {
      const n2 = /* @__PURE__ */ new Map();
      for (const t3 of e2)
        if (t3.structTreeParentId) {
          const e3 = parseInt(t3.structTreeParentId.split("_mc")[1], 10);
          let i3 = n2.get(e3);
          i3 || (i3 = [], n2.set(e3, i3)), i3.push(t3);
        }
      const s2 = i2.get("StructParents");
      if (!Number.isInteger(s2))
        return;
      const r2 = a2.get(s2), updateElement = /* @__PURE__ */ __name((e3, i3, a3) => {
        const s3 = n2.get(e3);
        if (s3) {
          const e4 = i3.getRaw("P"), n3 = t2.fetchIfRef(e4);
          if (e4 instanceof Ref && n3 instanceof Dict) {
            const e5 = { ref: a3, dict: i3 };
            for (const t3 of s3)
              t3.structTreeParent = e5;
          }
          return true;
        }
        return false;
      }, "updateElement");
      for (const e3 of r2) {
        if (!(e3 instanceof Ref))
          continue;
        const i3 = t2.fetch(e3), a3 = i3.get("K");
        if (Number.isInteger(a3))
          updateElement(a3, i3, e3);
        else if (Array.isArray(a3))
          for (let n3 of a3) {
            if (n3 = t2.fetchIfRef(n3), Number.isInteger(n3) && updateElement(n3, i3, e3))
              break;
            if (!(n3 instanceof Dict))
              continue;
            if (!isName(n3.get("Type"), "MCR"))
              break;
            const a4 = n3.get("MCID");
            if (Number.isInteger(a4) && updateElement(a4, i3, e3))
              break;
          }
      }
    }, "#ee");
    _ie = new WeakSet();
    ie_fn = /* @__PURE__ */ __name(async function({ structTreeParent: e2, tagDict: t2, newTagRef: i2, structTreeRootRef: a2, fallbackKids: n2, xref: s2, cache: r2 }) {
      let o2, l3 = null;
      e2 ? ({ ref: l3 } = e2, o2 = e2.dict.getRaw("P") || a2) : o2 = a2, t2.set("P", o2);
      const c2 = s2.fetchIfRef(o2);
      if (!c2)
        return void n2.push(i2);
      let h2 = r2.get(o2);
      h2 || (h2 = c2.clone(), r2.put(o2, h2));
      const d2 = h2.getRaw("K");
      let u2 = d2 instanceof Ref ? r2.get(d2) : null;
      if (!u2) {
        u2 = s2.fetchIfRef(d2), u2 = Array.isArray(u2) ? u2.slice() : [d2];
        const e3 = s2.getNewTemporaryRef();
        h2.set("K", e3), r2.put(e3, u2);
      }
      const g2 = u2.indexOf(l3);
      u2.splice(g2 >= 0 ? g2 + 1 : u2.length, 0, i2);
    }, "#ie");
    __privateAdd(StructTreeRoot, _Q);
    __privateAdd(StructTreeRoot, _te);
    __privateAdd(StructTreeRoot, _ee);
    __privateAdd(StructTreeRoot, _ie);
    StructElementNode = class {
      constructor(e2, t2) {
        this.tree = e2, this.xref = e2.xref, this.dict = t2, this.kids = [], this.parseKids();
      }
      get role() {
        const e2 = this.dict.get("S"), t2 = e2 instanceof Name ? e2.name : "", { root: i2 } = this.tree;
        return i2.roleMap.get(t2) ?? t2;
      }
      parseKids() {
        let e2 = null;
        const t2 = this.dict.getRaw("Pg");
        t2 instanceof Ref && (e2 = t2.toString());
        const i2 = this.dict.get("K");
        if (Array.isArray(i2))
          for (const t3 of i2) {
            const i3 = this.parseKid(e2, this.xref.fetchIfRef(t3));
            i3 && this.kids.push(i3);
          }
        else {
          const t3 = this.parseKid(e2, i2);
          t3 && this.kids.push(t3);
        }
      }
      parseKid(e2, t2) {
        if (Number.isInteger(t2))
          return this.tree.pageDict.objId !== e2 ? null : new StructElement({ type: Os, mcid: t2, pageObjId: e2 });
        if (!(t2 instanceof Dict))
          return null;
        const i2 = t2.getRaw("Pg");
        i2 instanceof Ref && (e2 = i2.toString());
        const a2 = t2.get("Type") instanceof Name ? t2.get("Type").name : null;
        if ("MCR" === a2) {
          if (this.tree.pageDict.objId !== e2)
            return null;
          const i3 = t2.getRaw("Stm");
          return new StructElement({ type: _s2, refObjId: i3 instanceof Ref ? i3.toString() : null, pageObjId: e2, mcid: t2.get("MCID") });
        }
        if ("OBJR" === a2) {
          if (this.tree.pageDict.objId !== e2)
            return null;
          const i3 = t2.getRaw("Obj");
          return new StructElement({ type: Rs, refObjId: i3 instanceof Ref ? i3.toString() : null, pageObjId: e2 });
        }
        return new StructElement({ type: Ns, dict: t2 });
      }
    };
    __name(StructElementNode, "StructElementNode");
    StructElement = class {
      constructor({ type: e2, dict: t2 = null, mcid: i2 = null, pageObjId: a2 = null, refObjId: n2 = null }) {
        this.type = e2, this.dict = t2, this.mcid = i2, this.pageObjId = a2, this.refObjId = n2, this.parentNode = null;
      }
    };
    __name(StructElement, "StructElement");
    StructTreePage = class {
      constructor(e2, t2) {
        this.root = e2, this.xref = e2?.xref ?? null, this.rootDict = e2?.dict ?? null, this.pageDict = t2, this.nodes = [];
      }
      collectObjects(e2) {
        if (!(this.root && this.rootDict && e2 instanceof Ref))
          return null;
        const t2 = this.rootDict.get("ParentTree");
        if (!t2)
          return null;
        const i2 = this.root.structParentIds?.get(e2);
        if (!i2)
          return null;
        const a2 = /* @__PURE__ */ new Map(), n2 = new NumberTree(t2, this.xref);
        for (const [e3] of i2) {
          const t3 = n2.getRaw(e3);
          t3 instanceof Ref && a2.set(e3, t3);
        }
        return a2;
      }
      parse(e2) {
        if (!(this.root && this.rootDict && e2 instanceof Ref))
          return;
        const t2 = this.rootDict.get("ParentTree");
        if (!t2)
          return;
        const i2 = this.pageDict.get("StructParents"), a2 = this.root.structParentIds?.get(e2);
        if (!Number.isInteger(i2) && !a2)
          return;
        const n2 = /* @__PURE__ */ new Map(), s2 = new NumberTree(t2, this.xref);
        if (Number.isInteger(i2)) {
          const e3 = s2.get(i2);
          if (Array.isArray(e3))
            for (const t3 of e3)
              t3 instanceof Ref && this.addNode(this.xref.fetch(t3), n2);
        }
        if (a2)
          for (const [e3, t3] of a2) {
            const i3 = s2.get(e3);
            if (i3) {
              const e4 = this.addNode(this.xref.fetchIfRef(i3), n2);
              1 === e4?.kids?.length && e4.kids[0].type === Rs && (e4.kids[0].type = t3);
            }
          }
      }
      addNode(e2, t2, i2 = 0) {
        if (i2 > 40)
          return warn$1("StructTree MAX_DEPTH reached."), null;
        if (!(e2 instanceof Dict))
          return null;
        if (t2.has(e2))
          return t2.get(e2);
        const a2 = new StructElementNode(this, e2);
        t2.set(e2, a2);
        const n2 = e2.get("P");
        if (!(n2 instanceof Dict) || isName(n2.get("Type"), "StructTreeRoot"))
          return this.addTopLevelNode(e2, a2) || t2.delete(e2), a2;
        const s2 = this.addNode(n2, t2, i2 + 1);
        if (!s2)
          return a2;
        let r2 = false;
        for (const t3 of s2.kids)
          t3.type === Ns && t3.dict === e2 && (t3.parentNode = a2, r2 = true);
        return r2 || t2.delete(e2), a2;
      }
      addTopLevelNode(e2, t2) {
        const i2 = this.rootDict.get("K");
        if (!i2)
          return false;
        if (i2 instanceof Dict)
          return i2.objId === e2.objId && (this.nodes[0] = t2, true);
        if (!Array.isArray(i2))
          return true;
        let a2 = false;
        for (let n2 = 0; n2 < i2.length; n2++) {
          const s2 = i2[n2];
          s2?.toString() === e2.objId && (this.nodes[n2] = t2, a2 = true);
        }
        return a2;
      }
      get serializable() {
        function nodeToSerializable(e3, t2, i2 = 0) {
          if (i2 > 40)
            return void warn$1("StructTree too deep to be fully serialized.");
          const a2 = /* @__PURE__ */ Object.create(null);
          a2.role = e3.role, a2.children = [], t2.children.push(a2);
          let n2 = e3.dict.get("Alt");
          "string" != typeof n2 && (n2 = e3.dict.get("ActualText")), "string" == typeof n2 && (a2.alt = stringToPDFString(n2));
          const s2 = e3.dict.get("A");
          if (s2 instanceof Dict) {
            const e4 = lookupNormalRect(s2.getArray("BBox"), null);
            if (e4)
              a2.bbox = e4;
            else {
              const e5 = s2.get("Width"), t3 = s2.get("Height");
              "number" == typeof e5 && e5 > 0 && "number" == typeof t3 && t3 > 0 && (a2.bbox = [0, 0, e5, t3]);
            }
          }
          const r2 = e3.dict.get("Lang");
          "string" == typeof r2 && (a2.lang = stringToPDFString(r2));
          for (const t3 of e3.kids) {
            const e4 = t3.type === Ns ? t3.parentNode : null;
            e4 ? nodeToSerializable(e4, a2, i2 + 1) : t3.type === Os || t3.type === _s2 ? a2.children.push({ type: "content", id: `p${t3.pageObjId}_mc${t3.mcid}` }) : t3.type === Rs ? a2.children.push({ type: "object", id: t3.refObjId }) : t3.type === Bs && a2.children.push({ type: "annotation", id: `pdfjs_internal_id_${t3.refObjId}` });
          }
        }
        __name(nodeToSerializable, "nodeToSerializable");
        const e2 = /* @__PURE__ */ Object.create(null);
        e2.children = [], e2.role = "Root";
        for (const t2 of this.nodes)
          t2 && nodeToSerializable(t2, e2);
        return e2;
      }
    };
    __name(StructTreePage, "StructTreePage");
    Ls = function(e2, t2, i2) {
      if (!Array.isArray(i2) || i2.length < 2)
        return false;
      const [a2, n2, ...s2] = i2;
      if (!e2(a2) && !Number.isInteger(a2))
        return false;
      if (!t2(n2))
        return false;
      const r2 = s2.length;
      let o2 = true;
      switch (n2.name) {
        case "XYZ":
          if (r2 < 2 || r2 > 3)
            return false;
          break;
        case "Fit":
        case "FitB":
          return 0 === r2;
        case "FitH":
        case "FitBH":
        case "FitV":
        case "FitBV":
          if (r2 > 1)
            return false;
          break;
        case "FitR":
          if (4 !== r2)
            return false;
          o2 = false;
          break;
        default:
          return false;
      }
      for (const e3 of s2)
        if (!("number" == typeof e3 || o2 && null === e3))
          return false;
      return true;
    }.bind(null, (e2) => e2 instanceof Ref, isName);
    __name(fetchDest, "fetchDest");
    __name(fetchRemoteDest, "fetchRemoteDest");
    Catalog = class {
      #ae = null;
      #ne = null;
      builtInCMapCache = /* @__PURE__ */ new Map();
      fontCache = new RefSetCache();
      globalColorSpaceCache = new GlobalColorSpaceCache();
      globalImageCache = new GlobalImageCache();
      nonBlendModesSet = new RefSet();
      pageDictCache = new RefSetCache();
      pageIndexCache = new RefSetCache();
      pageKidsCountCache = new RefSetCache();
      standardFontDataCache = /* @__PURE__ */ new Map();
      systemFontCache = /* @__PURE__ */ new Map();
      constructor(e2, t2) {
        if (this.pdfManager = e2, this.xref = t2, this.#ne = t2.getCatalogObj(), !(this.#ne instanceof Dict))
          throw new ti("Catalog object is not a dictionary.");
        this.toplevelPagesDict;
      }
      cloneDict() {
        return this.#ne.clone();
      }
      get version() {
        const e2 = this.#ne.get("Version");
        if (e2 instanceof Name) {
          if (gi.test(e2.name))
            return shadow$1(this, "version", e2.name);
          warn$1(`Invalid PDF catalog version: ${e2.name}`);
        }
        return shadow$1(this, "version", null);
      }
      get lang() {
        const e2 = this.#ne.get("Lang");
        return shadow$1(this, "lang", e2 && "string" == typeof e2 ? stringToPDFString(e2) : null);
      }
      get needsRendering() {
        const e2 = this.#ne.get("NeedsRendering");
        return shadow$1(this, "needsRendering", "boolean" == typeof e2 && e2);
      }
      get collection() {
        let e2 = null;
        try {
          const t2 = this.#ne.get("Collection");
          t2 instanceof Dict && t2.size > 0 && (e2 = t2);
        } catch (e3) {
          if (e3 instanceof MissingDataException)
            throw e3;
          info$1("Cannot fetch Collection entry; assuming no collection is present.");
        }
        return shadow$1(this, "collection", e2);
      }
      get acroForm() {
        let e2 = null;
        try {
          const t2 = this.#ne.get("AcroForm");
          t2 instanceof Dict && t2.size > 0 && (e2 = t2);
        } catch (e3) {
          if (e3 instanceof MissingDataException)
            throw e3;
          info$1("Cannot fetch AcroForm entry; assuming no forms are present.");
        }
        return shadow$1(this, "acroForm", e2);
      }
      get acroFormRef() {
        const e2 = this.#ne.getRaw("AcroForm");
        return shadow$1(this, "acroFormRef", e2 instanceof Ref ? e2 : null);
      }
      get metadata() {
        const e2 = this.#ne.getRaw("Metadata");
        if (!(e2 instanceof Ref))
          return shadow$1(this, "metadata", null);
        let t2 = null;
        try {
          const i2 = this.xref.fetch(e2, !this.xref.encrypt?.encryptMetadata);
          if (i2 instanceof BaseStream && i2.dict instanceof Dict) {
            const e3 = i2.dict.get("Type"), a2 = i2.dict.get("Subtype");
            if (isName(e3, "Metadata") && isName(a2, "XML")) {
              const e4 = stringToUTF8String$1(i2.getString());
              e4 && (t2 = new MetadataParser(e4).serializable);
            }
          }
        } catch (e3) {
          if (e3 instanceof MissingDataException)
            throw e3;
          info$1(`Skipping invalid Metadata: "${e3}".`);
        }
        return shadow$1(this, "metadata", t2);
      }
      get markInfo() {
        let e2 = null;
        try {
          e2 = this.#se();
        } catch (e3) {
          if (e3 instanceof MissingDataException)
            throw e3;
          warn$1("Unable to read mark info.");
        }
        return shadow$1(this, "markInfo", e2);
      }
      #se() {
        const e2 = this.#ne.get("MarkInfo");
        if (!(e2 instanceof Dict))
          return null;
        const t2 = { Marked: false, UserProperties: false, Suspects: false };
        for (const i2 in t2) {
          const a2 = e2.get(i2);
          "boolean" == typeof a2 && (t2[i2] = a2);
        }
        return t2;
      }
      get structTreeRoot() {
        let e2 = null;
        try {
          e2 = this.#re();
        } catch (e3) {
          if (e3 instanceof MissingDataException)
            throw e3;
          warn$1("Unable read to structTreeRoot info.");
        }
        return shadow$1(this, "structTreeRoot", e2);
      }
      #re() {
        const e2 = this.#ne.getRaw("StructTreeRoot"), t2 = this.xref.fetchIfRef(e2);
        if (!(t2 instanceof Dict))
          return null;
        const i2 = new StructTreeRoot(this.xref, t2, e2);
        return i2.init(), i2;
      }
      get toplevelPagesDict() {
        const e2 = this.#ne.get("Pages");
        if (!(e2 instanceof Dict))
          throw new ti("Invalid top-level pages dictionary.");
        return shadow$1(this, "toplevelPagesDict", e2);
      }
      get documentOutline() {
        let e2 = null;
        try {
          e2 = this.#oe();
        } catch (e3) {
          if (e3 instanceof MissingDataException)
            throw e3;
          warn$1("Unable to read document outline.");
        }
        return shadow$1(this, "documentOutline", e2);
      }
      #oe() {
        let e2 = this.#ne.get("Outlines");
        if (!(e2 instanceof Dict))
          return null;
        if (e2 = e2.getRaw("First"), !(e2 instanceof Ref))
          return null;
        const t2 = { items: [] }, i2 = [{ obj: e2, parent: t2 }], a2 = new RefSet();
        a2.put(e2);
        const n2 = this.xref, s2 = new Uint8ClampedArray(3);
        for (; i2.length > 0; ) {
          const t3 = i2.shift(), r2 = n2.fetchIfRef(t3.obj);
          if (null === r2)
            continue;
          r2.has("Title") || warn$1("Invalid outline item encountered.");
          const o2 = { url: null, dest: null, action: null };
          Catalog.parseDestDictionary({ destDict: r2, resultObj: o2, docBaseUrl: this.baseUrl, docAttachments: this.attachments });
          const l3 = r2.get("Title"), c2 = r2.get("F") || 0, h2 = r2.getArray("C"), d2 = r2.get("Count");
          let u2 = s2;
          !isNumberArray(h2, 3) || 0 === h2[0] && 0 === h2[1] && 0 === h2[2] || (u2 = ColorSpaceUtils.rgb.getRgb(h2, 0));
          const g2 = { action: o2.action, attachment: o2.attachment, dest: o2.dest, url: o2.url, unsafeUrl: o2.unsafeUrl, newWindow: o2.newWindow, setOCGState: o2.setOCGState, title: "string" == typeof l3 ? stringToPDFString(l3) : "", color: u2, count: Number.isInteger(d2) ? d2 : void 0, bold: !!(2 & c2), italic: !!(1 & c2), items: [] };
          t3.parent.items.push(g2), e2 = r2.getRaw("First"), e2 instanceof Ref && !a2.has(e2) && (i2.push({ obj: e2, parent: g2 }), a2.put(e2)), e2 = r2.getRaw("Next"), e2 instanceof Ref && !a2.has(e2) && (i2.push({ obj: e2, parent: t3.parent }), a2.put(e2));
        }
        return t2.items.length > 0 ? t2.items : null;
      }
      get permissions() {
        let e2 = null;
        try {
          e2 = this.#le();
        } catch (e3) {
          if (e3 instanceof MissingDataException)
            throw e3;
          warn$1("Unable to read permissions.");
        }
        return shadow$1(this, "permissions", e2);
      }
      #le() {
        const e2 = this.xref.trailer.get("Encrypt");
        if (!(e2 instanceof Dict))
          return null;
        let t2 = e2.get("P");
        if ("number" != typeof t2)
          return null;
        t2 += 2 ** 32;
        const i2 = [];
        for (const e3 in w) {
          const a2 = w[e3];
          t2 & a2 && i2.push(a2);
        }
        return i2;
      }
      get optionalContentConfig() {
        let e2 = null;
        try {
          const t2 = this.#ne.get("OCProperties");
          if (!t2)
            return shadow$1(this, "optionalContentConfig", null);
          const i2 = t2.get("D");
          if (!i2)
            return shadow$1(this, "optionalContentConfig", null);
          const a2 = t2.get("OCGs");
          if (!Array.isArray(a2))
            return shadow$1(this, "optionalContentConfig", null);
          const n2 = new RefSetCache();
          for (const e3 of a2)
            e3 instanceof Ref && !n2.has(e3) && n2.put(e3, this.#ce(e3));
          e2 = this.#he(i2, n2);
        } catch (e3) {
          if (e3 instanceof MissingDataException)
            throw e3;
          warn$1(`Unable to read optional content config: ${e3}`);
        }
        return shadow$1(this, "optionalContentConfig", e2);
      }
      #ce(e2) {
        const t2 = this.xref.fetch(e2), i2 = { id: e2.toString(), name: null, intent: null, usage: { print: null, view: null }, rbGroups: [] }, a2 = t2.get("Name");
        "string" == typeof a2 && (i2.name = stringToPDFString(a2));
        let n2 = t2.getArray("Intent");
        Array.isArray(n2) || (n2 = [n2]), n2.every((e3) => e3 instanceof Name) && (i2.intent = n2.map((e3) => e3.name));
        const s2 = t2.get("Usage");
        if (!(s2 instanceof Dict))
          return i2;
        const r2 = i2.usage, o2 = s2.get("Print");
        if (o2 instanceof Dict) {
          const e3 = o2.get("PrintState");
          if (e3 instanceof Name)
            switch (e3.name) {
              case "ON":
              case "OFF":
                r2.print = { printState: e3.name };
            }
        }
        const l3 = s2.get("View");
        if (l3 instanceof Dict) {
          const e3 = l3.get("ViewState");
          if (e3 instanceof Name)
            switch (e3.name) {
              case "ON":
              case "OFF":
                r2.view = { viewState: e3.name };
            }
        }
        return i2;
      }
      #he(e2, t2) {
        function parseOnOff(e3) {
          const i3 = [];
          if (Array.isArray(e3))
            for (const a3 of e3)
              a3 instanceof Ref && t2.has(a3) && i3.push(a3.toString());
          return i3;
        }
        __name(parseOnOff, "parseOnOff");
        function parseOrder(e3, i3 = 0) {
          if (!Array.isArray(e3))
            return null;
          const n3 = [];
          for (const s3 of e3) {
            if (s3 instanceof Ref && t2.has(s3)) {
              a2.put(s3), n3.push(s3.toString());
              continue;
            }
            const e4 = parseNestedOrder(s3, i3);
            e4 && n3.push(e4);
          }
          if (i3 > 0)
            return n3;
          const s2 = [];
          for (const [e4] of t2.items())
            a2.has(e4) || s2.push(e4.toString());
          return s2.length && n3.push({ name: null, order: s2 }), n3;
        }
        __name(parseOrder, "parseOrder");
        function parseNestedOrder(e3, t3) {
          if (++t3 > n2)
            return warn$1("parseNestedOrder - reached MAX_NESTED_LEVELS."), null;
          const a3 = i2.fetchIfRef(e3);
          if (!Array.isArray(a3))
            return null;
          const s2 = i2.fetchIfRef(a3[0]);
          if ("string" != typeof s2)
            return null;
          const r2 = parseOrder(a3.slice(1), t3);
          return r2?.length ? { name: stringToPDFString(s2), order: r2 } : null;
        }
        __name(parseNestedOrder, "parseNestedOrder");
        const i2 = this.xref, a2 = new RefSet(), n2 = 10;
        return function(e3) {
          if (Array.isArray(e3))
            for (const a3 of e3) {
              const e4 = i2.fetchIfRef(a3);
              if (!Array.isArray(e4) || !e4.length)
                continue;
              const n3 = /* @__PURE__ */ new Set();
              for (const i3 of e4)
                i3 instanceof Ref && t2.has(i3) && !n3.has(i3.toString()) && (n3.add(i3.toString()), t2.get(i3).rbGroups.push(n3));
            }
        }(e2.get("RBGroups")), { name: "string" == typeof e2.get("Name") ? stringToPDFString(e2.get("Name")) : null, creator: "string" == typeof e2.get("Creator") ? stringToPDFString(e2.get("Creator")) : null, baseState: e2.get("BaseState") instanceof Name ? e2.get("BaseState").name : null, on: parseOnOff(e2.get("ON")), off: parseOnOff(e2.get("OFF")), order: parseOrder(e2.get("Order")), groups: [...t2] };
      }
      setActualNumPages(e2 = null) {
        this.#ae = e2;
      }
      get hasActualNumPages() {
        return null !== this.#ae;
      }
      get _pagesCount() {
        const e2 = this.toplevelPagesDict.get("Count");
        if (!Number.isInteger(e2))
          throw new ti("Page count in top-level pages dictionary is not an integer.");
        return shadow$1(this, "_pagesCount", e2);
      }
      get numPages() {
        return this.#ae ?? this._pagesCount;
      }
      get destinations() {
        const e2 = this.#de(), t2 = /* @__PURE__ */ Object.create(null);
        for (const i2 of e2)
          if (i2 instanceof NameTree)
            for (const [e3, a2] of i2.getAll()) {
              const i3 = fetchDest(a2);
              i3 && (t2[stringToPDFString(e3, true)] = i3);
            }
          else if (i2 instanceof Dict)
            for (const [e3, a2] of i2) {
              const i3 = fetchDest(a2);
              i3 && (t2[stringToPDFString(e3, true)] ||= i3);
            }
        return shadow$1(this, "destinations", t2);
      }
      getDestination(e2) {
        if (this.hasOwnProperty("destinations"))
          return this.destinations[e2] ?? null;
        const t2 = this.#de();
        for (const i2 of t2)
          if (i2 instanceof NameTree || i2 instanceof Dict) {
            const t3 = fetchDest(i2.get(e2));
            if (t3)
              return t3;
          }
        if (t2.length) {
          const t3 = this.destinations[e2];
          if (t3)
            return t3;
        }
        return null;
      }
      #de() {
        const e2 = this.#ne.get("Names"), t2 = [];
        return e2?.has("Dests") && t2.push(new NameTree(e2.getRaw("Dests"), this.xref)), this.#ne.has("Dests") && t2.push(this.#ne.get("Dests")), t2;
      }
      get pageLabels() {
        let e2 = null;
        try {
          e2 = this.#ue();
        } catch (e3) {
          if (e3 instanceof MissingDataException)
            throw e3;
          warn$1("Unable to read page labels.");
        }
        return shadow$1(this, "pageLabels", e2);
      }
      #ue() {
        const e2 = this.#ne.getRaw("PageLabels");
        if (!e2)
          return null;
        const t2 = new Array(this.numPages);
        let i2 = null, a2 = "";
        const n2 = new NumberTree(e2, this.xref).getAll();
        let s2 = "", r2 = 1;
        for (let e3 = 0, o2 = this.numPages; e3 < o2; e3++) {
          const o3 = n2.get(e3);
          if (void 0 !== o3) {
            if (!(o3 instanceof Dict))
              throw new ti("PageLabel is not a dictionary.");
            if (o3.has("Type") && !isName(o3.get("Type"), "PageLabel"))
              throw new ti("Invalid type in PageLabel dictionary.");
            if (o3.has("S")) {
              const e4 = o3.get("S");
              if (!(e4 instanceof Name))
                throw new ti("Invalid style in PageLabel dictionary.");
              i2 = e4.name;
            } else
              i2 = null;
            if (o3.has("P")) {
              const e4 = o3.get("P");
              if ("string" != typeof e4)
                throw new ti("Invalid prefix in PageLabel dictionary.");
              a2 = stringToPDFString(e4);
            } else
              a2 = "";
            if (o3.has("St")) {
              const e4 = o3.get("St");
              if (!(Number.isInteger(e4) && e4 >= 1))
                throw new ti("Invalid start in PageLabel dictionary.");
              r2 = e4;
            } else
              r2 = 1;
          }
          switch (i2) {
            case "D":
              s2 = r2;
              break;
            case "R":
            case "r":
              s2 = toRomanNumerals(r2, "r" === i2);
              break;
            case "A":
            case "a":
              const e4 = 26, t3 = "a" === i2 ? 97 : 65, a3 = r2 - 1;
              s2 = String.fromCharCode(t3 + a3 % e4).repeat(Math.floor(a3 / e4) + 1);
              break;
            default:
              if (i2)
                throw new ti(`Invalid style "${i2}" in PageLabel dictionary.`);
              s2 = "";
          }
          t2[e3] = a2 + s2, r2++;
        }
        return t2;
      }
      get pageLayout() {
        const e2 = this.#ne.get("PageLayout");
        let t2 = "";
        if (e2 instanceof Name)
          switch (e2.name) {
            case "SinglePage":
            case "OneColumn":
            case "TwoColumnLeft":
            case "TwoColumnRight":
            case "TwoPageLeft":
            case "TwoPageRight":
              t2 = e2.name;
          }
        return shadow$1(this, "pageLayout", t2);
      }
      get pageMode() {
        const e2 = this.#ne.get("PageMode");
        let t2 = "UseNone";
        if (e2 instanceof Name)
          switch (e2.name) {
            case "UseNone":
            case "UseOutlines":
            case "UseThumbs":
            case "FullScreen":
            case "UseOC":
            case "UseAttachments":
              t2 = e2.name;
          }
        return shadow$1(this, "pageMode", t2);
      }
      get viewerPreferences() {
        const e2 = this.#ne.get("ViewerPreferences");
        if (!(e2 instanceof Dict))
          return shadow$1(this, "viewerPreferences", null);
        let t2 = null;
        for (const [i2, a2] of e2) {
          let e3;
          switch (i2) {
            case "HideToolbar":
            case "HideMenubar":
            case "HideWindowUI":
            case "FitWindow":
            case "CenterWindow":
            case "DisplayDocTitle":
            case "PickTrayByPDFSize":
              "boolean" == typeof a2 && (e3 = a2);
              break;
            case "NonFullScreenPageMode":
              if (a2 instanceof Name)
                switch (a2.name) {
                  case "UseNone":
                  case "UseOutlines":
                  case "UseThumbs":
                  case "UseOC":
                    e3 = a2.name;
                    break;
                  default:
                    e3 = "UseNone";
                }
              break;
            case "Direction":
              if (a2 instanceof Name)
                switch (a2.name) {
                  case "L2R":
                  case "R2L":
                    e3 = a2.name;
                    break;
                  default:
                    e3 = "L2R";
                }
              break;
            case "ViewArea":
            case "ViewClip":
            case "PrintArea":
            case "PrintClip":
              if (a2 instanceof Name)
                switch (a2.name) {
                  case "MediaBox":
                  case "CropBox":
                  case "BleedBox":
                  case "TrimBox":
                  case "ArtBox":
                    e3 = a2.name;
                    break;
                  default:
                    e3 = "CropBox";
                }
              break;
            case "PrintScaling":
              if (a2 instanceof Name)
                switch (a2.name) {
                  case "None":
                  case "AppDefault":
                    e3 = a2.name;
                    break;
                  default:
                    e3 = "AppDefault";
                }
              break;
            case "Duplex":
              if (a2 instanceof Name)
                switch (a2.name) {
                  case "Simplex":
                  case "DuplexFlipShortEdge":
                  case "DuplexFlipLongEdge":
                    e3 = a2.name;
                    break;
                  default:
                    e3 = "None";
                }
              break;
            case "PrintPageRange":
              if (Array.isArray(a2) && a2.length % 2 == 0) {
                a2.every((e4, t3, i3) => Number.isInteger(e4) && e4 > 0 && (0 === t3 || e4 >= i3[t3 - 1]) && e4 <= this.numPages) && (e3 = a2);
              }
              break;
            case "NumCopies":
              Number.isInteger(a2) && a2 > 0 && (e3 = a2);
              break;
            default:
              warn$1(`Ignoring non-standard key in ViewerPreferences: ${i2}.`);
              continue;
          }
          void 0 !== e3 ? (t2 ??= /* @__PURE__ */ Object.create(null), t2[i2] = e3) : warn$1(`Bad value, for key "${i2}", in ViewerPreferences: ${a2}.`);
        }
        return shadow$1(this, "viewerPreferences", t2);
      }
      get openAction() {
        const e2 = this.#ne.get("OpenAction"), t2 = /* @__PURE__ */ Object.create(null);
        if (e2 instanceof Dict) {
          const i2 = new Dict(this.xref);
          i2.set("A", e2);
          const a2 = { url: null, dest: null, action: null };
          Catalog.parseDestDictionary({ destDict: i2, resultObj: a2 }), Array.isArray(a2.dest) ? t2.dest = a2.dest : a2.action && (t2.action = a2.action);
        } else
          Ls(e2) && (t2.dest = e2);
        return shadow$1(this, "openAction", objectSize(t2) > 0 ? t2 : null);
      }
      get attachments() {
        const e2 = this.#ne.get("Names");
        let t2 = null;
        if (e2 instanceof Dict && e2.has("EmbeddedFiles")) {
          const i2 = new NameTree(e2.getRaw("EmbeddedFiles"), this.xref);
          for (const [e3, a2] of i2.getAll()) {
            const i3 = new FileSpec(a2, this.xref);
            t2 ??= /* @__PURE__ */ Object.create(null), t2[stringToPDFString(e3, true)] = i3.serializable;
          }
        }
        return shadow$1(this, "attachments", t2);
      }
      get xfaImages() {
        const e2 = this.#ne.get("Names");
        let t2 = null;
        if (e2 instanceof Dict && e2.has("XFAImages")) {
          const i2 = new NameTree(e2.getRaw("XFAImages"), this.xref);
          for (const [e3, a2] of i2.getAll())
            a2 instanceof BaseStream && (t2 ??= /* @__PURE__ */ new Map(), t2.set(stringToPDFString(e3, true), a2.getBytes()));
        }
        return shadow$1(this, "xfaImages", t2);
      }
      #ge() {
        const e2 = this.#ne.get("Names");
        let t2 = null;
        function appendIfJavaScriptDict(e3, i3) {
          if (!(i3 instanceof Dict))
            return;
          if (!isName(i3.get("S"), "JavaScript"))
            return;
          let a2 = i3.get("JS");
          if (a2 instanceof BaseStream)
            a2 = a2.getString();
          else if ("string" != typeof a2)
            return;
          a2 = stringToPDFString(a2, true).replaceAll("\0", ""), a2 && (t2 ||= /* @__PURE__ */ new Map()).set(e3, a2);
        }
        __name(appendIfJavaScriptDict, "appendIfJavaScriptDict");
        if (e2 instanceof Dict && e2.has("JavaScript")) {
          const t3 = new NameTree(e2.getRaw("JavaScript"), this.xref);
          for (const [e3, i3] of t3.getAll())
            appendIfJavaScriptDict(stringToPDFString(e3, true), i3);
        }
        const i2 = this.#ne.get("OpenAction");
        return i2 && appendIfJavaScriptDict("OpenAction", i2), t2;
      }
      get jsActions() {
        const e2 = this.#ge();
        let t2 = collectActions(this.xref, this.#ne, ie);
        if (e2) {
          t2 ||= /* @__PURE__ */ Object.create(null);
          for (const [i2, a2] of e2)
            i2 in t2 ? t2[i2].push(a2) : t2[i2] = [a2];
        }
        return shadow$1(this, "jsActions", t2);
      }
      async cleanup(e2 = false) {
        clearGlobalCaches(), this.globalColorSpaceCache.clear(), this.globalImageCache.clear(e2), this.pageKidsCountCache.clear(), this.pageIndexCache.clear(), this.pageDictCache.clear(), this.nonBlendModesSet.clear();
        for (const { dict: e3 } of await Promise.all(this.fontCache))
          delete e3.cacheKey;
        this.fontCache.clear(), this.builtInCMapCache.clear(), this.standardFontDataCache.clear(), this.systemFontCache.clear();
      }
      async getPageDict(e2) {
        const t2 = [this.toplevelPagesDict], i2 = new RefSet(), a2 = this.#ne.getRaw("Pages");
        a2 instanceof Ref && i2.put(a2);
        const n2 = this.xref, s2 = this.pageKidsCountCache, r2 = this.pageIndexCache, o2 = this.pageDictCache;
        let l3 = 0;
        for (; t2.length; ) {
          const a3 = t2.pop();
          if (a3 instanceof Ref) {
            const c3 = s2.get(a3);
            if (c3 >= 0 && l3 + c3 <= e2) {
              l3 += c3;
              continue;
            }
            if (i2.has(a3))
              throw new ti("Pages tree contains circular reference.");
            i2.put(a3);
            const h3 = await (o2.get(a3) || n2.fetchAsync(a3));
            if (h3 instanceof Dict) {
              let t3 = h3.getRaw("Type");
              if (t3 instanceof Ref && (t3 = await n2.fetchAsync(t3)), isName(t3, "Page") || !h3.has("Kids")) {
                if (s2.has(a3) || s2.put(a3, 1), r2.has(a3) || r2.put(a3, l3), l3 === e2)
                  return [h3, a3];
                l3++;
                continue;
              }
            }
            t2.push(h3);
            continue;
          }
          if (!(a3 instanceof Dict))
            throw new ti("Page dictionary kid reference points to wrong type of object.");
          const { objId: c2 } = a3;
          let h2 = a3.getRaw("Count");
          if (h2 instanceof Ref && (h2 = await n2.fetchAsync(h2)), Number.isInteger(h2) && h2 >= 0 && (c2 && !s2.has(c2) && s2.put(c2, h2), l3 + h2 <= e2)) {
            l3 += h2;
            continue;
          }
          let d2 = a3.getRaw("Kids");
          if (d2 instanceof Ref && (d2 = await n2.fetchAsync(d2)), !Array.isArray(d2)) {
            let t3 = a3.getRaw("Type");
            if (t3 instanceof Ref && (t3 = await n2.fetchAsync(t3)), isName(t3, "Page") || !a3.has("Kids")) {
              if (l3 === e2)
                return [a3, null];
              l3++;
              continue;
            }
            throw new ti("Page dictionary kids object is not an array.");
          }
          for (let e3 = d2.length - 1; e3 >= 0; e3--) {
            const i3 = d2[e3];
            t2.push(i3), a3 === this.toplevelPagesDict && i3 instanceof Ref && !o2.has(i3) && o2.put(i3, n2.fetchAsync(i3));
          }
        }
        throw new Error(`Page index ${e2} not found.`);
      }
      async getAllPageDicts(e2 = false) {
        const { ignoreErrors: t2 } = this.pdfManager.evaluatorOptions, i2 = [{ currentNode: this.toplevelPagesDict, posInKids: 0 }], a2 = new RefSet(), n2 = this.#ne.getRaw("Pages");
        n2 instanceof Ref && a2.put(n2);
        const s2 = /* @__PURE__ */ new Map(), r2 = this.xref, o2 = this.pageIndexCache;
        let l3 = 0;
        function addPageDict(e3, t3) {
          t3 && !o2.has(t3) && o2.put(t3, l3), s2.set(l3++, [e3, t3]);
        }
        __name(addPageDict, "addPageDict");
        function addPageError(i3) {
          if (i3 instanceof XRefEntryException && !e2)
            throw i3;
          e2 && t2 && 0 === l3 && (warn$1(`getAllPageDicts - Skipping invalid first page: "${i3}".`), i3 = Dict.empty), s2.set(l3++, [i3, null]);
        }
        __name(addPageError, "addPageError");
        for (; i2.length > 0; ) {
          const e3 = i2.at(-1), { currentNode: t3, posInKids: n3 } = e3;
          let s3 = t3.getRaw("Kids");
          if (s3 instanceof Ref)
            try {
              s3 = await r2.fetchAsync(s3);
            } catch (e4) {
              addPageError(e4);
              break;
            }
          if (!Array.isArray(s3)) {
            addPageError(new ti("Page dictionary kids object is not an array."));
            break;
          }
          if (n3 >= s3.length) {
            i2.pop();
            continue;
          }
          const o3 = s3[n3];
          let l4;
          if (o3 instanceof Ref) {
            if (a2.has(o3)) {
              addPageError(new ti("Pages tree contains circular reference."));
              break;
            }
            a2.put(o3);
            try {
              l4 = await r2.fetchAsync(o3);
            } catch (e4) {
              addPageError(e4);
              break;
            }
          } else
            l4 = o3;
          if (!(l4 instanceof Dict)) {
            addPageError(new ti("Page dictionary kid reference points to wrong type of object."));
            break;
          }
          let c2 = l4.getRaw("Type");
          if (c2 instanceof Ref)
            try {
              c2 = await r2.fetchAsync(c2);
            } catch (e4) {
              addPageError(e4);
              break;
            }
          isName(c2, "Page") || !l4.has("Kids") ? addPageDict(l4, o3 instanceof Ref ? o3 : null) : i2.push({ currentNode: l4, posInKids: 0 }), e3.posInKids++;
        }
        return s2;
      }
      getPageIndex(e2) {
        const t2 = this.pageIndexCache.get(e2);
        if (void 0 !== t2)
          return Promise.resolve(t2);
        const i2 = this.xref;
        let a2 = 0;
        const next = /* @__PURE__ */ __name((t3) => function(t4) {
          let a3, n2 = 0;
          return i2.fetchAsync(t4).then(function(i3) {
            if (isRefsEqual(t4, e2) && !isDict(i3, "Page") && !(i3 instanceof Dict && !i3.has("Type") && i3.has("Contents")))
              throw new ti("The reference does not point to a /Page dictionary.");
            if (!i3)
              return null;
            if (!(i3 instanceof Dict))
              throw new ti("Node must be a dictionary.");
            return a3 = i3.getRaw("Parent"), i3.getAsync("Parent");
          }).then(function(e3) {
            if (!e3)
              return null;
            if (!(e3 instanceof Dict))
              throw new ti("Parent must be a dictionary.");
            return e3.getAsync("Kids");
          }).then(function(e3) {
            if (!e3)
              return null;
            const s2 = [];
            let r2 = false;
            for (const a4 of e3) {
              if (!(a4 instanceof Ref))
                throw new ti("Kid must be a reference.");
              if (isRefsEqual(a4, t4)) {
                r2 = true;
                break;
              }
              s2.push(i2.fetchAsync(a4).then(function(e4) {
                if (!(e4 instanceof Dict))
                  throw new ti("Kid node must be a dictionary.");
                e4.has("Count") ? n2 += e4.get("Count") : n2++;
              }));
            }
            if (!r2)
              throw new ti("Kid reference not found in parent's kids.");
            return Promise.all(s2).then(() => [n2, a3]);
          });
        }(t3).then((t4) => {
          if (!t4)
            return this.pageIndexCache.put(e2, a2), a2;
          const [i3, n2] = t4;
          return a2 += i3, next(n2);
        }), "next");
        return next(e2);
      }
      get baseUrl() {
        const e2 = this.#ne.get("URI");
        if (e2 instanceof Dict) {
          const t2 = e2.get("Base");
          if ("string" == typeof t2) {
            const e3 = createValidAbsoluteUrl$1(t2, null, { tryConvertEncoding: true });
            if (e3)
              return shadow$1(this, "baseUrl", e3.href);
          }
        }
        return shadow$1(this, "baseUrl", this.pdfManager.docBaseUrl);
      }
      static parseDestDictionary({ destDict: e2, resultObj: t2, docBaseUrl: i2 = null, docAttachments: a2 = null }) {
        if (!(e2 instanceof Dict))
          return void warn$1("parseDestDictionary: `destDict` must be a dictionary.");
        let n2, s2, r2 = e2.get("A");
        if (r2 instanceof Dict || (e2.has("Dest") ? r2 = e2.get("Dest") : (r2 = e2.get("AA"), r2 instanceof Dict && (r2.has("D") ? r2 = r2.get("D") : r2.has("U") && (r2 = r2.get("U"))))), r2 instanceof Dict) {
          const e3 = r2.get("S");
          if (!(e3 instanceof Name))
            return void warn$1("parseDestDictionary: Invalid type in Action dictionary.");
          const i3 = e3.name;
          switch (i3) {
            case "ResetForm":
              const e4 = r2.get("Flags"), o2 = !(1 & ("number" == typeof e4 ? e4 : 0)), l3 = [], c2 = [];
              for (const e5 of r2.get("Fields") || [])
                e5 instanceof Ref ? c2.push(e5.toString()) : "string" == typeof e5 && l3.push(stringToPDFString(e5));
              t2.resetForm = { fields: l3, refs: c2, include: o2 };
              break;
            case "URI":
              n2 = r2.get("URI"), n2 instanceof Name && (n2 = "/" + n2.name);
              break;
            case "GoTo":
              s2 = r2.get("D");
              break;
            case "Launch":
            case "GoToR":
              const h2 = r2.get("F");
              if (h2 instanceof Dict) {
                const e5 = new FileSpec(h2, null, true), { rawFilename: t3 } = e5.serializable;
                n2 = t3;
              } else
                "string" == typeof h2 && (n2 = h2);
              const d2 = fetchRemoteDest(r2);
              d2 && "string" == typeof n2 && (n2 = n2.split("#", 1)[0] + "#" + d2);
              const u2 = r2.get("NewWindow");
              "boolean" == typeof u2 && (t2.newWindow = u2);
              break;
            case "GoToE":
              const g2 = r2.get("T");
              let p2;
              if (a2 && g2 instanceof Dict) {
                const e5 = g2.get("R"), t3 = g2.get("N");
                isName(e5, "C") && "string" == typeof t3 && (p2 = a2[stringToPDFString(t3, true)]);
              }
              if (p2) {
                t2.attachment = p2;
                const e5 = fetchRemoteDest(r2);
                e5 && (t2.attachmentDest = e5);
              } else
                warn$1('parseDestDictionary - unimplemented "GoToE" action.');
              break;
            case "Named":
              const f2 = r2.get("N");
              f2 instanceof Name && (t2.action = f2.name);
              break;
            case "SetOCGState":
              const m2 = r2.get("State"), b2 = r2.get("PreserveRB");
              if (!Array.isArray(m2) || 0 === m2.length)
                break;
              const y2 = [];
              for (const e5 of m2)
                if (e5 instanceof Name)
                  switch (e5.name) {
                    case "ON":
                    case "OFF":
                    case "Toggle":
                      y2.push(e5.name);
                  }
                else
                  e5 instanceof Ref && y2.push(e5.toString());
              if (y2.length !== m2.length)
                break;
              t2.setOCGState = { state: y2, preserveRB: "boolean" != typeof b2 || b2 };
              break;
            case "JavaScript":
              const w2 = r2.get("JS");
              let x2;
              w2 instanceof BaseStream ? x2 = w2.getString() : "string" == typeof w2 && (x2 = w2);
              const S2 = x2 && recoverJsURL(stringToPDFString(x2, true));
              if (S2) {
                n2 = S2.url, t2.newWindow = S2.newWindow;
                break;
              }
            default:
              if ("JavaScript" === i3 || "SubmitForm" === i3)
                break;
              warn$1(`parseDestDictionary - unsupported action: "${i3}".`);
          }
        } else
          e2.has("Dest") && (s2 = e2.get("Dest"));
        if ("string" == typeof n2) {
          const e3 = createValidAbsoluteUrl$1(n2, i2, { addDefaultProtocol: true, tryConvertEncoding: true });
          e3 && (t2.url = e3.href), t2.unsafeUrl = n2;
        }
        s2 && (s2 instanceof Name && (s2 = s2.name), "string" == typeof s2 ? t2.dest = stringToPDFString(s2, true) : Ls(s2) && (t2.dest = s2));
      }
    };
    __name(Catalog, "Catalog");
    __name(mayHaveChildren, "mayHaveChildren");
    __name(addChildren, "addChildren");
    ObjectLoader = class {
      refSet = new RefSet();
      constructor(e2, t2, i2) {
        this.dict = e2, this.keys = t2, this.xref = i2;
      }
      async load() {
        const { keys: e2, dict: t2 } = this, i2 = [];
        for (const a2 of e2) {
          const e3 = t2.getRaw(a2);
          void 0 !== e3 && i2.push(e3);
        }
        await this.#pe(i2), this.refSet = null;
      }
      async #pe(e2) {
        const t2 = [], i2 = [];
        for (; e2.length; ) {
          let a2 = e2.pop();
          if (a2 instanceof Ref) {
            if (this.refSet.has(a2))
              continue;
            try {
              this.refSet.put(a2), a2 = this.xref.fetch(a2);
            } catch (e3) {
              if (!(e3 instanceof MissingDataException))
                return warn$1(`ObjectLoader.#walk - requesting all data: "${e3}".`), void await this.xref.stream.manager.requestAllChunks();
              t2.push(a2), i2.push({ begin: e3.begin, end: e3.end });
            }
          }
          if (a2 instanceof BaseStream) {
            const e3 = a2.getBaseStreams();
            if (e3) {
              let n2 = false;
              for (const t3 of e3)
                t3.isDataLoaded || (n2 = true, i2.push({ begin: t3.start, end: t3.end }));
              n2 && t2.push(a2);
            }
          }
          addChildren(a2, e2);
        }
        if (i2.length) {
          await this.xref.stream.manager.requestRanges(i2);
          for (const e3 of t2)
            e3 instanceof Ref && this.refSet.remove(e3);
          await this.#pe(t2);
        }
      }
      static async load(e2, t2, i2) {
        if (i2.stream.isDataLoaded)
          return;
        const a2 = new ObjectLoader(e2, t2, i2);
        await a2.load();
      }
    };
    __name(ObjectLoader, "ObjectLoader");
    Us = Symbol();
    js = Symbol();
    $s = Symbol();
    Hs = Symbol();
    qs = Symbol();
    Xs = Symbol();
    zs = Symbol();
    Ws = Symbol();
    Gs = Symbol();
    Vs = Symbol("content");
    Ks = Symbol("data");
    Ys = Symbol();
    Js = Symbol("extra");
    Zs = Symbol();
    Qs = Symbol();
    er = Symbol();
    tr = Symbol();
    ir = Symbol();
    ar = Symbol();
    nr = Symbol();
    sr = Symbol();
    rr = Symbol();
    or = Symbol();
    lr = Symbol();
    cr = Symbol();
    hr = Symbol();
    dr = Symbol();
    ur = Symbol();
    gr = Symbol();
    pr = Symbol();
    fr = Symbol();
    mr = Symbol();
    br = Symbol();
    yr = Symbol();
    wr = Symbol();
    Ar = Symbol();
    xr = Symbol();
    Sr = Symbol();
    vr = Symbol();
    Cr = Symbol();
    kr = Symbol();
    Tr = Symbol();
    Ir = Symbol();
    Fr = Symbol();
    Mr = Symbol();
    Dr = Symbol("namespaceId");
    Er = Symbol("nodeName");
    Or = Symbol();
    _r2 = Symbol();
    Pr = Symbol();
    Rr = Symbol();
    Nr = Symbol();
    Lr = Symbol();
    Ur = Symbol();
    jr = Symbol();
    $r = Symbol("root");
    Hr = Symbol();
    qr = Symbol();
    Xr = Symbol();
    zr = Symbol();
    Wr = Symbol();
    Gr = Symbol();
    Vr = Symbol();
    Kr = Symbol();
    Yr = Symbol();
    Jr = Symbol();
    Zr = Symbol();
    Qr = Symbol("uid");
    eo = Symbol();
    to = { config: { id: 0, check: (e2) => e2.startsWith("http://www.xfa.org/schema/xci/") }, connectionSet: { id: 1, check: (e2) => e2.startsWith("http://www.xfa.org/schema/xfa-connection-set/") }, datasets: { id: 2, check: (e2) => e2.startsWith("http://www.xfa.org/schema/xfa-data/") }, form: { id: 3, check: (e2) => e2.startsWith("http://www.xfa.org/schema/xfa-form/") }, localeSet: { id: 4, check: (e2) => e2.startsWith("http://www.xfa.org/schema/xfa-locale-set/") }, pdf: { id: 5, check: (e2) => "http://ns.adobe.com/xdp/pdf/" === e2 }, signature: { id: 6, check: (e2) => "http://www.w3.org/2000/09/xmldsig#" === e2 }, sourceSet: { id: 7, check: (e2) => e2.startsWith("http://www.xfa.org/schema/xfa-source-set/") }, stylesheet: { id: 8, check: (e2) => "http://www.w3.org/1999/XSL/Transform" === e2 }, template: { id: 9, check: (e2) => e2.startsWith("http://www.xfa.org/schema/xfa-template/") }, xdc: { id: 10, check: (e2) => e2.startsWith("http://www.xfa.org/schema/xdc/") }, xdp: { id: 11, check: (e2) => "http://ns.adobe.com/xdp/" === e2 }, xfdf: { id: 12, check: (e2) => "http://ns.adobe.com/xfdf/" === e2 }, xhtml: { id: 13, check: (e2) => "http://www.w3.org/1999/xhtml" === e2 }, xmpmeta: { id: 14, check: (e2) => "http://ns.adobe.com/xmpmeta/" === e2 } };
    io = { pt: (e2) => e2, cm: (e2) => e2 / 2.54 * 72, mm: (e2) => e2 / 25.4 * 72, in: (e2) => 72 * e2, px: (e2) => e2 };
    ao = /([+-]?\d+\.?\d*)(.*)/;
    __name(stripQuotes, "stripQuotes");
    __name(getInteger, "getInteger");
    __name(getFloat, "getFloat");
    __name(getKeyword, "getKeyword");
    __name(getStringOption, "getStringOption");
    __name(getMeasurement, "getMeasurement");
    __name(getRatio, "getRatio");
    __name(getRelevant, "getRelevant");
    HTMLResult = class {
      static get FAILURE() {
        return shadow$1(this, "FAILURE", new HTMLResult(false, null, null, null));
      }
      static get EMPTY() {
        return shadow$1(this, "EMPTY", new HTMLResult(true, null, null, null));
      }
      constructor(e2, t2, i2, a2) {
        this.success = e2, this.html = t2, this.bbox = i2, this.breakNode = a2;
      }
      isBreak() {
        return !!this.breakNode;
      }
      static breakNode(e2) {
        return new HTMLResult(false, null, null, e2);
      }
      static success(e2, t2 = null) {
        return new HTMLResult(true, e2, t2, null);
      }
    };
    __name(HTMLResult, "HTMLResult");
    FontFinder = class {
      constructor(e2) {
        this.fonts = /* @__PURE__ */ new Map(), this.cache = /* @__PURE__ */ new Map(), this.warned = /* @__PURE__ */ new Set(), this.defaultFont = null, this.add(e2);
      }
      add(e2, t2 = null) {
        for (const t3 of e2)
          this.addPdfFont(t3);
        for (const e3 of this.fonts.values())
          e3.regular || (e3.regular = e3.italic || e3.bold || e3.bolditalic);
        if (!t2 || 0 === t2.size)
          return;
        const i2 = this.fonts.get("PdfJS-Fallback-PdfJS-XFA");
        for (const e3 of t2)
          this.fonts.set(e3, i2);
      }
      addPdfFont(e2) {
        const t2 = e2.cssFontInfo, i2 = t2.fontFamily;
        let a2 = this.fonts.get(i2);
        a2 || (a2 = /* @__PURE__ */ Object.create(null), this.fonts.set(i2, a2), this.defaultFont || (this.defaultFont = a2));
        let n2 = "";
        const s2 = parseFloat(t2.fontWeight);
        0 !== parseFloat(t2.italicAngle) ? n2 = s2 >= 700 ? "bolditalic" : "italic" : s2 >= 700 && (n2 = "bold"), n2 || ((e2.name.includes("Bold") || e2.psName?.includes("Bold")) && (n2 = "bold"), (e2.name.includes("Italic") || e2.name.endsWith("It") || e2.psName?.includes("Italic") || e2.psName?.endsWith("It")) && (n2 += "italic")), n2 || (n2 = "regular"), a2[n2] = e2;
      }
      getDefault() {
        return this.defaultFont;
      }
      find(e2, t2 = true) {
        let i2 = this.fonts.get(e2) || this.cache.get(e2);
        if (i2)
          return i2;
        const a2 = /,|-|_| |bolditalic|bold|italic|regular|it/gi;
        let n2 = e2.replaceAll(a2, "");
        if (i2 = this.fonts.get(n2), i2)
          return this.cache.set(e2, i2), i2;
        n2 = n2.toLowerCase();
        const s2 = [];
        for (const [e3, t3] of this.fonts.entries())
          e3.replaceAll(a2, "").toLowerCase().startsWith(n2) && s2.push(t3);
        if (0 === s2.length)
          for (const [, e3] of this.fonts.entries())
            e3.regular.name?.replaceAll(a2, "").toLowerCase().startsWith(n2) && s2.push(e3);
        if (0 === s2.length) {
          n2 = n2.replaceAll(/psmt|mt/gi, "");
          for (const [e3, t3] of this.fonts.entries())
            e3.replaceAll(a2, "").toLowerCase().startsWith(n2) && s2.push(t3);
        }
        if (0 === s2.length)
          for (const e3 of this.fonts.values())
            e3.regular.name?.replaceAll(a2, "").toLowerCase().startsWith(n2) && s2.push(e3);
        return s2.length >= 1 ? (1 !== s2.length && t2 && warn$1(`XFA - Too many choices to guess the correct font: ${e2}`), this.cache.set(e2, s2[0]), s2[0]) : (t2 && !this.warned.has(e2) && (this.warned.add(e2), warn$1(`XFA - Cannot find the font: ${e2}`)), null);
      }
    };
    __name(FontFinder, "FontFinder");
    __name(selectFont, "selectFont");
    FontInfo = class {
      constructor(e2, t2, i2, a2) {
        if (this.lineHeight = i2, this.paraMargin = t2 || { top: 0, bottom: 0, left: 0, right: 0 }, !e2)
          return void ([this.pdfFont, this.xfaFont] = this.defaultFont(a2));
        this.xfaFont = { typeface: e2.typeface, posture: e2.posture, weight: e2.weight, size: e2.size, letterSpacing: e2.letterSpacing };
        const n2 = a2.find(e2.typeface);
        n2 ? (this.pdfFont = selectFont(e2, n2), this.pdfFont || ([this.pdfFont, this.xfaFont] = this.defaultFont(a2))) : [this.pdfFont, this.xfaFont] = this.defaultFont(a2);
      }
      defaultFont(e2) {
        const t2 = e2.find("Helvetica", false) || e2.find("Myriad Pro", false) || e2.find("Arial", false) || e2.getDefault();
        if (t2?.regular) {
          const e3 = t2.regular;
          return [e3, { typeface: e3.cssFontInfo.fontFamily, posture: "normal", weight: "normal", size: 10, letterSpacing: 0 }];
        }
        return [null, { typeface: "Courier", posture: "normal", weight: "normal", size: 10, letterSpacing: 0 }];
      }
    };
    __name(FontInfo, "FontInfo");
    FontSelector = class {
      constructor(e2, t2, i2, a2) {
        this.fontFinder = a2, this.stack = [new FontInfo(e2, t2, i2, a2)];
      }
      pushData(e2, t2, i2) {
        const a2 = this.stack.at(-1);
        for (const t3 of ["typeface", "posture", "weight", "size", "letterSpacing"])
          e2[t3] || (e2[t3] = a2.xfaFont[t3]);
        for (const e3 of ["top", "bottom", "left", "right"])
          isNaN(t2[e3]) && (t2[e3] = a2.paraMargin[e3]);
        const n2 = new FontInfo(e2, t2, i2 || a2.lineHeight, this.fontFinder);
        n2.pdfFont || (n2.pdfFont = a2.pdfFont), this.stack.push(n2);
      }
      popFont() {
        this.stack.pop();
      }
      topFont() {
        return this.stack.at(-1);
      }
    };
    __name(FontSelector, "FontSelector");
    TextMeasure = class {
      constructor(e2, t2, i2, a2) {
        this.glyphs = [], this.fontSelector = new FontSelector(e2, t2, i2, a2), this.extraHeight = 0;
      }
      pushData(e2, t2, i2) {
        this.fontSelector.pushData(e2, t2, i2);
      }
      popFont(e2) {
        return this.fontSelector.popFont();
      }
      addPara() {
        const e2 = this.fontSelector.topFont();
        this.extraHeight += e2.paraMargin.top + e2.paraMargin.bottom;
      }
      addString(e2) {
        if (!e2)
          return;
        const t2 = this.fontSelector.topFont(), i2 = t2.xfaFont.size;
        if (t2.pdfFont) {
          const a2 = t2.xfaFont.letterSpacing, n2 = t2.pdfFont, s2 = n2.lineHeight || 1.2, r2 = t2.lineHeight || Math.max(1.2, s2) * i2, o2 = s2 - (void 0 === n2.lineGap ? 0.2 : n2.lineGap), l3 = Math.max(1, o2) * i2, c2 = i2 / 1e3, h2 = n2.defaultWidth || n2.charsToGlyphs(" ")[0].width;
          for (const t3 of e2.split(/[\u2029\n]/)) {
            const e3 = n2.encodeString(t3).join(""), i3 = n2.charsToGlyphs(e3);
            for (const e4 of i3) {
              const t4 = e4.width || h2;
              this.glyphs.push([t4 * c2 + a2, r2, l3, e4.unicode, false]);
            }
            this.glyphs.push([0, 0, 0, "\n", true]);
          }
          return void this.glyphs.pop();
        }
        for (const t3 of e2.split(/[\u2029\n]/)) {
          for (const e3 of t3.split(""))
            this.glyphs.push([i2, 1.2 * i2, i2, e3, false]);
          this.glyphs.push([0, 0, 0, "\n", true]);
        }
        this.glyphs.pop();
      }
      compute(e2) {
        let t2 = -1, i2 = 0, a2 = 0, n2 = 0, s2 = 0, r2 = 0, o2 = false, l3 = true;
        for (let c2 = 0, h2 = this.glyphs.length; c2 < h2; c2++) {
          const [h3, d2, u2, g2, p2] = this.glyphs[c2], f2 = " " === g2, m2 = l3 ? u2 : d2;
          p2 ? (a2 = Math.max(a2, s2), s2 = 0, n2 += r2, r2 = m2, t2 = -1, i2 = 0, l3 = false) : f2 ? s2 + h3 > e2 ? (a2 = Math.max(a2, s2), s2 = 0, n2 += r2, r2 = m2, t2 = -1, i2 = 0, o2 = true, l3 = false) : (r2 = Math.max(m2, r2), i2 = s2, s2 += h3, t2 = c2) : s2 + h3 > e2 ? (n2 += r2, r2 = m2, -1 !== t2 ? (c2 = t2, a2 = Math.max(a2, i2), s2 = 0, t2 = -1, i2 = 0) : (a2 = Math.max(a2, s2), s2 = h3), o2 = true, l3 = false) : (s2 += h3, r2 = Math.max(m2, r2));
        }
        return a2 = Math.max(a2, s2), n2 += r2 + this.extraHeight, { width: 1.02 * a2, height: n2, isBroken: o2 };
      }
    };
    __name(TextMeasure, "TextMeasure");
    no = /^[^.[]+/;
    so = /^[^\]]+/;
    ro = 0;
    oo = 1;
    lo = 2;
    co = 3;
    ho = 4;
    uo = /* @__PURE__ */ new Map([["$data", (e2, t2) => e2.datasets ? e2.datasets.data : e2], ["$record", (e2, t2) => (e2.datasets ? e2.datasets.data : e2)[cr]()[0]], ["$template", (e2, t2) => e2.template], ["$connectionSet", (e2, t2) => e2.connectionSet], ["$form", (e2, t2) => e2.form], ["$layout", (e2, t2) => e2.layout], ["$host", (e2, t2) => e2.host], ["$dataWindow", (e2, t2) => e2.dataWindow], ["$event", (e2, t2) => e2.event], ["!", (e2, t2) => e2.datasets], ["$xfa", (e2, t2) => e2], ["xfa", (e2, t2) => e2], ["$", (e2, t2) => t2]]);
    go = /* @__PURE__ */ new WeakMap();
    __name(parseIndex, "parseIndex");
    __name(parseExpression, "parseExpression");
    __name(searchNode, "searchNode");
    __name(createDataNode, "createDataNode");
    po = Symbol();
    fo = Symbol();
    mo = Symbol();
    bo = Symbol("_children");
    yo = Symbol();
    wo = Symbol();
    Ao = Symbol();
    xo = Symbol();
    So = Symbol();
    vo = Symbol();
    Co = Symbol();
    ko = Symbol();
    Io = Symbol();
    Fo = Symbol("parent");
    Mo = Symbol();
    Do = Symbol();
    Eo = Symbol();
    Oo = 0;
    _o2 = to.datasets.id;
    XFAObject = class {
      constructor(e2, t2, i2 = false) {
        this[Dr] = e2, this[Er] = t2, this[Co] = i2, this[Fo] = null, this[bo] = [], this[Qr] = `${t2}${Oo++}`, this[fr] = null;
      }
      get isXFAObject() {
        return true;
      }
      get isXFAObjectArray() {
        return false;
      }
      createNodes(e2) {
        let t2 = this, i2 = null;
        for (const { name: a2, index: n2 } of e2) {
          for (let e3 = 0, s2 = isFinite(n2) ? n2 : 0; e3 <= s2; e3++) {
            const e4 = t2[Dr] === _o2 ? -1 : t2[Dr];
            i2 = new XmlObject(e4, a2), t2[$s](i2);
          }
          t2 = i2;
        }
        return i2;
      }
      [_r2](e2) {
        if (!this[Co] || !this[Pr](e2))
          return false;
        const t2 = e2[Er], i2 = this[t2];
        if (!(i2 instanceof XFAObjectArray))
          return null !== i2 && this[jr](i2), this[t2] = e2, this[$s](e2), true;
        if (i2.push(e2))
          return this[$s](e2), true;
        let a2 = "";
        return this.id ? a2 = ` (id: ${this.id})` : this.name && (a2 = ` (name: ${this.name} ${this.h.value})`), warn$1(`XFA - node "${this[Er]}"${a2} has already enough "${t2}"!`), false;
      }
      [Pr](e2) {
        return this.hasOwnProperty(e2[Er]) && e2[Dr] === this[Dr];
      }
      [Cr]() {
        return false;
      }
      [Us]() {
        return false;
      }
      [Ar]() {
        return false;
      }
      [xr]() {
        return false;
      }
      [Lr]() {
        this.para && this[pr]()[Js].paraStack.pop();
      }
      [Ur]() {
        this[pr]()[Js].paraStack.push(this.para);
      }
      [Xr](e2) {
        this.id && this[Dr] === to.template.id && e2.set(this.id, this);
      }
      [pr]() {
        return this[fr].template;
      }
      [kr]() {
        return false;
      }
      [Tr]() {
        return false;
      }
      [$s](e2) {
        e2[Fo] = this, this[bo].push(e2), !e2[fr] && this[fr] && (e2[fr] = this[fr]);
      }
      [jr](e2) {
        const t2 = this[bo].indexOf(e2);
        this[bo].splice(t2, 1);
      }
      [mr]() {
        return this.hasOwnProperty("value");
      }
      [Wr](e2) {
      }
      [Rr](e2) {
      }
      [Zs]() {
      }
      [qs](e2) {
        delete this[Co], this[zs] && (e2.clean(this[zs]), delete this[zs]);
      }
      [yr](e2) {
        return this[bo].indexOf(e2);
      }
      [wr](e2, t2) {
        t2[Fo] = this, this[bo].splice(e2, 0, t2), !t2[fr] && this[fr] && (t2[fr] = this[fr]);
      }
      [Ir]() {
        return !this.name;
      }
      [Mr]() {
        return "";
      }
      [Vr]() {
        return 0 === this[bo].length ? this[Vs] : this[bo].map((e2) => e2[Vr]()).join("");
      }
      get [mo]() {
        const e2 = Object.getPrototypeOf(this);
        if (!e2._attributes) {
          const t2 = e2._attributes = /* @__PURE__ */ new Set();
          for (const e3 of Object.getOwnPropertyNames(this)) {
            if (null === this[e3] || this[e3] instanceof XFAObject || this[e3] instanceof XFAObjectArray)
              break;
            t2.add(e3);
          }
        }
        return shadow$1(this, mo, e2._attributes);
      }
      [vr](e2) {
        let t2 = this;
        for (; t2; ) {
          if (t2 === e2)
            return true;
          t2 = t2[gr]();
        }
        return false;
      }
      [gr]() {
        return this[Fo];
      }
      [ur]() {
        return this[gr]();
      }
      [cr](e2 = null) {
        return e2 ? this[e2] : this[bo];
      }
      [Ys]() {
        const e2 = /* @__PURE__ */ Object.create(null);
        this[Vs] && (e2.$content = this[Vs]);
        for (const t2 of Object.getOwnPropertyNames(this)) {
          const i2 = this[t2];
          null !== i2 && (i2 instanceof XFAObject ? e2[t2] = i2[Ys]() : i2 instanceof XFAObjectArray ? i2.isEmpty() || (e2[t2] = i2.dump()) : e2[t2] = i2);
        }
        return e2;
      }
      [Zr]() {
        return null;
      }
      [Yr]() {
        return HTMLResult.EMPTY;
      }
      *[hr]() {
        for (const e2 of this[cr]())
          yield e2;
      }
      *[xo](e2, t2) {
        for (const i2 of this[hr]())
          if (!e2 || t2 === e2.has(i2[Er])) {
            const e3 = this[ir](), t3 = i2[Yr](e3);
            t3.success || (this[Js].failingNode = i2), yield t3;
          }
      }
      [Qs]() {
        return null;
      }
      [js](e2, t2) {
        this[Js].children.push(e2);
      }
      [ir]() {
      }
      [Hs]({ filter: e2 = null, include: t2 = true }) {
        if (this[Js].generator) {
          const e3 = this[ir](), t3 = this[Js].failingNode[Yr](e3);
          if (!t3.success)
            return t3;
          t3.html && this[js](t3.html, t3.bbox), delete this[Js].failingNode;
        } else
          this[Js].generator = this[xo](e2, t2);
        for (; ; ) {
          const e3 = this[Js].generator.next();
          if (e3.done)
            break;
          const t3 = e3.value;
          if (!t3.success)
            return t3;
          t3.html && this[js](t3.html, t3.bbox);
        }
        return this[Js].generator = null, HTMLResult.EMPTY;
      }
      [zr](e2) {
        this[Do] = new Set(Object.keys(e2));
      }
      [vo](e2) {
        const t2 = this[mo], i2 = this[Do];
        return [...e2].filter((e3) => t2.has(e3) && !i2.has(e3));
      }
      [Hr](e2, t2 = /* @__PURE__ */ new Set()) {
        for (const i2 of this[bo])
          i2[Mo](e2, t2);
      }
      [Mo](e2, t2) {
        const i2 = this[So](e2, t2);
        i2 ? this[po](i2, e2, t2) : this[Hr](e2, t2);
      }
      [So](e2, t2) {
        const { use: i2, usehref: a2 } = this;
        if (!i2 && !a2)
          return null;
        let n2 = null, s2 = null, r2 = null, o2 = i2;
        if (a2 ? (o2 = a2, a2.startsWith("#som(") && a2.endsWith(")") ? s2 = a2.slice(5, -1) : a2.startsWith(".#som(") && a2.endsWith(")") ? s2 = a2.slice(6, -1) : a2.startsWith("#") ? r2 = a2.slice(1) : a2.startsWith(".#") && (r2 = a2.slice(2))) : i2.startsWith("#") ? r2 = i2.slice(1) : s2 = i2, this.use = this.usehref = "", r2 ? n2 = e2.get(r2) : (n2 = searchNode(e2.get($r), this, s2, true, false), n2 && (n2 = n2[0])), !n2)
          return warn$1(`XFA - Invalid prototype reference: ${o2}.`), null;
        if (n2[Er] !== this[Er])
          return warn$1(`XFA - Incompatible prototype: ${n2[Er]} !== ${this[Er]}.`), null;
        if (t2.has(n2))
          return warn$1("XFA - Cycle detected in prototypes use."), null;
        t2.add(n2);
        const l3 = n2[So](e2, t2);
        return l3 && n2[po](l3, e2, t2), n2[Hr](e2, t2), t2.delete(n2), n2;
      }
      [po](e2, t2, i2) {
        if (i2.has(e2))
          return void warn$1("XFA - Cycle detected in prototypes use.");
        !this[Vs] && e2[Vs] && (this[Vs] = e2[Vs]);
        new Set(i2).add(e2);
        for (const t3 of this[vo](e2[Do]))
          this[t3] = e2[t3], this[Do] && this[Do].add(t3);
        for (const a2 of Object.getOwnPropertyNames(this)) {
          if (this[mo].has(a2))
            continue;
          const n2 = this[a2], s2 = e2[a2];
          if (n2 instanceof XFAObjectArray) {
            for (const e3 of n2[bo])
              e3[Mo](t2, i2);
            for (let a3 = n2[bo].length, r2 = s2[bo].length; a3 < r2; a3++) {
              const s3 = e2[bo][a3][Ws]();
              if (!n2.push(s3))
                break;
              s3[Fo] = this, this[bo].push(s3), s3[Mo](t2, i2);
            }
          } else if (null === n2) {
            if (null !== s2) {
              const e3 = s2[Ws]();
              e3[Fo] = this, this[a2] = e3, this[bo].push(e3), e3[Mo](t2, i2);
            }
          } else
            n2[Hr](t2, i2), s2 && n2[po](s2, t2, i2);
        }
      }
      static [yo](e2) {
        return Array.isArray(e2) ? e2.map((e3) => XFAObject[yo](e3)) : "object" == typeof e2 && null !== e2 ? Object.assign({}, e2) : e2;
      }
      [Ws]() {
        const e2 = Object.create(Object.getPrototypeOf(this));
        for (const t2 of Object.getOwnPropertySymbols(this))
          try {
            e2[t2] = this[t2];
          } catch {
            shadow$1(e2, t2, this[t2]);
          }
        e2[Qr] = `${e2[Er]}${Oo++}`, e2[bo] = [];
        for (const t2 of Object.getOwnPropertyNames(this)) {
          if (this[mo].has(t2)) {
            e2[t2] = XFAObject[yo](this[t2]);
            continue;
          }
          const i2 = this[t2];
          e2[t2] = i2 instanceof XFAObjectArray ? new XFAObjectArray(i2[ko]) : null;
        }
        for (const t2 of this[bo]) {
          const i2 = t2[Er], a2 = t2[Ws]();
          e2[bo].push(a2), a2[Fo] = e2, null === e2[i2] ? e2[i2] = a2 : e2[i2][bo].push(a2);
        }
        return e2;
      }
      [cr](e2 = null) {
        return e2 ? this[bo].filter((t2) => t2[Er] === e2) : this[bo];
      }
      [ar](e2) {
        return this[e2];
      }
      [nr](e2, t2, i2 = true) {
        return Array.from(this[sr](e2, t2, i2));
      }
      *[sr](e2, t2, i2 = true) {
        if ("parent" !== e2) {
          for (const i3 of this[bo])
            i3[Er] === e2 && (yield i3), i3.name === e2 && (yield i3), (t2 || i3[Ir]()) && (yield* i3[sr](e2, t2, false));
          i2 && this[mo].has(e2) && (yield new XFAAttribute(this, e2, this[e2]));
        } else
          yield this[Fo];
      }
    };
    __name(XFAObject, "XFAObject");
    XFAObjectArray = class {
      constructor(e2 = 1 / 0) {
        this[ko] = e2, this[bo] = [];
      }
      get isXFAObject() {
        return false;
      }
      get isXFAObjectArray() {
        return true;
      }
      push(e2) {
        return this[bo].length <= this[ko] ? (this[bo].push(e2), true) : (warn$1(`XFA - node "${e2[Er]}" accepts no more than ${this[ko]} children`), false);
      }
      isEmpty() {
        return 0 === this[bo].length;
      }
      dump() {
        return 1 === this[bo].length ? this[bo][0][Ys]() : this[bo].map((e2) => e2[Ys]());
      }
      [Ws]() {
        const e2 = new XFAObjectArray(this[ko]);
        return e2[bo] = this[bo].map((e3) => e3[Ws]()), e2;
      }
      get children() {
        return this[bo];
      }
      clear() {
        this[bo].length = 0;
      }
    };
    __name(XFAObjectArray, "XFAObjectArray");
    XFAAttribute = class {
      constructor(e2, t2, i2) {
        this[Fo] = e2, this[Er] = t2, this[Vs] = i2, this[Gs] = false, this[Qr] = "attribute" + Oo++;
      }
      [gr]() {
        return this[Fo];
      }
      [Sr]() {
        return true;
      }
      [rr]() {
        return this[Vs].trim();
      }
      [Wr](e2) {
        e2 = e2.value || "", this[Vs] = e2.toString();
      }
      [Vr]() {
        return this[Vs];
      }
      [vr](e2) {
        return this[Fo] === e2 || this[Fo][vr](e2);
      }
    };
    __name(XFAAttribute, "XFAAttribute");
    XmlObject = class extends XFAObject {
      constructor(e2, t2, i2 = {}) {
        if (super(e2, t2), this[Vs] = "", this[wo] = null, "#text" !== t2) {
          const e3 = /* @__PURE__ */ new Map();
          this[fo] = e3;
          for (const [t3, a2] of Object.entries(i2))
            e3.set(t3, new XFAAttribute(this, t3, a2));
          if (i2.hasOwnProperty(Or)) {
            const e4 = i2[Or].xfa.dataNode;
            void 0 !== e4 && ("dataGroup" === e4 ? this[wo] = false : "dataValue" === e4 && (this[wo] = true));
          }
        }
        this[Gs] = false;
      }
      [Jr](e2) {
        const t2 = this[Er];
        if ("#text" === t2)
          return void e2.push(encodeToXmlString(this[Vs]));
        const i2 = utf8StringToString(t2), a2 = this[Dr] === _o2 ? "xfa:" : "";
        e2.push(`<${a2}${i2}`);
        for (const [t3, i3] of this[fo].entries()) {
          const a3 = utf8StringToString(t3);
          e2.push(` ${a3}="${encodeToXmlString(i3[Vs])}"`);
        }
        if (null !== this[wo] && (this[wo] ? e2.push(' xfa:dataNode="dataValue"') : e2.push(' xfa:dataNode="dataGroup"')), this[Vs] || 0 !== this[bo].length) {
          if (e2.push(">"), this[Vs])
            "string" == typeof this[Vs] ? e2.push(encodeToXmlString(this[Vs])) : this[Vs][Jr](e2);
          else
            for (const t3 of this[bo])
              t3[Jr](e2);
          e2.push(`</${a2}${i2}>`);
        } else
          e2.push("/>");
      }
      [_r2](e2) {
        if (this[Vs]) {
          const e3 = new XmlObject(this[Dr], "#text");
          this[$s](e3), e3[Vs] = this[Vs], this[Vs] = "";
        }
        return this[$s](e2), true;
      }
      [Rr](e2) {
        this[Vs] += e2;
      }
      [Zs]() {
        if (this[Vs] && this[bo].length > 0) {
          const e2 = new XmlObject(this[Dr], "#text");
          this[$s](e2), e2[Vs] = this[Vs], delete this[Vs];
        }
      }
      [Yr]() {
        return "#text" === this[Er] ? HTMLResult.success({ name: "#text", value: this[Vs] }) : HTMLResult.EMPTY;
      }
      [cr](e2 = null) {
        return e2 ? this[bo].filter((t2) => t2[Er] === e2) : this[bo];
      }
      [tr]() {
        return this[fo];
      }
      [ar](e2) {
        const t2 = this[fo].get(e2);
        return void 0 !== t2 ? t2 : this[cr](e2);
      }
      *[sr](e2, t2) {
        const i2 = this[fo].get(e2);
        i2 && (yield i2);
        for (const i3 of this[bo])
          i3[Er] === e2 && (yield i3), t2 && (yield* i3[sr](e2, t2));
      }
      *[er](e2, t2) {
        const i2 = this[fo].get(e2);
        !i2 || t2 && i2[Gs] || (yield i2);
        for (const i3 of this[bo])
          yield* i3[er](e2, t2);
      }
      *[lr](e2, t2, i2) {
        for (const a2 of this[bo])
          a2[Er] !== e2 || i2 && a2[Gs] || (yield a2), t2 && (yield* a2[lr](e2, t2, i2));
      }
      [Sr]() {
        return null === this[wo] ? 0 === this[bo].length || this[bo][0][Dr] === to.xhtml.id : this[wo];
      }
      [rr]() {
        return null === this[wo] ? 0 === this[bo].length ? this[Vs].trim() : this[bo][0][Dr] === to.xhtml.id ? this[bo][0][Vr]().trim() : null : this[Vs].trim();
      }
      [Wr](e2) {
        e2 = e2.value || "", this[Vs] = e2.toString();
      }
      [Ys](e2 = false) {
        const t2 = /* @__PURE__ */ Object.create(null);
        e2 && (t2.$ns = this[Dr]), this[Vs] && (t2.$content = this[Vs]), t2.$name = this[Er], t2.children = [];
        for (const i2 of this[bo])
          t2.children.push(i2[Ys](e2));
        t2.attributes = /* @__PURE__ */ Object.create(null);
        for (const [e3, i2] of this[fo])
          t2.attributes[e3] = i2[Vs];
        return t2;
      }
    };
    __name(XmlObject, "XmlObject");
    ContentObject = class extends XFAObject {
      constructor(e2, t2) {
        super(e2, t2), this[Vs] = "";
      }
      [Rr](e2) {
        this[Vs] += e2;
      }
      [Zs]() {
      }
    };
    __name(ContentObject, "ContentObject");
    OptionObject = class extends ContentObject {
      constructor(e2, t2, i2) {
        super(e2, t2), this[Io] = i2;
      }
      [Zs]() {
        this[Vs] = getKeyword({ data: this[Vs], defaultValue: this[Io][0], validate: (e2) => this[Io].includes(e2) });
      }
      [qs](e2) {
        super[qs](e2), delete this[Io];
      }
    };
    __name(OptionObject, "OptionObject");
    StringObject = class extends ContentObject {
      [Zs]() {
        this[Vs] = this[Vs].trim();
      }
    };
    __name(StringObject, "StringObject");
    IntegerObject = class extends ContentObject {
      constructor(e2, t2, i2, a2) {
        super(e2, t2), this[Ao] = i2, this[Eo] = a2;
      }
      [Zs]() {
        this[Vs] = getInteger({ data: this[Vs], defaultValue: this[Ao], validate: this[Eo] });
      }
      [qs](e2) {
        super[qs](e2), delete this[Ao], delete this[Eo];
      }
    };
    __name(IntegerObject, "IntegerObject");
    Option01 = class extends IntegerObject {
      constructor(e2, t2) {
        super(e2, t2, 0, (e3) => 1 === e3);
      }
    };
    __name(Option01, "Option01");
    Option10 = class extends IntegerObject {
      constructor(e2, t2) {
        super(e2, t2, 1, (e3) => 0 === e3);
      }
    };
    __name(Option10, "Option10");
    __name(measureToString, "measureToString");
    Po = { anchorType(e2, t2) {
      const i2 = e2[ur]();
      if (i2 && (!i2.layout || "position" === i2.layout))
        switch ("transform" in t2 || (t2.transform = ""), e2.anchorType) {
          case "bottomCenter":
            t2.transform += "translate(-50%, -100%)";
            break;
          case "bottomLeft":
            t2.transform += "translate(0,-100%)";
            break;
          case "bottomRight":
            t2.transform += "translate(-100%,-100%)";
            break;
          case "middleCenter":
            t2.transform += "translate(-50%,-50%)";
            break;
          case "middleLeft":
            t2.transform += "translate(0,-50%)";
            break;
          case "middleRight":
            t2.transform += "translate(-100%,-50%)";
            break;
          case "topCenter":
            t2.transform += "translate(-50%,0)";
            break;
          case "topRight":
            t2.transform += "translate(-100%,0)";
        }
    }, dimensions(e2, t2) {
      const i2 = e2[ur]();
      let a2 = e2.w;
      const n2 = e2.h;
      if (i2.layout?.includes("row")) {
        const t3 = i2[Js], n3 = e2.colSpan;
        let s2;
        -1 === n3 ? (s2 = Math.sumPrecise(t3.columnWidths.slice(t3.currentColumn)), t3.currentColumn = 0) : (s2 = Math.sumPrecise(t3.columnWidths.slice(t3.currentColumn, t3.currentColumn + n3)), t3.currentColumn = (t3.currentColumn + e2.colSpan) % t3.columnWidths.length), isNaN(s2) || (a2 = e2.w = s2);
      }
      t2.width = "" !== a2 ? measureToString(a2) : "auto", t2.height = "" !== n2 ? measureToString(n2) : "auto";
    }, position(e2, t2) {
      const i2 = e2[ur]();
      i2?.layout && "position" !== i2.layout || (t2.position = "absolute", t2.left = measureToString(e2.x), t2.top = measureToString(e2.y));
    }, rotate(e2, t2) {
      e2.rotate && ("transform" in t2 || (t2.transform = ""), t2.transform += `rotate(-${e2.rotate}deg)`, t2.transformOrigin = "top left");
    }, presence(e2, t2) {
      switch (e2.presence) {
        case "invisible":
          t2.visibility = "hidden";
          break;
        case "hidden":
        case "inactive":
          t2.display = "none";
      }
    }, hAlign(e2, t2) {
      if ("para" === e2[Er])
        switch (e2.hAlign) {
          case "justifyAll":
            t2.textAlign = "justify-all";
            break;
          case "radix":
            t2.textAlign = "left";
            break;
          default:
            t2.textAlign = e2.hAlign;
        }
      else
        switch (e2.hAlign) {
          case "left":
            t2.alignSelf = "start";
            break;
          case "center":
            t2.alignSelf = "center";
            break;
          case "right":
            t2.alignSelf = "end";
        }
    }, margin(e2, t2) {
      e2.margin && (t2.margin = e2.margin[Zr]().margin);
    } };
    __name(setMinMaxDimensions, "setMinMaxDimensions");
    __name(layoutText, "layoutText");
    __name(layoutNode, "layoutNode");
    __name(computeBbox, "computeBbox");
    __name(fixDimensions, "fixDimensions");
    __name(layoutClass, "layoutClass");
    __name(toStyle, "toStyle");
    __name(createWrapper, "createWrapper");
    __name(fixTextIndent, "fixTextIndent");
    __name(setAccess, "setAccess");
    __name(isPrintOnly, "isPrintOnly");
    __name(getCurrentPara, "getCurrentPara");
    __name(setPara, "setPara");
    __name(setFontFamily, "setFontFamily");
    __name(fixURL, "fixURL");
    __name(createLine, "createLine");
    __name(flushHTML, "flushHTML");
    __name(addHTML, "addHTML");
    __name(getAvailableSpace, "getAvailableSpace");
    __name(checkDimensions, "checkDimensions");
    Ro = to.template.id;
    Bo = "http://www.w3.org/2000/svg";
    No = /^H(\d+)$/;
    Lo = /* @__PURE__ */ new Set(["image/gif", "image/jpeg", "image/jpg", "image/pjpeg", "image/png", "image/apng", "image/x-png", "image/bmp", "image/x-ms-bmp", "image/tiff", "image/tif", "application/octet-stream"]);
    Uo = [[[66, 77], "image/bmp"], [[255, 216, 255], "image/jpeg"], [[73, 73, 42, 0], "image/tiff"], [[77, 77, 0, 42], "image/tiff"], [[71, 73, 70, 56, 57, 97], "image/gif"], [[137, 80, 78, 71, 13, 10, 26, 10], "image/png"]];
    __name(getBorderDims, "getBorderDims");
    __name(hasMargin, "hasMargin");
    __name(_setValue, "_setValue");
    __name(getContainedChildren, "getContainedChildren");
    __name(isRequired, "isRequired");
    __name(setTabIndex, "setTabIndex");
    __name(applyAssist, "applyAssist");
    __name(ariaLabel, "ariaLabel");
    __name(valueToHtml, "valueToHtml");
    __name(setFirstUnsplittable, "setFirstUnsplittable");
    __name(unsetFirstUnsplittable, "unsetFirstUnsplittable");
    __name(handleBreak, "handleBreak");
    __name(handleOverflow, "handleOverflow");
    AppearanceFilter = class extends StringObject {
      constructor(e2) {
        super(Ro, "appearanceFilter"), this.id = e2.id || "", this.type = getStringOption(e2.type, ["optional", "required"]), this.use = e2.use || "", this.usehref = e2.usehref || "";
      }
    };
    __name(AppearanceFilter, "AppearanceFilter");
    Arc = class extends XFAObject {
      constructor(e2) {
        super(Ro, "arc", true), this.circular = getInteger({ data: e2.circular, defaultValue: 0, validate: (e3) => 1 === e3 }), this.hand = getStringOption(e2.hand, ["even", "left", "right"]), this.id = e2.id || "", this.startAngle = getFloat({ data: e2.startAngle, defaultValue: 0, validate: (e3) => true }), this.sweepAngle = getFloat({ data: e2.sweepAngle, defaultValue: 360, validate: (e3) => true }), this.use = e2.use || "", this.usehref = e2.usehref || "", this.edge = null, this.fill = null;
      }
      [Yr]() {
        const e2 = this.edge || new Edge({}), t2 = e2[Zr](), i2 = /* @__PURE__ */ Object.create(null);
        let a2;
        "visible" === this.fill?.presence ? Object.assign(i2, this.fill[Zr]()) : i2.fill = "transparent", i2.strokeWidth = measureToString("visible" === e2.presence ? e2.thickness : 0), i2.stroke = t2.color;
        const n2 = { xmlns: Bo, style: { width: "100%", height: "100%", overflow: "visible" } };
        if (360 === this.sweepAngle)
          a2 = { name: "ellipse", attributes: { xmlns: Bo, cx: "50%", cy: "50%", rx: "50%", ry: "50%", style: i2 } };
        else {
          const e3 = this.startAngle * Math.PI / 180, t3 = this.sweepAngle * Math.PI / 180, s3 = this.sweepAngle > 180 ? 1 : 0, [r2, o2, l3, c2] = [50 * (1 + Math.cos(e3)), 50 * (1 - Math.sin(e3)), 50 * (1 + Math.cos(e3 + t3)), 50 * (1 - Math.sin(e3 + t3))];
          a2 = { name: "path", attributes: { xmlns: Bo, d: `M ${r2} ${o2} A 50 50 0 ${s3} 0 ${l3} ${c2}`, vectorEffect: "non-scaling-stroke", style: i2 } }, Object.assign(n2, { viewBox: "0 0 100 100", preserveAspectRatio: "none" });
        }
        const s2 = { name: "svg", children: [a2], attributes: n2 };
        return hasMargin(this[gr]()[gr]()) ? HTMLResult.success({ name: "div", attributes: { style: { display: "inline", width: "100%", height: "100%" } }, children: [s2] }) : (s2.attributes.style.position = "absolute", HTMLResult.success(s2));
      }
    };
    __name(Arc, "Arc");
    Area = class extends XFAObject {
      constructor(e2) {
        super(Ro, "area", true), this.colSpan = getInteger({ data: e2.colSpan, defaultValue: 1, validate: (e3) => e3 >= 1 || -1 === e3 }), this.id = e2.id || "", this.name = e2.name || "", this.relevant = getRelevant(e2.relevant), this.use = e2.use || "", this.usehref = e2.usehref || "", this.x = getMeasurement(e2.x, "0pt"), this.y = getMeasurement(e2.y, "0pt"), this.desc = null, this.extras = null, this.area = new XFAObjectArray(), this.draw = new XFAObjectArray(), this.exObject = new XFAObjectArray(), this.exclGroup = new XFAObjectArray(), this.field = new XFAObjectArray(), this.subform = new XFAObjectArray(), this.subformSet = new XFAObjectArray();
      }
      *[hr]() {
        yield* getContainedChildren(this);
      }
      [Ir]() {
        return true;
      }
      [xr]() {
        return true;
      }
      [js](e2, t2) {
        const [i2, a2, n2, s2] = t2;
        this[Js].width = Math.max(this[Js].width, i2 + n2), this[Js].height = Math.max(this[Js].height, a2 + s2), this[Js].children.push(e2);
      }
      [ir]() {
        return this[Js].availableSpace;
      }
      [Yr](e2) {
        const t2 = toStyle(this, "position"), i2 = { style: t2, id: this[Qr], class: ["xfaArea"] };
        isPrintOnly(this) && i2.class.push("xfaPrintOnly"), this.name && (i2.xfaName = this.name);
        const a2 = [];
        this[Js] = { children: a2, width: 0, height: 0, availableSpace: e2 };
        const n2 = this[Hs]({ filter: /* @__PURE__ */ new Set(["area", "draw", "field", "exclGroup", "subform", "subformSet"]), include: true });
        if (!n2.success)
          return n2.isBreak() ? n2 : (delete this[Js], HTMLResult.FAILURE);
        t2.width = measureToString(this[Js].width), t2.height = measureToString(this[Js].height);
        const s2 = { name: "div", attributes: i2, children: a2 }, r2 = [this.x, this.y, this[Js].width, this[Js].height];
        return delete this[Js], HTMLResult.success(s2, r2);
      }
    };
    __name(Area, "Area");
    Assist = class extends XFAObject {
      constructor(e2) {
        super(Ro, "assist", true), this.id = e2.id || "", this.role = e2.role || "", this.use = e2.use || "", this.usehref = e2.usehref || "", this.speak = null, this.toolTip = null;
      }
      [Yr]() {
        return this.toolTip?.[Vs] || null;
      }
    };
    __name(Assist, "Assist");
    Barcode = class extends XFAObject {
      constructor(e2) {
        super(Ro, "barcode", true), this.charEncoding = getKeyword({ data: e2.charEncoding ? e2.charEncoding.toLowerCase() : "", defaultValue: "", validate: (e3) => ["utf-8", "big-five", "fontspecific", "gbk", "gb-18030", "gb-2312", "ksc-5601", "none", "shift-jis", "ucs-2", "utf-16"].includes(e3) || e3.match(/iso-8859-\d{2}/) }), this.checksum = getStringOption(e2.checksum, ["none", "1mod10", "1mod10_1mod11", "2mod10", "auto"]), this.dataColumnCount = getInteger({ data: e2.dataColumnCount, defaultValue: -1, validate: (e3) => e3 >= 0 }), this.dataLength = getInteger({ data: e2.dataLength, defaultValue: -1, validate: (e3) => e3 >= 0 }), this.dataPrep = getStringOption(e2.dataPrep, ["none", "flateCompress"]), this.dataRowCount = getInteger({ data: e2.dataRowCount, defaultValue: -1, validate: (e3) => e3 >= 0 }), this.endChar = e2.endChar || "", this.errorCorrectionLevel = getInteger({ data: e2.errorCorrectionLevel, defaultValue: -1, validate: (e3) => e3 >= 0 && e3 <= 8 }), this.id = e2.id || "", this.moduleHeight = getMeasurement(e2.moduleHeight, "5mm"), this.moduleWidth = getMeasurement(e2.moduleWidth, "0.25mm"), this.printCheckDigit = getInteger({ data: e2.printCheckDigit, defaultValue: 0, validate: (e3) => 1 === e3 }), this.rowColumnRatio = getRatio(e2.rowColumnRatio), this.startChar = e2.startChar || "", this.textLocation = getStringOption(e2.textLocation, ["below", "above", "aboveEmbedded", "belowEmbedded", "none"]), this.truncate = getInteger({ data: e2.truncate, defaultValue: 0, validate: (e3) => 1 === e3 }), this.type = getStringOption(e2.type ? e2.type.toLowerCase() : "", ["aztec", "codabar", "code2of5industrial", "code2of5interleaved", "code2of5matrix", "code2of5standard", "code3of9", "code3of9extended", "code11", "code49", "code93", "code128", "code128a", "code128b", "code128c", "code128sscc", "datamatrix", "ean8", "ean8add2", "ean8add5", "ean13", "ean13add2", "ean13add5", "ean13pwcd", "fim", "logmars", "maxicode", "msi", "pdf417", "pdf417macro", "plessey", "postauscust2", "postauscust3", "postausreplypaid", "postausstandard", "postukrm4scc", "postusdpbc", "postusimb", "postusstandard", "postus5zip", "qrcode", "rfid", "rss14", "rss14expanded", "rss14limited", "rss14stacked", "rss14stackedomni", "rss14truncated", "telepen", "ucc128", "ucc128random", "ucc128sscc", "upca", "upcaadd2", "upcaadd5", "upcapwcd", "upce", "upceadd2", "upceadd5", "upcean2", "upcean5", "upsmaxicode"]), this.upsMode = getStringOption(e2.upsMode, ["usCarrier", "internationalCarrier", "secureSymbol", "standardSymbol"]), this.use = e2.use || "", this.usehref = e2.usehref || "", this.wideNarrowRatio = getRatio(e2.wideNarrowRatio), this.encrypt = null, this.extras = null;
      }
    };
    __name(Barcode, "Barcode");
    Bind = class extends XFAObject {
      constructor(e2) {
        super(Ro, "bind", true), this.match = getStringOption(e2.match, ["once", "dataRef", "global", "none"]), this.ref = e2.ref || "", this.picture = null;
      }
    };
    __name(Bind, "Bind");
    BindItems = class extends XFAObject {
      constructor(e2) {
        super(Ro, "bindItems"), this.connection = e2.connection || "", this.labelRef = e2.labelRef || "", this.ref = e2.ref || "", this.valueRef = e2.valueRef || "";
      }
    };
    __name(BindItems, "BindItems");
    Bookend = class extends XFAObject {
      constructor(e2) {
        super(Ro, "bookend"), this.id = e2.id || "", this.leader = e2.leader || "", this.trailer = e2.trailer || "", this.use = e2.use || "", this.usehref = e2.usehref || "";
      }
    };
    __name(Bookend, "Bookend");
    BooleanElement = class extends Option01 {
      constructor(e2) {
        super(Ro, "boolean"), this.id = e2.id || "", this.name = e2.name || "", this.use = e2.use || "", this.usehref = e2.usehref || "";
      }
      [Yr](e2) {
        return valueToHtml(1 === this[Vs] ? "1" : "0");
      }
    };
    __name(BooleanElement, "BooleanElement");
    Border = class extends XFAObject {
      constructor(e2) {
        super(Ro, "border", true), this.break = getStringOption(e2.break, ["close", "open"]), this.hand = getStringOption(e2.hand, ["even", "left", "right"]), this.id = e2.id || "", this.presence = getStringOption(e2.presence, ["visible", "hidden", "inactive", "invisible"]), this.relevant = getRelevant(e2.relevant), this.use = e2.use || "", this.usehref = e2.usehref || "", this.corner = new XFAObjectArray(4), this.edge = new XFAObjectArray(4), this.extras = null, this.fill = null, this.margin = null;
      }
      [or]() {
        if (!this[Js]) {
          const e2 = this.edge.children.slice();
          if (e2.length < 4) {
            const t3 = e2.at(-1) || new Edge({});
            for (let i3 = e2.length; i3 < 4; i3++)
              e2.push(t3);
          }
          const t2 = e2.map((e3) => e3.thickness), i2 = [0, 0, 0, 0];
          this.margin && (i2[0] = this.margin.topInset, i2[1] = this.margin.rightInset, i2[2] = this.margin.bottomInset, i2[3] = this.margin.leftInset), this[Js] = { widths: t2, insets: i2, edges: e2 };
        }
        return this[Js];
      }
      [Zr]() {
        const { edges: e2 } = this[or](), t2 = e2.map((e3) => {
          const t3 = e3[Zr]();
          return t3.color ||= "#000000", t3;
        }), i2 = /* @__PURE__ */ Object.create(null);
        if (this.margin && Object.assign(i2, this.margin[Zr]()), "visible" === this.fill?.presence && Object.assign(i2, this.fill[Zr]()), this.corner.children.some((e3) => 0 !== e3.radius)) {
          const e3 = this.corner.children.map((e4) => e4[Zr]());
          if (2 === e3.length || 3 === e3.length) {
            const t3 = e3.at(-1);
            for (let i3 = e3.length; i3 < 4; i3++)
              e3.push(t3);
          }
          i2.borderRadius = e3.map((e4) => e4.radius).join(" ");
        }
        switch (this.presence) {
          case "invisible":
          case "hidden":
            i2.borderStyle = "";
            break;
          case "inactive":
            i2.borderStyle = "none";
            break;
          default:
            i2.borderStyle = t2.map((e3) => e3.style).join(" ");
        }
        return i2.borderWidth = t2.map((e3) => e3.width).join(" "), i2.borderColor = t2.map((e3) => e3.color).join(" "), i2;
      }
    };
    __name(Border, "Border");
    Break = class extends XFAObject {
      constructor(e2) {
        super(Ro, "break", true), this.after = getStringOption(e2.after, ["auto", "contentArea", "pageArea", "pageEven", "pageOdd"]), this.afterTarget = e2.afterTarget || "", this.before = getStringOption(e2.before, ["auto", "contentArea", "pageArea", "pageEven", "pageOdd"]), this.beforeTarget = e2.beforeTarget || "", this.bookendLeader = e2.bookendLeader || "", this.bookendTrailer = e2.bookendTrailer || "", this.id = e2.id || "", this.overflowLeader = e2.overflowLeader || "", this.overflowTarget = e2.overflowTarget || "", this.overflowTrailer = e2.overflowTrailer || "", this.startNew = getInteger({ data: e2.startNew, defaultValue: 0, validate: (e3) => 1 === e3 }), this.use = e2.use || "", this.usehref = e2.usehref || "", this.extras = null;
      }
    };
    __name(Break, "Break");
    BreakAfter = class extends XFAObject {
      constructor(e2) {
        super(Ro, "breakAfter", true), this.id = e2.id || "", this.leader = e2.leader || "", this.startNew = getInteger({ data: e2.startNew, defaultValue: 0, validate: (e3) => 1 === e3 }), this.target = e2.target || "", this.targetType = getStringOption(e2.targetType, ["auto", "contentArea", "pageArea"]), this.trailer = e2.trailer || "", this.use = e2.use || "", this.usehref = e2.usehref || "", this.script = null;
      }
    };
    __name(BreakAfter, "BreakAfter");
    BreakBefore = class extends XFAObject {
      constructor(e2) {
        super(Ro, "breakBefore", true), this.id = e2.id || "", this.leader = e2.leader || "", this.startNew = getInteger({ data: e2.startNew, defaultValue: 0, validate: (e3) => 1 === e3 }), this.target = e2.target || "", this.targetType = getStringOption(e2.targetType, ["auto", "contentArea", "pageArea"]), this.trailer = e2.trailer || "", this.use = e2.use || "", this.usehref = e2.usehref || "", this.script = null;
      }
      [Yr](e2) {
        return this[Js] = {}, HTMLResult.FAILURE;
      }
    };
    __name(BreakBefore, "BreakBefore");
    Button = class extends XFAObject {
      constructor(e2) {
        super(Ro, "button", true), this.highlight = getStringOption(e2.highlight, ["inverted", "none", "outline", "push"]), this.id = e2.id || "", this.use = e2.use || "", this.usehref = e2.usehref || "", this.extras = null;
      }
      [Yr](e2) {
        const t2 = this[gr]()[gr](), i2 = { name: "button", attributes: { id: this[Qr], class: ["xfaButton"], style: {} }, children: [] };
        for (const e3 of t2.event.children) {
          if ("click" !== e3.activity || !e3.script)
            continue;
          const t3 = recoverJsURL(e3.script[Vs]);
          if (!t3)
            continue;
          const a2 = fixURL(t3.url);
          a2 && i2.children.push({ name: "a", attributes: { id: "link" + this[Qr], href: a2, newWindow: t3.newWindow, class: ["xfaLink"], style: {} }, children: [] });
        }
        return HTMLResult.success(i2);
      }
    };
    __name(Button, "Button");
    Calculate = class extends XFAObject {
      constructor(e2) {
        super(Ro, "calculate", true), this.id = e2.id || "", this.override = getStringOption(e2.override, ["disabled", "error", "ignore", "warning"]), this.use = e2.use || "", this.usehref = e2.usehref || "", this.extras = null, this.message = null, this.script = null;
      }
    };
    __name(Calculate, "Calculate");
    Caption = class extends XFAObject {
      constructor(e2) {
        super(Ro, "caption", true), this.id = e2.id || "", this.placement = getStringOption(e2.placement, ["left", "bottom", "inline", "right", "top"]), this.presence = getStringOption(e2.presence, ["visible", "hidden", "inactive", "invisible"]), this.reserve = Math.ceil(getMeasurement(e2.reserve)), this.use = e2.use || "", this.usehref = e2.usehref || "", this.extras = null, this.font = null, this.margin = null, this.para = null, this.value = null;
      }
      [Wr](e2) {
        _setValue(this, e2);
      }
      [or](e2) {
        if (!this[Js]) {
          let { width: t2, height: i2 } = e2;
          switch (this.placement) {
            case "left":
            case "right":
            case "inline":
              t2 = this.reserve <= 0 ? t2 : this.reserve;
              break;
            case "top":
            case "bottom":
              i2 = this.reserve <= 0 ? i2 : this.reserve;
          }
          this[Js] = layoutNode(this, { width: t2 });
        }
        return this[Js];
      }
      [Yr](e2) {
        if (!this.value)
          return HTMLResult.EMPTY;
        this[Ur]();
        const t2 = this.value[Yr](e2).html;
        if (!t2)
          return this[Lr](), HTMLResult.EMPTY;
        const i2 = this.reserve;
        if (this.reserve <= 0) {
          const { w: t3, h: i3 } = this[or](e2);
          switch (this.placement) {
            case "left":
            case "right":
            case "inline":
              this.reserve = t3;
              break;
            case "top":
            case "bottom":
              this.reserve = i3;
          }
        }
        const a2 = [];
        "string" == typeof t2 ? a2.push({ name: "#text", value: t2 }) : a2.push(t2);
        const n2 = toStyle(this, "font", "margin", "visibility");
        switch (this.placement) {
          case "left":
          case "right":
            this.reserve > 0 && (n2.width = measureToString(this.reserve));
            break;
          case "top":
          case "bottom":
            this.reserve > 0 && (n2.height = measureToString(this.reserve));
        }
        return setPara(this, null, t2), this[Lr](), this.reserve = i2, HTMLResult.success({ name: "div", attributes: { style: n2, class: ["xfaCaption"] }, children: a2 });
      }
    };
    __name(Caption, "Caption");
    Certificate = class extends StringObject {
      constructor(e2) {
        super(Ro, "certificate"), this.id = e2.id || "", this.name = e2.name || "", this.use = e2.use || "", this.usehref = e2.usehref || "";
      }
    };
    __name(Certificate, "Certificate");
    Certificates = class extends XFAObject {
      constructor(e2) {
        super(Ro, "certificates", true), this.credentialServerPolicy = getStringOption(e2.credentialServerPolicy, ["optional", "required"]), this.id = e2.id || "", this.url = e2.url || "", this.urlPolicy = e2.urlPolicy || "", this.use = e2.use || "", this.usehref = e2.usehref || "", this.encryption = null, this.issuers = null, this.keyUsage = null, this.oids = null, this.signing = null, this.subjectDNs = null;
      }
    };
    __name(Certificates, "Certificates");
    CheckButton = class extends XFAObject {
      constructor(e2) {
        super(Ro, "checkButton", true), this.id = e2.id || "", this.mark = getStringOption(e2.mark, ["default", "check", "circle", "cross", "diamond", "square", "star"]), this.shape = getStringOption(e2.shape, ["square", "round"]), this.size = getMeasurement(e2.size, "10pt"), this.use = e2.use || "", this.usehref = e2.usehref || "", this.border = null, this.extras = null, this.margin = null;
      }
      [Yr](e2) {
        const t2 = toStyle(this, "margin"), i2 = measureToString(this.size);
        let a2, n2, s2;
        t2.width = t2.height = i2;
        const r2 = this[gr]()[gr](), o2 = r2.items.children.length && r2.items.children[0][Yr]().html || [], l3 = { on: (void 0 !== o2[0] ? o2[0] : "on").toString(), off: (void 0 !== o2[1] ? o2[1] : "off").toString() }, c2 = (r2.value?.[Vr]() || "off") === l3.on || void 0, h2 = r2[ur](), d2 = r2[Qr];
        let u2;
        h2 instanceof ExclGroup ? (s2 = h2[Qr], a2 = "radio", n2 = "xfaRadio", u2 = h2[Ks]?.[Qr] || h2[Qr]) : (a2 = "checkbox", n2 = "xfaCheckbox", u2 = r2[Ks]?.[Qr] || r2[Qr]);
        const g2 = { name: "input", attributes: { class: [n2], style: t2, fieldId: d2, dataId: u2, type: a2, checked: c2, xfaOn: l3.on, xfaOff: l3.off, "aria-label": ariaLabel(r2), "aria-required": false } };
        return s2 && (g2.attributes.name = s2), isRequired(r2) && (g2.attributes["aria-required"] = true, g2.attributes.required = true), HTMLResult.success({ name: "label", attributes: { class: ["xfaLabel"] }, children: [g2] });
      }
    };
    __name(CheckButton, "CheckButton");
    ChoiceList = class extends XFAObject {
      constructor(e2) {
        super(Ro, "choiceList", true), this.commitOn = getStringOption(e2.commitOn, ["select", "exit"]), this.id = e2.id || "", this.open = getStringOption(e2.open, ["userControl", "always", "multiSelect", "onEntry"]), this.textEntry = getInteger({ data: e2.textEntry, defaultValue: 0, validate: (e3) => 1 === e3 }), this.use = e2.use || "", this.usehref = e2.usehref || "", this.border = null, this.extras = null, this.margin = null;
      }
      [Yr](e2) {
        const t2 = toStyle(this, "border", "margin"), i2 = this[gr]()[gr](), a2 = { fontSize: `calc(${i2.font?.size || 10}px * var(--total-scale-factor))` }, n2 = [];
        if (i2.items.children.length > 0) {
          const e3 = i2.items;
          let t3 = 0, s3 = 0;
          2 === e3.children.length && (t3 = e3.children[0].save, s3 = 1 - t3);
          const r2 = e3.children[t3][Yr]().html, o2 = e3.children[s3][Yr]().html;
          let l3 = false;
          const c2 = i2.value?.[Vr]() || "";
          for (let e4 = 0, t4 = r2.length; e4 < t4; e4++) {
            const t5 = { name: "option", attributes: { value: o2[e4] || r2[e4], style: a2 }, value: r2[e4] };
            o2[e4] === c2 && (t5.attributes.selected = l3 = true), n2.push(t5);
          }
          l3 || n2.splice(0, 0, { name: "option", attributes: { hidden: true, selected: true }, value: " " });
        }
        const s2 = { class: ["xfaSelect"], fieldId: i2[Qr], dataId: i2[Ks]?.[Qr] || i2[Qr], style: t2, "aria-label": ariaLabel(i2), "aria-required": false };
        return isRequired(i2) && (s2["aria-required"] = true, s2.required = true), "multiSelect" === this.open && (s2.multiple = true), HTMLResult.success({ name: "label", attributes: { class: ["xfaLabel"] }, children: [{ name: "select", children: n2, attributes: s2 }] });
      }
    };
    __name(ChoiceList, "ChoiceList");
    Color = class extends XFAObject {
      constructor(e2) {
        super(Ro, "color", true), this.cSpace = getStringOption(e2.cSpace, ["SRGB"]), this.id = e2.id || "", this.use = e2.use || "", this.usehref = e2.usehref || "", this.value = e2.value ? function(e3, t2 = [0, 0, 0]) {
          let [i2, a2, n2] = t2;
          if (!e3)
            return { r: i2, g: a2, b: n2 };
          const s2 = e3.split(",", 3).map((e4) => MathClamp$1(parseInt(e4.trim(), 10), 0, 255)).map((e4) => isNaN(e4) ? 0 : e4);
          return s2.length < 3 || ([i2, a2, n2] = s2), { r: i2, g: a2, b: n2 };
        }(e2.value) : "", this.extras = null;
      }
      [mr]() {
        return false;
      }
      [Zr]() {
        return this.value ? ni.makeHexColor(this.value.r, this.value.g, this.value.b) : null;
      }
    };
    __name(Color, "Color");
    Comb = class extends XFAObject {
      constructor(e2) {
        super(Ro, "comb"), this.id = e2.id || "", this.numberOfCells = getInteger({ data: e2.numberOfCells, defaultValue: 0, validate: (e3) => e3 >= 0 }), this.use = e2.use || "", this.usehref = e2.usehref || "";
      }
    };
    __name(Comb, "Comb");
    Connect = class extends XFAObject {
      constructor(e2) {
        super(Ro, "connect", true), this.connection = e2.connection || "", this.id = e2.id || "", this.ref = e2.ref || "", this.usage = getStringOption(e2.usage, ["exportAndImport", "exportOnly", "importOnly"]), this.use = e2.use || "", this.usehref = e2.usehref || "", this.picture = null;
      }
    };
    __name(Connect, "Connect");
    ContentArea = class extends XFAObject {
      constructor(e2) {
        super(Ro, "contentArea", true), this.h = getMeasurement(e2.h), this.id = e2.id || "", this.name = e2.name || "", this.relevant = getRelevant(e2.relevant), this.use = e2.use || "", this.usehref = e2.usehref || "", this.w = getMeasurement(e2.w), this.x = getMeasurement(e2.x, "0pt"), this.y = getMeasurement(e2.y, "0pt"), this.desc = null, this.extras = null;
      }
      [Yr](e2) {
        const t2 = { left: measureToString(this.x), top: measureToString(this.y), width: measureToString(this.w), height: measureToString(this.h) }, i2 = ["xfaContentarea"];
        return isPrintOnly(this) && i2.push("xfaPrintOnly"), HTMLResult.success({ name: "div", children: [], attributes: { style: t2, class: i2, id: this[Qr] } });
      }
    };
    __name(ContentArea, "ContentArea");
    Corner = class extends XFAObject {
      constructor(e2) {
        super(Ro, "corner", true), this.id = e2.id || "", this.inverted = getInteger({ data: e2.inverted, defaultValue: 0, validate: (e3) => 1 === e3 }), this.join = getStringOption(e2.join, ["square", "round"]), this.presence = getStringOption(e2.presence, ["visible", "hidden", "inactive", "invisible"]), this.radius = getMeasurement(e2.radius), this.stroke = getStringOption(e2.stroke, ["solid", "dashDot", "dashDotDot", "dashed", "dotted", "embossed", "etched", "lowered", "raised"]), this.thickness = getMeasurement(e2.thickness, "0.5pt"), this.use = e2.use || "", this.usehref = e2.usehref || "", this.color = null, this.extras = null;
      }
      [Zr]() {
        const e2 = toStyle(this, "visibility");
        return e2.radius = measureToString("square" === this.join ? 0 : this.radius), e2;
      }
    };
    __name(Corner, "Corner");
    DateElement = class extends ContentObject {
      constructor(e2) {
        super(Ro, "date"), this.id = e2.id || "", this.name = e2.name || "", this.use = e2.use || "", this.usehref = e2.usehref || "";
      }
      [Zs]() {
        const e2 = this[Vs].trim();
        this[Vs] = e2 ? new Date(e2) : null;
      }
      [Yr](e2) {
        return valueToHtml(this[Vs] ? this[Vs].toString() : "");
      }
    };
    __name(DateElement, "DateElement");
    DateTime = class extends ContentObject {
      constructor(e2) {
        super(Ro, "dateTime"), this.id = e2.id || "", this.name = e2.name || "", this.use = e2.use || "", this.usehref = e2.usehref || "";
      }
      [Zs]() {
        const e2 = this[Vs].trim();
        this[Vs] = e2 ? new Date(e2) : null;
      }
      [Yr](e2) {
        return valueToHtml(this[Vs] ? this[Vs].toString() : "");
      }
    };
    __name(DateTime, "DateTime");
    DateTimeEdit = class extends XFAObject {
      constructor(e2) {
        super(Ro, "dateTimeEdit", true), this.hScrollPolicy = getStringOption(e2.hScrollPolicy, ["auto", "off", "on"]), this.id = e2.id || "", this.picker = getStringOption(e2.picker, ["host", "none"]), this.use = e2.use || "", this.usehref = e2.usehref || "", this.border = null, this.comb = null, this.extras = null, this.margin = null;
      }
      [Yr](e2) {
        const t2 = toStyle(this, "border", "font", "margin"), i2 = this[gr]()[gr](), a2 = { name: "input", attributes: { type: "text", fieldId: i2[Qr], dataId: i2[Ks]?.[Qr] || i2[Qr], class: ["xfaTextfield"], style: t2, "aria-label": ariaLabel(i2), "aria-required": false } };
        return isRequired(i2) && (a2.attributes["aria-required"] = true, a2.attributes.required = true), HTMLResult.success({ name: "label", attributes: { class: ["xfaLabel"] }, children: [a2] });
      }
    };
    __name(DateTimeEdit, "DateTimeEdit");
    Decimal = class extends ContentObject {
      constructor(e2) {
        super(Ro, "decimal"), this.fracDigits = getInteger({ data: e2.fracDigits, defaultValue: 2, validate: (e3) => true }), this.id = e2.id || "", this.leadDigits = getInteger({ data: e2.leadDigits, defaultValue: -1, validate: (e3) => true }), this.name = e2.name || "", this.use = e2.use || "", this.usehref = e2.usehref || "";
      }
      [Zs]() {
        const e2 = parseFloat(this[Vs].trim());
        this[Vs] = isNaN(e2) ? null : e2;
      }
      [Yr](e2) {
        return valueToHtml(null !== this[Vs] ? this[Vs].toString() : "");
      }
    };
    __name(Decimal, "Decimal");
    DefaultUi = class extends XFAObject {
      constructor(e2) {
        super(Ro, "defaultUi", true), this.id = e2.id || "", this.use = e2.use || "", this.usehref = e2.usehref || "", this.extras = null;
      }
    };
    __name(DefaultUi, "DefaultUi");
    Desc = class extends XFAObject {
      constructor(e2) {
        super(Ro, "desc", true), this.id = e2.id || "", this.use = e2.use || "", this.usehref = e2.usehref || "", this.boolean = new XFAObjectArray(), this.date = new XFAObjectArray(), this.dateTime = new XFAObjectArray(), this.decimal = new XFAObjectArray(), this.exData = new XFAObjectArray(), this.float = new XFAObjectArray(), this.image = new XFAObjectArray(), this.integer = new XFAObjectArray(), this.text = new XFAObjectArray(), this.time = new XFAObjectArray();
      }
    };
    __name(Desc, "Desc");
    DigestMethod = class extends OptionObject {
      constructor(e2) {
        super(Ro, "digestMethod", ["", "SHA1", "SHA256", "SHA512", "RIPEMD160"]), this.id = e2.id || "", this.use = e2.use || "", this.usehref = e2.usehref || "";
      }
    };
    __name(DigestMethod, "DigestMethod");
    DigestMethods = class extends XFAObject {
      constructor(e2) {
        super(Ro, "digestMethods", true), this.id = e2.id || "", this.type = getStringOption(e2.type, ["optional", "required"]), this.use = e2.use || "", this.usehref = e2.usehref || "", this.digestMethod = new XFAObjectArray();
      }
    };
    __name(DigestMethods, "DigestMethods");
    Draw = class extends XFAObject {
      constructor(e2) {
        super(Ro, "draw", true), this.anchorType = getStringOption(e2.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]), this.colSpan = getInteger({ data: e2.colSpan, defaultValue: 1, validate: (e3) => e3 >= 1 || -1 === e3 }), this.h = e2.h ? getMeasurement(e2.h) : "", this.hAlign = getStringOption(e2.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]), this.id = e2.id || "", this.locale = e2.locale || "", this.maxH = getMeasurement(e2.maxH, "0pt"), this.maxW = getMeasurement(e2.maxW, "0pt"), this.minH = getMeasurement(e2.minH, "0pt"), this.minW = getMeasurement(e2.minW, "0pt"), this.name = e2.name || "", this.presence = getStringOption(e2.presence, ["visible", "hidden", "inactive", "invisible"]), this.relevant = getRelevant(e2.relevant), this.rotate = getInteger({ data: e2.rotate, defaultValue: 0, validate: (e3) => e3 % 90 == 0 }), this.use = e2.use || "", this.usehref = e2.usehref || "", this.w = e2.w ? getMeasurement(e2.w) : "", this.x = getMeasurement(e2.x, "0pt"), this.y = getMeasurement(e2.y, "0pt"), this.assist = null, this.border = null, this.caption = null, this.desc = null, this.extras = null, this.font = null, this.keep = null, this.margin = null, this.para = null, this.traversal = null, this.ui = null, this.value = null, this.setProperty = new XFAObjectArray();
      }
      [Wr](e2) {
        _setValue(this, e2);
      }
      [Yr](e2) {
        if (setTabIndex(this), "hidden" === this.presence || "inactive" === this.presence)
          return HTMLResult.EMPTY;
        fixDimensions(this), this[Ur]();
        const t2 = this.w, i2 = this.h, { w: a2, h: n2, isBroken: s2 } = layoutNode(this, e2);
        if (a2 && "" === this.w) {
          if (s2 && this[ur]()[Tr]())
            return this[Lr](), HTMLResult.FAILURE;
          this.w = a2;
        }
        if (n2 && "" === this.h && (this.h = n2), setFirstUnsplittable(this), !checkDimensions(this, e2))
          return this.w = t2, this.h = i2, this[Lr](), HTMLResult.FAILURE;
        unsetFirstUnsplittable(this);
        const r2 = toStyle(this, "font", "hAlign", "dimensions", "position", "presence", "rotate", "anchorType", "border", "margin");
        setMinMaxDimensions(this, r2), r2.margin && (r2.padding = r2.margin, delete r2.margin);
        const o2 = ["xfaDraw"];
        this.font && o2.push("xfaFont"), isPrintOnly(this) && o2.push("xfaPrintOnly");
        const l3 = { style: r2, id: this[Qr], class: o2 };
        this.name && (l3.xfaName = this.name);
        const c2 = { name: "div", attributes: l3, children: [] };
        applyAssist(this, l3);
        const h2 = computeBbox(this, c2, e2), d2 = this.value ? this.value[Yr](e2).html : null;
        return null === d2 ? (this.w = t2, this.h = i2, this[Lr](), HTMLResult.success(createWrapper(this, c2), h2)) : (c2.children.push(d2), setPara(this, r2, d2), this.w = t2, this.h = i2, this[Lr](), HTMLResult.success(createWrapper(this, c2), h2));
      }
    };
    __name(Draw, "Draw");
    Edge = class extends XFAObject {
      constructor(e2) {
        super(Ro, "edge", true), this.cap = getStringOption(e2.cap, ["square", "butt", "round"]), this.id = e2.id || "", this.presence = getStringOption(e2.presence, ["visible", "hidden", "inactive", "invisible"]), this.stroke = getStringOption(e2.stroke, ["solid", "dashDot", "dashDotDot", "dashed", "dotted", "embossed", "etched", "lowered", "raised"]), this.thickness = getMeasurement(e2.thickness, "0.5pt"), this.use = e2.use || "", this.usehref = e2.usehref || "", this.color = null, this.extras = null;
      }
      [Zr]() {
        const e2 = toStyle(this, "visibility");
        if (Object.assign(e2, { linecap: this.cap, width: measureToString(this.thickness), color: this.color ? this.color[Zr]() : "#000000", style: "" }), "visible" !== this.presence)
          e2.style = "none";
        else
          switch (this.stroke) {
            case "solid":
              e2.style = "solid";
              break;
            case "dashDot":
            case "dashDotDot":
            case "dashed":
              e2.style = "dashed";
              break;
            case "dotted":
              e2.style = "dotted";
              break;
            case "embossed":
              e2.style = "ridge";
              break;
            case "etched":
              e2.style = "groove";
              break;
            case "lowered":
              e2.style = "inset";
              break;
            case "raised":
              e2.style = "outset";
          }
        return e2;
      }
    };
    __name(Edge, "Edge");
    Encoding = class extends OptionObject {
      constructor(e2) {
        super(Ro, "encoding", ["adbe.x509.rsa_sha1", "adbe.pkcs7.detached", "adbe.pkcs7.sha1"]), this.id = e2.id || "", this.use = e2.use || "", this.usehref = e2.usehref || "";
      }
    };
    __name(Encoding, "Encoding");
    Encodings = class extends XFAObject {
      constructor(e2) {
        super(Ro, "encodings", true), this.id = e2.id || "", this.type = getStringOption(e2.type, ["optional", "required"]), this.use = e2.use || "", this.usehref = e2.usehref || "", this.encoding = new XFAObjectArray();
      }
    };
    __name(Encodings, "Encodings");
    Encrypt = class extends XFAObject {
      constructor(e2) {
        super(Ro, "encrypt", true), this.id = e2.id || "", this.use = e2.use || "", this.usehref = e2.usehref || "", this.certificate = null;
      }
    };
    __name(Encrypt, "Encrypt");
    EncryptData = class extends XFAObject {
      constructor(e2) {
        super(Ro, "encryptData", true), this.id = e2.id || "", this.operation = getStringOption(e2.operation, ["encrypt", "decrypt"]), this.target = e2.target || "", this.use = e2.use || "", this.usehref = e2.usehref || "", this.filter = null, this.manifest = null;
      }
    };
    __name(EncryptData, "EncryptData");
    Encryption = class extends XFAObject {
      constructor(e2) {
        super(Ro, "encryption", true), this.id = e2.id || "", this.type = getStringOption(e2.type, ["optional", "required"]), this.use = e2.use || "", this.usehref = e2.usehref || "", this.certificate = new XFAObjectArray();
      }
    };
    __name(Encryption, "Encryption");
    EncryptionMethod = class extends OptionObject {
      constructor(e2) {
        super(Ro, "encryptionMethod", ["", "AES256-CBC", "TRIPLEDES-CBC", "AES128-CBC", "AES192-CBC"]), this.id = e2.id || "", this.use = e2.use || "", this.usehref = e2.usehref || "";
      }
    };
    __name(EncryptionMethod, "EncryptionMethod");
    EncryptionMethods = class extends XFAObject {
      constructor(e2) {
        super(Ro, "encryptionMethods", true), this.id = e2.id || "", this.type = getStringOption(e2.type, ["optional", "required"]), this.use = e2.use || "", this.usehref = e2.usehref || "", this.encryptionMethod = new XFAObjectArray();
      }
    };
    __name(EncryptionMethods, "EncryptionMethods");
    jo = /* @__PURE__ */ __name(class extends XFAObject {
      constructor(e2) {
        super(Ro, "event", true), this.activity = getStringOption(e2.activity, ["click", "change", "docClose", "docReady", "enter", "exit", "full", "indexChange", "initialize", "mouseDown", "mouseEnter", "mouseExit", "mouseUp", "postExecute", "postOpen", "postPrint", "postSave", "postSign", "postSubmit", "preExecute", "preOpen", "prePrint", "preSave", "preSign", "preSubmit", "ready", "validationState"]), this.id = e2.id || "", this.listen = getStringOption(e2.listen, ["refOnly", "refAndDescendents"]), this.name = e2.name || "", this.ref = e2.ref || "", this.use = e2.use || "", this.usehref = e2.usehref || "", this.extras = null, this.encryptData = null, this.execute = null, this.script = null, this.signData = null, this.submit = null;
      }
    }, "jo");
    ExData = class extends ContentObject {
      constructor(e2) {
        super(Ro, "exData"), this.contentType = e2.contentType || "", this.href = e2.href || "", this.id = e2.id || "", this.maxLength = getInteger({ data: e2.maxLength, defaultValue: -1, validate: (e3) => e3 >= -1 }), this.name = e2.name || "", this.rid = e2.rid || "", this.transferEncoding = getStringOption(e2.transferEncoding, ["none", "base64", "package"]), this.use = e2.use || "", this.usehref = e2.usehref || "";
      }
      [Ar]() {
        return "text/html" === this.contentType;
      }
      [_r2](e2) {
        return ("text/html" === this.contentType && e2[Dr] === to.xhtml.id || "text/xml" === this.contentType) && (this[Vs] = e2, true);
      }
      [Yr](e2) {
        return "text/html" === this.contentType && this[Vs] ? this[Vs][Yr](e2) : HTMLResult.EMPTY;
      }
    };
    __name(ExData, "ExData");
    ExObject = class extends XFAObject {
      constructor(e2) {
        super(Ro, "exObject", true), this.archive = e2.archive || "", this.classId = e2.classId || "", this.codeBase = e2.codeBase || "", this.codeType = e2.codeType || "", this.id = e2.id || "", this.name = e2.name || "", this.use = e2.use || "", this.usehref = e2.usehref || "", this.extras = null, this.boolean = new XFAObjectArray(), this.date = new XFAObjectArray(), this.dateTime = new XFAObjectArray(), this.decimal = new XFAObjectArray(), this.exData = new XFAObjectArray(), this.exObject = new XFAObjectArray(), this.float = new XFAObjectArray(), this.image = new XFAObjectArray(), this.integer = new XFAObjectArray(), this.text = new XFAObjectArray(), this.time = new XFAObjectArray();
      }
    };
    __name(ExObject, "ExObject");
    ExclGroup = class extends XFAObject {
      constructor(e2) {
        super(Ro, "exclGroup", true), this.access = getStringOption(e2.access, ["open", "nonInteractive", "protected", "readOnly"]), this.accessKey = e2.accessKey || "", this.anchorType = getStringOption(e2.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]), this.colSpan = getInteger({ data: e2.colSpan, defaultValue: 1, validate: (e3) => e3 >= 1 || -1 === e3 }), this.h = e2.h ? getMeasurement(e2.h) : "", this.hAlign = getStringOption(e2.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]), this.id = e2.id || "", this.layout = getStringOption(e2.layout, ["position", "lr-tb", "rl-row", "rl-tb", "row", "table", "tb"]), this.maxH = getMeasurement(e2.maxH, "0pt"), this.maxW = getMeasurement(e2.maxW, "0pt"), this.minH = getMeasurement(e2.minH, "0pt"), this.minW = getMeasurement(e2.minW, "0pt"), this.name = e2.name || "", this.presence = getStringOption(e2.presence, ["visible", "hidden", "inactive", "invisible"]), this.relevant = getRelevant(e2.relevant), this.use = e2.use || "", this.usehref = e2.usehref || "", this.w = e2.w ? getMeasurement(e2.w) : "", this.x = getMeasurement(e2.x, "0pt"), this.y = getMeasurement(e2.y, "0pt"), this.assist = null, this.bind = null, this.border = null, this.calculate = null, this.caption = null, this.desc = null, this.extras = null, this.margin = null, this.para = null, this.traversal = null, this.validate = null, this.connect = new XFAObjectArray(), this.event = new XFAObjectArray(), this.field = new XFAObjectArray(), this.setProperty = new XFAObjectArray();
      }
      [xr]() {
        return true;
      }
      [mr]() {
        return true;
      }
      [Wr](e2) {
        for (const t2 of this.field.children) {
          if (!t2.value) {
            const e3 = new Value({});
            t2[$s](e3), t2.value = e3;
          }
          t2.value[Wr](e2);
        }
      }
      [Tr]() {
        return this.layout.endsWith("-tb") && 0 === this[Js].attempt && this[Js].numberInLine > 0 || this[gr]()[Tr]();
      }
      [kr]() {
        const e2 = this[ur]();
        return !!e2[kr]() && (void 0 !== this[Js]._isSplittable ? this[Js]._isSplittable : "position" === this.layout || this.layout.includes("row") ? (this[Js]._isSplittable = false, false) : (!e2.layout?.endsWith("-tb") || 0 === e2[Js].numberInLine) && (this[Js]._isSplittable = true, true));
      }
      [Qs]() {
        return flushHTML(this);
      }
      [js](e2, t2) {
        addHTML(this, e2, t2);
      }
      [ir]() {
        return getAvailableSpace(this);
      }
      [Yr](e2) {
        if (setTabIndex(this), "hidden" === this.presence || "inactive" === this.presence || 0 === this.h || 0 === this.w)
          return HTMLResult.EMPTY;
        fixDimensions(this);
        const t2 = [], i2 = { id: this[Qr], class: [] };
        setAccess(this, i2.class), this[Js] ||= /* @__PURE__ */ Object.create(null), Object.assign(this[Js], { children: t2, attributes: i2, attempt: 0, line: null, numberInLine: 0, availableSpace: { width: Math.min(this.w || 1 / 0, e2.width), height: Math.min(this.h || 1 / 0, e2.height) }, width: 0, height: 0, prevHeight: 0, currentWidth: 0 });
        const a2 = this[kr]();
        if (a2 || setFirstUnsplittable(this), !checkDimensions(this, e2))
          return HTMLResult.FAILURE;
        const n2 = /* @__PURE__ */ new Set(["field"]);
        if (this.layout.includes("row")) {
          const e3 = this[ur]().columnWidths;
          Array.isArray(e3) && e3.length > 0 && (this[Js].columnWidths = e3, this[Js].currentColumn = 0);
        }
        const s2 = toStyle(this, "anchorType", "dimensions", "position", "presence", "border", "margin", "hAlign"), r2 = ["xfaExclgroup"], o2 = layoutClass(this);
        o2 && r2.push(o2), isPrintOnly(this) && r2.push("xfaPrintOnly"), i2.style = s2, i2.class = r2, this.name && (i2.xfaName = this.name), this[Ur]();
        const l3 = "lr-tb" === this.layout || "rl-tb" === this.layout, c2 = l3 ? 2 : 1;
        for (; this[Js].attempt < c2; this[Js].attempt++) {
          l3 && 1 === this[Js].attempt && (this[Js].numberInLine = 0);
          const e3 = this[Hs]({ filter: n2, include: true });
          if (e3.success)
            break;
          if (e3.isBreak())
            return this[Lr](), e3;
          if (l3 && 0 === this[Js].attempt && 0 === this[Js].numberInLine && !this[pr]()[Js].noLayoutFailure) {
            this[Js].attempt = c2;
            break;
          }
        }
        if (this[Lr](), a2 || unsetFirstUnsplittable(this), this[Js].attempt === c2)
          return a2 || delete this[Js], HTMLResult.FAILURE;
        let h2 = 0, d2 = 0;
        this.margin && (h2 = this.margin.leftInset + this.margin.rightInset, d2 = this.margin.topInset + this.margin.bottomInset);
        const u2 = Math.max(this[Js].width + h2, this.w || 0), g2 = Math.max(this[Js].height + d2, this.h || 0), p2 = [this.x, this.y, u2, g2];
        "" === this.w && (s2.width = measureToString(u2)), "" === this.h && (s2.height = measureToString(g2));
        const f2 = { name: "div", attributes: i2, children: t2 };
        return applyAssist(this, i2), delete this[Js], HTMLResult.success(createWrapper(this, f2), p2);
      }
    };
    __name(ExclGroup, "ExclGroup");
    Execute = class extends XFAObject {
      constructor(e2) {
        super(Ro, "execute"), this.connection = e2.connection || "", this.executeType = getStringOption(e2.executeType, ["import", "remerge"]), this.id = e2.id || "", this.runAt = getStringOption(e2.runAt, ["client", "both", "server"]), this.use = e2.use || "", this.usehref = e2.usehref || "";
      }
    };
    __name(Execute, "Execute");
    Extras = class extends XFAObject {
      constructor(e2) {
        super(Ro, "extras", true), this.id = e2.id || "", this.name = e2.name || "", this.use = e2.use || "", this.usehref = e2.usehref || "", this.boolean = new XFAObjectArray(), this.date = new XFAObjectArray(), this.dateTime = new XFAObjectArray(), this.decimal = new XFAObjectArray(), this.exData = new XFAObjectArray(), this.extras = new XFAObjectArray(), this.float = new XFAObjectArray(), this.image = new XFAObjectArray(), this.integer = new XFAObjectArray(), this.text = new XFAObjectArray(), this.time = new XFAObjectArray();
      }
    };
    __name(Extras, "Extras");
    Field = class extends XFAObject {
      constructor(e2) {
        super(Ro, "field", true), this.access = getStringOption(e2.access, ["open", "nonInteractive", "protected", "readOnly"]), this.accessKey = e2.accessKey || "", this.anchorType = getStringOption(e2.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]), this.colSpan = getInteger({ data: e2.colSpan, defaultValue: 1, validate: (e3) => e3 >= 1 || -1 === e3 }), this.h = e2.h ? getMeasurement(e2.h) : "", this.hAlign = getStringOption(e2.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]), this.id = e2.id || "", this.locale = e2.locale || "", this.maxH = getMeasurement(e2.maxH, "0pt"), this.maxW = getMeasurement(e2.maxW, "0pt"), this.minH = getMeasurement(e2.minH, "0pt"), this.minW = getMeasurement(e2.minW, "0pt"), this.name = e2.name || "", this.presence = getStringOption(e2.presence, ["visible", "hidden", "inactive", "invisible"]), this.relevant = getRelevant(e2.relevant), this.rotate = getInteger({ data: e2.rotate, defaultValue: 0, validate: (e3) => e3 % 90 == 0 }), this.use = e2.use || "", this.usehref = e2.usehref || "", this.w = e2.w ? getMeasurement(e2.w) : "", this.x = getMeasurement(e2.x, "0pt"), this.y = getMeasurement(e2.y, "0pt"), this.assist = null, this.bind = null, this.border = null, this.calculate = null, this.caption = null, this.desc = null, this.extras = null, this.font = null, this.format = null, this.items = new XFAObjectArray(2), this.keep = null, this.margin = null, this.para = null, this.traversal = null, this.ui = null, this.validate = null, this.value = null, this.bindItems = new XFAObjectArray(), this.connect = new XFAObjectArray(), this.event = new XFAObjectArray(), this.setProperty = new XFAObjectArray();
      }
      [xr]() {
        return true;
      }
      [Wr](e2) {
        _setValue(this, e2);
      }
      [Yr](e2) {
        if (setTabIndex(this), !this.ui) {
          let e3;
          switch (this.ui = new Ui({}), this.ui[fr] = this[fr], this[$s](this.ui), this.items.children.length) {
            case 0:
              e3 = new TextEdit({}), this.ui.textEdit = e3;
              break;
            case 1:
              e3 = new CheckButton({}), this.ui.checkButton = e3;
              break;
            case 2:
              e3 = new ChoiceList({}), this.ui.choiceList = e3;
          }
          this.ui[$s](e3);
        }
        if (!this.ui || "hidden" === this.presence || "inactive" === this.presence || 0 === this.h || 0 === this.w)
          return HTMLResult.EMPTY;
        this.caption && delete this.caption[Js], this[Ur]();
        const t2 = this.caption ? this.caption[Yr](e2).html : null, i2 = this.w, a2 = this.h;
        let n2 = 0, s2 = 0;
        this.margin && (n2 = this.margin.leftInset + this.margin.rightInset, s2 = this.margin.topInset + this.margin.bottomInset);
        let r2 = null;
        if ("" === this.w || "" === this.h) {
          let t3 = null, i3 = null, a3 = 0, o3 = 0;
          if (this.ui.checkButton)
            a3 = o3 = this.ui.checkButton.size;
          else {
            const { w: t4, h: i4 } = layoutNode(this, e2);
            null !== t4 ? (a3 = t4, o3 = i4) : o3 = function(e3, t5 = false) {
              let i5 = null;
              if (e3) {
                const t6 = stripQuotes(e3.typeface), a5 = e3[fr].fontFinder.find(t6);
                i5 = selectFont(e3, a5);
              }
              if (!i5)
                return { lineHeight: 12, lineGap: 2, lineNoGap: 10 };
              const a4 = e3.size || 10, n3 = i5.lineHeight ? Math.max(t5 ? 0 : 1.2, i5.lineHeight) : 1.2, s3 = void 0 === i5.lineGap ? 0.2 : i5.lineGap;
              return { lineHeight: n3 * a4, lineGap: s3 * a4, lineNoGap: Math.max(1, n3 - s3) * a4 };
            }(this.font, true).lineNoGap;
          }
          if (r2 = getBorderDims(this.ui[or]()), a3 += r2.w, o3 += r2.h, this.caption) {
            const { w: n3, h: s3, isBroken: r3 } = this.caption[or](e2);
            if (r3 && this[ur]()[Tr]())
              return this[Lr](), HTMLResult.FAILURE;
            switch (t3 = n3, i3 = s3, this.caption.placement) {
              case "left":
              case "right":
              case "inline":
                t3 += a3;
                break;
              case "top":
              case "bottom":
                i3 += o3;
            }
          } else
            t3 = a3, i3 = o3;
          t3 && "" === this.w && (t3 += n2, this.w = Math.min(this.maxW <= 0 ? 1 / 0 : this.maxW, this.minW + 1 < t3 ? t3 : this.minW)), i3 && "" === this.h && (i3 += s2, this.h = Math.min(this.maxH <= 0 ? 1 / 0 : this.maxH, this.minH + 1 < i3 ? i3 : this.minH));
        }
        if (this[Lr](), fixDimensions(this), setFirstUnsplittable(this), !checkDimensions(this, e2))
          return this.w = i2, this.h = a2, this[Lr](), HTMLResult.FAILURE;
        unsetFirstUnsplittable(this);
        const o2 = toStyle(this, "font", "dimensions", "position", "rotate", "anchorType", "presence", "margin", "hAlign");
        setMinMaxDimensions(this, o2);
        const l3 = ["xfaField"];
        this.font && l3.push("xfaFont"), isPrintOnly(this) && l3.push("xfaPrintOnly");
        const c2 = { style: o2, id: this[Qr], class: l3 };
        o2.margin && (o2.padding = o2.margin, delete o2.margin), setAccess(this, l3), this.name && (c2.xfaName = this.name);
        const h2 = [], d2 = { name: "div", attributes: c2, children: h2 };
        applyAssist(this, c2);
        const u2 = this.border ? this.border[Zr]() : null, g2 = computeBbox(this, d2, e2), p2 = this.ui[Yr]().html;
        if (!p2)
          return Object.assign(o2, u2), HTMLResult.success(createWrapper(this, d2), g2);
        this[Gr] && (p2.children?.[0] ? p2.children[0].attributes.tabindex = this[Gr] : p2.attributes.tabindex = this[Gr]), p2.attributes.style ||= /* @__PURE__ */ Object.create(null);
        let f2 = null;
        if (this.ui.button ? (1 === p2.children.length && ([f2] = p2.children.splice(0, 1)), Object.assign(p2.attributes.style, u2)) : Object.assign(o2, u2), h2.push(p2), this.value) {
          if (this.ui.imageEdit)
            p2.children.push(this.value[Yr]().html);
          else if (!this.ui.button) {
            let e3 = "";
            if (this.value.exData)
              e3 = this.value.exData[Vr]();
            else if (this.value.text)
              e3 = this.value.text[or]();
            else {
              const t3 = this.value[Yr]().html;
              null !== t3 && (e3 = t3.children[0].value);
            }
            this.ui.textEdit && this.value.text?.maxChars && (p2.children[0].attributes.maxLength = this.value.text.maxChars), e3 && (this.ui.numericEdit && (e3 = parseFloat(e3), e3 = isNaN(e3) ? "" : e3.toString()), "textarea" === p2.children[0].name ? p2.children[0].attributes.textContent = e3 : p2.children[0].attributes.value = e3);
          }
        }
        if (!this.ui.imageEdit && p2.children?.[0] && this.h) {
          r2 = r2 || getBorderDims(this.ui[or]());
          let t3 = 0;
          if (this.caption && ["top", "bottom"].includes(this.caption.placement)) {
            t3 = this.caption.reserve, t3 <= 0 && (t3 = this.caption[or](e2).h);
            const i3 = this.h - t3 - s2 - r2.h;
            p2.children[0].attributes.style.height = measureToString(i3);
          } else
            p2.children[0].attributes.style.height = "100%";
        }
        if (f2 && p2.children.push(f2), !t2)
          return p2.attributes.class && p2.attributes.class.push("xfaLeft"), this.w = i2, this.h = a2, HTMLResult.success(createWrapper(this, d2), g2);
        if (this.ui.button)
          return o2.padding && delete o2.padding, "div" === t2.name && (t2.name = "span"), p2.children.push(t2), HTMLResult.success(d2, g2);
        switch (this.ui.checkButton && (t2.attributes.class[0] = "xfaCaptionForCheckButton"), p2.attributes.class ||= [], p2.children.splice(0, 0, t2), this.caption.placement) {
          case "left":
          case "inline":
            p2.attributes.class.push("xfaLeft");
            break;
          case "right":
            p2.attributes.class.push("xfaRight");
            break;
          case "top":
            p2.attributes.class.push("xfaTop");
            break;
          case "bottom":
            p2.attributes.class.push("xfaBottom");
        }
        return this.w = i2, this.h = a2, HTMLResult.success(createWrapper(this, d2), g2);
      }
    };
    __name(Field, "Field");
    Fill = class extends XFAObject {
      constructor(e2) {
        super(Ro, "fill", true), this.id = e2.id || "", this.presence = getStringOption(e2.presence, ["visible", "hidden", "inactive", "invisible"]), this.use = e2.use || "", this.usehref = e2.usehref || "", this.color = null, this.extras = null, this.linear = null, this.pattern = null, this.radial = null, this.solid = null, this.stipple = null;
      }
      [Zr]() {
        const e2 = this[gr](), t2 = e2[gr]()[gr](), i2 = /* @__PURE__ */ Object.create(null);
        let a2 = "color", n2 = a2;
        e2 instanceof Border && (a2 = "background-color", n2 = "background", t2 instanceof Ui && (i2.backgroundColor = "white")), (e2 instanceof Rectangle || e2 instanceof Arc) && (a2 = n2 = "fill", i2.fill = "white");
        for (const e3 of Object.getOwnPropertyNames(this)) {
          if ("extras" === e3 || "color" === e3)
            continue;
          const t3 = this[e3];
          if (!(t3 instanceof XFAObject))
            continue;
          const s2 = t3[Zr](this.color);
          return s2 && (i2[s2.startsWith("#") ? a2 : n2] = s2), i2;
        }
        if (this.color?.value) {
          const e3 = this.color[Zr]();
          i2[e3.startsWith("#") ? a2 : n2] = e3;
        }
        return i2;
      }
    };
    __name(Fill, "Fill");
    Filter = class extends XFAObject {
      constructor(e2) {
        super(Ro, "filter", true), this.addRevocationInfo = getStringOption(e2.addRevocationInfo, ["", "required", "optional", "none"]), this.id = e2.id || "", this.name = e2.name || "", this.use = e2.use || "", this.usehref = e2.usehref || "", this.version = getInteger({ data: this.version, defaultValue: 5, validate: (e3) => e3 >= 1 && e3 <= 5 }), this.appearanceFilter = null, this.certificates = null, this.digestMethods = null, this.encodings = null, this.encryptionMethods = null, this.handler = null, this.lockDocument = null, this.mdp = null, this.reasons = null, this.timeStamp = null;
      }
    };
    __name(Filter, "Filter");
    Float = class extends ContentObject {
      constructor(e2) {
        super(Ro, "float"), this.id = e2.id || "", this.name = e2.name || "", this.use = e2.use || "", this.usehref = e2.usehref || "";
      }
      [Zs]() {
        const e2 = parseFloat(this[Vs].trim());
        this[Vs] = isNaN(e2) ? null : e2;
      }
      [Yr](e2) {
        return valueToHtml(null !== this[Vs] ? this[Vs].toString() : "");
      }
    };
    __name(Float, "Float");
    template_Font = class extends XFAObject {
      constructor(e2) {
        super(Ro, "font", true), this.baselineShift = getMeasurement(e2.baselineShift), this.fontHorizontalScale = getFloat({ data: e2.fontHorizontalScale, defaultValue: 100, validate: (e3) => e3 >= 0 }), this.fontVerticalScale = getFloat({ data: e2.fontVerticalScale, defaultValue: 100, validate: (e3) => e3 >= 0 }), this.id = e2.id || "", this.kerningMode = getStringOption(e2.kerningMode, ["none", "pair"]), this.letterSpacing = getMeasurement(e2.letterSpacing, "0"), this.lineThrough = getInteger({ data: e2.lineThrough, defaultValue: 0, validate: (e3) => 1 === e3 || 2 === e3 }), this.lineThroughPeriod = getStringOption(e2.lineThroughPeriod, ["all", "word"]), this.overline = getInteger({ data: e2.overline, defaultValue: 0, validate: (e3) => 1 === e3 || 2 === e3 }), this.overlinePeriod = getStringOption(e2.overlinePeriod, ["all", "word"]), this.posture = getStringOption(e2.posture, ["normal", "italic"]), this.size = getMeasurement(e2.size, "10pt"), this.typeface = e2.typeface || "Courier", this.underline = getInteger({ data: e2.underline, defaultValue: 0, validate: (e3) => 1 === e3 || 2 === e3 }), this.underlinePeriod = getStringOption(e2.underlinePeriod, ["all", "word"]), this.use = e2.use || "", this.usehref = e2.usehref || "", this.weight = getStringOption(e2.weight, ["normal", "bold"]), this.extras = null, this.fill = null;
      }
      [qs](e2) {
        super[qs](e2), this[fr].usedTypefaces.add(this.typeface);
      }
      [Zr]() {
        const e2 = toStyle(this, "fill"), t2 = e2.color;
        return t2 && ("#000000" === t2 ? delete e2.color : t2.startsWith("#") || (e2.background = t2, e2.backgroundClip = "text", e2.color = "transparent")), this.baselineShift && (e2.verticalAlign = measureToString(this.baselineShift)), e2.fontKerning = "none" === this.kerningMode ? "none" : "normal", e2.letterSpacing = measureToString(this.letterSpacing), 0 !== this.lineThrough && (e2.textDecoration = "line-through", 2 === this.lineThrough && (e2.textDecorationStyle = "double")), 0 !== this.overline && (e2.textDecoration = "overline", 2 === this.overline && (e2.textDecorationStyle = "double")), e2.fontStyle = this.posture, e2.fontSize = measureToString(0.99 * this.size), setFontFamily(this, this, this[fr].fontFinder, e2), 0 !== this.underline && (e2.textDecoration = "underline", 2 === this.underline && (e2.textDecorationStyle = "double")), e2.fontWeight = this.weight, e2;
      }
    };
    __name(template_Font, "template_Font");
    Format = class extends XFAObject {
      constructor(e2) {
        super(Ro, "format", true), this.id = e2.id || "", this.use = e2.use || "", this.usehref = e2.usehref || "", this.extras = null, this.picture = null;
      }
    };
    __name(Format, "Format");
    Handler = class extends StringObject {
      constructor(e2) {
        super(Ro, "handler"), this.id = e2.id || "", this.type = getStringOption(e2.type, ["optional", "required"]), this.use = e2.use || "", this.usehref = e2.usehref || "";
      }
    };
    __name(Handler, "Handler");
    Hyphenation = class extends XFAObject {
      constructor(e2) {
        super(Ro, "hyphenation"), this.excludeAllCaps = getInteger({ data: e2.excludeAllCaps, defaultValue: 0, validate: (e3) => 1 === e3 }), this.excludeInitialCap = getInteger({ data: e2.excludeInitialCap, defaultValue: 0, validate: (e3) => 1 === e3 }), this.hyphenate = getInteger({ data: e2.hyphenate, defaultValue: 0, validate: (e3) => 1 === e3 }), this.id = e2.id || "", this.pushCharacterCount = getInteger({ data: e2.pushCharacterCount, defaultValue: 3, validate: (e3) => e3 >= 0 }), this.remainCharacterCount = getInteger({ data: e2.remainCharacterCount, defaultValue: 3, validate: (e3) => e3 >= 0 }), this.use = e2.use || "", this.usehref = e2.usehref || "", this.wordCharacterCount = getInteger({ data: e2.wordCharacterCount, defaultValue: 7, validate: (e3) => e3 >= 0 });
      }
    };
    __name(Hyphenation, "Hyphenation");
    $o = /* @__PURE__ */ __name(class extends StringObject {
      constructor(e2) {
        super(Ro, "image"), this.aspect = getStringOption(e2.aspect, ["fit", "actual", "height", "none", "width"]), this.contentType = e2.contentType || "", this.href = e2.href || "", this.id = e2.id || "", this.name = e2.name || "", this.transferEncoding = getStringOption(e2.transferEncoding, ["base64", "none", "package"]), this.use = e2.use || "", this.usehref = e2.usehref || "";
      }
      [Yr]() {
        if (this.contentType && !Lo.has(this.contentType.toLowerCase()))
          return HTMLResult.EMPTY;
        let e2 = this[fr].images?.get(this.href);
        if (!e2 && (this.href || !this[Vs]))
          return HTMLResult.EMPTY;
        var t2;
        if (e2 || "base64" !== this.transferEncoding || (t2 = this[Vs], e2 = Uint8Array.fromBase64 ? Uint8Array.fromBase64(t2) : stringToBytes$1(atob(t2))), !e2)
          return HTMLResult.EMPTY;
        if (!this.contentType) {
          for (const [t3, i3] of Uo)
            if (e2.length > t3.length && t3.every((t4, i4) => t4 === e2[i4])) {
              this.contentType = i3;
              break;
            }
          if (!this.contentType)
            return HTMLResult.EMPTY;
        }
        const i2 = new Blob([e2], { type: this.contentType });
        let a2;
        switch (this.aspect) {
          case "fit":
          case "actual":
            break;
          case "height":
            a2 = { height: "100%", objectFit: "fill" };
            break;
          case "none":
            a2 = { width: "100%", height: "100%", objectFit: "fill" };
            break;
          case "width":
            a2 = { width: "100%", objectFit: "fill" };
        }
        const n2 = this[gr]();
        return HTMLResult.success({ name: "img", attributes: { class: ["xfaImage"], style: a2, src: URL.createObjectURL(i2), alt: n2 ? ariaLabel(n2[gr]()) : null } });
      }
    }, "$o");
    ImageEdit = class extends XFAObject {
      constructor(e2) {
        super(Ro, "imageEdit", true), this.data = getStringOption(e2.data, ["link", "embed"]), this.id = e2.id || "", this.use = e2.use || "", this.usehref = e2.usehref || "", this.border = null, this.extras = null, this.margin = null;
      }
      [Yr](e2) {
        return "embed" === this.data ? HTMLResult.success({ name: "div", children: [], attributes: {} }) : HTMLResult.EMPTY;
      }
    };
    __name(ImageEdit, "ImageEdit");
    Integer = class extends ContentObject {
      constructor(e2) {
        super(Ro, "integer"), this.id = e2.id || "", this.name = e2.name || "", this.use = e2.use || "", this.usehref = e2.usehref || "";
      }
      [Zs]() {
        const e2 = parseInt(this[Vs].trim(), 10);
        this[Vs] = isNaN(e2) ? null : e2;
      }
      [Yr](e2) {
        return valueToHtml(null !== this[Vs] ? this[Vs].toString() : "");
      }
    };
    __name(Integer, "Integer");
    Issuers = class extends XFAObject {
      constructor(e2) {
        super(Ro, "issuers", true), this.id = e2.id || "", this.type = getStringOption(e2.type, ["optional", "required"]), this.use = e2.use || "", this.usehref = e2.usehref || "", this.certificate = new XFAObjectArray();
      }
    };
    __name(Issuers, "Issuers");
    Items = class extends XFAObject {
      constructor(e2) {
        super(Ro, "items", true), this.id = e2.id || "", this.name = e2.name || "", this.presence = getStringOption(e2.presence, ["visible", "hidden", "inactive", "invisible"]), this.ref = e2.ref || "", this.save = getInteger({ data: e2.save, defaultValue: 0, validate: (e3) => 1 === e3 }), this.use = e2.use || "", this.usehref = e2.usehref || "", this.boolean = new XFAObjectArray(), this.date = new XFAObjectArray(), this.dateTime = new XFAObjectArray(), this.decimal = new XFAObjectArray(), this.exData = new XFAObjectArray(), this.float = new XFAObjectArray(), this.image = new XFAObjectArray(), this.integer = new XFAObjectArray(), this.text = new XFAObjectArray(), this.time = new XFAObjectArray();
      }
      [Yr]() {
        const e2 = [];
        for (const t2 of this[cr]())
          e2.push(t2[Vr]());
        return HTMLResult.success(e2);
      }
    };
    __name(Items, "Items");
    Keep = class extends XFAObject {
      constructor(e2) {
        super(Ro, "keep", true), this.id = e2.id || "";
        const t2 = ["none", "contentArea", "pageArea"];
        this.intact = getStringOption(e2.intact, t2), this.next = getStringOption(e2.next, t2), this.previous = getStringOption(e2.previous, t2), this.use = e2.use || "", this.usehref = e2.usehref || "", this.extras = null;
      }
    };
    __name(Keep, "Keep");
    KeyUsage = class extends XFAObject {
      constructor(e2) {
        super(Ro, "keyUsage");
        const t2 = ["", "yes", "no"];
        this.crlSign = getStringOption(e2.crlSign, t2), this.dataEncipherment = getStringOption(e2.dataEncipherment, t2), this.decipherOnly = getStringOption(e2.decipherOnly, t2), this.digitalSignature = getStringOption(e2.digitalSignature, t2), this.encipherOnly = getStringOption(e2.encipherOnly, t2), this.id = e2.id || "", this.keyAgreement = getStringOption(e2.keyAgreement, t2), this.keyCertSign = getStringOption(e2.keyCertSign, t2), this.keyEncipherment = getStringOption(e2.keyEncipherment, t2), this.nonRepudiation = getStringOption(e2.nonRepudiation, t2), this.type = getStringOption(e2.type, ["optional", "required"]), this.use = e2.use || "", this.usehref = e2.usehref || "";
      }
    };
    __name(KeyUsage, "KeyUsage");
    Line = class extends XFAObject {
      constructor(e2) {
        super(Ro, "line", true), this.hand = getStringOption(e2.hand, ["even", "left", "right"]), this.id = e2.id || "", this.slope = getStringOption(e2.slope, ["\\", "/"]), this.use = e2.use || "", this.usehref = e2.usehref || "", this.edge = null;
      }
      [Yr]() {
        const e2 = this[gr]()[gr](), t2 = this.edge || new Edge({}), i2 = t2[Zr](), a2 = /* @__PURE__ */ Object.create(null), n2 = "visible" === t2.presence ? t2.thickness : 0;
        let s2, r2, o2, l3;
        a2.strokeWidth = measureToString(n2), a2.stroke = i2.color;
        let c2 = "100%", h2 = "100%";
        e2.w <= n2 ? ([s2, r2, o2, l3] = ["50%", 0, "50%", "100%"], c2 = a2.strokeWidth) : e2.h <= n2 ? ([s2, r2, o2, l3] = [0, "50%", "100%", "50%"], h2 = a2.strokeWidth) : "\\" === this.slope ? [s2, r2, o2, l3] = [0, 0, "100%", "100%"] : [s2, r2, o2, l3] = [0, "100%", "100%", 0];
        const d2 = { name: "svg", children: [{ name: "line", attributes: { xmlns: Bo, x1: s2, y1: r2, x2: o2, y2: l3, style: a2 } }], attributes: { xmlns: Bo, width: c2, height: h2, style: { overflow: "visible" } } };
        return hasMargin(e2) ? HTMLResult.success({ name: "div", attributes: { style: { display: "inline", width: "100%", height: "100%" } }, children: [d2] }) : (d2.attributes.style.position = "absolute", HTMLResult.success(d2));
      }
    };
    __name(Line, "Line");
    Linear = class extends XFAObject {
      constructor(e2) {
        super(Ro, "linear", true), this.id = e2.id || "", this.type = getStringOption(e2.type, ["toRight", "toBottom", "toLeft", "toTop"]), this.use = e2.use || "", this.usehref = e2.usehref || "", this.color = null, this.extras = null;
      }
      [Zr](e2) {
        e2 = e2 ? e2[Zr]() : "#FFFFFF";
        return `linear-gradient(${this.type.replace(/([RBLT])/, " $1").toLowerCase()}, ${e2}, ${this.color ? this.color[Zr]() : "#000000"})`;
      }
    };
    __name(Linear, "Linear");
    LockDocument = class extends ContentObject {
      constructor(e2) {
        super(Ro, "lockDocument"), this.id = e2.id || "", this.type = getStringOption(e2.type, ["optional", "required"]), this.use = e2.use || "", this.usehref = e2.usehref || "";
      }
      [Zs]() {
        this[Vs] = getStringOption(this[Vs], ["auto", "0", "1"]);
      }
    };
    __name(LockDocument, "LockDocument");
    Manifest = class extends XFAObject {
      constructor(e2) {
        super(Ro, "manifest", true), this.action = getStringOption(e2.action, ["include", "all", "exclude"]), this.id = e2.id || "", this.name = e2.name || "", this.use = e2.use || "", this.usehref = e2.usehref || "", this.extras = null, this.ref = new XFAObjectArray();
      }
    };
    __name(Manifest, "Manifest");
    Margin = class extends XFAObject {
      constructor(e2) {
        super(Ro, "margin", true), this.bottomInset = getMeasurement(e2.bottomInset, "0"), this.id = e2.id || "", this.leftInset = getMeasurement(e2.leftInset, "0"), this.rightInset = getMeasurement(e2.rightInset, "0"), this.topInset = getMeasurement(e2.topInset, "0"), this.use = e2.use || "", this.usehref = e2.usehref || "", this.extras = null;
      }
      [Zr]() {
        return { margin: measureToString(this.topInset) + " " + measureToString(this.rightInset) + " " + measureToString(this.bottomInset) + " " + measureToString(this.leftInset) };
      }
    };
    __name(Margin, "Margin");
    Mdp = class extends XFAObject {
      constructor(e2) {
        super(Ro, "mdp"), this.id = e2.id || "", this.permissions = getInteger({ data: e2.permissions, defaultValue: 2, validate: (e3) => 1 === e3 || 3 === e3 }), this.signatureType = getStringOption(e2.signatureType, ["filler", "author"]), this.use = e2.use || "", this.usehref = e2.usehref || "";
      }
    };
    __name(Mdp, "Mdp");
    Medium = class extends XFAObject {
      constructor(e2) {
        super(Ro, "medium"), this.id = e2.id || "", this.imagingBBox = function(e3) {
          const t2 = -1;
          if (!e3)
            return { x: t2, y: t2, width: t2, height: t2 };
          const i2 = e3.split(",", 4).map((e4) => getMeasurement(e4.trim(), "-1"));
          if (i2.length < 4 || i2[2] < 0 || i2[3] < 0)
            return { x: t2, y: t2, width: t2, height: t2 };
          const [a2, n2, s2, r2] = i2;
          return { x: a2, y: n2, width: s2, height: r2 };
        }(e2.imagingBBox), this.long = getMeasurement(e2.long), this.orientation = getStringOption(e2.orientation, ["portrait", "landscape"]), this.short = getMeasurement(e2.short), this.stock = e2.stock || "", this.trayIn = getStringOption(e2.trayIn, ["auto", "delegate", "pageFront"]), this.trayOut = getStringOption(e2.trayOut, ["auto", "delegate"]), this.use = e2.use || "", this.usehref = e2.usehref || "";
      }
    };
    __name(Medium, "Medium");
    Message = class extends XFAObject {
      constructor(e2) {
        super(Ro, "message", true), this.id = e2.id || "", this.use = e2.use || "", this.usehref = e2.usehref || "", this.text = new XFAObjectArray();
      }
    };
    __name(Message, "Message");
    NumericEdit = class extends XFAObject {
      constructor(e2) {
        super(Ro, "numericEdit", true), this.hScrollPolicy = getStringOption(e2.hScrollPolicy, ["auto", "off", "on"]), this.id = e2.id || "", this.use = e2.use || "", this.usehref = e2.usehref || "", this.border = null, this.comb = null, this.extras = null, this.margin = null;
      }
      [Yr](e2) {
        const t2 = toStyle(this, "border", "font", "margin"), i2 = this[gr]()[gr](), a2 = { name: "input", attributes: { type: "text", fieldId: i2[Qr], dataId: i2[Ks]?.[Qr] || i2[Qr], class: ["xfaTextfield"], style: t2, "aria-label": ariaLabel(i2), "aria-required": false } };
        return isRequired(i2) && (a2.attributes["aria-required"] = true, a2.attributes.required = true), HTMLResult.success({ name: "label", attributes: { class: ["xfaLabel"] }, children: [a2] });
      }
    };
    __name(NumericEdit, "NumericEdit");
    Occur = class extends XFAObject {
      constructor(e2) {
        super(Ro, "occur", true), this.id = e2.id || "", this.initial = "" !== e2.initial ? getInteger({ data: e2.initial, defaultValue: "", validate: (e3) => true }) : "", this.max = "" !== e2.max ? getInteger({ data: e2.max, defaultValue: 1, validate: (e3) => true }) : "", this.min = "" !== e2.min ? getInteger({ data: e2.min, defaultValue: 1, validate: (e3) => true }) : "", this.use = e2.use || "", this.usehref = e2.usehref || "", this.extras = null;
      }
      [qs]() {
        const e2 = this[gr](), t2 = this.min;
        "" === this.min && (this.min = e2 instanceof PageArea || e2 instanceof PageSet ? 0 : 1), "" === this.max && (this.max = "" === t2 ? e2 instanceof PageArea || e2 instanceof PageSet ? -1 : 1 : this.min), -1 !== this.max && this.max < this.min && (this.max = this.min), "" === this.initial && (this.initial = e2 instanceof Template ? 1 : this.min);
      }
    };
    __name(Occur, "Occur");
    Oid = class extends StringObject {
      constructor(e2) {
        super(Ro, "oid"), this.id = e2.id || "", this.name = e2.name || "", this.use = e2.use || "", this.usehref = e2.usehref || "";
      }
    };
    __name(Oid, "Oid");
    Oids = class extends XFAObject {
      constructor(e2) {
        super(Ro, "oids", true), this.id = e2.id || "", this.type = getStringOption(e2.type, ["optional", "required"]), this.use = e2.use || "", this.usehref = e2.usehref || "", this.oid = new XFAObjectArray();
      }
    };
    __name(Oids, "Oids");
    Overflow = class extends XFAObject {
      constructor(e2) {
        super(Ro, "overflow"), this.id = e2.id || "", this.leader = e2.leader || "", this.target = e2.target || "", this.trailer = e2.trailer || "", this.use = e2.use || "", this.usehref = e2.usehref || "";
      }
      [or]() {
        if (!this[Js]) {
          const e2 = this[gr](), t2 = this[pr](), i2 = t2[qr](this.target, e2), a2 = t2[qr](this.leader, e2), n2 = t2[qr](this.trailer, e2);
          this[Js] = { target: i2?.[0] || null, leader: a2?.[0] || null, trailer: n2?.[0] || null, addLeader: false, addTrailer: false };
        }
        return this[Js];
      }
    };
    __name(Overflow, "Overflow");
    PageArea = class extends XFAObject {
      constructor(e2) {
        super(Ro, "pageArea", true), this.blankOrNotBlank = getStringOption(e2.blankOrNotBlank, ["any", "blank", "notBlank"]), this.id = e2.id || "", this.initialNumber = getInteger({ data: e2.initialNumber, defaultValue: 1, validate: (e3) => true }), this.name = e2.name || "", this.numbered = getInteger({ data: e2.numbered, defaultValue: 1, validate: (e3) => true }), this.oddOrEven = getStringOption(e2.oddOrEven, ["any", "even", "odd"]), this.pagePosition = getStringOption(e2.pagePosition, ["any", "first", "last", "only", "rest"]), this.relevant = getRelevant(e2.relevant), this.use = e2.use || "", this.usehref = e2.usehref || "", this.desc = null, this.extras = null, this.medium = null, this.occur = null, this.area = new XFAObjectArray(), this.contentArea = new XFAObjectArray(), this.draw = new XFAObjectArray(), this.exclGroup = new XFAObjectArray(), this.field = new XFAObjectArray(), this.subform = new XFAObjectArray();
      }
      [Fr]() {
        return this[Js] ? !this.occur || -1 === this.occur.max || this[Js].numberOfUse < this.occur.max : (this[Js] = { numberOfUse: 0 }, true);
      }
      [Xs]() {
        delete this[Js];
      }
      [dr]() {
        this[Js] ||= { numberOfUse: 0 };
        const e2 = this[gr]();
        return "orderedOccurrence" === e2.relation && this[Fr]() ? (this[Js].numberOfUse += 1, this) : e2[dr]();
      }
      [ir]() {
        return this[Js].space || { width: 0, height: 0 };
      }
      [Yr]() {
        this[Js] ||= { numberOfUse: 1 };
        const e2 = [];
        this[Js].children = e2;
        const t2 = /* @__PURE__ */ Object.create(null);
        if (this.medium && this.medium.short && this.medium.long) {
          if (t2.width = measureToString(this.medium.short), t2.height = measureToString(this.medium.long), this[Js].space = { width: this.medium.short, height: this.medium.long }, "landscape" === this.medium.orientation) {
            const e3 = t2.width;
            t2.width = t2.height, t2.height = e3, this[Js].space = { width: this.medium.long, height: this.medium.short };
          }
        } else
          warn$1("XFA - No medium specified in pageArea: please file a bug.");
        return this[Hs]({ filter: /* @__PURE__ */ new Set(["area", "draw", "field", "subform"]), include: true }), this[Hs]({ filter: /* @__PURE__ */ new Set(["contentArea"]), include: true }), HTMLResult.success({ name: "div", children: e2, attributes: { class: ["xfaPage"], id: this[Qr], style: t2, xfaName: this.name } });
      }
    };
    __name(PageArea, "PageArea");
    PageSet = class extends XFAObject {
      constructor(e2) {
        super(Ro, "pageSet", true), this.duplexImposition = getStringOption(e2.duplexImposition, ["longEdge", "shortEdge"]), this.id = e2.id || "", this.name = e2.name || "", this.relation = getStringOption(e2.relation, ["orderedOccurrence", "duplexPaginated", "simplexPaginated"]), this.relevant = getRelevant(e2.relevant), this.use = e2.use || "", this.usehref = e2.usehref || "", this.extras = null, this.occur = null, this.pageArea = new XFAObjectArray(), this.pageSet = new XFAObjectArray();
      }
      [Xs]() {
        for (const e2 of this.pageArea.children)
          e2[Xs]();
        for (const e2 of this.pageSet.children)
          e2[Xs]();
      }
      [Fr]() {
        return !this.occur || -1 === this.occur.max || this[Js].numberOfUse < this.occur.max;
      }
      [dr]() {
        if (this[Js] ||= { numberOfUse: 1, pageIndex: -1, pageSetIndex: -1 }, "orderedOccurrence" === this.relation) {
          if (this[Js].pageIndex + 1 < this.pageArea.children.length) {
            this[Js].pageIndex += 1;
            return this.pageArea.children[this[Js].pageIndex][dr]();
          }
          if (this[Js].pageSetIndex + 1 < this.pageSet.children.length)
            return this[Js].pageSetIndex += 1, this.pageSet.children[this[Js].pageSetIndex][dr]();
          if (this[Fr]())
            return this[Js].numberOfUse += 1, this[Js].pageIndex = -1, this[Js].pageSetIndex = -1, this[dr]();
          const e3 = this[gr]();
          return e3 instanceof PageSet ? e3[dr]() : (this[Xs](), this[dr]());
        }
        const e2 = this[pr]()[Js].pageNumber, t2 = e2 % 2 == 0 ? "even" : "odd", i2 = 0 === e2 ? "first" : "rest";
        let a2 = this.pageArea.children.find((e3) => e3.oddOrEven === t2 && e3.pagePosition === i2);
        return a2 || (a2 = this.pageArea.children.find((e3) => "any" === e3.oddOrEven && e3.pagePosition === i2), a2 || (a2 = this.pageArea.children.find((e3) => "any" === e3.oddOrEven && "any" === e3.pagePosition), a2 || this.pageArea.children[0]));
      }
    };
    __name(PageSet, "PageSet");
    Para = class extends XFAObject {
      constructor(e2) {
        super(Ro, "para", true), this.hAlign = getStringOption(e2.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]), this.id = e2.id || "", this.lineHeight = e2.lineHeight ? getMeasurement(e2.lineHeight, "0pt") : "", this.marginLeft = e2.marginLeft ? getMeasurement(e2.marginLeft, "0pt") : "", this.marginRight = e2.marginRight ? getMeasurement(e2.marginRight, "0pt") : "", this.orphans = getInteger({ data: e2.orphans, defaultValue: 0, validate: (e3) => e3 >= 0 }), this.preserve = e2.preserve || "", this.radixOffset = e2.radixOffset ? getMeasurement(e2.radixOffset, "0pt") : "", this.spaceAbove = e2.spaceAbove ? getMeasurement(e2.spaceAbove, "0pt") : "", this.spaceBelow = e2.spaceBelow ? getMeasurement(e2.spaceBelow, "0pt") : "", this.tabDefault = e2.tabDefault ? getMeasurement(this.tabDefault) : "", this.tabStops = (e2.tabStops || "").trim().split(/\s+/).map((e3, t2) => t2 % 2 == 1 ? getMeasurement(e3) : e3), this.textIndent = e2.textIndent ? getMeasurement(e2.textIndent, "0pt") : "", this.use = e2.use || "", this.usehref = e2.usehref || "", this.vAlign = getStringOption(e2.vAlign, ["top", "bottom", "middle"]), this.widows = getInteger({ data: e2.widows, defaultValue: 0, validate: (e3) => e3 >= 0 }), this.hyphenation = null;
      }
      [Zr]() {
        const e2 = toStyle(this, "hAlign");
        return "" !== this.marginLeft && (e2.paddingLeft = measureToString(this.marginLeft)), "" !== this.marginRight && (e2.paddingRight = measureToString(this.marginRight)), "" !== this.spaceAbove && (e2.paddingTop = measureToString(this.spaceAbove)), "" !== this.spaceBelow && (e2.paddingBottom = measureToString(this.spaceBelow)), "" !== this.textIndent && (e2.textIndent = measureToString(this.textIndent), fixTextIndent(e2)), this.lineHeight > 0 && (e2.lineHeight = measureToString(this.lineHeight)), "" !== this.tabDefault && (e2.tabSize = measureToString(this.tabDefault)), this.tabStops.length, this.hyphenatation && Object.assign(e2, this.hyphenatation[Zr]()), e2;
      }
    };
    __name(Para, "Para");
    PasswordEdit = class extends XFAObject {
      constructor(e2) {
        super(Ro, "passwordEdit", true), this.hScrollPolicy = getStringOption(e2.hScrollPolicy, ["auto", "off", "on"]), this.id = e2.id || "", this.passwordChar = e2.passwordChar || "*", this.use = e2.use || "", this.usehref = e2.usehref || "", this.border = null, this.extras = null, this.margin = null;
      }
    };
    __name(PasswordEdit, "PasswordEdit");
    template_Pattern = class extends XFAObject {
      constructor(e2) {
        super(Ro, "pattern", true), this.id = e2.id || "", this.type = getStringOption(e2.type, ["crossHatch", "crossDiagonal", "diagonalLeft", "diagonalRight", "horizontal", "vertical"]), this.use = e2.use || "", this.usehref = e2.usehref || "", this.color = null, this.extras = null;
      }
      [Zr](e2) {
        e2 = e2 ? e2[Zr]() : "#FFFFFF";
        const t2 = this.color ? this.color[Zr]() : "#000000", i2 = "repeating-linear-gradient", a2 = `${e2},${e2} 5px,${t2} 5px,${t2} 10px`;
        switch (this.type) {
          case "crossHatch":
            return `${i2}(to top,${a2}) ${i2}(to right,${a2})`;
          case "crossDiagonal":
            return `${i2}(45deg,${a2}) ${i2}(-45deg,${a2})`;
          case "diagonalLeft":
            return `${i2}(45deg,${a2})`;
          case "diagonalRight":
            return `${i2}(-45deg,${a2})`;
          case "horizontal":
            return `${i2}(to top,${a2})`;
          case "vertical":
            return `${i2}(to right,${a2})`;
        }
        return "";
      }
    };
    __name(template_Pattern, "template_Pattern");
    Picture = class extends StringObject {
      constructor(e2) {
        super(Ro, "picture"), this.id = e2.id || "", this.use = e2.use || "", this.usehref = e2.usehref || "";
      }
    };
    __name(Picture, "Picture");
    Proto = class extends XFAObject {
      constructor(e2) {
        super(Ro, "proto", true), this.appearanceFilter = new XFAObjectArray(), this.arc = new XFAObjectArray(), this.area = new XFAObjectArray(), this.assist = new XFAObjectArray(), this.barcode = new XFAObjectArray(), this.bindItems = new XFAObjectArray(), this.bookend = new XFAObjectArray(), this.boolean = new XFAObjectArray(), this.border = new XFAObjectArray(), this.break = new XFAObjectArray(), this.breakAfter = new XFAObjectArray(), this.breakBefore = new XFAObjectArray(), this.button = new XFAObjectArray(), this.calculate = new XFAObjectArray(), this.caption = new XFAObjectArray(), this.certificate = new XFAObjectArray(), this.certificates = new XFAObjectArray(), this.checkButton = new XFAObjectArray(), this.choiceList = new XFAObjectArray(), this.color = new XFAObjectArray(), this.comb = new XFAObjectArray(), this.connect = new XFAObjectArray(), this.contentArea = new XFAObjectArray(), this.corner = new XFAObjectArray(), this.date = new XFAObjectArray(), this.dateTime = new XFAObjectArray(), this.dateTimeEdit = new XFAObjectArray(), this.decimal = new XFAObjectArray(), this.defaultUi = new XFAObjectArray(), this.desc = new XFAObjectArray(), this.digestMethod = new XFAObjectArray(), this.digestMethods = new XFAObjectArray(), this.draw = new XFAObjectArray(), this.edge = new XFAObjectArray(), this.encoding = new XFAObjectArray(), this.encodings = new XFAObjectArray(), this.encrypt = new XFAObjectArray(), this.encryptData = new XFAObjectArray(), this.encryption = new XFAObjectArray(), this.encryptionMethod = new XFAObjectArray(), this.encryptionMethods = new XFAObjectArray(), this.event = new XFAObjectArray(), this.exData = new XFAObjectArray(), this.exObject = new XFAObjectArray(), this.exclGroup = new XFAObjectArray(), this.execute = new XFAObjectArray(), this.extras = new XFAObjectArray(), this.field = new XFAObjectArray(), this.fill = new XFAObjectArray(), this.filter = new XFAObjectArray(), this.float = new XFAObjectArray(), this.font = new XFAObjectArray(), this.format = new XFAObjectArray(), this.handler = new XFAObjectArray(), this.hyphenation = new XFAObjectArray(), this.image = new XFAObjectArray(), this.imageEdit = new XFAObjectArray(), this.integer = new XFAObjectArray(), this.issuers = new XFAObjectArray(), this.items = new XFAObjectArray(), this.keep = new XFAObjectArray(), this.keyUsage = new XFAObjectArray(), this.line = new XFAObjectArray(), this.linear = new XFAObjectArray(), this.lockDocument = new XFAObjectArray(), this.manifest = new XFAObjectArray(), this.margin = new XFAObjectArray(), this.mdp = new XFAObjectArray(), this.medium = new XFAObjectArray(), this.message = new XFAObjectArray(), this.numericEdit = new XFAObjectArray(), this.occur = new XFAObjectArray(), this.oid = new XFAObjectArray(), this.oids = new XFAObjectArray(), this.overflow = new XFAObjectArray(), this.pageArea = new XFAObjectArray(), this.pageSet = new XFAObjectArray(), this.para = new XFAObjectArray(), this.passwordEdit = new XFAObjectArray(), this.pattern = new XFAObjectArray(), this.picture = new XFAObjectArray(), this.radial = new XFAObjectArray(), this.reason = new XFAObjectArray(), this.reasons = new XFAObjectArray(), this.rectangle = new XFAObjectArray(), this.ref = new XFAObjectArray(), this.script = new XFAObjectArray(), this.setProperty = new XFAObjectArray(), this.signData = new XFAObjectArray(), this.signature = new XFAObjectArray(), this.signing = new XFAObjectArray(), this.solid = new XFAObjectArray(), this.speak = new XFAObjectArray(), this.stipple = new XFAObjectArray(), this.subform = new XFAObjectArray(), this.subformSet = new XFAObjectArray(), this.subjectDN = new XFAObjectArray(), this.subjectDNs = new XFAObjectArray(), this.submit = new XFAObjectArray(), this.text = new XFAObjectArray(), this.textEdit = new XFAObjectArray(), this.time = new XFAObjectArray(), this.timeStamp = new XFAObjectArray(), this.toolTip = new XFAObjectArray(), this.traversal = new XFAObjectArray(), this.traverse = new XFAObjectArray(), this.ui = new XFAObjectArray(), this.validate = new XFAObjectArray(), this.value = new XFAObjectArray(), this.variables = new XFAObjectArray();
      }
    };
    __name(Proto, "Proto");
    Radial = class extends XFAObject {
      constructor(e2) {
        super(Ro, "radial", true), this.id = e2.id || "", this.type = getStringOption(e2.type, ["toEdge", "toCenter"]), this.use = e2.use || "", this.usehref = e2.usehref || "", this.color = null, this.extras = null;
      }
      [Zr](e2) {
        e2 = e2 ? e2[Zr]() : "#FFFFFF";
        const t2 = this.color ? this.color[Zr]() : "#000000";
        return `radial-gradient(circle at center, ${"toEdge" === this.type ? `${e2},${t2}` : `${t2},${e2}`})`;
      }
    };
    __name(Radial, "Radial");
    Reason = class extends StringObject {
      constructor(e2) {
        super(Ro, "reason"), this.id = e2.id || "", this.name = e2.name || "", this.use = e2.use || "", this.usehref = e2.usehref || "";
      }
    };
    __name(Reason, "Reason");
    Reasons = class extends XFAObject {
      constructor(e2) {
        super(Ro, "reasons", true), this.id = e2.id || "", this.type = getStringOption(e2.type, ["optional", "required"]), this.use = e2.use || "", this.usehref = e2.usehref || "", this.reason = new XFAObjectArray();
      }
    };
    __name(Reasons, "Reasons");
    Rectangle = class extends XFAObject {
      constructor(e2) {
        super(Ro, "rectangle", true), this.hand = getStringOption(e2.hand, ["even", "left", "right"]), this.id = e2.id || "", this.use = e2.use || "", this.usehref = e2.usehref || "", this.corner = new XFAObjectArray(4), this.edge = new XFAObjectArray(4), this.fill = null;
      }
      [Yr]() {
        const e2 = this.edge.children.length ? this.edge.children[0] : new Edge({}), t2 = e2[Zr](), i2 = /* @__PURE__ */ Object.create(null);
        "visible" === this.fill?.presence ? Object.assign(i2, this.fill[Zr]()) : i2.fill = "transparent", i2.strokeWidth = measureToString("visible" === e2.presence ? e2.thickness : 0), i2.stroke = t2.color;
        const a2 = (this.corner.children.length ? this.corner.children[0] : new Corner({}))[Zr](), n2 = { name: "svg", children: [{ name: "rect", attributes: { xmlns: Bo, width: "100%", height: "100%", x: 0, y: 0, rx: a2.radius, ry: a2.radius, style: i2 } }], attributes: { xmlns: Bo, style: { overflow: "visible" }, width: "100%", height: "100%" } };
        return hasMargin(this[gr]()[gr]()) ? HTMLResult.success({ name: "div", attributes: { style: { display: "inline", width: "100%", height: "100%" } }, children: [n2] }) : (n2.attributes.style.position = "absolute", HTMLResult.success(n2));
      }
    };
    __name(Rectangle, "Rectangle");
    RefElement = class extends StringObject {
      constructor(e2) {
        super(Ro, "ref"), this.id = e2.id || "", this.use = e2.use || "", this.usehref = e2.usehref || "";
      }
    };
    __name(RefElement, "RefElement");
    Script = class extends StringObject {
      constructor(e2) {
        super(Ro, "script"), this.binding = e2.binding || "", this.contentType = e2.contentType || "", this.id = e2.id || "", this.name = e2.name || "", this.runAt = getStringOption(e2.runAt, ["client", "both", "server"]), this.use = e2.use || "", this.usehref = e2.usehref || "";
      }
    };
    __name(Script, "Script");
    SetProperty = class extends XFAObject {
      constructor(e2) {
        super(Ro, "setProperty"), this.connection = e2.connection || "", this.ref = e2.ref || "", this.target = e2.target || "";
      }
    };
    __name(SetProperty, "SetProperty");
    SignData = class extends XFAObject {
      constructor(e2) {
        super(Ro, "signData", true), this.id = e2.id || "", this.operation = getStringOption(e2.operation, ["sign", "clear", "verify"]), this.ref = e2.ref || "", this.target = e2.target || "", this.use = e2.use || "", this.usehref = e2.usehref || "", this.filter = null, this.manifest = null;
      }
    };
    __name(SignData, "SignData");
    Signature = class extends XFAObject {
      constructor(e2) {
        super(Ro, "signature", true), this.id = e2.id || "", this.type = getStringOption(e2.type, ["PDF1.3", "PDF1.6"]), this.use = e2.use || "", this.usehref = e2.usehref || "", this.border = null, this.extras = null, this.filter = null, this.manifest = null, this.margin = null;
      }
    };
    __name(Signature, "Signature");
    Signing = class extends XFAObject {
      constructor(e2) {
        super(Ro, "signing", true), this.id = e2.id || "", this.type = getStringOption(e2.type, ["optional", "required"]), this.use = e2.use || "", this.usehref = e2.usehref || "", this.certificate = new XFAObjectArray();
      }
    };
    __name(Signing, "Signing");
    Solid = class extends XFAObject {
      constructor(e2) {
        super(Ro, "solid", true), this.id = e2.id || "", this.use = e2.use || "", this.usehref = e2.usehref || "", this.extras = null;
      }
      [Zr](e2) {
        return e2 ? e2[Zr]() : "#FFFFFF";
      }
    };
    __name(Solid, "Solid");
    Speak = class extends StringObject {
      constructor(e2) {
        super(Ro, "speak"), this.disable = getInteger({ data: e2.disable, defaultValue: 0, validate: (e3) => 1 === e3 }), this.id = e2.id || "", this.priority = getStringOption(e2.priority, ["custom", "caption", "name", "toolTip"]), this.rid = e2.rid || "", this.use = e2.use || "", this.usehref = e2.usehref || "";
      }
    };
    __name(Speak, "Speak");
    Stipple = class extends XFAObject {
      constructor(e2) {
        super(Ro, "stipple", true), this.id = e2.id || "", this.rate = getInteger({ data: e2.rate, defaultValue: 50, validate: (e3) => e3 >= 0 && e3 <= 100 }), this.use = e2.use || "", this.usehref = e2.usehref || "", this.color = null, this.extras = null;
      }
      [Zr](e2) {
        const t2 = this.rate / 100;
        return ni.makeHexColor(Math.round(e2.value.r * (1 - t2) + this.value.r * t2), Math.round(e2.value.g * (1 - t2) + this.value.g * t2), Math.round(e2.value.b * (1 - t2) + this.value.b * t2));
      }
    };
    __name(Stipple, "Stipple");
    Subform = class extends XFAObject {
      constructor(e2) {
        super(Ro, "subform", true), this.access = getStringOption(e2.access, ["open", "nonInteractive", "protected", "readOnly"]), this.allowMacro = getInteger({ data: e2.allowMacro, defaultValue: 0, validate: (e3) => 1 === e3 }), this.anchorType = getStringOption(e2.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]), this.colSpan = getInteger({ data: e2.colSpan, defaultValue: 1, validate: (e3) => e3 >= 1 || -1 === e3 }), this.columnWidths = (e2.columnWidths || "").trim().split(/\s+/).map((e3) => "-1" === e3 ? -1 : getMeasurement(e3)), this.h = e2.h ? getMeasurement(e2.h) : "", this.hAlign = getStringOption(e2.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]), this.id = e2.id || "", this.layout = getStringOption(e2.layout, ["position", "lr-tb", "rl-row", "rl-tb", "row", "table", "tb"]), this.locale = e2.locale || "", this.maxH = getMeasurement(e2.maxH, "0pt"), this.maxW = getMeasurement(e2.maxW, "0pt"), this.mergeMode = getStringOption(e2.mergeMode, ["consumeData", "matchTemplate"]), this.minH = getMeasurement(e2.minH, "0pt"), this.minW = getMeasurement(e2.minW, "0pt"), this.name = e2.name || "", this.presence = getStringOption(e2.presence, ["visible", "hidden", "inactive", "invisible"]), this.relevant = getRelevant(e2.relevant), this.restoreState = getStringOption(e2.restoreState, ["manual", "auto"]), this.scope = getStringOption(e2.scope, ["name", "none"]), this.use = e2.use || "", this.usehref = e2.usehref || "", this.w = e2.w ? getMeasurement(e2.w) : "", this.x = getMeasurement(e2.x, "0pt"), this.y = getMeasurement(e2.y, "0pt"), this.assist = null, this.bind = null, this.bookend = null, this.border = null, this.break = null, this.calculate = null, this.desc = null, this.extras = null, this.keep = null, this.margin = null, this.occur = null, this.overflow = null, this.pageSet = null, this.para = null, this.traversal = null, this.validate = null, this.variables = null, this.area = new XFAObjectArray(), this.breakAfter = new XFAObjectArray(), this.breakBefore = new XFAObjectArray(), this.connect = new XFAObjectArray(), this.draw = new XFAObjectArray(), this.event = new XFAObjectArray(), this.exObject = new XFAObjectArray(), this.exclGroup = new XFAObjectArray(), this.field = new XFAObjectArray(), this.proto = new XFAObjectArray(), this.setProperty = new XFAObjectArray(), this.subform = new XFAObjectArray(), this.subformSet = new XFAObjectArray();
      }
      [ur]() {
        const e2 = this[gr]();
        return e2 instanceof SubformSet ? e2[ur]() : e2;
      }
      [xr]() {
        return true;
      }
      [Tr]() {
        return this.layout.endsWith("-tb") && 0 === this[Js].attempt && this[Js].numberInLine > 0 || this[gr]()[Tr]();
      }
      *[hr]() {
        yield* getContainedChildren(this);
      }
      [Qs]() {
        return flushHTML(this);
      }
      [js](e2, t2) {
        addHTML(this, e2, t2);
      }
      [ir]() {
        return getAvailableSpace(this);
      }
      [kr]() {
        const e2 = this[ur]();
        return !!e2[kr]() && (void 0 !== this[Js]._isSplittable ? this[Js]._isSplittable : "position" === this.layout || this.layout.includes("row") || this.keep && "none" !== this.keep.intact ? (this[Js]._isSplittable = false, false) : (!e2.layout?.endsWith("-tb") || 0 === e2[Js].numberInLine) && (this[Js]._isSplittable = true, true));
      }
      [Yr](e2) {
        if (setTabIndex(this), this.break) {
          if ("auto" !== this.break.after || "" !== this.break.afterTarget) {
            const e3 = new BreakAfter({ targetType: this.break.after, target: this.break.afterTarget, startNew: this.break.startNew.toString() });
            e3[fr] = this[fr], this[$s](e3), this.breakAfter.push(e3);
          }
          if ("auto" !== this.break.before || "" !== this.break.beforeTarget) {
            const e3 = new BreakBefore({ targetType: this.break.before, target: this.break.beforeTarget, startNew: this.break.startNew.toString() });
            e3[fr] = this[fr], this[$s](e3), this.breakBefore.push(e3);
          }
          if ("" !== this.break.overflowTarget) {
            const e3 = new Overflow({ target: this.break.overflowTarget, leader: this.break.overflowLeader, trailer: this.break.overflowTrailer });
            e3[fr] = this[fr], this[$s](e3), this.overflow.push(e3);
          }
          this[jr](this.break), this.break = null;
        }
        if ("hidden" === this.presence || "inactive" === this.presence)
          return HTMLResult.EMPTY;
        if ((this.breakBefore.children.length > 1 || this.breakAfter.children.length > 1) && warn$1("XFA - Several breakBefore or breakAfter in subforms: please file a bug."), this.breakBefore.children.length >= 1) {
          const e3 = this.breakBefore.children[0];
          if (handleBreak(e3))
            return HTMLResult.breakNode(e3);
        }
        if (this[Js]?.afterBreakAfter)
          return HTMLResult.EMPTY;
        fixDimensions(this);
        const t2 = [], i2 = { id: this[Qr], class: [] };
        setAccess(this, i2.class), this[Js] ||= /* @__PURE__ */ Object.create(null), Object.assign(this[Js], { children: t2, line: null, attributes: i2, attempt: 0, numberInLine: 0, availableSpace: { width: Math.min(this.w || 1 / 0, e2.width), height: Math.min(this.h || 1 / 0, e2.height) }, width: 0, height: 0, prevHeight: 0, currentWidth: 0 });
        const a2 = this[pr](), n2 = a2[Js].noLayoutFailure, s2 = this[kr]();
        if (s2 || setFirstUnsplittable(this), !checkDimensions(this, e2))
          return HTMLResult.FAILURE;
        const r2 = /* @__PURE__ */ new Set(["area", "draw", "exclGroup", "field", "subform", "subformSet"]);
        if (this.layout.includes("row")) {
          const e3 = this[ur]().columnWidths;
          Array.isArray(e3) && e3.length > 0 && (this[Js].columnWidths = e3, this[Js].currentColumn = 0);
        }
        const o2 = toStyle(this, "anchorType", "dimensions", "position", "presence", "border", "margin", "hAlign"), l3 = ["xfaSubform"], c2 = layoutClass(this);
        if (c2 && l3.push(c2), i2.style = o2, i2.class = l3, this.name && (i2.xfaName = this.name), this.overflow) {
          const t3 = this.overflow[or]();
          t3.addLeader && (t3.addLeader = false, handleOverflow(this, t3.leader, e2));
        }
        this[Ur]();
        const h2 = "lr-tb" === this.layout || "rl-tb" === this.layout, d2 = h2 ? 2 : 1;
        for (; this[Js].attempt < d2; this[Js].attempt++) {
          h2 && 1 === this[Js].attempt && (this[Js].numberInLine = 0);
          const e3 = this[Hs]({ filter: r2, include: true });
          if (e3.success)
            break;
          if (e3.isBreak())
            return this[Lr](), e3;
          if (h2 && 0 === this[Js].attempt && 0 === this[Js].numberInLine && !a2[Js].noLayoutFailure) {
            this[Js].attempt = d2;
            break;
          }
        }
        if (this[Lr](), s2 || unsetFirstUnsplittable(this), a2[Js].noLayoutFailure = n2, this[Js].attempt === d2)
          return this.overflow && (this[pr]()[Js].overflowNode = this.overflow), s2 || delete this[Js], HTMLResult.FAILURE;
        if (this.overflow) {
          const t3 = this.overflow[or]();
          t3.addTrailer && (t3.addTrailer = false, handleOverflow(this, t3.trailer, e2));
        }
        let u2 = 0, g2 = 0;
        this.margin && (u2 = this.margin.leftInset + this.margin.rightInset, g2 = this.margin.topInset + this.margin.bottomInset);
        const p2 = Math.max(this[Js].width + u2, this.w || 0), f2 = Math.max(this[Js].height + g2, this.h || 0), m2 = [this.x, this.y, p2, f2];
        if ("" === this.w && (o2.width = measureToString(p2)), "" === this.h && (o2.height = measureToString(f2)), ("0px" === o2.width || "0px" === o2.height) && 0 === t2.length)
          return HTMLResult.EMPTY;
        const b2 = { name: "div", attributes: i2, children: t2 };
        applyAssist(this, i2);
        const y2 = HTMLResult.success(createWrapper(this, b2), m2);
        if (this.breakAfter.children.length >= 1) {
          const e3 = this.breakAfter.children[0];
          if (handleBreak(e3))
            return this[Js].afterBreakAfter = y2, HTMLResult.breakNode(e3);
        }
        return delete this[Js], y2;
      }
    };
    __name(Subform, "Subform");
    SubformSet = class extends XFAObject {
      constructor(e2) {
        super(Ro, "subformSet", true), this.id = e2.id || "", this.name = e2.name || "", this.relation = getStringOption(e2.relation, ["ordered", "choice", "unordered"]), this.relevant = getRelevant(e2.relevant), this.use = e2.use || "", this.usehref = e2.usehref || "", this.bookend = null, this.break = null, this.desc = null, this.extras = null, this.occur = null, this.overflow = null, this.breakAfter = new XFAObjectArray(), this.breakBefore = new XFAObjectArray(), this.subform = new XFAObjectArray(), this.subformSet = new XFAObjectArray();
      }
      *[hr]() {
        yield* getContainedChildren(this);
      }
      [ur]() {
        let e2 = this[gr]();
        for (; !(e2 instanceof Subform); )
          e2 = e2[gr]();
        return e2;
      }
      [xr]() {
        return true;
      }
    };
    __name(SubformSet, "SubformSet");
    SubjectDN = class extends ContentObject {
      constructor(e2) {
        super(Ro, "subjectDN"), this.delimiter = e2.delimiter || ",", this.id = e2.id || "", this.name = e2.name || "", this.use = e2.use || "", this.usehref = e2.usehref || "";
      }
      [Zs]() {
        this[Vs] = new Map(this[Vs].split(this.delimiter).map((e2) => ((e2 = e2.split("=", 2))[0] = e2[0].trim(), e2)));
      }
    };
    __name(SubjectDN, "SubjectDN");
    SubjectDNs = class extends XFAObject {
      constructor(e2) {
        super(Ro, "subjectDNs", true), this.id = e2.id || "", this.type = getStringOption(e2.type, ["optional", "required"]), this.use = e2.use || "", this.usehref = e2.usehref || "", this.subjectDN = new XFAObjectArray();
      }
    };
    __name(SubjectDNs, "SubjectDNs");
    Submit = class extends XFAObject {
      constructor(e2) {
        super(Ro, "submit", true), this.embedPDF = getInteger({ data: e2.embedPDF, defaultValue: 0, validate: (e3) => 1 === e3 }), this.format = getStringOption(e2.format, ["xdp", "formdata", "pdf", "urlencoded", "xfd", "xml"]), this.id = e2.id || "", this.target = e2.target || "", this.textEncoding = getKeyword({ data: e2.textEncoding ? e2.textEncoding.toLowerCase() : "", defaultValue: "", validate: (e3) => ["utf-8", "big-five", "fontspecific", "gbk", "gb-18030", "gb-2312", "ksc-5601", "none", "shift-jis", "ucs-2", "utf-16"].includes(e3) || e3.match(/iso-8859-\d{2}/) }), this.use = e2.use || "", this.usehref = e2.usehref || "", this.xdpContent = e2.xdpContent || "", this.encrypt = null, this.encryptData = new XFAObjectArray(), this.signData = new XFAObjectArray();
      }
    };
    __name(Submit, "Submit");
    Template = class extends XFAObject {
      constructor(e2) {
        super(Ro, "template", true), this.baseProfile = getStringOption(e2.baseProfile, ["full", "interactiveForms"]), this.extras = null, this.subform = new XFAObjectArray();
      }
      [Zs]() {
        0 === this.subform.children.length && warn$1("XFA - No subforms in template node."), this.subform.children.length >= 2 && warn$1("XFA - Several subforms in template node: please file a bug."), this[Gr] = 5e3;
      }
      [kr]() {
        return true;
      }
      [qr](e2, t2) {
        return e2.startsWith("#") ? [this[br].get(e2.slice(1))] : searchNode(this, t2, e2, true, true);
      }
      *[Kr]() {
        if (!this.subform.children.length)
          return HTMLResult.success({ name: "div", children: [] });
        this[Js] = { overflowNode: null, firstUnsplittable: null, currentContentArea: null, currentPageArea: null, noLayoutFailure: false, pageNumber: 1, pagePosition: "first", oddOrEven: "odd", blankOrNotBlank: "nonBlank", paraStack: [] };
        const e2 = this.subform.children[0];
        e2.pageSet[Xs]();
        const t2 = e2.pageSet.pageArea.children, i2 = { name: "div", children: [] };
        let a2 = null, n2 = null, s2 = null;
        if (e2.breakBefore.children.length >= 1 ? (n2 = e2.breakBefore.children[0], s2 = n2.target) : e2.subform.children.length >= 1 && e2.subform.children[0].breakBefore.children.length >= 1 ? (n2 = e2.subform.children[0].breakBefore.children[0], s2 = n2.target) : e2.break?.beforeTarget ? (n2 = e2.break, s2 = n2.beforeTarget) : e2.subform.children.length >= 1 && e2.subform.children[0].break?.beforeTarget && (n2 = e2.subform.children[0].break, s2 = n2.beforeTarget), n2) {
          const e3 = this[qr](s2, n2[gr]());
          e3 instanceof PageArea && (a2 = e3, n2[Js] = {});
        }
        a2 ||= t2[0], a2[Js] = { numberOfUse: 1 };
        const r2 = a2[gr]();
        let o2;
        r2[Js] = { numberOfUse: 1, pageIndex: r2.pageArea.children.indexOf(a2), pageSetIndex: 0 };
        let l3 = null, c2 = null, h2 = true, d2 = 0, u2 = 0;
        for (; ; ) {
          if (h2)
            d2 = 0;
          else if (i2.children.pop(), 3 === ++d2)
            return warn$1("XFA - Something goes wrong: please file a bug."), i2;
          o2 = null, this[Js].currentPageArea = a2;
          const t3 = a2[Yr]().html;
          i2.children.push(t3), l3 && (this[Js].noLayoutFailure = true, t3.children.push(l3[Yr](a2[Js].space).html), l3 = null), c2 && (this[Js].noLayoutFailure = true, t3.children.push(c2[Yr](a2[Js].space).html), c2 = null);
          const n3 = a2.contentArea.children, s3 = t3.children.filter((e3) => e3.attributes.class.includes("xfaContentarea"));
          h2 = false, this[Js].firstUnsplittable = null, this[Js].noLayoutFailure = false;
          const flush = /* @__PURE__ */ __name((t4) => {
            const i3 = e2[Qs]();
            i3 && (h2 ||= i3.children?.length > 0, s3[t4].children.push(i3));
          }, "flush");
          for (let t4 = u2, a3 = n3.length; t4 < a3; t4++) {
            const a4 = this[Js].currentContentArea = n3[t4], r3 = { width: a4.w, height: a4.h };
            u2 = 0, l3 && (s3[t4].children.push(l3[Yr](r3).html), l3 = null), c2 && (s3[t4].children.push(c2[Yr](r3).html), c2 = null);
            const d3 = e2[Yr](r3);
            if (d3.success)
              return d3.html ? (h2 ||= d3.html.children?.length > 0, s3[t4].children.push(d3.html)) : !h2 && i2.children.length > 1 && i2.children.pop(), i2;
            if (d3.isBreak()) {
              const e3 = d3.breakNode;
              if (flush(t4), "auto" === e3.targetType)
                continue;
              e3.leader && (l3 = this[qr](e3.leader, e3[gr]()), l3 = l3 ? l3[0] : null), e3.trailer && (c2 = this[qr](e3.trailer, e3[gr]()), c2 = c2 ? c2[0] : null), "pageArea" === e3.targetType ? (o2 = e3[Js].target, t4 = 1 / 0) : e3[Js].target ? (o2 = e3[Js].target, u2 = e3[Js].index + 1, t4 = 1 / 0) : t4 = e3[Js].index;
              continue;
            }
            if (this[Js].overflowNode) {
              const e3 = this[Js].overflowNode;
              this[Js].overflowNode = null;
              const i3 = e3[or](), a5 = i3.target;
              i3.addLeader = null !== i3.leader, i3.addTrailer = null !== i3.trailer, flush(t4);
              const s4 = t4;
              if (t4 = 1 / 0, a5 instanceof PageArea)
                o2 = a5;
              else if (a5 instanceof ContentArea) {
                const e4 = n3.indexOf(a5);
                -1 !== e4 ? e4 > s4 ? t4 = e4 - 1 : u2 = e4 : (o2 = a5[gr](), u2 = o2.contentArea.children.indexOf(a5));
              }
              continue;
            }
            flush(t4);
          }
          this[Js].pageNumber += 1, o2 && (o2[Fr]() ? o2[Js].numberOfUse += 1 : o2 = null), a2 = o2 || a2[dr](), yield null;
        }
      }
    };
    __name(Template, "Template");
    Text = class extends ContentObject {
      constructor(e2) {
        super(Ro, "text"), this.id = e2.id || "", this.maxChars = getInteger({ data: e2.maxChars, defaultValue: 0, validate: (e3) => e3 >= 0 }), this.name = e2.name || "", this.rid = e2.rid || "", this.use = e2.use || "", this.usehref = e2.usehref || "";
      }
      [Us]() {
        return true;
      }
      [_r2](e2) {
        return e2[Dr] === to.xhtml.id ? (this[Vs] = e2, true) : (warn$1(`XFA - Invalid content in Text: ${e2[Er]}.`), false);
      }
      [Rr](e2) {
        this[Vs] instanceof XFAObject || super[Rr](e2);
      }
      [Zs]() {
        "string" == typeof this[Vs] && (this[Vs] = this[Vs].replaceAll("\r\n", "\n"));
      }
      [or]() {
        return "string" == typeof this[Vs] ? this[Vs].split(/[\u2029\u2028\n]/).filter((e2) => !!e2).join("\n") : this[Vs][Vr]();
      }
      [Yr](e2) {
        if ("string" == typeof this[Vs]) {
          const e3 = valueToHtml(this[Vs]).html;
          return this[Vs].includes("\u2029") ? (e3.name = "div", e3.children = [], this[Vs].split("\u2029").map((e4) => e4.split(/[\u2028\n]/).flatMap((e5) => [{ name: "span", value: e5 }, { name: "br" }])).forEach((t2) => {
            e3.children.push({ name: "p", children: t2 });
          })) : /[\u2028\n]/.test(this[Vs]) && (e3.name = "div", e3.children = [], this[Vs].split(/[\u2028\n]/).forEach((t2) => {
            e3.children.push({ name: "span", value: t2 }, { name: "br" });
          })), HTMLResult.success(e3);
        }
        return this[Vs][Yr](e2);
      }
    };
    __name(Text, "Text");
    TextEdit = class extends XFAObject {
      constructor(e2) {
        super(Ro, "textEdit", true), this.allowRichText = getInteger({ data: e2.allowRichText, defaultValue: 0, validate: (e3) => 1 === e3 }), this.hScrollPolicy = getStringOption(e2.hScrollPolicy, ["auto", "off", "on"]), this.id = e2.id || "", this.multiLine = getInteger({ data: e2.multiLine, defaultValue: "", validate: (e3) => 0 === e3 || 1 === e3 }), this.use = e2.use || "", this.usehref = e2.usehref || "", this.vScrollPolicy = getStringOption(e2.vScrollPolicy, ["auto", "off", "on"]), this.border = null, this.comb = null, this.extras = null, this.margin = null;
      }
      [Yr](e2) {
        const t2 = toStyle(this, "border", "font", "margin");
        let i2;
        const a2 = this[gr]()[gr]();
        return "" === this.multiLine && (this.multiLine = a2 instanceof Draw ? 1 : 0), i2 = 1 === this.multiLine ? { name: "textarea", attributes: { dataId: a2[Ks]?.[Qr] || a2[Qr], fieldId: a2[Qr], class: ["xfaTextfield"], style: t2, "aria-label": ariaLabel(a2), "aria-required": false } } : { name: "input", attributes: { type: "text", dataId: a2[Ks]?.[Qr] || a2[Qr], fieldId: a2[Qr], class: ["xfaTextfield"], style: t2, "aria-label": ariaLabel(a2), "aria-required": false } }, isRequired(a2) && (i2.attributes["aria-required"] = true, i2.attributes.required = true), HTMLResult.success({ name: "label", attributes: { class: ["xfaLabel"] }, children: [i2] });
      }
    };
    __name(TextEdit, "TextEdit");
    Time = class extends StringObject {
      constructor(e2) {
        super(Ro, "time"), this.id = e2.id || "", this.name = e2.name || "", this.use = e2.use || "", this.usehref = e2.usehref || "";
      }
      [Zs]() {
        const e2 = this[Vs].trim();
        this[Vs] = e2 ? new Date(e2) : null;
      }
      [Yr](e2) {
        return valueToHtml(this[Vs] ? this[Vs].toString() : "");
      }
    };
    __name(Time, "Time");
    TimeStamp = class extends XFAObject {
      constructor(e2) {
        super(Ro, "timeStamp"), this.id = e2.id || "", this.server = e2.server || "", this.type = getStringOption(e2.type, ["optional", "required"]), this.use = e2.use || "", this.usehref = e2.usehref || "";
      }
    };
    __name(TimeStamp, "TimeStamp");
    ToolTip = class extends StringObject {
      constructor(e2) {
        super(Ro, "toolTip"), this.id = e2.id || "", this.rid = e2.rid || "", this.use = e2.use || "", this.usehref = e2.usehref || "";
      }
    };
    __name(ToolTip, "ToolTip");
    Traversal = class extends XFAObject {
      constructor(e2) {
        super(Ro, "traversal", true), this.id = e2.id || "", this.use = e2.use || "", this.usehref = e2.usehref || "", this.extras = null, this.traverse = new XFAObjectArray();
      }
    };
    __name(Traversal, "Traversal");
    Traverse = class extends XFAObject {
      constructor(e2) {
        super(Ro, "traverse", true), this.id = e2.id || "", this.operation = getStringOption(e2.operation, ["next", "back", "down", "first", "left", "right", "up"]), this.ref = e2.ref || "", this.use = e2.use || "", this.usehref = e2.usehref || "", this.extras = null, this.script = null;
      }
      get name() {
        return this.operation;
      }
      [Ir]() {
        return false;
      }
    };
    __name(Traverse, "Traverse");
    Ui = class extends XFAObject {
      constructor(e2) {
        super(Ro, "ui", true), this.id = e2.id || "", this.use = e2.use || "", this.usehref = e2.usehref || "", this.extras = null, this.picture = null, this.barcode = null, this.button = null, this.checkButton = null, this.choiceList = null, this.dateTimeEdit = null, this.defaultUi = null, this.imageEdit = null, this.numericEdit = null, this.passwordEdit = null, this.signature = null, this.textEdit = null;
      }
      [or]() {
        if (void 0 === this[Js]) {
          for (const e2 of Object.getOwnPropertyNames(this)) {
            if ("extras" === e2 || "picture" === e2)
              continue;
            const t2 = this[e2];
            if (t2 instanceof XFAObject)
              return this[Js] = t2, t2;
          }
          this[Js] = null;
        }
        return this[Js];
      }
      [Yr](e2) {
        const t2 = this[or]();
        return t2 ? t2[Yr](e2) : HTMLResult.EMPTY;
      }
    };
    __name(Ui, "Ui");
    Validate = class extends XFAObject {
      constructor(e2) {
        super(Ro, "validate", true), this.formatTest = getStringOption(e2.formatTest, ["warning", "disabled", "error"]), this.id = e2.id || "", this.nullTest = getStringOption(e2.nullTest, ["disabled", "error", "warning"]), this.scriptTest = getStringOption(e2.scriptTest, ["error", "disabled", "warning"]), this.use = e2.use || "", this.usehref = e2.usehref || "", this.extras = null, this.message = null, this.picture = null, this.script = null;
      }
    };
    __name(Validate, "Validate");
    Value = class extends XFAObject {
      constructor(e2) {
        super(Ro, "value", true), this.id = e2.id || "", this.override = getInteger({ data: e2.override, defaultValue: 0, validate: (e3) => 1 === e3 }), this.relevant = getRelevant(e2.relevant), this.use = e2.use || "", this.usehref = e2.usehref || "", this.arc = null, this.boolean = null, this.date = null, this.dateTime = null, this.decimal = null, this.exData = null, this.float = null, this.image = null, this.integer = null, this.line = null, this.rectangle = null, this.text = null, this.time = null;
      }
      [Wr](e2) {
        const t2 = this[gr]();
        if (t2 instanceof Field && t2.ui?.imageEdit)
          return this.image || (this.image = new $o({}), this[$s](this.image)), void (this.image[Vs] = e2[Vs]);
        const i2 = e2[Er];
        if (null === this[i2]) {
          for (const e3 of Object.getOwnPropertyNames(this)) {
            const t3 = this[e3];
            t3 instanceof XFAObject && (this[e3] = null, this[jr](t3));
          }
          this[e2[Er]] = e2, this[$s](e2);
        } else
          this[i2][Vs] = e2[Vs];
      }
      [Vr]() {
        if (this.exData)
          return "string" == typeof this.exData[Vs] ? this.exData[Vs].trim() : this.exData[Vs][Vr]().trim();
        for (const e2 of Object.getOwnPropertyNames(this)) {
          if ("image" === e2)
            continue;
          const t2 = this[e2];
          if (t2 instanceof XFAObject)
            return (t2[Vs] || "").toString().trim();
        }
        return null;
      }
      [Yr](e2) {
        for (const t2 of Object.getOwnPropertyNames(this)) {
          const i2 = this[t2];
          if (i2 instanceof XFAObject)
            return i2[Yr](e2);
        }
        return HTMLResult.EMPTY;
      }
    };
    __name(Value, "Value");
    Variables = class extends XFAObject {
      constructor(e2) {
        super(Ro, "variables", true), this.id = e2.id || "", this.use = e2.use || "", this.usehref = e2.usehref || "", this.boolean = new XFAObjectArray(), this.date = new XFAObjectArray(), this.dateTime = new XFAObjectArray(), this.decimal = new XFAObjectArray(), this.exData = new XFAObjectArray(), this.float = new XFAObjectArray(), this.image = new XFAObjectArray(), this.integer = new XFAObjectArray(), this.manifest = new XFAObjectArray(), this.script = new XFAObjectArray(), this.text = new XFAObjectArray(), this.time = new XFAObjectArray();
      }
      [Ir]() {
        return true;
      }
    };
    __name(Variables, "Variables");
    TemplateNamespace = class {
      static [eo](e2, t2) {
        if (TemplateNamespace.hasOwnProperty(e2)) {
          const i2 = TemplateNamespace[e2](t2);
          return i2[zr](t2), i2;
        }
      }
      static appearanceFilter(e2) {
        return new AppearanceFilter(e2);
      }
      static arc(e2) {
        return new Arc(e2);
      }
      static area(e2) {
        return new Area(e2);
      }
      static assist(e2) {
        return new Assist(e2);
      }
      static barcode(e2) {
        return new Barcode(e2);
      }
      static bind(e2) {
        return new Bind(e2);
      }
      static bindItems(e2) {
        return new BindItems(e2);
      }
      static bookend(e2) {
        return new Bookend(e2);
      }
      static boolean(e2) {
        return new BooleanElement(e2);
      }
      static border(e2) {
        return new Border(e2);
      }
      static break(e2) {
        return new Break(e2);
      }
      static breakAfter(e2) {
        return new BreakAfter(e2);
      }
      static breakBefore(e2) {
        return new BreakBefore(e2);
      }
      static button(e2) {
        return new Button(e2);
      }
      static calculate(e2) {
        return new Calculate(e2);
      }
      static caption(e2) {
        return new Caption(e2);
      }
      static certificate(e2) {
        return new Certificate(e2);
      }
      static certificates(e2) {
        return new Certificates(e2);
      }
      static checkButton(e2) {
        return new CheckButton(e2);
      }
      static choiceList(e2) {
        return new ChoiceList(e2);
      }
      static color(e2) {
        return new Color(e2);
      }
      static comb(e2) {
        return new Comb(e2);
      }
      static connect(e2) {
        return new Connect(e2);
      }
      static contentArea(e2) {
        return new ContentArea(e2);
      }
      static corner(e2) {
        return new Corner(e2);
      }
      static date(e2) {
        return new DateElement(e2);
      }
      static dateTime(e2) {
        return new DateTime(e2);
      }
      static dateTimeEdit(e2) {
        return new DateTimeEdit(e2);
      }
      static decimal(e2) {
        return new Decimal(e2);
      }
      static defaultUi(e2) {
        return new DefaultUi(e2);
      }
      static desc(e2) {
        return new Desc(e2);
      }
      static digestMethod(e2) {
        return new DigestMethod(e2);
      }
      static digestMethods(e2) {
        return new DigestMethods(e2);
      }
      static draw(e2) {
        return new Draw(e2);
      }
      static edge(e2) {
        return new Edge(e2);
      }
      static encoding(e2) {
        return new Encoding(e2);
      }
      static encodings(e2) {
        return new Encodings(e2);
      }
      static encrypt(e2) {
        return new Encrypt(e2);
      }
      static encryptData(e2) {
        return new EncryptData(e2);
      }
      static encryption(e2) {
        return new Encryption(e2);
      }
      static encryptionMethod(e2) {
        return new EncryptionMethod(e2);
      }
      static encryptionMethods(e2) {
        return new EncryptionMethods(e2);
      }
      static event(e2) {
        return new jo(e2);
      }
      static exData(e2) {
        return new ExData(e2);
      }
      static exObject(e2) {
        return new ExObject(e2);
      }
      static exclGroup(e2) {
        return new ExclGroup(e2);
      }
      static execute(e2) {
        return new Execute(e2);
      }
      static extras(e2) {
        return new Extras(e2);
      }
      static field(e2) {
        return new Field(e2);
      }
      static fill(e2) {
        return new Fill(e2);
      }
      static filter(e2) {
        return new Filter(e2);
      }
      static float(e2) {
        return new Float(e2);
      }
      static font(e2) {
        return new template_Font(e2);
      }
      static format(e2) {
        return new Format(e2);
      }
      static handler(e2) {
        return new Handler(e2);
      }
      static hyphenation(e2) {
        return new Hyphenation(e2);
      }
      static image(e2) {
        return new $o(e2);
      }
      static imageEdit(e2) {
        return new ImageEdit(e2);
      }
      static integer(e2) {
        return new Integer(e2);
      }
      static issuers(e2) {
        return new Issuers(e2);
      }
      static items(e2) {
        return new Items(e2);
      }
      static keep(e2) {
        return new Keep(e2);
      }
      static keyUsage(e2) {
        return new KeyUsage(e2);
      }
      static line(e2) {
        return new Line(e2);
      }
      static linear(e2) {
        return new Linear(e2);
      }
      static lockDocument(e2) {
        return new LockDocument(e2);
      }
      static manifest(e2) {
        return new Manifest(e2);
      }
      static margin(e2) {
        return new Margin(e2);
      }
      static mdp(e2) {
        return new Mdp(e2);
      }
      static medium(e2) {
        return new Medium(e2);
      }
      static message(e2) {
        return new Message(e2);
      }
      static numericEdit(e2) {
        return new NumericEdit(e2);
      }
      static occur(e2) {
        return new Occur(e2);
      }
      static oid(e2) {
        return new Oid(e2);
      }
      static oids(e2) {
        return new Oids(e2);
      }
      static overflow(e2) {
        return new Overflow(e2);
      }
      static pageArea(e2) {
        return new PageArea(e2);
      }
      static pageSet(e2) {
        return new PageSet(e2);
      }
      static para(e2) {
        return new Para(e2);
      }
      static passwordEdit(e2) {
        return new PasswordEdit(e2);
      }
      static pattern(e2) {
        return new template_Pattern(e2);
      }
      static picture(e2) {
        return new Picture(e2);
      }
      static proto(e2) {
        return new Proto(e2);
      }
      static radial(e2) {
        return new Radial(e2);
      }
      static reason(e2) {
        return new Reason(e2);
      }
      static reasons(e2) {
        return new Reasons(e2);
      }
      static rectangle(e2) {
        return new Rectangle(e2);
      }
      static ref(e2) {
        return new RefElement(e2);
      }
      static script(e2) {
        return new Script(e2);
      }
      static setProperty(e2) {
        return new SetProperty(e2);
      }
      static signData(e2) {
        return new SignData(e2);
      }
      static signature(e2) {
        return new Signature(e2);
      }
      static signing(e2) {
        return new Signing(e2);
      }
      static solid(e2) {
        return new Solid(e2);
      }
      static speak(e2) {
        return new Speak(e2);
      }
      static stipple(e2) {
        return new Stipple(e2);
      }
      static subform(e2) {
        return new Subform(e2);
      }
      static subformSet(e2) {
        return new SubformSet(e2);
      }
      static subjectDN(e2) {
        return new SubjectDN(e2);
      }
      static subjectDNs(e2) {
        return new SubjectDNs(e2);
      }
      static submit(e2) {
        return new Submit(e2);
      }
      static template(e2) {
        return new Template(e2);
      }
      static text(e2) {
        return new Text(e2);
      }
      static textEdit(e2) {
        return new TextEdit(e2);
      }
      static time(e2) {
        return new Time(e2);
      }
      static timeStamp(e2) {
        return new TimeStamp(e2);
      }
      static toolTip(e2) {
        return new ToolTip(e2);
      }
      static traversal(e2) {
        return new Traversal(e2);
      }
      static traverse(e2) {
        return new Traverse(e2);
      }
      static ui(e2) {
        return new Ui(e2);
      }
      static validate(e2) {
        return new Validate(e2);
      }
      static value(e2) {
        return new Value(e2);
      }
      static variables(e2) {
        return new Variables(e2);
      }
    };
    __name(TemplateNamespace, "TemplateNamespace");
    Ho = to.datasets.id;
    __name(createText, "createText");
    Binder = class {
      constructor(e2) {
        this.root = e2, this.datasets = e2.datasets, this.data = e2.datasets?.data || new XmlObject(to.datasets.id, "data"), this.emptyMerge = 0 === this.data[cr]().length, this.root.form = this.form = e2.template[Ws]();
      }
      _isConsumeData() {
        return !this.emptyMerge && this._mergeMode;
      }
      _isMatchTemplate() {
        return !this._isConsumeData();
      }
      bind() {
        return this._bindElement(this.form, this.data), this.form;
      }
      getData() {
        return this.data;
      }
      _bindValue(e2, t2, i2) {
        if (e2[Ks] = t2, e2[mr]())
          if (t2[Sr]()) {
            const i3 = t2[rr]();
            e2[Wr](createText(i3));
          } else if (e2 instanceof Field && "multiSelect" === e2.ui?.choiceList?.open) {
            const i3 = t2[cr]().map((e3) => e3[Vs].trim()).join("\n");
            e2[Wr](createText(i3));
          } else
            this._isConsumeData() && warn$1("XFA - Nodes haven't the same type.");
        else
          !t2[Sr]() || this._isMatchTemplate() ? this._bindElement(e2, t2) : warn$1("XFA - Nodes haven't the same type.");
      }
      _findDataByNameToConsume(e2, t2, i2, a2) {
        if (!e2)
          return null;
        let n2, s2;
        for (let a3 = 0; a3 < 3; a3++) {
          for (n2 = i2[lr](e2, false, true); s2 = n2.next().value, s2; )
            if (t2 === s2[Sr]())
              return s2;
          if (i2[Dr] === to.datasets.id && "data" === i2[Er])
            break;
          i2 = i2[gr]();
        }
        return a2 ? (n2 = this.data[lr](e2, true, false), s2 = n2.next().value, s2 || (n2 = this.data[er](e2, true), s2 = n2.next().value, s2?.[Sr]() ? s2 : null)) : null;
      }
      _setProperties(e2, t2) {
        if (e2.hasOwnProperty("setProperty"))
          for (const { ref: i2, target: a2, connection: n2 } of e2.setProperty.children) {
            if (n2)
              continue;
            if (!i2)
              continue;
            const s2 = searchNode(this.root, t2, i2, false, false);
            if (!s2) {
              warn$1(`XFA - Invalid reference: ${i2}.`);
              continue;
            }
            const [r2] = s2;
            if (!r2[vr](this.data)) {
              warn$1("XFA - Invalid node: must be a data node.");
              continue;
            }
            const o2 = searchNode(this.root, e2, a2, false, false);
            if (!o2) {
              warn$1(`XFA - Invalid target: ${a2}.`);
              continue;
            }
            const [l3] = o2;
            if (!l3[vr](e2)) {
              warn$1("XFA - Invalid target: must be a property or subproperty.");
              continue;
            }
            const c2 = l3[gr]();
            if (l3 instanceof SetProperty || c2 instanceof SetProperty) {
              warn$1("XFA - Invalid target: cannot be a setProperty or one of its properties.");
              continue;
            }
            if (l3 instanceof BindItems || c2 instanceof BindItems) {
              warn$1("XFA - Invalid target: cannot be a bindItems or one of its properties.");
              continue;
            }
            const h2 = r2[Vr](), d2 = l3[Er];
            if (l3 instanceof XFAAttribute) {
              const e3 = /* @__PURE__ */ Object.create(null);
              e3[d2] = h2;
              const t3 = Reflect.construct(Object.getPrototypeOf(c2).constructor, [e3]);
              c2[d2] = t3[d2];
              continue;
            }
            l3.hasOwnProperty(Vs) ? (l3[Ks] = r2, l3[Vs] = h2, l3[Zs]()) : warn$1("XFA - Invalid node to use in setProperty");
          }
      }
      _bindItems(e2, t2) {
        if (!e2.hasOwnProperty("items") || !e2.hasOwnProperty("bindItems") || e2.bindItems.isEmpty())
          return;
        for (const t3 of e2.items.children)
          e2[jr](t3);
        e2.items.clear();
        const i2 = new Items({}), a2 = new Items({});
        e2[$s](i2), e2.items.push(i2), e2[$s](a2), e2.items.push(a2);
        for (const { ref: n2, labelRef: s2, valueRef: r2, connection: o2 } of e2.bindItems.children) {
          if (o2)
            continue;
          if (!n2)
            continue;
          const e3 = searchNode(this.root, t2, n2, false, false);
          if (e3)
            for (const t3 of e3) {
              if (!t3[vr](this.datasets)) {
                warn$1(`XFA - Invalid ref (${n2}): must be a datasets child.`);
                continue;
              }
              const e4 = searchNode(this.root, t3, s2, true, false);
              if (!e4) {
                warn$1(`XFA - Invalid label: ${s2}.`);
                continue;
              }
              const [o3] = e4;
              if (!o3[vr](this.datasets)) {
                warn$1("XFA - Invalid label: must be a datasets child.");
                continue;
              }
              const l3 = searchNode(this.root, t3, r2, true, false);
              if (!l3) {
                warn$1(`XFA - Invalid value: ${r2}.`);
                continue;
              }
              const [c2] = l3;
              if (!c2[vr](this.datasets)) {
                warn$1("XFA - Invalid value: must be a datasets child.");
                continue;
              }
              const h2 = createText(o3[Vr]()), d2 = createText(c2[Vr]());
              i2[$s](h2), i2.text.push(h2), a2[$s](d2), a2.text.push(d2);
            }
          else
            warn$1(`XFA - Invalid reference: ${n2}.`);
        }
      }
      _bindOccurrences(e2, t2, i2) {
        let a2;
        if (t2.length > 1 && (a2 = e2[Ws](), a2[jr](a2.occur), a2.occur = null), this._bindValue(e2, t2[0], i2), this._setProperties(e2, t2[0]), this._bindItems(e2, t2[0]), 1 === t2.length)
          return;
        const n2 = e2[gr](), s2 = e2[Er], r2 = n2[yr](e2);
        for (let e3 = 1, o2 = t2.length; e3 < o2; e3++) {
          const o3 = t2[e3], l3 = a2[Ws]();
          n2[s2].push(l3), n2[wr](r2 + e3, l3), this._bindValue(l3, o3, i2), this._setProperties(l3, o3), this._bindItems(l3, o3);
        }
      }
      _createOccurrences(e2) {
        if (!this.emptyMerge)
          return;
        const { occur: t2 } = e2;
        if (!t2 || t2.initial <= 1)
          return;
        const i2 = e2[gr](), a2 = e2[Er];
        if (!(i2[a2] instanceof XFAObjectArray))
          return;
        let n2;
        n2 = e2.name ? i2[a2].children.filter((t3) => t3.name === e2.name).length : i2[a2].children.length;
        const s2 = i2[yr](e2) + 1, r2 = t2.initial - n2;
        if (r2) {
          const t3 = e2[Ws]();
          t3[jr](t3.occur), t3.occur = null, i2[a2].push(t3), i2[wr](s2, t3);
          for (let e3 = 1; e3 < r2; e3++) {
            const n3 = t3[Ws]();
            i2[a2].push(n3), i2[wr](s2 + e3, n3);
          }
        }
      }
      _getOccurInfo(e2) {
        const { name: t2, occur: i2 } = e2;
        if (!i2 || !t2)
          return [1, 1];
        const a2 = -1 === i2.max ? 1 / 0 : i2.max;
        return [i2.min, a2];
      }
      _setAndBind(e2, t2) {
        this._setProperties(e2, t2), this._bindItems(e2, t2), this._bindElement(e2, t2);
      }
      _bindElement(e2, t2) {
        const i2 = [];
        this._createOccurrences(e2);
        for (const a2 of e2[cr]()) {
          if (a2[Ks])
            continue;
          if (void 0 === this._mergeMode && "subform" === a2[Er]) {
            this._mergeMode = "consumeData" === a2.mergeMode;
            const e4 = t2[cr]();
            if (e4.length > 0)
              this._bindOccurrences(a2, [e4[0]], null);
            else if (this.emptyMerge) {
              const e5 = t2[Dr] === Ho ? -1 : t2[Dr], i3 = a2[Ks] = new XmlObject(e5, a2.name || "root");
              t2[$s](i3), this._bindElement(a2, i3);
            }
            continue;
          }
          if (!a2[xr]())
            continue;
          let e3 = false, n2 = null, s2 = null, r2 = null;
          if (a2.bind) {
            switch (a2.bind.match) {
              case "none":
                this._setAndBind(a2, t2);
                continue;
              case "global":
                e3 = true;
                break;
              case "dataRef":
                if (!a2.bind.ref) {
                  warn$1(`XFA - ref is empty in node ${a2[Er]}.`), this._setAndBind(a2, t2);
                  continue;
                }
                s2 = a2.bind.ref;
            }
            a2.bind.picture && (n2 = a2.bind.picture[Vs]);
          }
          const [o2, l3] = this._getOccurInfo(a2);
          if (s2) {
            if (r2 = searchNode(this.root, t2, s2, true, false), null === r2) {
              if (r2 = createDataNode(this.data, t2, s2), !r2)
                continue;
              this._isConsumeData() && (r2[Gs] = true), this._setAndBind(a2, r2);
              continue;
            }
            this._isConsumeData() && (r2 = r2.filter((e4) => !e4[Gs])), r2.length > l3 ? r2 = r2.slice(0, l3) : 0 === r2.length && (r2 = null), r2 && this._isConsumeData() && r2.forEach((e4) => {
              e4[Gs] = true;
            });
          } else {
            if (!a2.name) {
              this._setAndBind(a2, t2);
              continue;
            }
            if (this._isConsumeData()) {
              const i3 = [];
              for (; i3.length < l3; ) {
                const n3 = this._findDataByNameToConsume(a2.name, a2[mr](), t2, e3);
                if (!n3)
                  break;
                n3[Gs] = true, i3.push(n3);
              }
              r2 = i3.length > 0 ? i3 : null;
            } else {
              if (r2 = t2[lr](a2.name, false, this.emptyMerge).next().value, !r2) {
                if (0 === o2) {
                  i2.push(a2);
                  continue;
                }
                const e4 = t2[Dr] === Ho ? -1 : t2[Dr];
                r2 = a2[Ks] = new XmlObject(e4, a2.name), this.emptyMerge && (r2[Gs] = true), t2[$s](r2), this._setAndBind(a2, r2);
                continue;
              }
              this.emptyMerge && (r2[Gs] = true), r2 = [r2];
            }
          }
          r2 ? this._bindOccurrences(a2, r2, n2) : o2 > 0 ? this._setAndBind(a2, t2) : i2.push(a2);
        }
        i2.forEach((e3) => e3[gr]()[jr](e3));
      }
    };
    __name(Binder, "Binder");
    DataHandler = class {
      constructor(e2, t2) {
        this.data = t2, this.dataset = e2.datasets || null;
      }
      serialize(e2) {
        const t2 = [[-1, this.data[cr]()]];
        for (; t2.length > 0; ) {
          const i3 = t2.at(-1), [a2, n2] = i3;
          if (a2 + 1 === n2.length) {
            t2.pop();
            continue;
          }
          const s2 = n2[++i3[0]], r2 = e2.get(s2[Qr]);
          if (r2)
            s2[Wr](r2);
          else {
            const t3 = s2[tr]();
            for (const i4 of t3.values()) {
              const t4 = e2.get(i4[Qr]);
              if (t4) {
                i4[Wr](t4);
                break;
              }
            }
          }
          const o2 = s2[cr]();
          o2.length > 0 && t2.push([-1, o2]);
        }
        const i2 = ['<xfa:datasets xmlns:xfa="http://www.xfa.org/schema/xfa-data/1.0/">'];
        if (this.dataset)
          for (const e3 of this.dataset[cr]())
            "data" !== e3[Er] && e3[Jr](i2);
        return this.data[Jr](i2), i2.push("</xfa:datasets>"), i2.join("");
      }
    };
    __name(DataHandler, "DataHandler");
    qo = to.config.id;
    Acrobat = class extends XFAObject {
      constructor(e2) {
        super(qo, "acrobat", true), this.acrobat7 = null, this.autoSave = null, this.common = null, this.validate = null, this.validateApprovalSignatures = null, this.submitUrl = new XFAObjectArray();
      }
    };
    __name(Acrobat, "Acrobat");
    Acrobat7 = class extends XFAObject {
      constructor(e2) {
        super(qo, "acrobat7", true), this.dynamicRender = null;
      }
    };
    __name(Acrobat7, "Acrobat7");
    ADBE_JSConsole = class extends OptionObject {
      constructor(e2) {
        super(qo, "ADBE_JSConsole", ["delegate", "Enable", "Disable"]);
      }
    };
    __name(ADBE_JSConsole, "ADBE_JSConsole");
    ADBE_JSDebugger = class extends OptionObject {
      constructor(e2) {
        super(qo, "ADBE_JSDebugger", ["delegate", "Enable", "Disable"]);
      }
    };
    __name(ADBE_JSDebugger, "ADBE_JSDebugger");
    AddSilentPrint = class extends Option01 {
      constructor(e2) {
        super(qo, "addSilentPrint");
      }
    };
    __name(AddSilentPrint, "AddSilentPrint");
    AddViewerPreferences = class extends Option01 {
      constructor(e2) {
        super(qo, "addViewerPreferences");
      }
    };
    __name(AddViewerPreferences, "AddViewerPreferences");
    AdjustData = class extends Option10 {
      constructor(e2) {
        super(qo, "adjustData");
      }
    };
    __name(AdjustData, "AdjustData");
    AdobeExtensionLevel = class extends IntegerObject {
      constructor(e2) {
        super(qo, "adobeExtensionLevel", 0, (e3) => e3 >= 1 && e3 <= 8);
      }
    };
    __name(AdobeExtensionLevel, "AdobeExtensionLevel");
    Agent = class extends XFAObject {
      constructor(e2) {
        super(qo, "agent", true), this.name = e2.name ? e2.name.trim() : "", this.common = new XFAObjectArray();
      }
    };
    __name(Agent, "Agent");
    AlwaysEmbed = class extends ContentObject {
      constructor(e2) {
        super(qo, "alwaysEmbed");
      }
    };
    __name(AlwaysEmbed, "AlwaysEmbed");
    Amd = class extends StringObject {
      constructor(e2) {
        super(qo, "amd");
      }
    };
    __name(Amd, "Amd");
    config_Area = class extends XFAObject {
      constructor(e2) {
        super(qo, "area"), this.level = getInteger({ data: e2.level, defaultValue: 0, validate: (e3) => e3 >= 1 && e3 <= 3 }), this.name = getStringOption(e2.name, ["", "barcode", "coreinit", "deviceDriver", "font", "general", "layout", "merge", "script", "signature", "sourceSet", "templateCache"]);
      }
    };
    __name(config_Area, "config_Area");
    Attributes = class extends OptionObject {
      constructor(e2) {
        super(qo, "attributes", ["preserve", "delegate", "ignore"]);
      }
    };
    __name(Attributes, "Attributes");
    AutoSave = class extends OptionObject {
      constructor(e2) {
        super(qo, "autoSave", ["disabled", "enabled"]);
      }
    };
    __name(AutoSave, "AutoSave");
    Base = class extends StringObject {
      constructor(e2) {
        super(qo, "base");
      }
    };
    __name(Base, "Base");
    BatchOutput = class extends XFAObject {
      constructor(e2) {
        super(qo, "batchOutput"), this.format = getStringOption(e2.format, ["none", "concat", "zip", "zipCompress"]);
      }
    };
    __name(BatchOutput, "BatchOutput");
    BehaviorOverride = class extends ContentObject {
      constructor(e2) {
        super(qo, "behaviorOverride");
      }
      [Zs]() {
        this[Vs] = new Map(this[Vs].trim().split(/\s+/).filter((e2) => e2.includes(":")).map((e2) => e2.split(":", 2)));
      }
    };
    __name(BehaviorOverride, "BehaviorOverride");
    Cache = class extends XFAObject {
      constructor(e2) {
        super(qo, "cache", true), this.templateCache = null;
      }
    };
    __name(Cache, "Cache");
    Change = class extends Option01 {
      constructor(e2) {
        super(qo, "change");
      }
    };
    __name(Change, "Change");
    Common = class extends XFAObject {
      constructor(e2) {
        super(qo, "common", true), this.data = null, this.locale = null, this.localeSet = null, this.messaging = null, this.suppressBanner = null, this.template = null, this.validationMessaging = null, this.versionControl = null, this.log = new XFAObjectArray();
      }
    };
    __name(Common, "Common");
    Compress = class extends XFAObject {
      constructor(e2) {
        super(qo, "compress"), this.scope = getStringOption(e2.scope, ["imageOnly", "document"]);
      }
    };
    __name(Compress, "Compress");
    CompressLogicalStructure = class extends Option01 {
      constructor(e2) {
        super(qo, "compressLogicalStructure");
      }
    };
    __name(CompressLogicalStructure, "CompressLogicalStructure");
    CompressObjectStream = class extends Option10 {
      constructor(e2) {
        super(qo, "compressObjectStream");
      }
    };
    __name(CompressObjectStream, "CompressObjectStream");
    Compression = class extends XFAObject {
      constructor(e2) {
        super(qo, "compression", true), this.compressLogicalStructure = null, this.compressObjectStream = null, this.level = null, this.type = null;
      }
    };
    __name(Compression, "Compression");
    Config = class extends XFAObject {
      constructor(e2) {
        super(qo, "config", true), this.acrobat = null, this.present = null, this.trace = null, this.agent = new XFAObjectArray();
      }
    };
    __name(Config, "Config");
    Conformance = class extends OptionObject {
      constructor(e2) {
        super(qo, "conformance", ["A", "B"]);
      }
    };
    __name(Conformance, "Conformance");
    ContentCopy = class extends Option01 {
      constructor(e2) {
        super(qo, "contentCopy");
      }
    };
    __name(ContentCopy, "ContentCopy");
    Copies = class extends IntegerObject {
      constructor(e2) {
        super(qo, "copies", 1, (e3) => e3 >= 1);
      }
    };
    __name(Copies, "Copies");
    Creator = class extends StringObject {
      constructor(e2) {
        super(qo, "creator");
      }
    };
    __name(Creator, "Creator");
    CurrentPage = class extends IntegerObject {
      constructor(e2) {
        super(qo, "currentPage", 0, (e3) => e3 >= 0);
      }
    };
    __name(CurrentPage, "CurrentPage");
    Data = class extends XFAObject {
      constructor(e2) {
        super(qo, "data", true), this.adjustData = null, this.attributes = null, this.incrementalLoad = null, this.outputXSL = null, this.range = null, this.record = null, this.startNode = null, this.uri = null, this.window = null, this.xsl = null, this.excludeNS = new XFAObjectArray(), this.transform = new XFAObjectArray();
      }
    };
    __name(Data, "Data");
    Debug = class extends XFAObject {
      constructor(e2) {
        super(qo, "debug", true), this.uri = null;
      }
    };
    __name(Debug, "Debug");
    DefaultTypeface = class extends ContentObject {
      constructor(e2) {
        super(qo, "defaultTypeface"), this.writingScript = getStringOption(e2.writingScript, ["*", "Arabic", "Cyrillic", "EastEuropeanRoman", "Greek", "Hebrew", "Japanese", "Korean", "Roman", "SimplifiedChinese", "Thai", "TraditionalChinese", "Vietnamese"]);
      }
    };
    __name(DefaultTypeface, "DefaultTypeface");
    Destination = class extends OptionObject {
      constructor(e2) {
        super(qo, "destination", ["pdf", "pcl", "ps", "webClient", "zpl"]);
      }
    };
    __name(Destination, "Destination");
    DocumentAssembly = class extends Option01 {
      constructor(e2) {
        super(qo, "documentAssembly");
      }
    };
    __name(DocumentAssembly, "DocumentAssembly");
    Driver = class extends XFAObject {
      constructor(e2) {
        super(qo, "driver", true), this.name = e2.name ? e2.name.trim() : "", this.fontInfo = null, this.xdc = null;
      }
    };
    __name(Driver, "Driver");
    DuplexOption = class extends OptionObject {
      constructor(e2) {
        super(qo, "duplexOption", ["simplex", "duplexFlipLongEdge", "duplexFlipShortEdge"]);
      }
    };
    __name(DuplexOption, "DuplexOption");
    DynamicRender = class extends OptionObject {
      constructor(e2) {
        super(qo, "dynamicRender", ["forbidden", "required"]);
      }
    };
    __name(DynamicRender, "DynamicRender");
    Embed = class extends Option01 {
      constructor(e2) {
        super(qo, "embed");
      }
    };
    __name(Embed, "Embed");
    config_Encrypt = class extends Option01 {
      constructor(e2) {
        super(qo, "encrypt");
      }
    };
    __name(config_Encrypt, "config_Encrypt");
    config_Encryption = class extends XFAObject {
      constructor(e2) {
        super(qo, "encryption", true), this.encrypt = null, this.encryptionLevel = null, this.permissions = null;
      }
    };
    __name(config_Encryption, "config_Encryption");
    EncryptionLevel = class extends OptionObject {
      constructor(e2) {
        super(qo, "encryptionLevel", ["40bit", "128bit"]);
      }
    };
    __name(EncryptionLevel, "EncryptionLevel");
    Enforce = class extends StringObject {
      constructor(e2) {
        super(qo, "enforce");
      }
    };
    __name(Enforce, "Enforce");
    Equate = class extends XFAObject {
      constructor(e2) {
        super(qo, "equate"), this.force = getInteger({ data: e2.force, defaultValue: 1, validate: (e3) => 0 === e3 }), this.from = e2.from || "", this.to = e2.to || "";
      }
    };
    __name(Equate, "Equate");
    EquateRange = class extends XFAObject {
      constructor(e2) {
        super(qo, "equateRange"), this.from = e2.from || "", this.to = e2.to || "", this._unicodeRange = e2.unicodeRange || "";
      }
      get unicodeRange() {
        const e2 = [], t2 = /U\+([0-9a-fA-F]+)/, i2 = this._unicodeRange;
        for (let a2 of i2.split(",").map((e3) => e3.trim()).filter((e3) => !!e3))
          a2 = a2.split("-", 2).map((e3) => {
            const i3 = e3.match(t2);
            return i3 ? parseInt(i3[1], 16) : 0;
          }), 1 === a2.length && a2.push(a2[0]), e2.push(a2);
        return shadow$1(this, "unicodeRange", e2);
      }
    };
    __name(EquateRange, "EquateRange");
    Exclude = class extends ContentObject {
      constructor(e2) {
        super(qo, "exclude");
      }
      [Zs]() {
        this[Vs] = this[Vs].trim().split(/\s+/).filter((e2) => e2 && ["calculate", "close", "enter", "exit", "initialize", "ready", "validate"].includes(e2));
      }
    };
    __name(Exclude, "Exclude");
    ExcludeNS = class extends StringObject {
      constructor(e2) {
        super(qo, "excludeNS");
      }
    };
    __name(ExcludeNS, "ExcludeNS");
    FlipLabel = class extends OptionObject {
      constructor(e2) {
        super(qo, "flipLabel", ["usePrinterSetting", "on", "off"]);
      }
    };
    __name(FlipLabel, "FlipLabel");
    config_FontInfo = class extends XFAObject {
      constructor(e2) {
        super(qo, "fontInfo", true), this.embed = null, this.map = null, this.subsetBelow = null, this.alwaysEmbed = new XFAObjectArray(), this.defaultTypeface = new XFAObjectArray(), this.neverEmbed = new XFAObjectArray();
      }
    };
    __name(config_FontInfo, "config_FontInfo");
    FormFieldFilling = class extends Option01 {
      constructor(e2) {
        super(qo, "formFieldFilling");
      }
    };
    __name(FormFieldFilling, "FormFieldFilling");
    GroupParent = class extends StringObject {
      constructor(e2) {
        super(qo, "groupParent");
      }
    };
    __name(GroupParent, "GroupParent");
    IfEmpty = class extends OptionObject {
      constructor(e2) {
        super(qo, "ifEmpty", ["dataValue", "dataGroup", "ignore", "remove"]);
      }
    };
    __name(IfEmpty, "IfEmpty");
    IncludeXDPContent = class extends StringObject {
      constructor(e2) {
        super(qo, "includeXDPContent");
      }
    };
    __name(IncludeXDPContent, "IncludeXDPContent");
    IncrementalLoad = class extends OptionObject {
      constructor(e2) {
        super(qo, "incrementalLoad", ["none", "forwardOnly"]);
      }
    };
    __name(IncrementalLoad, "IncrementalLoad");
    IncrementalMerge = class extends Option01 {
      constructor(e2) {
        super(qo, "incrementalMerge");
      }
    };
    __name(IncrementalMerge, "IncrementalMerge");
    Interactive = class extends Option01 {
      constructor(e2) {
        super(qo, "interactive");
      }
    };
    __name(Interactive, "Interactive");
    Jog = class extends OptionObject {
      constructor(e2) {
        super(qo, "jog", ["usePrinterSetting", "none", "pageSet"]);
      }
    };
    __name(Jog, "Jog");
    LabelPrinter = class extends XFAObject {
      constructor(e2) {
        super(qo, "labelPrinter", true), this.name = getStringOption(e2.name, ["zpl", "dpl", "ipl", "tcpl"]), this.batchOutput = null, this.flipLabel = null, this.fontInfo = null, this.xdc = null;
      }
    };
    __name(LabelPrinter, "LabelPrinter");
    Layout = class extends OptionObject {
      constructor(e2) {
        super(qo, "layout", ["paginate", "panel"]);
      }
    };
    __name(Layout, "Layout");
    Level = class extends IntegerObject {
      constructor(e2) {
        super(qo, "level", 0, (e3) => e3 > 0);
      }
    };
    __name(Level, "Level");
    Linearized = class extends Option01 {
      constructor(e2) {
        super(qo, "linearized");
      }
    };
    __name(Linearized, "Linearized");
    Locale = class extends StringObject {
      constructor(e2) {
        super(qo, "locale");
      }
    };
    __name(Locale, "Locale");
    LocaleSet = class extends StringObject {
      constructor(e2) {
        super(qo, "localeSet");
      }
    };
    __name(LocaleSet, "LocaleSet");
    Log = class extends XFAObject {
      constructor(e2) {
        super(qo, "log", true), this.mode = null, this.threshold = null, this.to = null, this.uri = null;
      }
    };
    __name(Log, "Log");
    MapElement = class extends XFAObject {
      constructor(e2) {
        super(qo, "map", true), this.equate = new XFAObjectArray(), this.equateRange = new XFAObjectArray();
      }
    };
    __name(MapElement, "MapElement");
    MediumInfo = class extends XFAObject {
      constructor(e2) {
        super(qo, "mediumInfo", true), this.map = null;
      }
    };
    __name(MediumInfo, "MediumInfo");
    config_Message = class extends XFAObject {
      constructor(e2) {
        super(qo, "message", true), this.msgId = null, this.severity = null;
      }
    };
    __name(config_Message, "config_Message");
    Messaging = class extends XFAObject {
      constructor(e2) {
        super(qo, "messaging", true), this.message = new XFAObjectArray();
      }
    };
    __name(Messaging, "Messaging");
    Mode = class extends OptionObject {
      constructor(e2) {
        super(qo, "mode", ["append", "overwrite"]);
      }
    };
    __name(Mode, "Mode");
    ModifyAnnots = class extends Option01 {
      constructor(e2) {
        super(qo, "modifyAnnots");
      }
    };
    __name(ModifyAnnots, "ModifyAnnots");
    MsgId = class extends IntegerObject {
      constructor(e2) {
        super(qo, "msgId", 1, (e3) => e3 >= 1);
      }
    };
    __name(MsgId, "MsgId");
    NameAttr = class extends StringObject {
      constructor(e2) {
        super(qo, "nameAttr");
      }
    };
    __name(NameAttr, "NameAttr");
    NeverEmbed = class extends ContentObject {
      constructor(e2) {
        super(qo, "neverEmbed");
      }
    };
    __name(NeverEmbed, "NeverEmbed");
    NumberOfCopies = class extends IntegerObject {
      constructor(e2) {
        super(qo, "numberOfCopies", null, (e3) => e3 >= 2 && e3 <= 5);
      }
    };
    __name(NumberOfCopies, "NumberOfCopies");
    OpenAction = class extends XFAObject {
      constructor(e2) {
        super(qo, "openAction", true), this.destination = null;
      }
    };
    __name(OpenAction, "OpenAction");
    Output = class extends XFAObject {
      constructor(e2) {
        super(qo, "output", true), this.to = null, this.type = null, this.uri = null;
      }
    };
    __name(Output, "Output");
    OutputBin = class extends StringObject {
      constructor(e2) {
        super(qo, "outputBin");
      }
    };
    __name(OutputBin, "OutputBin");
    OutputXSL = class extends XFAObject {
      constructor(e2) {
        super(qo, "outputXSL", true), this.uri = null;
      }
    };
    __name(OutputXSL, "OutputXSL");
    Overprint = class extends OptionObject {
      constructor(e2) {
        super(qo, "overprint", ["none", "both", "draw", "field"]);
      }
    };
    __name(Overprint, "Overprint");
    Packets = class extends StringObject {
      constructor(e2) {
        super(qo, "packets");
      }
      [Zs]() {
        "*" !== this[Vs] && (this[Vs] = this[Vs].trim().split(/\s+/).filter((e2) => ["config", "datasets", "template", "xfdf", "xslt"].includes(e2)));
      }
    };
    __name(Packets, "Packets");
    PageOffset = class extends XFAObject {
      constructor(e2) {
        super(qo, "pageOffset"), this.x = getInteger({ data: e2.x, defaultValue: "useXDCSetting", validate: (e3) => true }), this.y = getInteger({ data: e2.y, defaultValue: "useXDCSetting", validate: (e3) => true });
      }
    };
    __name(PageOffset, "PageOffset");
    PageRange = class extends StringObject {
      constructor(e2) {
        super(qo, "pageRange");
      }
      [Zs]() {
        const e2 = this[Vs].trim().split(/\s+/).map((e3) => parseInt(e3, 10)), t2 = [];
        for (let i2 = 0, a2 = e2.length; i2 < a2; i2 += 2)
          t2.push(e2.slice(i2, i2 + 2));
        this[Vs] = t2;
      }
    };
    __name(PageRange, "PageRange");
    Pagination = class extends OptionObject {
      constructor(e2) {
        super(qo, "pagination", ["simplex", "duplexShortEdge", "duplexLongEdge"]);
      }
    };
    __name(Pagination, "Pagination");
    PaginationOverride = class extends OptionObject {
      constructor(e2) {
        super(qo, "paginationOverride", ["none", "forceDuplex", "forceDuplexLongEdge", "forceDuplexShortEdge", "forceSimplex"]);
      }
    };
    __name(PaginationOverride, "PaginationOverride");
    Part = class extends IntegerObject {
      constructor(e2) {
        super(qo, "part", 1, (e3) => false);
      }
    };
    __name(Part, "Part");
    Pcl = class extends XFAObject {
      constructor(e2) {
        super(qo, "pcl", true), this.name = e2.name || "", this.batchOutput = null, this.fontInfo = null, this.jog = null, this.mediumInfo = null, this.outputBin = null, this.pageOffset = null, this.staple = null, this.xdc = null;
      }
    };
    __name(Pcl, "Pcl");
    Pdf = class extends XFAObject {
      constructor(e2) {
        super(qo, "pdf", true), this.name = e2.name || "", this.adobeExtensionLevel = null, this.batchOutput = null, this.compression = null, this.creator = null, this.encryption = null, this.fontInfo = null, this.interactive = null, this.linearized = null, this.openAction = null, this.pdfa = null, this.producer = null, this.renderPolicy = null, this.scriptModel = null, this.silentPrint = null, this.submitFormat = null, this.tagged = null, this.version = null, this.viewerPreferences = null, this.xdc = null;
      }
    };
    __name(Pdf, "Pdf");
    Pdfa = class extends XFAObject {
      constructor(e2) {
        super(qo, "pdfa", true), this.amd = null, this.conformance = null, this.includeXDPContent = null, this.part = null;
      }
    };
    __name(Pdfa, "Pdfa");
    Permissions = class extends XFAObject {
      constructor(e2) {
        super(qo, "permissions", true), this.accessibleContent = null, this.change = null, this.contentCopy = null, this.documentAssembly = null, this.formFieldFilling = null, this.modifyAnnots = null, this.plaintextMetadata = null, this.print = null, this.printHighQuality = null;
      }
    };
    __name(Permissions, "Permissions");
    PickTrayByPDFSize = class extends Option01 {
      constructor(e2) {
        super(qo, "pickTrayByPDFSize");
      }
    };
    __name(PickTrayByPDFSize, "PickTrayByPDFSize");
    config_Picture = class extends StringObject {
      constructor(e2) {
        super(qo, "picture");
      }
    };
    __name(config_Picture, "config_Picture");
    PlaintextMetadata = class extends Option01 {
      constructor(e2) {
        super(qo, "plaintextMetadata");
      }
    };
    __name(PlaintextMetadata, "PlaintextMetadata");
    Presence = class extends OptionObject {
      constructor(e2) {
        super(qo, "presence", ["preserve", "dissolve", "dissolveStructure", "ignore", "remove"]);
      }
    };
    __name(Presence, "Presence");
    Present = class extends XFAObject {
      constructor(e2) {
        super(qo, "present", true), this.behaviorOverride = null, this.cache = null, this.common = null, this.copies = null, this.destination = null, this.incrementalMerge = null, this.layout = null, this.output = null, this.overprint = null, this.pagination = null, this.paginationOverride = null, this.script = null, this.validate = null, this.xdp = null, this.driver = new XFAObjectArray(), this.labelPrinter = new XFAObjectArray(), this.pcl = new XFAObjectArray(), this.pdf = new XFAObjectArray(), this.ps = new XFAObjectArray(), this.submitUrl = new XFAObjectArray(), this.webClient = new XFAObjectArray(), this.zpl = new XFAObjectArray();
      }
    };
    __name(Present, "Present");
    Print = class extends Option01 {
      constructor(e2) {
        super(qo, "print");
      }
    };
    __name(Print, "Print");
    PrintHighQuality = class extends Option01 {
      constructor(e2) {
        super(qo, "printHighQuality");
      }
    };
    __name(PrintHighQuality, "PrintHighQuality");
    PrintScaling = class extends OptionObject {
      constructor(e2) {
        super(qo, "printScaling", ["appdefault", "noScaling"]);
      }
    };
    __name(PrintScaling, "PrintScaling");
    PrinterName = class extends StringObject {
      constructor(e2) {
        super(qo, "printerName");
      }
    };
    __name(PrinterName, "PrinterName");
    Producer = class extends StringObject {
      constructor(e2) {
        super(qo, "producer");
      }
    };
    __name(Producer, "Producer");
    Ps = class extends XFAObject {
      constructor(e2) {
        super(qo, "ps", true), this.name = e2.name || "", this.batchOutput = null, this.fontInfo = null, this.jog = null, this.mediumInfo = null, this.outputBin = null, this.staple = null, this.xdc = null;
      }
    };
    __name(Ps, "Ps");
    Xo = /* @__PURE__ */ __name(class extends ContentObject {
      constructor(e2) {
        super(qo, "range");
      }
      [Zs]() {
        this[Vs] = this[Vs].split(",", 2).map((e2) => e2.split("-").map((e3) => parseInt(e3.trim(), 10))).filter((e2) => e2.every((e3) => !isNaN(e3))).map((e2) => (1 === e2.length && e2.push(e2[0]), e2));
      }
    }, "Xo");
    Record = class extends ContentObject {
      constructor(e2) {
        super(qo, "record");
      }
      [Zs]() {
        this[Vs] = this[Vs].trim();
        const e2 = parseInt(this[Vs], 10);
        !isNaN(e2) && e2 >= 0 && (this[Vs] = e2);
      }
    };
    __name(Record, "Record");
    Relevant = class extends ContentObject {
      constructor(e2) {
        super(qo, "relevant");
      }
      [Zs]() {
        this[Vs] = this[Vs].trim().split(/\s+/);
      }
    };
    __name(Relevant, "Relevant");
    Rename = class extends ContentObject {
      constructor(e2) {
        super(qo, "rename");
      }
      [Zs]() {
        this[Vs] = this[Vs].trim(), (this[Vs].toLowerCase().startsWith("xml") || new RegExp("[\\p{L}_][\\p{L}\\d._\\p{M}-]*", "u").test(this[Vs])) && warn$1("XFA - Rename: invalid XFA name");
      }
    };
    __name(Rename, "Rename");
    RenderPolicy = class extends OptionObject {
      constructor(e2) {
        super(qo, "renderPolicy", ["server", "client"]);
      }
    };
    __name(RenderPolicy, "RenderPolicy");
    RunScripts = class extends OptionObject {
      constructor(e2) {
        super(qo, "runScripts", ["both", "client", "none", "server"]);
      }
    };
    __name(RunScripts, "RunScripts");
    config_Script = class extends XFAObject {
      constructor(e2) {
        super(qo, "script", true), this.currentPage = null, this.exclude = null, this.runScripts = null;
      }
    };
    __name(config_Script, "config_Script");
    ScriptModel = class extends OptionObject {
      constructor(e2) {
        super(qo, "scriptModel", ["XFA", "none"]);
      }
    };
    __name(ScriptModel, "ScriptModel");
    Severity = class extends OptionObject {
      constructor(e2) {
        super(qo, "severity", ["ignore", "error", "information", "trace", "warning"]);
      }
    };
    __name(Severity, "Severity");
    SilentPrint = class extends XFAObject {
      constructor(e2) {
        super(qo, "silentPrint", true), this.addSilentPrint = null, this.printerName = null;
      }
    };
    __name(SilentPrint, "SilentPrint");
    Staple = class extends XFAObject {
      constructor(e2) {
        super(qo, "staple"), this.mode = getStringOption(e2.mode, ["usePrinterSetting", "on", "off"]);
      }
    };
    __name(Staple, "Staple");
    StartNode = class extends StringObject {
      constructor(e2) {
        super(qo, "startNode");
      }
    };
    __name(StartNode, "StartNode");
    StartPage = class extends IntegerObject {
      constructor(e2) {
        super(qo, "startPage", 0, (e3) => true);
      }
    };
    __name(StartPage, "StartPage");
    SubmitFormat = class extends OptionObject {
      constructor(e2) {
        super(qo, "submitFormat", ["html", "delegate", "fdf", "xml", "pdf"]);
      }
    };
    __name(SubmitFormat, "SubmitFormat");
    SubmitUrl = class extends StringObject {
      constructor(e2) {
        super(qo, "submitUrl");
      }
    };
    __name(SubmitUrl, "SubmitUrl");
    SubsetBelow = class extends IntegerObject {
      constructor(e2) {
        super(qo, "subsetBelow", 100, (e3) => e3 >= 0 && e3 <= 100);
      }
    };
    __name(SubsetBelow, "SubsetBelow");
    SuppressBanner = class extends Option01 {
      constructor(e2) {
        super(qo, "suppressBanner");
      }
    };
    __name(SuppressBanner, "SuppressBanner");
    Tagged = class extends Option01 {
      constructor(e2) {
        super(qo, "tagged");
      }
    };
    __name(Tagged, "Tagged");
    config_Template = class extends XFAObject {
      constructor(e2) {
        super(qo, "template", true), this.base = null, this.relevant = null, this.startPage = null, this.uri = null, this.xsl = null;
      }
    };
    __name(config_Template, "config_Template");
    Threshold = class extends OptionObject {
      constructor(e2) {
        super(qo, "threshold", ["trace", "error", "information", "warning"]);
      }
    };
    __name(Threshold, "Threshold");
    To = class extends OptionObject {
      constructor(e2) {
        super(qo, "to", ["null", "memory", "stderr", "stdout", "system", "uri"]);
      }
    };
    __name(To, "To");
    TemplateCache = class extends XFAObject {
      constructor(e2) {
        super(qo, "templateCache"), this.maxEntries = getInteger({ data: e2.maxEntries, defaultValue: 5, validate: (e3) => e3 >= 0 });
      }
    };
    __name(TemplateCache, "TemplateCache");
    Trace = class extends XFAObject {
      constructor(e2) {
        super(qo, "trace", true), this.area = new XFAObjectArray();
      }
    };
    __name(Trace, "Trace");
    Transform = class extends XFAObject {
      constructor(e2) {
        super(qo, "transform", true), this.groupParent = null, this.ifEmpty = null, this.nameAttr = null, this.picture = null, this.presence = null, this.rename = null, this.whitespace = null;
      }
    };
    __name(Transform, "Transform");
    Type = class extends OptionObject {
      constructor(e2) {
        super(qo, "type", ["none", "ascii85", "asciiHex", "ccittfax", "flate", "lzw", "runLength", "native", "xdp", "mergedXDP"]);
      }
    };
    __name(Type, "Type");
    Uri = class extends StringObject {
      constructor(e2) {
        super(qo, "uri");
      }
    };
    __name(Uri, "Uri");
    config_Validate = class extends OptionObject {
      constructor(e2) {
        super(qo, "validate", ["preSubmit", "prePrint", "preExecute", "preSave"]);
      }
    };
    __name(config_Validate, "config_Validate");
    ValidateApprovalSignatures = class extends ContentObject {
      constructor(e2) {
        super(qo, "validateApprovalSignatures");
      }
      [Zs]() {
        this[Vs] = this[Vs].trim().split(/\s+/).filter((e2) => ["docReady", "postSign"].includes(e2));
      }
    };
    __name(ValidateApprovalSignatures, "ValidateApprovalSignatures");
    ValidationMessaging = class extends OptionObject {
      constructor(e2) {
        super(qo, "validationMessaging", ["allMessagesIndividually", "allMessagesTogether", "firstMessageOnly", "noMessages"]);
      }
    };
    __name(ValidationMessaging, "ValidationMessaging");
    Version = class extends OptionObject {
      constructor(e2) {
        super(qo, "version", ["1.7", "1.6", "1.5", "1.4", "1.3", "1.2"]);
      }
    };
    __name(Version, "Version");
    VersionControl = class extends XFAObject {
      constructor(e2) {
        super(qo, "VersionControl"), this.outputBelow = getStringOption(e2.outputBelow, ["warn", "error", "update"]), this.sourceAbove = getStringOption(e2.sourceAbove, ["warn", "error"]), this.sourceBelow = getStringOption(e2.sourceBelow, ["update", "maintain"]);
      }
    };
    __name(VersionControl, "VersionControl");
    ViewerPreferences = class extends XFAObject {
      constructor(e2) {
        super(qo, "viewerPreferences", true), this.ADBE_JSConsole = null, this.ADBE_JSDebugger = null, this.addViewerPreferences = null, this.duplexOption = null, this.enforce = null, this.numberOfCopies = null, this.pageRange = null, this.pickTrayByPDFSize = null, this.printScaling = null;
      }
    };
    __name(ViewerPreferences, "ViewerPreferences");
    WebClient = class extends XFAObject {
      constructor(e2) {
        super(qo, "webClient", true), this.name = e2.name ? e2.name.trim() : "", this.fontInfo = null, this.xdc = null;
      }
    };
    __name(WebClient, "WebClient");
    Whitespace = class extends OptionObject {
      constructor(e2) {
        super(qo, "whitespace", ["preserve", "ltrim", "normalize", "rtrim", "trim"]);
      }
    };
    __name(Whitespace, "Whitespace");
    Window = class extends ContentObject {
      constructor(e2) {
        super(qo, "window");
      }
      [Zs]() {
        const e2 = this[Vs].split(",", 2).map((e3) => parseInt(e3.trim(), 10));
        e2.some((e3) => isNaN(e3)) ? this[Vs] = [0, 0] : (1 === e2.length && e2.push(e2[0]), this[Vs] = e2);
      }
    };
    __name(Window, "Window");
    Xdc = class extends XFAObject {
      constructor(e2) {
        super(qo, "xdc", true), this.uri = new XFAObjectArray(), this.xsl = new XFAObjectArray();
      }
    };
    __name(Xdc, "Xdc");
    Xdp = class extends XFAObject {
      constructor(e2) {
        super(qo, "xdp", true), this.packets = null;
      }
    };
    __name(Xdp, "Xdp");
    Xsl = class extends XFAObject {
      constructor(e2) {
        super(qo, "xsl", true), this.debug = null, this.uri = null;
      }
    };
    __name(Xsl, "Xsl");
    Zpl = class extends XFAObject {
      constructor(e2) {
        super(qo, "zpl", true), this.name = e2.name ? e2.name.trim() : "", this.batchOutput = null, this.flipLabel = null, this.fontInfo = null, this.xdc = null;
      }
    };
    __name(Zpl, "Zpl");
    ConfigNamespace = class {
      static [eo](e2, t2) {
        if (ConfigNamespace.hasOwnProperty(e2))
          return ConfigNamespace[e2](t2);
      }
      static acrobat(e2) {
        return new Acrobat(e2);
      }
      static acrobat7(e2) {
        return new Acrobat7(e2);
      }
      static ADBE_JSConsole(e2) {
        return new ADBE_JSConsole(e2);
      }
      static ADBE_JSDebugger(e2) {
        return new ADBE_JSDebugger(e2);
      }
      static addSilentPrint(e2) {
        return new AddSilentPrint(e2);
      }
      static addViewerPreferences(e2) {
        return new AddViewerPreferences(e2);
      }
      static adjustData(e2) {
        return new AdjustData(e2);
      }
      static adobeExtensionLevel(e2) {
        return new AdobeExtensionLevel(e2);
      }
      static agent(e2) {
        return new Agent(e2);
      }
      static alwaysEmbed(e2) {
        return new AlwaysEmbed(e2);
      }
      static amd(e2) {
        return new Amd(e2);
      }
      static area(e2) {
        return new config_Area(e2);
      }
      static attributes(e2) {
        return new Attributes(e2);
      }
      static autoSave(e2) {
        return new AutoSave(e2);
      }
      static base(e2) {
        return new Base(e2);
      }
      static batchOutput(e2) {
        return new BatchOutput(e2);
      }
      static behaviorOverride(e2) {
        return new BehaviorOverride(e2);
      }
      static cache(e2) {
        return new Cache(e2);
      }
      static change(e2) {
        return new Change(e2);
      }
      static common(e2) {
        return new Common(e2);
      }
      static compress(e2) {
        return new Compress(e2);
      }
      static compressLogicalStructure(e2) {
        return new CompressLogicalStructure(e2);
      }
      static compressObjectStream(e2) {
        return new CompressObjectStream(e2);
      }
      static compression(e2) {
        return new Compression(e2);
      }
      static config(e2) {
        return new Config(e2);
      }
      static conformance(e2) {
        return new Conformance(e2);
      }
      static contentCopy(e2) {
        return new ContentCopy(e2);
      }
      static copies(e2) {
        return new Copies(e2);
      }
      static creator(e2) {
        return new Creator(e2);
      }
      static currentPage(e2) {
        return new CurrentPage(e2);
      }
      static data(e2) {
        return new Data(e2);
      }
      static debug(e2) {
        return new Debug(e2);
      }
      static defaultTypeface(e2) {
        return new DefaultTypeface(e2);
      }
      static destination(e2) {
        return new Destination(e2);
      }
      static documentAssembly(e2) {
        return new DocumentAssembly(e2);
      }
      static driver(e2) {
        return new Driver(e2);
      }
      static duplexOption(e2) {
        return new DuplexOption(e2);
      }
      static dynamicRender(e2) {
        return new DynamicRender(e2);
      }
      static embed(e2) {
        return new Embed(e2);
      }
      static encrypt(e2) {
        return new config_Encrypt(e2);
      }
      static encryption(e2) {
        return new config_Encryption(e2);
      }
      static encryptionLevel(e2) {
        return new EncryptionLevel(e2);
      }
      static enforce(e2) {
        return new Enforce(e2);
      }
      static equate(e2) {
        return new Equate(e2);
      }
      static equateRange(e2) {
        return new EquateRange(e2);
      }
      static exclude(e2) {
        return new Exclude(e2);
      }
      static excludeNS(e2) {
        return new ExcludeNS(e2);
      }
      static flipLabel(e2) {
        return new FlipLabel(e2);
      }
      static fontInfo(e2) {
        return new config_FontInfo(e2);
      }
      static formFieldFilling(e2) {
        return new FormFieldFilling(e2);
      }
      static groupParent(e2) {
        return new GroupParent(e2);
      }
      static ifEmpty(e2) {
        return new IfEmpty(e2);
      }
      static includeXDPContent(e2) {
        return new IncludeXDPContent(e2);
      }
      static incrementalLoad(e2) {
        return new IncrementalLoad(e2);
      }
      static incrementalMerge(e2) {
        return new IncrementalMerge(e2);
      }
      static interactive(e2) {
        return new Interactive(e2);
      }
      static jog(e2) {
        return new Jog(e2);
      }
      static labelPrinter(e2) {
        return new LabelPrinter(e2);
      }
      static layout(e2) {
        return new Layout(e2);
      }
      static level(e2) {
        return new Level(e2);
      }
      static linearized(e2) {
        return new Linearized(e2);
      }
      static locale(e2) {
        return new Locale(e2);
      }
      static localeSet(e2) {
        return new LocaleSet(e2);
      }
      static log(e2) {
        return new Log(e2);
      }
      static map(e2) {
        return new MapElement(e2);
      }
      static mediumInfo(e2) {
        return new MediumInfo(e2);
      }
      static message(e2) {
        return new config_Message(e2);
      }
      static messaging(e2) {
        return new Messaging(e2);
      }
      static mode(e2) {
        return new Mode(e2);
      }
      static modifyAnnots(e2) {
        return new ModifyAnnots(e2);
      }
      static msgId(e2) {
        return new MsgId(e2);
      }
      static nameAttr(e2) {
        return new NameAttr(e2);
      }
      static neverEmbed(e2) {
        return new NeverEmbed(e2);
      }
      static numberOfCopies(e2) {
        return new NumberOfCopies(e2);
      }
      static openAction(e2) {
        return new OpenAction(e2);
      }
      static output(e2) {
        return new Output(e2);
      }
      static outputBin(e2) {
        return new OutputBin(e2);
      }
      static outputXSL(e2) {
        return new OutputXSL(e2);
      }
      static overprint(e2) {
        return new Overprint(e2);
      }
      static packets(e2) {
        return new Packets(e2);
      }
      static pageOffset(e2) {
        return new PageOffset(e2);
      }
      static pageRange(e2) {
        return new PageRange(e2);
      }
      static pagination(e2) {
        return new Pagination(e2);
      }
      static paginationOverride(e2) {
        return new PaginationOverride(e2);
      }
      static part(e2) {
        return new Part(e2);
      }
      static pcl(e2) {
        return new Pcl(e2);
      }
      static pdf(e2) {
        return new Pdf(e2);
      }
      static pdfa(e2) {
        return new Pdfa(e2);
      }
      static permissions(e2) {
        return new Permissions(e2);
      }
      static pickTrayByPDFSize(e2) {
        return new PickTrayByPDFSize(e2);
      }
      static picture(e2) {
        return new config_Picture(e2);
      }
      static plaintextMetadata(e2) {
        return new PlaintextMetadata(e2);
      }
      static presence(e2) {
        return new Presence(e2);
      }
      static present(e2) {
        return new Present(e2);
      }
      static print(e2) {
        return new Print(e2);
      }
      static printHighQuality(e2) {
        return new PrintHighQuality(e2);
      }
      static printScaling(e2) {
        return new PrintScaling(e2);
      }
      static printerName(e2) {
        return new PrinterName(e2);
      }
      static producer(e2) {
        return new Producer(e2);
      }
      static ps(e2) {
        return new Ps(e2);
      }
      static range(e2) {
        return new Xo(e2);
      }
      static record(e2) {
        return new Record(e2);
      }
      static relevant(e2) {
        return new Relevant(e2);
      }
      static rename(e2) {
        return new Rename(e2);
      }
      static renderPolicy(e2) {
        return new RenderPolicy(e2);
      }
      static runScripts(e2) {
        return new RunScripts(e2);
      }
      static script(e2) {
        return new config_Script(e2);
      }
      static scriptModel(e2) {
        return new ScriptModel(e2);
      }
      static severity(e2) {
        return new Severity(e2);
      }
      static silentPrint(e2) {
        return new SilentPrint(e2);
      }
      static staple(e2) {
        return new Staple(e2);
      }
      static startNode(e2) {
        return new StartNode(e2);
      }
      static startPage(e2) {
        return new StartPage(e2);
      }
      static submitFormat(e2) {
        return new SubmitFormat(e2);
      }
      static submitUrl(e2) {
        return new SubmitUrl(e2);
      }
      static subsetBelow(e2) {
        return new SubsetBelow(e2);
      }
      static suppressBanner(e2) {
        return new SuppressBanner(e2);
      }
      static tagged(e2) {
        return new Tagged(e2);
      }
      static template(e2) {
        return new config_Template(e2);
      }
      static templateCache(e2) {
        return new TemplateCache(e2);
      }
      static threshold(e2) {
        return new Threshold(e2);
      }
      static to(e2) {
        return new To(e2);
      }
      static trace(e2) {
        return new Trace(e2);
      }
      static transform(e2) {
        return new Transform(e2);
      }
      static type(e2) {
        return new Type(e2);
      }
      static uri(e2) {
        return new Uri(e2);
      }
      static validate(e2) {
        return new config_Validate(e2);
      }
      static validateApprovalSignatures(e2) {
        return new ValidateApprovalSignatures(e2);
      }
      static validationMessaging(e2) {
        return new ValidationMessaging(e2);
      }
      static version(e2) {
        return new Version(e2);
      }
      static versionControl(e2) {
        return new VersionControl(e2);
      }
      static viewerPreferences(e2) {
        return new ViewerPreferences(e2);
      }
      static webClient(e2) {
        return new WebClient(e2);
      }
      static whitespace(e2) {
        return new Whitespace(e2);
      }
      static window(e2) {
        return new Window(e2);
      }
      static xdc(e2) {
        return new Xdc(e2);
      }
      static xdp(e2) {
        return new Xdp(e2);
      }
      static xsl(e2) {
        return new Xsl(e2);
      }
      static zpl(e2) {
        return new Zpl(e2);
      }
    };
    __name(ConfigNamespace, "ConfigNamespace");
    zo = to.connectionSet.id;
    ConnectionSet = class extends XFAObject {
      constructor(e2) {
        super(zo, "connectionSet", true), this.wsdlConnection = new XFAObjectArray(), this.xmlConnection = new XFAObjectArray(), this.xsdConnection = new XFAObjectArray();
      }
    };
    __name(ConnectionSet, "ConnectionSet");
    EffectiveInputPolicy = class extends XFAObject {
      constructor(e2) {
        super(zo, "effectiveInputPolicy"), this.id = e2.id || "", this.name = e2.name || "", this.use = e2.use || "", this.usehref = e2.usehref || "";
      }
    };
    __name(EffectiveInputPolicy, "EffectiveInputPolicy");
    EffectiveOutputPolicy = class extends XFAObject {
      constructor(e2) {
        super(zo, "effectiveOutputPolicy"), this.id = e2.id || "", this.name = e2.name || "", this.use = e2.use || "", this.usehref = e2.usehref || "";
      }
    };
    __name(EffectiveOutputPolicy, "EffectiveOutputPolicy");
    Operation = class extends StringObject {
      constructor(e2) {
        super(zo, "operation"), this.id = e2.id || "", this.input = e2.input || "", this.name = e2.name || "", this.output = e2.output || "", this.use = e2.use || "", this.usehref = e2.usehref || "";
      }
    };
    __name(Operation, "Operation");
    RootElement = class extends StringObject {
      constructor(e2) {
        super(zo, "rootElement"), this.id = e2.id || "", this.name = e2.name || "", this.use = e2.use || "", this.usehref = e2.usehref || "";
      }
    };
    __name(RootElement, "RootElement");
    SoapAction = class extends StringObject {
      constructor(e2) {
        super(zo, "soapAction"), this.id = e2.id || "", this.name = e2.name || "", this.use = e2.use || "", this.usehref = e2.usehref || "";
      }
    };
    __name(SoapAction, "SoapAction");
    SoapAddress = class extends StringObject {
      constructor(e2) {
        super(zo, "soapAddress"), this.id = e2.id || "", this.name = e2.name || "", this.use = e2.use || "", this.usehref = e2.usehref || "";
      }
    };
    __name(SoapAddress, "SoapAddress");
    connection_set_Uri = class extends StringObject {
      constructor(e2) {
        super(zo, "uri"), this.id = e2.id || "", this.name = e2.name || "", this.use = e2.use || "", this.usehref = e2.usehref || "";
      }
    };
    __name(connection_set_Uri, "connection_set_Uri");
    WsdlAddress = class extends StringObject {
      constructor(e2) {
        super(zo, "wsdlAddress"), this.id = e2.id || "", this.name = e2.name || "", this.use = e2.use || "", this.usehref = e2.usehref || "";
      }
    };
    __name(WsdlAddress, "WsdlAddress");
    WsdlConnection = class extends XFAObject {
      constructor(e2) {
        super(zo, "wsdlConnection", true), this.dataDescription = e2.dataDescription || "", this.name = e2.name || "", this.effectiveInputPolicy = null, this.effectiveOutputPolicy = null, this.operation = null, this.soapAction = null, this.soapAddress = null, this.wsdlAddress = null;
      }
    };
    __name(WsdlConnection, "WsdlConnection");
    XmlConnection = class extends XFAObject {
      constructor(e2) {
        super(zo, "xmlConnection", true), this.dataDescription = e2.dataDescription || "", this.name = e2.name || "", this.uri = null;
      }
    };
    __name(XmlConnection, "XmlConnection");
    XsdConnection = class extends XFAObject {
      constructor(e2) {
        super(zo, "xsdConnection", true), this.dataDescription = e2.dataDescription || "", this.name = e2.name || "", this.rootElement = null, this.uri = null;
      }
    };
    __name(XsdConnection, "XsdConnection");
    ConnectionSetNamespace = class {
      static [eo](e2, t2) {
        if (ConnectionSetNamespace.hasOwnProperty(e2))
          return ConnectionSetNamespace[e2](t2);
      }
      static connectionSet(e2) {
        return new ConnectionSet(e2);
      }
      static effectiveInputPolicy(e2) {
        return new EffectiveInputPolicy(e2);
      }
      static effectiveOutputPolicy(e2) {
        return new EffectiveOutputPolicy(e2);
      }
      static operation(e2) {
        return new Operation(e2);
      }
      static rootElement(e2) {
        return new RootElement(e2);
      }
      static soapAction(e2) {
        return new SoapAction(e2);
      }
      static soapAddress(e2) {
        return new SoapAddress(e2);
      }
      static uri(e2) {
        return new connection_set_Uri(e2);
      }
      static wsdlAddress(e2) {
        return new WsdlAddress(e2);
      }
      static wsdlConnection(e2) {
        return new WsdlConnection(e2);
      }
      static xmlConnection(e2) {
        return new XmlConnection(e2);
      }
      static xsdConnection(e2) {
        return new XsdConnection(e2);
      }
    };
    __name(ConnectionSetNamespace, "ConnectionSetNamespace");
    Wo = to.datasets.id;
    datasets_Data = class extends XmlObject {
      constructor(e2) {
        super(Wo, "data", e2);
      }
      [Cr]() {
        return true;
      }
    };
    __name(datasets_Data, "datasets_Data");
    Datasets = class extends XFAObject {
      constructor(e2) {
        super(Wo, "datasets", true), this.data = null, this.Signature = null;
      }
      [_r2](e2) {
        const t2 = e2[Er];
        ("data" === t2 && e2[Dr] === Wo || "Signature" === t2 && e2[Dr] === to.signature.id) && (this[t2] = e2), this[$s](e2);
      }
    };
    __name(Datasets, "Datasets");
    DatasetsNamespace = class {
      static [eo](e2, t2) {
        if (DatasetsNamespace.hasOwnProperty(e2))
          return DatasetsNamespace[e2](t2);
      }
      static datasets(e2) {
        return new Datasets(e2);
      }
      static data(e2) {
        return new datasets_Data(e2);
      }
    };
    __name(DatasetsNamespace, "DatasetsNamespace");
    Go = to.localeSet.id;
    CalendarSymbols = class extends XFAObject {
      constructor(e2) {
        super(Go, "calendarSymbols", true), this.name = "gregorian", this.dayNames = new XFAObjectArray(2), this.eraNames = null, this.meridiemNames = null, this.monthNames = new XFAObjectArray(2);
      }
    };
    __name(CalendarSymbols, "CalendarSymbols");
    CurrencySymbol = class extends StringObject {
      constructor(e2) {
        super(Go, "currencySymbol"), this.name = getStringOption(e2.name, ["symbol", "isoname", "decimal"]);
      }
    };
    __name(CurrencySymbol, "CurrencySymbol");
    CurrencySymbols = class extends XFAObject {
      constructor(e2) {
        super(Go, "currencySymbols", true), this.currencySymbol = new XFAObjectArray(3);
      }
    };
    __name(CurrencySymbols, "CurrencySymbols");
    DatePattern = class extends StringObject {
      constructor(e2) {
        super(Go, "datePattern"), this.name = getStringOption(e2.name, ["full", "long", "med", "short"]);
      }
    };
    __name(DatePattern, "DatePattern");
    DatePatterns = class extends XFAObject {
      constructor(e2) {
        super(Go, "datePatterns", true), this.datePattern = new XFAObjectArray(4);
      }
    };
    __name(DatePatterns, "DatePatterns");
    DateTimeSymbols = class extends ContentObject {
      constructor(e2) {
        super(Go, "dateTimeSymbols");
      }
    };
    __name(DateTimeSymbols, "DateTimeSymbols");
    Day = class extends StringObject {
      constructor(e2) {
        super(Go, "day");
      }
    };
    __name(Day, "Day");
    DayNames = class extends XFAObject {
      constructor(e2) {
        super(Go, "dayNames", true), this.abbr = getInteger({ data: e2.abbr, defaultValue: 0, validate: (e3) => 1 === e3 }), this.day = new XFAObjectArray(7);
      }
    };
    __name(DayNames, "DayNames");
    Era = class extends StringObject {
      constructor(e2) {
        super(Go, "era");
      }
    };
    __name(Era, "Era");
    EraNames = class extends XFAObject {
      constructor(e2) {
        super(Go, "eraNames", true), this.era = new XFAObjectArray(2);
      }
    };
    __name(EraNames, "EraNames");
    locale_set_Locale = class extends XFAObject {
      constructor(e2) {
        super(Go, "locale", true), this.desc = e2.desc || "", this.name = "isoname", this.calendarSymbols = null, this.currencySymbols = null, this.datePatterns = null, this.dateTimeSymbols = null, this.numberPatterns = null, this.numberSymbols = null, this.timePatterns = null, this.typeFaces = null;
      }
    };
    __name(locale_set_Locale, "locale_set_Locale");
    locale_set_LocaleSet = class extends XFAObject {
      constructor(e2) {
        super(Go, "localeSet", true), this.locale = new XFAObjectArray();
      }
    };
    __name(locale_set_LocaleSet, "locale_set_LocaleSet");
    Meridiem = class extends StringObject {
      constructor(e2) {
        super(Go, "meridiem");
      }
    };
    __name(Meridiem, "Meridiem");
    MeridiemNames = class extends XFAObject {
      constructor(e2) {
        super(Go, "meridiemNames", true), this.meridiem = new XFAObjectArray(2);
      }
    };
    __name(MeridiemNames, "MeridiemNames");
    Month = class extends StringObject {
      constructor(e2) {
        super(Go, "month");
      }
    };
    __name(Month, "Month");
    MonthNames = class extends XFAObject {
      constructor(e2) {
        super(Go, "monthNames", true), this.abbr = getInteger({ data: e2.abbr, defaultValue: 0, validate: (e3) => 1 === e3 }), this.month = new XFAObjectArray(12);
      }
    };
    __name(MonthNames, "MonthNames");
    NumberPattern = class extends StringObject {
      constructor(e2) {
        super(Go, "numberPattern"), this.name = getStringOption(e2.name, ["full", "long", "med", "short"]);
      }
    };
    __name(NumberPattern, "NumberPattern");
    NumberPatterns = class extends XFAObject {
      constructor(e2) {
        super(Go, "numberPatterns", true), this.numberPattern = new XFAObjectArray(4);
      }
    };
    __name(NumberPatterns, "NumberPatterns");
    NumberSymbol = class extends StringObject {
      constructor(e2) {
        super(Go, "numberSymbol"), this.name = getStringOption(e2.name, ["decimal", "grouping", "percent", "minus", "zero"]);
      }
    };
    __name(NumberSymbol, "NumberSymbol");
    NumberSymbols = class extends XFAObject {
      constructor(e2) {
        super(Go, "numberSymbols", true), this.numberSymbol = new XFAObjectArray(5);
      }
    };
    __name(NumberSymbols, "NumberSymbols");
    TimePattern = class extends StringObject {
      constructor(e2) {
        super(Go, "timePattern"), this.name = getStringOption(e2.name, ["full", "long", "med", "short"]);
      }
    };
    __name(TimePattern, "TimePattern");
    TimePatterns = class extends XFAObject {
      constructor(e2) {
        super(Go, "timePatterns", true), this.timePattern = new XFAObjectArray(4);
      }
    };
    __name(TimePatterns, "TimePatterns");
    TypeFace = class extends XFAObject {
      constructor(e2) {
        super(Go, "typeFace", true), this.name = "" | e2.name;
      }
    };
    __name(TypeFace, "TypeFace");
    TypeFaces = class extends XFAObject {
      constructor(e2) {
        super(Go, "typeFaces", true), this.typeFace = new XFAObjectArray();
      }
    };
    __name(TypeFaces, "TypeFaces");
    LocaleSetNamespace = class {
      static [eo](e2, t2) {
        if (LocaleSetNamespace.hasOwnProperty(e2))
          return LocaleSetNamespace[e2](t2);
      }
      static calendarSymbols(e2) {
        return new CalendarSymbols(e2);
      }
      static currencySymbol(e2) {
        return new CurrencySymbol(e2);
      }
      static currencySymbols(e2) {
        return new CurrencySymbols(e2);
      }
      static datePattern(e2) {
        return new DatePattern(e2);
      }
      static datePatterns(e2) {
        return new DatePatterns(e2);
      }
      static dateTimeSymbols(e2) {
        return new DateTimeSymbols(e2);
      }
      static day(e2) {
        return new Day(e2);
      }
      static dayNames(e2) {
        return new DayNames(e2);
      }
      static era(e2) {
        return new Era(e2);
      }
      static eraNames(e2) {
        return new EraNames(e2);
      }
      static locale(e2) {
        return new locale_set_Locale(e2);
      }
      static localeSet(e2) {
        return new locale_set_LocaleSet(e2);
      }
      static meridiem(e2) {
        return new Meridiem(e2);
      }
      static meridiemNames(e2) {
        return new MeridiemNames(e2);
      }
      static month(e2) {
        return new Month(e2);
      }
      static monthNames(e2) {
        return new MonthNames(e2);
      }
      static numberPattern(e2) {
        return new NumberPattern(e2);
      }
      static numberPatterns(e2) {
        return new NumberPatterns(e2);
      }
      static numberSymbol(e2) {
        return new NumberSymbol(e2);
      }
      static numberSymbols(e2) {
        return new NumberSymbols(e2);
      }
      static timePattern(e2) {
        return new TimePattern(e2);
      }
      static timePatterns(e2) {
        return new TimePatterns(e2);
      }
      static typeFace(e2) {
        return new TypeFace(e2);
      }
      static typeFaces(e2) {
        return new TypeFaces(e2);
      }
    };
    __name(LocaleSetNamespace, "LocaleSetNamespace");
    Vo = to.signature.id;
    signature_Signature = class extends XFAObject {
      constructor(e2) {
        super(Vo, "signature", true);
      }
    };
    __name(signature_Signature, "signature_Signature");
    SignatureNamespace = class {
      static [eo](e2, t2) {
        if (SignatureNamespace.hasOwnProperty(e2))
          return SignatureNamespace[e2](t2);
      }
      static signature(e2) {
        return new signature_Signature(e2);
      }
    };
    __name(SignatureNamespace, "SignatureNamespace");
    Ko = to.stylesheet.id;
    Stylesheet = class extends XFAObject {
      constructor(e2) {
        super(Ko, "stylesheet", true);
      }
    };
    __name(Stylesheet, "Stylesheet");
    StylesheetNamespace = class {
      static [eo](e2, t2) {
        if (StylesheetNamespace.hasOwnProperty(e2))
          return StylesheetNamespace[e2](t2);
      }
      static stylesheet(e2) {
        return new Stylesheet(e2);
      }
    };
    __name(StylesheetNamespace, "StylesheetNamespace");
    Yo = to.xdp.id;
    xdp_Xdp = class extends XFAObject {
      constructor(e2) {
        super(Yo, "xdp", true), this.uuid = e2.uuid || "", this.timeStamp = e2.timeStamp || "", this.config = null, this.connectionSet = null, this.datasets = null, this.localeSet = null, this.stylesheet = new XFAObjectArray(), this.template = null;
      }
      [Pr](e2) {
        const t2 = to[e2[Er]];
        return t2 && e2[Dr] === t2.id;
      }
    };
    __name(xdp_Xdp, "xdp_Xdp");
    XdpNamespace = class {
      static [eo](e2, t2) {
        if (XdpNamespace.hasOwnProperty(e2))
          return XdpNamespace[e2](t2);
      }
      static xdp(e2) {
        return new xdp_Xdp(e2);
      }
    };
    __name(XdpNamespace, "XdpNamespace");
    Jo = to.xhtml.id;
    Zo = Symbol();
    Qo = /* @__PURE__ */ new Set(["color", "font", "font-family", "font-size", "font-stretch", "font-style", "font-weight", "margin", "margin-bottom", "margin-left", "margin-right", "margin-top", "letter-spacing", "line-height", "orphans", "page-break-after", "page-break-before", "page-break-inside", "tab-interval", "tab-stop", "text-align", "text-decoration", "text-indent", "vertical-align", "widows", "kerning-mode", "xfa-font-horizontal-scale", "xfa-font-vertical-scale", "xfa-spacerun", "xfa-tab-stops"]);
    el = /* @__PURE__ */ new Map([["page-break-after", "breakAfter"], ["page-break-before", "breakBefore"], ["page-break-inside", "breakInside"], ["kerning-mode", (e2) => "none" === e2 ? "none" : "normal"], ["xfa-font-horizontal-scale", (e2) => `scaleX(${Math.max(0, parseInt(e2) / 100).toFixed(2)})`], ["xfa-font-vertical-scale", (e2) => `scaleY(${Math.max(0, parseInt(e2) / 100).toFixed(2)})`], ["xfa-spacerun", ""], ["xfa-tab-stops", ""], ["font-size", (e2, t2) => measureToString(0.99 * (e2 = t2.fontSize = Math.abs(getMeasurement(e2))))], ["letter-spacing", (e2) => measureToString(getMeasurement(e2))], ["line-height", (e2) => measureToString(getMeasurement(e2))], ["margin", (e2) => measureToString(getMeasurement(e2))], ["margin-bottom", (e2) => measureToString(getMeasurement(e2))], ["margin-left", (e2) => measureToString(getMeasurement(e2))], ["margin-right", (e2) => measureToString(getMeasurement(e2))], ["margin-top", (e2) => measureToString(getMeasurement(e2))], ["text-indent", (e2) => measureToString(getMeasurement(e2))], ["font-family", (e2) => e2], ["vertical-align", (e2) => measureToString(getMeasurement(e2))]]);
    tl = /\s+/g;
    il = /[\r\n]+/g;
    al = /\r\n?/g;
    __name(mapStyle, "mapStyle");
    nl = /* @__PURE__ */ new Set(["body", "html"]);
    XhtmlObject = class extends XmlObject {
      constructor(e2, t2) {
        super(Jo, t2), this[Zo] = false, this.style = e2.style || "";
      }
      [qs](e2) {
        var t2;
        super[qs](e2), this.style = (t2 = this).style ? t2.style.split(";").filter((e3) => !!e3.trim()).map((e3) => e3.split(":", 2).map((e4) => e4.trim())).filter(([e3, i2]) => ("font-family" === e3 && t2[fr].usedTypefaces.add(i2), Qo.has(e3))).map((e3) => e3.join(":")).join(";") : "";
      }
      [Us]() {
        return !nl.has(this[Er]);
      }
      [Rr](e2, t2 = false) {
        t2 ? this[Zo] = true : (e2 = e2.replaceAll(il, ""), this.style.includes("xfa-spacerun:yes") || (e2 = e2.replaceAll(tl, " "))), e2 && (this[Vs] += e2);
      }
      [Nr](e2, t2 = true) {
        const i2 = /* @__PURE__ */ Object.create(null), a2 = { top: NaN, bottom: NaN, left: NaN, right: NaN };
        let n2 = null;
        for (const [e3, t3] of this.style.split(";").map((e4) => e4.split(":", 2)))
          switch (e3) {
            case "font-family":
              i2.typeface = stripQuotes(t3);
              break;
            case "font-size":
              i2.size = getMeasurement(t3);
              break;
            case "font-weight":
              i2.weight = t3;
              break;
            case "font-style":
              i2.posture = t3;
              break;
            case "letter-spacing":
              i2.letterSpacing = getMeasurement(t3);
              break;
            case "margin":
              const e4 = t3.split(/ \t/).map((e5) => getMeasurement(e5));
              switch (e4.length) {
                case 1:
                  a2.top = a2.bottom = a2.left = a2.right = e4[0];
                  break;
                case 2:
                  a2.top = a2.bottom = e4[0], a2.left = a2.right = e4[1];
                  break;
                case 3:
                  a2.top = e4[0], a2.bottom = e4[2], a2.left = a2.right = e4[1];
                  break;
                case 4:
                  a2.top = e4[0], a2.left = e4[1], a2.bottom = e4[2], a2.right = e4[3];
              }
              break;
            case "margin-top":
              a2.top = getMeasurement(t3);
              break;
            case "margin-bottom":
              a2.bottom = getMeasurement(t3);
              break;
            case "margin-left":
              a2.left = getMeasurement(t3);
              break;
            case "margin-right":
              a2.right = getMeasurement(t3);
              break;
            case "line-height":
              n2 = getMeasurement(t3);
          }
        if (e2.pushData(i2, a2, n2), this[Vs])
          e2.addString(this[Vs]);
        else
          for (const t3 of this[cr]())
            "#text" !== t3[Er] ? t3[Nr](e2) : e2.addString(t3[Vs]);
        t2 && e2.popFont();
      }
      [Yr](e2) {
        const t2 = [];
        if (this[Js] = { children: t2 }, this[Hs]({}), 0 === t2.length && !this[Vs])
          return HTMLResult.EMPTY;
        let i2;
        return i2 = this[Zo] ? this[Vs] ? this[Vs].replaceAll(al, "\n") : void 0 : this[Vs] || void 0, HTMLResult.success({ name: this[Er], attributes: { href: this.href, style: mapStyle(this.style, this, this[Zo]) }, children: t2, value: i2 });
      }
    };
    __name(XhtmlObject, "XhtmlObject");
    A = class extends XhtmlObject {
      constructor(e2) {
        super(e2, "a"), this.href = fixURL(e2.href) || "";
      }
    };
    __name(A, "A");
    B = class extends XhtmlObject {
      constructor(e2) {
        super(e2, "b");
      }
      [Nr](e2) {
        e2.pushFont({ weight: "bold" }), super[Nr](e2), e2.popFont();
      }
    };
    __name(B, "B");
    Body = class extends XhtmlObject {
      constructor(e2) {
        super(e2, "body");
      }
      [Yr](e2) {
        const t2 = super[Yr](e2), { html: i2 } = t2;
        return i2 ? (i2.name = "div", i2.attributes.class = ["xfaRich"], t2) : HTMLResult.EMPTY;
      }
    };
    __name(Body, "Body");
    Br = class extends XhtmlObject {
      constructor(e2) {
        super(e2, "br");
      }
      [Vr]() {
        return "\n";
      }
      [Nr](e2) {
        e2.addString("\n");
      }
      [Yr](e2) {
        return HTMLResult.success({ name: "br" });
      }
    };
    __name(Br, "Br");
    Html = class extends XhtmlObject {
      constructor(e2) {
        super(e2, "html");
      }
      [Yr](e2) {
        const t2 = [];
        if (this[Js] = { children: t2 }, this[Hs]({}), 0 === t2.length)
          return HTMLResult.success({ name: "div", attributes: { class: ["xfaRich"], style: {} }, value: this[Vs] || "" });
        if (1 === t2.length) {
          const e3 = t2[0];
          if (e3.attributes?.class.includes("xfaRich"))
            return HTMLResult.success(e3);
        }
        return HTMLResult.success({ name: "div", attributes: { class: ["xfaRich"], style: {} }, children: t2 });
      }
    };
    __name(Html, "Html");
    I = class extends XhtmlObject {
      constructor(e2) {
        super(e2, "i");
      }
      [Nr](e2) {
        e2.pushFont({ posture: "italic" }), super[Nr](e2), e2.popFont();
      }
    };
    __name(I, "I");
    Li = class extends XhtmlObject {
      constructor(e2) {
        super(e2, "li");
      }
    };
    __name(Li, "Li");
    Ol = class extends XhtmlObject {
      constructor(e2) {
        super(e2, "ol");
      }
    };
    __name(Ol, "Ol");
    P = class extends XhtmlObject {
      constructor(e2) {
        super(e2, "p");
      }
      [Nr](e2) {
        super[Nr](e2, false), e2.addString("\n"), e2.addPara(), e2.popFont();
      }
      [Vr]() {
        return this[gr]()[cr]().at(-1) === this ? super[Vr]() : super[Vr]() + "\n";
      }
    };
    __name(P, "P");
    Span = class extends XhtmlObject {
      constructor(e2) {
        super(e2, "span");
      }
    };
    __name(Span, "Span");
    Sub = class extends XhtmlObject {
      constructor(e2) {
        super(e2, "sub");
      }
    };
    __name(Sub, "Sub");
    Sup = class extends XhtmlObject {
      constructor(e2) {
        super(e2, "sup");
      }
    };
    __name(Sup, "Sup");
    Ul = class extends XhtmlObject {
      constructor(e2) {
        super(e2, "ul");
      }
    };
    __name(Ul, "Ul");
    XhtmlNamespace = class {
      static [eo](e2, t2) {
        if (XhtmlNamespace.hasOwnProperty(e2))
          return XhtmlNamespace[e2](t2);
      }
      static a(e2) {
        return new A(e2);
      }
      static b(e2) {
        return new B(e2);
      }
      static body(e2) {
        return new Body(e2);
      }
      static br(e2) {
        return new Br(e2);
      }
      static html(e2) {
        return new Html(e2);
      }
      static i(e2) {
        return new I(e2);
      }
      static li(e2) {
        return new Li(e2);
      }
      static ol(e2) {
        return new Ol(e2);
      }
      static p(e2) {
        return new P(e2);
      }
      static span(e2) {
        return new Span(e2);
      }
      static sub(e2) {
        return new Sub(e2);
      }
      static sup(e2) {
        return new Sup(e2);
      }
      static ul(e2) {
        return new Ul(e2);
      }
    };
    __name(XhtmlNamespace, "XhtmlNamespace");
    sl = { config: ConfigNamespace, connection: ConnectionSetNamespace, datasets: DatasetsNamespace, localeSet: LocaleSetNamespace, signature: SignatureNamespace, stylesheet: StylesheetNamespace, template: TemplateNamespace, xdp: XdpNamespace, xhtml: XhtmlNamespace };
    UnknownNamespace = class {
      constructor(e2) {
        this.namespaceId = e2;
      }
      [eo](e2, t2) {
        return new XmlObject(this.namespaceId, e2, t2);
      }
    };
    __name(UnknownNamespace, "UnknownNamespace");
    Root = class extends XFAObject {
      constructor(e2) {
        super(-1, "root", /* @__PURE__ */ Object.create(null)), this.element = null, this[br] = e2;
      }
      [_r2](e2) {
        return this.element = e2, true;
      }
      [Zs]() {
        super[Zs](), this.element.template instanceof Template && (this[br].set($r, this.element), this.element.template[Hr](this[br]), this.element.template[br] = this[br]);
      }
    };
    __name(Root, "Root");
    Empty = class extends XFAObject {
      constructor() {
        super(-1, "", /* @__PURE__ */ Object.create(null));
      }
      [_r2](e2) {
        return false;
      }
    };
    __name(Empty, "Empty");
    Builder = class {
      constructor(e2 = null) {
        this._namespaceStack = [], this._nsAgnosticLevel = 0, this._namespacePrefixes = /* @__PURE__ */ new Map(), this._namespaces = /* @__PURE__ */ new Map(), this._nextNsId = Math.max(...Object.values(to).map(({ id: e3 }) => e3)), this._currentNamespace = e2 || new UnknownNamespace(++this._nextNsId);
      }
      buildRoot(e2) {
        return new Root(e2);
      }
      build({ nsPrefix: e2, name: t2, attributes: i2, namespace: a2, prefixes: n2 }) {
        const s2 = null !== a2;
        if (s2 && (this._namespaceStack.push(this._currentNamespace), this._currentNamespace = this._searchNamespace(a2)), n2 && this._addNamespacePrefix(n2), i2.hasOwnProperty(Or)) {
          const e3 = sl.datasets, t3 = i2[Or];
          let a3 = null;
          for (const [i3, n3] of Object.entries(t3)) {
            if (this._getNamespaceToUse(i3) === e3) {
              a3 = { xfa: n3 };
              break;
            }
          }
          a3 ? i2[Or] = a3 : delete i2[Or];
        }
        const r2 = this._getNamespaceToUse(e2), o2 = r2?.[eo](t2, i2) || new Empty();
        return o2[Cr]() && this._nsAgnosticLevel++, (s2 || n2 || o2[Cr]()) && (o2[zs] = { hasNamespace: s2, prefixes: n2, nsAgnostic: o2[Cr]() }), o2;
      }
      isNsAgnostic() {
        return this._nsAgnosticLevel > 0;
      }
      _searchNamespace(e2) {
        let t2 = this._namespaces.get(e2);
        if (t2)
          return t2;
        for (const [i2, { check: a2 }] of Object.entries(to))
          if (a2(e2)) {
            if (t2 = sl[i2], t2)
              return this._namespaces.set(e2, t2), t2;
            break;
          }
        return t2 = new UnknownNamespace(++this._nextNsId), this._namespaces.set(e2, t2), t2;
      }
      _addNamespacePrefix(e2) {
        for (const { prefix: t2, value: i2 } of e2) {
          const e3 = this._searchNamespace(i2);
          let a2 = this._namespacePrefixes.get(t2);
          a2 || (a2 = [], this._namespacePrefixes.set(t2, a2)), a2.push(e3);
        }
      }
      _getNamespaceToUse(e2) {
        if (!e2)
          return this._currentNamespace;
        const t2 = this._namespacePrefixes.get(e2);
        return t2?.length > 0 ? t2.at(-1) : (warn$1(`Unknown namespace prefix: ${e2}.`), null);
      }
      clean(e2) {
        const { hasNamespace: t2, prefixes: i2, nsAgnostic: a2 } = e2;
        t2 && (this._currentNamespace = this._namespaceStack.pop()), i2 && i2.forEach(({ prefix: e3 }) => {
          this._namespacePrefixes.get(e3).pop();
        }), a2 && this._nsAgnosticLevel--;
      }
    };
    __name(Builder, "Builder");
    XFAParser = class extends XMLParserBase {
      constructor(e2 = null, t2 = false) {
        super(), this._builder = new Builder(e2), this._stack = [], this._globalData = { usedTypefaces: /* @__PURE__ */ new Set() }, this._ids = /* @__PURE__ */ new Map(), this._current = this._builder.buildRoot(this._ids), this._errorCode = ks, this._whiteRegex = /^\s+$/, this._nbsps = /\xa0+/g, this._richText = t2;
      }
      parse(e2) {
        if (this.parseXml(e2), this._errorCode === ks)
          return this._current[Zs](), this._current.element;
      }
      onText(e2) {
        e2 = e2.replace(this._nbsps, (e3) => e3.slice(1) + " "), this._richText || this._current[Us]() ? this._current[Rr](e2, this._richText) : this._whiteRegex.test(e2) || this._current[Rr](e2.trim());
      }
      onCdata(e2) {
        this._current[Rr](e2);
      }
      _mkAttributes(e2, t2) {
        let i2 = null, a2 = null;
        const n2 = /* @__PURE__ */ Object.create({});
        for (const { name: s2, value: r2 } of e2)
          if ("xmlns" === s2)
            i2 ? warn$1(`XFA - multiple namespace definition in <${t2}>`) : i2 = r2;
          else if (s2.startsWith("xmlns:")) {
            const e3 = s2.substring(6);
            a2 ??= [], a2.push({ prefix: e3, value: r2 });
          } else {
            const e3 = s2.indexOf(":");
            if (-1 === e3)
              n2[s2] = r2;
            else {
              const t3 = n2[Or] ??= /* @__PURE__ */ Object.create(null), [i3, a3] = [s2.slice(0, e3), s2.slice(e3 + 1)];
              (t3[i3] ||= /* @__PURE__ */ Object.create(null))[a3] = r2;
            }
          }
        return [i2, a2, n2];
      }
      _getNameAndPrefix(e2, t2) {
        const i2 = e2.indexOf(":");
        return -1 === i2 ? [e2, null] : [e2.substring(i2 + 1), t2 ? "" : e2.substring(0, i2)];
      }
      onBeginElement(e2, t2, i2) {
        const [a2, n2, s2] = this._mkAttributes(t2, e2), [r2, o2] = this._getNameAndPrefix(e2, this._builder.isNsAgnostic()), l3 = this._builder.build({ nsPrefix: o2, name: r2, attributes: s2, namespace: a2, prefixes: n2 });
        if (l3[fr] = this._globalData, i2)
          return l3[Zs](), this._current[_r2](l3) && l3[Xr](this._ids), void l3[qs](this._builder);
        this._stack.push(this._current), this._current = l3;
      }
      onEndElement(e2) {
        const t2 = this._current;
        if (t2[Ar]() && "string" == typeof t2[Vs]) {
          const e3 = new XFAParser();
          e3._globalData = this._globalData;
          const i2 = e3.parse(t2[Vs]);
          t2[Vs] = null, t2[_r2](i2);
        }
        t2[Zs](), this._current = this._stack.pop(), this._current[_r2](t2) && t2[Xr](this._ids), t2[qs](this._builder);
      }
      onError(e2) {
        this._errorCode = e2;
      }
    };
    __name(XFAParser, "XFAParser");
    XFAFactory = class {
      constructor(e2) {
        try {
          this.root = new XFAParser().parse(XFAFactory._createDocument(e2));
          const t2 = new Binder(this.root);
          this.form = t2.bind(), this.dataHandler = new DataHandler(this.root, t2.getData()), this.form[fr].template = this.form;
        } catch (e3) {
          warn$1(`XFA - an error occurred during parsing and binding: ${e3}`);
        }
      }
      isValid() {
        return !(!this.root || !this.form);
      }
      _createPagesHelper() {
        const e2 = this.form[Kr]();
        return new Promise((t2, i2) => {
          const nextIteration = /* @__PURE__ */ __name(() => {
            try {
              const i3 = e2.next();
              i3.done ? t2(i3.value) : setTimeout(nextIteration, 0);
            } catch (e3) {
              i2(e3);
            }
          }, "nextIteration");
          setTimeout(nextIteration, 0);
        });
      }
      async _createPages() {
        try {
          this.pages = await this._createPagesHelper(), this.dims = this.pages.children.map((e2) => {
            const { width: t2, height: i2 } = e2.attributes.style;
            return [0, 0, parseInt(t2), parseInt(i2)];
          });
        } catch (e2) {
          warn$1(`XFA - an error occurred during layout: ${e2}`);
        }
      }
      getBoundingBox(e2) {
        return this.dims[e2];
      }
      async getNumPages() {
        return this.pages || await this._createPages(), this.dims.length;
      }
      setImages(e2) {
        this.form[fr].images = e2;
      }
      setFonts(e2) {
        this.form[fr].fontFinder = new FontFinder(e2);
        const t2 = [];
        for (let e3 of this.form[fr].usedTypefaces) {
          e3 = stripQuotes(e3);
          this.form[fr].fontFinder.find(e3) || t2.push(e3);
        }
        return t2.length > 0 ? t2 : null;
      }
      appendFonts(e2, t2) {
        this.form[fr].fontFinder.add(e2, t2);
      }
      async getPages() {
        this.pages || await this._createPages();
        const e2 = this.pages;
        return this.pages = null, e2;
      }
      serializeData(e2) {
        return this.dataHandler.serialize(e2);
      }
      static _createDocument(e2) {
        return e2["/xdp:xdp"] ? Object.values(e2).join("") : e2["xdp:xdp"];
      }
      static getRichTextAsHtml(e2) {
        if (!e2 || "string" != typeof e2)
          return null;
        try {
          let t2 = new XFAParser(XhtmlNamespace, true).parse(e2);
          if (!["body", "xhtml"].includes(t2[Er])) {
            const e3 = XhtmlNamespace.body({});
            e3[$s](t2), t2 = e3;
          }
          const i2 = t2[Yr]();
          if (!i2.success)
            return null;
          const { html: a2 } = i2, { attributes: n2 } = a2;
          return n2 && (n2.class && (n2.class = n2.class.filter((e3) => !e3.startsWith("xfa"))), n2.dir = "auto"), { html: a2, str: t2[Vr]() };
        } catch (e3) {
          warn$1(`XFA - an error occurred during parsing of rich text: ${e3}`);
        }
        return null;
      }
    };
    __name(XFAFactory, "XFAFactory");
    AnnotationFactory = class {
      static createGlobals(e2) {
        return Promise.all([e2.ensureCatalog("acroForm"), e2.ensureDoc("xfaDatasets"), e2.ensureCatalog("structTreeRoot"), e2.ensureCatalog("baseUrl"), e2.ensureCatalog("attachments"), e2.ensureCatalog("globalColorSpaceCache")]).then(([t2, i2, a2, n2, s2, r2]) => ({ pdfManager: e2, acroForm: t2 instanceof Dict ? t2 : Dict.empty, xfaDatasets: i2, structTreeRoot: a2, baseUrl: n2, attachments: s2, globalColorSpaceCache: r2 }), (e3) => (warn$1(`createGlobals: "${e3}".`), null));
      }
      static async create(e2, t2, i2, a2, n2, s2, r2, o2) {
        const l3 = n2 ? await this._getPageIndex(e2, t2, i2.pdfManager) : null;
        return i2.pdfManager.ensure(this, "_create", [e2, t2, i2, a2, n2, s2, r2, l3, o2]);
      }
      static _create(e2, t2, i2, a2, n2 = false, s2 = null, r2 = null, o2 = null, l3 = null) {
        const c2 = e2.fetchIfRef(t2);
        if (!(c2 instanceof Dict))
          return;
        let h2 = c2.get("Subtype");
        if (h2 = h2 instanceof Name ? h2.name : null, r2 && !r2.has(T[h2.toUpperCase()]))
          return null;
        const { acroForm: d2, pdfManager: u2 } = i2, g2 = t2 instanceof Ref ? t2.toString() : `annot_${a2.createObjId()}`, p2 = { xref: e2, ref: t2, dict: c2, subtype: h2, id: g2, annotationGlobals: i2, collectFields: n2, orphanFields: s2, needAppearances: !n2 && true === d2.get("NeedAppearances"), pageIndex: o2, evaluatorOptions: u2.evaluatorOptions, pageRef: l3 };
        switch (h2) {
          case "Link":
            return new LinkAnnotation(p2);
          case "Text":
            return new TextAnnotation(p2);
          case "Widget":
            let e3 = getInheritableProperty({ dict: c2, key: "FT" });
            switch (e3 = e3 instanceof Name ? e3.name : null, e3) {
              case "Tx":
                return new TextWidgetAnnotation(p2);
              case "Btn":
                return new ButtonWidgetAnnotation(p2);
              case "Ch":
                return new ChoiceWidgetAnnotation(p2);
              case "Sig":
                return new SignatureWidgetAnnotation(p2);
            }
            return warn$1(`Unimplemented widget field type "${e3}", falling back to base field type.`), new WidgetAnnotation(p2);
          case "Popup":
            return new PopupAnnotation(p2);
          case "FreeText":
            return new FreeTextAnnotation(p2);
          case "Line":
            return new LineAnnotation(p2);
          case "Square":
            return new SquareAnnotation(p2);
          case "Circle":
            return new CircleAnnotation(p2);
          case "PolyLine":
            return new PolylineAnnotation(p2);
          case "Polygon":
            return new PolygonAnnotation(p2);
          case "Caret":
            return new CaretAnnotation(p2);
          case "Ink":
            return new InkAnnotation(p2);
          case "Highlight":
            return new HighlightAnnotation(p2);
          case "Underline":
            return new UnderlineAnnotation(p2);
          case "Squiggly":
            return new SquigglyAnnotation(p2);
          case "StrikeOut":
            return new StrikeOutAnnotation(p2);
          case "Stamp":
            return new StampAnnotation(p2);
          case "FileAttachment":
            return new FileAttachmentAnnotation(p2);
          default:
            return n2 || warn$1(h2 ? `Unimplemented annotation type "${h2}", falling back to base annotation.` : "Annotation is missing the required /Subtype."), new Annotation(p2);
        }
      }
      static async _getPageIndex(e2, t2, i2) {
        try {
          const a2 = await e2.fetchIfRefAsync(t2);
          if (!(a2 instanceof Dict))
            return -1;
          const n2 = a2.getRaw("P");
          if (n2 instanceof Ref)
            try {
              return await i2.ensureCatalog("getPageIndex", [n2]);
            } catch (e3) {
              info$1(`_getPageIndex -- not a valid page reference: "${e3}".`);
            }
          if (a2.has("Kids"))
            return -1;
          const s2 = await i2.ensureDoc("numPages");
          for (let e3 = 0; e3 < s2; e3++) {
            const a3 = await i2.getPage(e3), n3 = await i2.ensure(a3, "annotations");
            for (const i3 of n3)
              if (i3 instanceof Ref && isRefsEqual(i3, t2))
                return e3;
          }
        } catch (e3) {
          warn$1(`_getPageIndex: "${e3}".`);
        }
        return -1;
      }
      static generateImages(e2, t2, i2) {
        if (!i2)
          return warn$1("generateImages: OffscreenCanvas is not supported, cannot save or print some annotations with images."), null;
        let a2;
        for (const { bitmapId: i3, bitmap: n2 } of e2)
          n2 && (a2 ||= /* @__PURE__ */ new Map(), a2.set(i3, StampAnnotation.createImage(n2, t2)));
        return a2;
      }
      static async saveNewAnnotations(e2, t2, i2, a2, n2) {
        const s2 = e2.xref;
        let r2;
        const o2 = [], { isOffscreenCanvasSupported: l3 } = e2.options;
        for (const c2 of i2)
          if (!c2.deleted)
            switch (c2.annotationType) {
              case p:
                if (!r2) {
                  const e3 = new Dict(s2);
                  e3.setIfName("BaseFont", "Helvetica"), e3.setIfName("Type", "Font"), e3.setIfName("Subtype", "Type1"), e3.setIfName("Encoding", "WinAnsiEncoding"), r2 = s2.getNewTemporaryRef(), n2.put(r2, { data: e3 });
                }
                o2.push(FreeTextAnnotation.createNewAnnotation(s2, c2, n2, { evaluator: e2, task: t2, baseFontRef: r2 }));
                break;
              case f:
                c2.quadPoints ? o2.push(HighlightAnnotation.createNewAnnotation(s2, c2, n2)) : o2.push(InkAnnotation.createNewAnnotation(s2, c2, n2));
                break;
              case b:
                o2.push(InkAnnotation.createNewAnnotation(s2, c2, n2));
                break;
              case m:
                const i3 = l3 ? await a2?.get(c2.bitmapId) : null;
                if (i3?.imageStream) {
                  const { imageStream: e3, smaskStream: t3 } = i3;
                  if (t3) {
                    const i4 = s2.getNewTemporaryRef();
                    n2.put(i4, { data: t3 }), e3.dict.set("SMask", i4);
                  }
                  const a3 = i3.imageRef = s2.getNewTemporaryRef();
                  n2.put(a3, { data: e3 }), i3.imageStream = i3.smaskStream = null;
                }
                o2.push(StampAnnotation.createNewAnnotation(s2, c2, n2, { image: i3 }));
                break;
              case y:
                o2.push(StampAnnotation.createNewAnnotation(s2, c2, n2, {}));
            }
        return { annotations: (await Promise.all(o2)).flat() };
      }
      static async printNewAnnotations(e2, t2, i2, a2, n2) {
        if (!a2)
          return null;
        const { options: s2, xref: r2 } = t2, o2 = [];
        for (const l3 of a2)
          if (!l3.deleted)
            switch (l3.annotationType) {
              case p:
                o2.push(FreeTextAnnotation.createNewPrintAnnotation(e2, r2, l3, { evaluator: t2, task: i2, evaluatorOptions: s2 }));
                break;
              case f:
                l3.quadPoints ? o2.push(HighlightAnnotation.createNewPrintAnnotation(e2, r2, l3, { evaluatorOptions: s2 })) : o2.push(InkAnnotation.createNewPrintAnnotation(e2, r2, l3, { evaluatorOptions: s2 }));
                break;
              case b:
                o2.push(InkAnnotation.createNewPrintAnnotation(e2, r2, l3, { evaluatorOptions: s2 }));
                break;
              case m:
                const a3 = s2.isOffscreenCanvasSupported ? await n2?.get(l3.bitmapId) : null;
                if (a3?.imageStream) {
                  const { imageStream: e3, smaskStream: t3 } = a3;
                  t3 && e3.dict.set("SMask", t3), a3.imageRef = new JpegStream(e3, e3.length), a3.imageStream = a3.smaskStream = null;
                }
                o2.push(StampAnnotation.createNewPrintAnnotation(e2, r2, l3, { image: a3, evaluatorOptions: s2 }));
                break;
              case y:
                o2.push(StampAnnotation.createNewPrintAnnotation(e2, r2, l3, { evaluatorOptions: s2 }));
            }
        return Promise.all(o2);
      }
    };
    __name(AnnotationFactory, "AnnotationFactory");
    __name(getRgbColor, "getRgbColor");
    __name(getPdfColorArray, "getPdfColorArray");
    __name(getQuadPoints, "getQuadPoints");
    __name(getTransformMatrix, "getTransformMatrix");
    Annotation = class {
      constructor(e2) {
        const { dict: t2, xref: i2, annotationGlobals: a2, ref: n2, orphanFields: s2 } = e2, r2 = s2?.get(n2);
        r2 && t2.set("Parent", r2), this.setTitle(t2.get("T")), this.setContents(t2.get("Contents")), this.setModificationDate(t2.get("M")), this.setFlags(t2.get("F")), this.setRectangle(t2.getArray("Rect")), this.setColor(t2.getArray("C")), this.setBorderStyle(t2), this.setAppearance(t2), this.setOptionalContent(t2);
        const o2 = t2.get("MK");
        this.setBorderAndBackgroundColors(o2), this.setRotation(o2, t2), this.ref = e2.ref instanceof Ref ? e2.ref : null, this._streams = [], this.appearance && this._streams.push(this.appearance);
        const l3 = !!(this.flags & N), c2 = !!(this.flags & L);
        if (this.data = { annotationFlags: this.flags, borderStyle: this.borderStyle, color: this.color, backgroundColor: this.backgroundColor, borderColor: this.borderColor, rotation: this.rotation, contentsObj: this._contents, hasAppearance: !!this.appearance, id: e2.id, modificationDate: this.modificationDate, rect: this.rectangle, subtype: e2.subtype, hasOwnCanvas: false, noRotate: !!(this.flags & _), noHTML: l3 && c2, isEditable: false, structParent: -1 }, a2.structTreeRoot) {
          let i3 = t2.get("StructParent");
          this.data.structParent = i3 = Number.isInteger(i3) && i3 >= 0 ? i3 : -1, a2.structTreeRoot.addAnnotationIdToPage(e2.pageRef, i3);
        }
        if (e2.collectFields) {
          const a3 = t2.get("Kids");
          if (Array.isArray(a3)) {
            const e3 = [];
            for (const t3 of a3)
              t3 instanceof Ref && e3.push(t3.toString());
            0 !== e3.length && (this.data.kidIds = e3);
          }
          this.data.actions = collectActions(i2, t2, te), this.data.fieldName = this._constructFieldName(t2), this.data.pageIndex = e2.pageIndex;
        }
        const h2 = t2.get("IT");
        h2 instanceof Name && (this.data.it = h2.name), this._isOffscreenCanvasSupported = e2.evaluatorOptions.isOffscreenCanvasSupported, this._fallbackFontDict = null, this._needAppearances = false;
      }
      _hasFlag(e2, t2) {
        return !!(e2 & t2);
      }
      _buildFlags(e2, t2) {
        let { flags: i2 } = this;
        if (void 0 === e2) {
          if (void 0 === t2)
            return;
          return t2 ? -5 & i2 : -3 & i2 | O;
        }
        return e2 ? (i2 |= O, t2 ? -33 & i2 | E : -3 & i2 | R) : (i2 &= -35, t2 ? -5 & i2 : i2 | O);
      }
      _isViewable(e2) {
        return !this._hasFlag(e2, D) && !this._hasFlag(e2, R);
      }
      _isPrintable(e2) {
        return this._hasFlag(e2, O) && !this._hasFlag(e2, E) && !this._hasFlag(e2, D);
      }
      mustBeViewed(e2, t2) {
        const i2 = e2?.get(this.data.id)?.noView;
        return void 0 !== i2 ? !i2 : this.viewable && !this._hasFlag(this.flags, E);
      }
      mustBePrinted(e2) {
        const t2 = e2?.get(this.data.id)?.noPrint;
        return void 0 !== t2 ? !t2 : this.printable;
      }
      mustBeViewedWhenEditing(e2, t2 = null) {
        return e2 ? !this.data.isEditable : !t2?.has(this.data.id);
      }
      get viewable() {
        return null !== this.data.quadPoints && (0 === this.flags || this._isViewable(this.flags));
      }
      get printable() {
        return null !== this.data.quadPoints && (0 !== this.flags && this._isPrintable(this.flags));
      }
      _parseStringHelper(e2) {
        const t2 = "string" == typeof e2 ? stringToPDFString(e2) : "";
        return { str: t2, dir: t2 && "rtl" === bidi(t2).dir ? "rtl" : "ltr" };
      }
      setDefaultAppearance(e2) {
        const { dict: t2, annotationGlobals: i2 } = e2, a2 = getInheritableProperty({ dict: t2, key: "DA" }) || i2.acroForm.get("DA");
        this._defaultAppearance = "string" == typeof a2 ? a2 : "", this.data.defaultAppearanceData = parseDefaultAppearance(this._defaultAppearance);
      }
      setTitle(e2) {
        this._title = this._parseStringHelper(e2);
      }
      setContents(e2) {
        this._contents = this._parseStringHelper(e2);
      }
      setModificationDate(e2) {
        this.modificationDate = "string" == typeof e2 ? e2 : null;
      }
      setFlags(e2) {
        this.flags = Number.isInteger(e2) && e2 > 0 ? e2 : 0, this.flags & D && "Annotation" !== this.constructor.name && (this.flags ^= D);
      }
      hasFlag(e2) {
        return this._hasFlag(this.flags, e2);
      }
      setRectangle(e2) {
        this.rectangle = lookupNormalRect(e2, [0, 0, 0, 0]);
      }
      setColor(e2) {
        this.color = getRgbColor(e2);
      }
      setLineEndings(e2) {
        if (this.lineEndings = ["None", "None"], Array.isArray(e2) && 2 === e2.length)
          for (let t2 = 0; t2 < 2; t2++) {
            const i2 = e2[t2];
            if (i2 instanceof Name)
              switch (i2.name) {
                case "None":
                  continue;
                case "Square":
                case "Circle":
                case "Diamond":
                case "OpenArrow":
                case "ClosedArrow":
                case "Butt":
                case "ROpenArrow":
                case "RClosedArrow":
                case "Slash":
                  this.lineEndings[t2] = i2.name;
                  continue;
              }
            warn$1(`Ignoring invalid lineEnding: ${i2}`);
          }
      }
      setRotation(e2, t2) {
        this.rotation = 0;
        let i2 = e2 instanceof Dict ? e2.get("R") || 0 : t2.get("Rotate") || 0;
        Number.isInteger(i2) && 0 !== i2 && (i2 %= 360, i2 < 0 && (i2 += 360), i2 % 90 == 0 && (this.rotation = i2));
      }
      setBorderAndBackgroundColors(e2) {
        e2 instanceof Dict ? (this.borderColor = getRgbColor(e2.getArray("BC"), null), this.backgroundColor = getRgbColor(e2.getArray("BG"), null)) : this.borderColor = this.backgroundColor = null;
      }
      setBorderStyle(e2) {
        if (this.borderStyle = new AnnotationBorderStyle(), e2 instanceof Dict)
          if (e2.has("BS")) {
            const t2 = e2.get("BS");
            if (t2 instanceof Dict) {
              const e3 = t2.get("Type");
              e3 && !isName(e3, "Border") || (this.borderStyle.setWidth(t2.get("W"), this.rectangle), this.borderStyle.setStyle(t2.get("S")), this.borderStyle.setDashArray(t2.getArray("D")));
            }
          } else if (e2.has("Border")) {
            const t2 = e2.getArray("Border");
            Array.isArray(t2) && t2.length >= 3 && (this.borderStyle.setHorizontalCornerRadius(t2[0]), this.borderStyle.setVerticalCornerRadius(t2[1]), this.borderStyle.setWidth(t2[2], this.rectangle), 4 === t2.length && this.borderStyle.setDashArray(t2[3], true));
          } else
            this.borderStyle.setWidth(0);
      }
      setAppearance(e2) {
        this.appearance = null;
        const t2 = e2.get("AP");
        if (!(t2 instanceof Dict))
          return;
        const i2 = t2.get("N");
        if (i2 instanceof BaseStream)
          return void (this.appearance = i2);
        if (!(i2 instanceof Dict))
          return;
        const a2 = e2.get("AS");
        if (!(a2 instanceof Name && i2.has(a2.name)))
          return;
        const n2 = i2.get(a2.name);
        n2 instanceof BaseStream && (this.appearance = n2);
      }
      setOptionalContent(e2) {
        this.oc = null;
        const t2 = e2.get("OC");
        t2 instanceof Name ? warn$1("setOptionalContent: Support for /Name-entry is not implemented.") : t2 instanceof Dict && (this.oc = t2);
      }
      async loadResources(e2, t2) {
        const i2 = await t2.dict.getAsync("Resources");
        return i2 && await ObjectLoader.load(i2, e2, i2.xref), i2;
      }
      async getOperatorList(e2, t2, i2, a2) {
        const { hasOwnCanvas: n2, id: s2, rect: o2 } = this.data;
        let l3 = this.appearance;
        const c2 = !!(n2 && i2 & r);
        if (c2 && (0 === this.width || 0 === this.height))
          return this.data.hasOwnCanvas = false, { opList: new OperatorList(), separateForm: false, separateCanvas: false };
        if (!l3) {
          if (!c2)
            return { opList: new OperatorList(), separateForm: false, separateCanvas: false };
          l3 = new StringStream(""), l3.dict = new Dict();
        }
        const h2 = l3.dict, d2 = await this.loadResources(mi, l3), u2 = lookupRect(h2.getArray("BBox"), [0, 0, 1, 1]), g2 = lookupMatrix(h2.getArray("Matrix"), fi), p2 = getTransformMatrix(o2, u2, g2), f2 = new OperatorList();
        let m2;
        return this.oc && (m2 = await e2.parseMarkedContentProps(this.oc, null)), void 0 !== m2 && f2.addOp(xt, ["OC", m2]), f2.addOp(Mt, [s2, o2, p2, g2, c2]), await e2.getOperatorList({ stream: l3, task: t2, resources: d2, operatorList: f2, fallbackFontDict: this._fallbackFontDict }), f2.addOp(Dt, []), void 0 !== m2 && f2.addOp(St, []), this.reset(), { opList: f2, separateForm: false, separateCanvas: c2 };
      }
      async save(e2, t2, i2, a2) {
        return null;
      }
      get overlaysTextContent() {
        return false;
      }
      get hasTextContent() {
        return false;
      }
      async extractTextContent(e2, t2, i2) {
        if (!this.appearance)
          return;
        const a2 = await this.loadResources(bi, this.appearance), n2 = [], s2 = [];
        let r2 = null;
        const o2 = { desiredSize: Math.Infinity, ready: true, enqueue(e3, t3) {
          for (const t4 of e3.items)
            void 0 !== t4.str && (r2 ||= t4.transform.slice(-2), s2.push(t4.str), t4.hasEOL && (n2.push(s2.join("").trimEnd()), s2.length = 0));
        } };
        if (await e2.getTextContent({ stream: this.appearance, task: t2, resources: a2, includeMarkedContent: true, keepWhiteSpace: true, sink: o2, viewBox: i2 }), this.reset(), s2.length && n2.push(s2.join("").trimEnd()), n2.length > 1 || n2[0]) {
          const e3 = this.appearance.dict, t3 = lookupRect(e3.getArray("BBox"), null), i3 = lookupMatrix(e3.getArray("Matrix"), null);
          this.data.textPosition = this._transformPoint(r2, t3, i3), this.data.textContent = n2;
        }
      }
      _transformPoint(e2, t2, i2) {
        const { rect: a2 } = this.data;
        t2 ||= [0, 0, 1, 1], i2 ||= [1, 0, 0, 1, 0, 0];
        const n2 = getTransformMatrix(a2, t2, i2);
        n2[4] -= a2[0], n2[5] -= a2[1];
        const s2 = e2.slice();
        return ni.applyTransform(s2, n2), ni.applyTransform(s2, i2), s2;
      }
      getFieldObject() {
        return this.data.kidIds ? { id: this.data.id, actions: this.data.actions, name: this.data.fieldName, strokeColor: this.data.borderColor, fillColor: this.data.backgroundColor, type: "", kidIds: this.data.kidIds, page: this.data.pageIndex, rotation: this.rotation } : null;
      }
      reset() {
        for (const e2 of this._streams)
          e2.reset();
      }
      _constructFieldName(e2) {
        if (!e2.has("T") && !e2.has("Parent"))
          return warn$1("Unknown field name, falling back to empty field name."), "";
        if (!e2.has("Parent"))
          return stringToPDFString(e2.get("T"));
        const t2 = [];
        e2.has("T") && t2.unshift(stringToPDFString(e2.get("T")));
        let i2 = e2;
        const a2 = new RefSet();
        for (e2.objId && a2.put(e2.objId); i2.has("Parent") && (i2 = i2.get("Parent"), i2 instanceof Dict && (!i2.objId || !a2.has(i2.objId))); )
          i2.objId && a2.put(i2.objId), i2.has("T") && t2.unshift(stringToPDFString(i2.get("T")));
        return t2.join(".");
      }
      get width() {
        return this.data.rect[2] - this.data.rect[0];
      }
      get height() {
        return this.data.rect[3] - this.data.rect[1];
      }
    };
    __name(Annotation, "Annotation");
    AnnotationBorderStyle = class {
      constructor() {
        this.width = 1, this.rawWidth = 1, this.style = Y, this.dashArray = [3], this.horizontalCornerRadius = 0, this.verticalCornerRadius = 0;
      }
      setWidth(e2, t2 = [0, 0, 0, 0]) {
        if (e2 instanceof Name)
          this.width = 0;
        else if ("number" == typeof e2) {
          if (e2 > 0) {
            this.rawWidth = e2;
            const i2 = (t2[2] - t2[0]) / 2, a2 = (t2[3] - t2[1]) / 2;
            i2 > 0 && a2 > 0 && (e2 > i2 || e2 > a2) && (warn$1(`AnnotationBorderStyle.setWidth - ignoring width: ${e2}`), e2 = 1);
          }
          this.width = e2;
        }
      }
      setStyle(e2) {
        if (e2 instanceof Name)
          switch (e2.name) {
            case "S":
              this.style = Y;
              break;
            case "D":
              this.style = J;
              break;
            case "B":
              this.style = Z;
              break;
            case "I":
              this.style = Q;
              break;
            case "U":
              this.style = ee;
          }
      }
      setDashArray(e2, t2 = false) {
        if (Array.isArray(e2)) {
          let i2 = true, a2 = true;
          for (const t3 of e2) {
            if (!(+t3 >= 0)) {
              i2 = false;
              break;
            }
            t3 > 0 && (a2 = false);
          }
          0 === e2.length || i2 && !a2 ? (this.dashArray = e2, t2 && this.setStyle(Name.get("D"))) : this.width = 0;
        } else
          e2 && (this.width = 0);
      }
      setHorizontalCornerRadius(e2) {
        Number.isInteger(e2) && (this.horizontalCornerRadius = e2);
      }
      setVerticalCornerRadius(e2) {
        Number.isInteger(e2) && (this.verticalCornerRadius = e2);
      }
    };
    __name(AnnotationBorderStyle, "AnnotationBorderStyle");
    MarkupAnnotation = class extends Annotation {
      constructor(e2) {
        super(e2);
        const { dict: t2 } = e2;
        if (t2.has("IRT")) {
          const e3 = t2.getRaw("IRT");
          this.data.inReplyTo = e3 instanceof Ref ? e3.toString() : null;
          const i3 = t2.get("RT");
          this.data.replyType = i3 instanceof Name ? i3.name : M;
        }
        let i2 = null;
        if (this.data.replyType === F) {
          const e3 = t2.get("IRT");
          this.setTitle(e3.get("T")), this.data.titleObj = this._title, this.setContents(e3.get("Contents")), this.data.contentsObj = this._contents, e3.has("CreationDate") ? (this.setCreationDate(e3.get("CreationDate")), this.data.creationDate = this.creationDate) : this.data.creationDate = null, e3.has("M") ? (this.setModificationDate(e3.get("M")), this.data.modificationDate = this.modificationDate) : this.data.modificationDate = null, i2 = e3.getRaw("Popup"), e3.has("C") ? (this.setColor(e3.getArray("C")), this.data.color = this.color) : this.data.color = null;
        } else
          this.data.titleObj = this._title, this.setCreationDate(t2.get("CreationDate")), this.data.creationDate = this.creationDate, i2 = t2.getRaw("Popup"), t2.has("C") || (this.data.color = null);
        this.data.popupRef = i2 instanceof Ref ? i2.toString() : null, t2.has("RC") && (this.data.richText = XFAFactory.getRichTextAsHtml(t2.get("RC")));
      }
      setCreationDate(e2) {
        this.creationDate = "string" == typeof e2 ? e2 : null;
      }
      _setDefaultAppearance({ xref: e2, extra: t2, strokeColor: i2, fillColor: a2, blendMode: n2, strokeAlpha: s2, fillAlpha: r2, pointsCallback: o2 }) {
        const l3 = this.data.rect = [1 / 0, 1 / 0, -1 / 0, -1 / 0], c2 = ["q"];
        t2 && c2.push(t2), i2 && c2.push(`${i2[0]} ${i2[1]} ${i2[2]} RG`), a2 && c2.push(`${a2[0]} ${a2[1]} ${a2[2]} rg`);
        const h2 = this.data.quadPoints || Float32Array.from([this.rectangle[0], this.rectangle[3], this.rectangle[2], this.rectangle[3], this.rectangle[0], this.rectangle[1], this.rectangle[2], this.rectangle[1]]);
        for (let e3 = 0, t3 = h2.length; e3 < t3; e3 += 8) {
          const t4 = o2(c2, h2.subarray(e3, e3 + 8));
          ni.rectBoundingBox(...t4, l3);
        }
        c2.push("Q");
        const d2 = new Dict(e2), u2 = new Dict(e2);
        u2.setIfName("Subtype", "Form");
        const g2 = new StringStream(c2.join(" "));
        g2.dict = u2, d2.set("Fm0", g2);
        const p2 = new Dict(e2);
        n2 && p2.setIfName("BM", n2), p2.setIfNumber("CA", s2), p2.setIfNumber("ca", r2);
        const f2 = new Dict(e2);
        f2.set("GS0", p2);
        const m2 = new Dict(e2);
        m2.set("ExtGState", f2), m2.set("XObject", d2);
        const b2 = new Dict(e2);
        b2.set("Resources", m2), b2.set("BBox", l3), this.appearance = new StringStream("/GS0 gs /Fm0 Do"), this.appearance.dict = b2, this._streams.push(this.appearance, g2);
      }
      static async createNewAnnotation(e2, t2, i2, a2) {
        const n2 = t2.ref ||= e2.getNewTemporaryRef(), s2 = await this.createNewAppearanceStream(t2, e2, a2);
        let r2;
        if (s2) {
          const a3 = e2.getNewTemporaryRef();
          r2 = this.createNewDict(t2, e2, { apRef: a3 }), i2.put(a3, { data: s2 });
        } else
          r2 = this.createNewDict(t2, e2, {});
        Number.isInteger(t2.parentTreeId) && r2.set("StructParent", t2.parentTreeId), i2.put(n2, { data: r2 });
        const o2 = { ref: n2 };
        if (t2.popup) {
          const a3 = t2.popup;
          if (a3.deleted)
            return r2.delete("Popup"), r2.delete("Contents"), r2.delete("RC"), o2;
          const s3 = a3.ref ||= e2.getNewTemporaryRef();
          a3.parent = n2;
          const l3 = PopupAnnotation.createNewDict(a3, e2);
          return i2.put(s3, { data: l3 }), r2.setIfDefined("Contents", stringToAsciiOrUTF16BE(a3.contents)), r2.set("Popup", s3), [o2, { ref: s3 }];
        }
        return o2;
      }
      static async createNewPrintAnnotation(e2, t2, i2, a2) {
        const n2 = await this.createNewAppearanceStream(i2, t2, a2), s2 = this.createNewDict(i2, t2, n2 ? { ap: n2 } : {}), r2 = new this.prototype.constructor({ dict: s2, xref: t2, annotationGlobals: e2, evaluatorOptions: a2.evaluatorOptions });
        return i2.ref && (r2.ref = r2.refToReplace = i2.ref), r2;
      }
    };
    __name(MarkupAnnotation, "MarkupAnnotation");
    WidgetAnnotation = class extends Annotation {
      constructor(e2) {
        super(e2);
        const { dict: t2, xref: i2, annotationGlobals: a2 } = e2, n2 = this.data;
        this._needAppearances = e2.needAppearances, n2.annotationType = T.WIDGET, void 0 === n2.fieldName && (n2.fieldName = this._constructFieldName(t2)), void 0 === n2.actions && (n2.actions = collectActions(i2, t2, te));
        let s2 = getInheritableProperty({ dict: t2, key: "V", getArray: true });
        n2.fieldValue = this._decodeFormValue(s2);
        const r2 = getInheritableProperty({ dict: t2, key: "DV", getArray: true });
        if (n2.defaultFieldValue = this._decodeFormValue(r2), void 0 === s2 && a2.xfaDatasets) {
          const e3 = this._title.str;
          e3 && (this._hasValueFromXFA = true, n2.fieldValue = s2 = a2.xfaDatasets.getValue(e3));
        }
        void 0 === s2 && null !== n2.defaultFieldValue && (n2.fieldValue = n2.defaultFieldValue), n2.alternativeText = stringToPDFString(t2.get("TU") || ""), this.setDefaultAppearance(e2), n2.hasAppearance ||= this._needAppearances && void 0 !== n2.fieldValue && null !== n2.fieldValue;
        const o2 = getInheritableProperty({ dict: t2, key: "FT" });
        n2.fieldType = o2 instanceof Name ? o2.name : null;
        const l3 = getInheritableProperty({ dict: t2, key: "DR" }), c2 = a2.acroForm.get("DR"), h2 = this.appearance?.dict.get("Resources");
        this._fieldResources = { localResources: l3, acroFormResources: c2, appearanceResources: h2, mergedResources: Dict.merge({ xref: i2, dictArray: [l3, h2, c2], mergeSubDicts: true }) }, n2.fieldFlags = getInheritableProperty({ dict: t2, key: "Ff" }), (!Number.isInteger(n2.fieldFlags) || n2.fieldFlags < 0) && (n2.fieldFlags = 0), n2.password = this.hasFieldFlag(H), n2.readOnly = this.hasFieldFlag(U), n2.required = this.hasFieldFlag(j), n2.hidden = this._hasFlag(n2.annotationFlags, E) || this._hasFlag(n2.annotationFlags, R);
      }
      _decodeFormValue(e2) {
        return Array.isArray(e2) ? e2.filter((e3) => "string" == typeof e3).map((e3) => stringToPDFString(e3)) : e2 instanceof Name ? stringToPDFString(e2.name) : "string" == typeof e2 ? stringToPDFString(e2) : null;
      }
      hasFieldFlag(e2) {
        return !!(this.data.fieldFlags & e2);
      }
      _isViewable(e2) {
        return true;
      }
      mustBeViewed(e2, t2) {
        return t2 ? this.viewable : super.mustBeViewed(e2, t2) && !this._hasFlag(this.flags, R);
      }
      getRotationMatrix(e2) {
        let t2 = e2?.get(this.data.id)?.rotation;
        return void 0 === t2 && (t2 = this.rotation), 0 === t2 ? fi : getRotationMatrix(t2, this.width, this.height);
      }
      getBorderAndBackgroundAppearances(e2) {
        let t2 = e2?.get(this.data.id)?.rotation;
        if (void 0 === t2 && (t2 = this.rotation), !this.backgroundColor && !this.borderColor)
          return "";
        const i2 = 0 === t2 || 180 === t2 ? `0 0 ${this.width} ${this.height} re` : `0 0 ${this.height} ${this.width} re`;
        let a2 = "";
        if (this.backgroundColor && (a2 = `${getPdfColor(this.backgroundColor, true)} ${i2} f `), this.borderColor) {
          a2 += `${this.borderStyle.width || 1} w ${getPdfColor(this.borderColor, false)} ${i2} S `;
        }
        return a2;
      }
      async getOperatorList(e2, t2, i2, a2) {
        if (i2 & c && !(this instanceof SignatureWidgetAnnotation) && !this.data.noHTML && !this.data.hasOwnCanvas)
          return { opList: new OperatorList(), separateForm: true, separateCanvas: false };
        if (!this._hasText)
          return super.getOperatorList(e2, t2, i2, a2);
        const n2 = await this._getAppearance(e2, t2, i2, a2);
        if (this.appearance && null === n2)
          return super.getOperatorList(e2, t2, i2, a2);
        const s2 = new OperatorList();
        if (!this._defaultAppearance || null === n2)
          return { opList: s2, separateForm: false, separateCanvas: false };
        const o2 = !!(this.data.hasOwnCanvas && i2 & r), l3 = [0, 0, this.width, this.height], h2 = getTransformMatrix(this.data.rect, l3, [1, 0, 0, 1, 0, 0]);
        let d2;
        this.oc && (d2 = await e2.parseMarkedContentProps(this.oc, null)), void 0 !== d2 && s2.addOp(xt, ["OC", d2]), s2.addOp(Mt, [this.data.id, this.data.rect, h2, this.getRotationMatrix(a2), o2]);
        const u2 = new StringStream(n2);
        return await e2.getOperatorList({ stream: u2, task: t2, resources: this._fieldResources.mergedResources, operatorList: s2 }), s2.addOp(Dt, []), void 0 !== d2 && s2.addOp(St, []), { opList: s2, separateForm: false, separateCanvas: o2 };
      }
      _getMKDict(e2) {
        const t2 = new Dict(null);
        return e2 && t2.set("R", e2), t2.setIfArray("BC", getPdfColorArray(this.borderColor)), t2.setIfArray("BG", getPdfColorArray(this.backgroundColor)), t2.size > 0 ? t2 : null;
      }
      amendSavedDict(e2, t2) {
      }
      setValue(e2, t2, i2, a2) {
        const { dict: n2, ref: s2 } = function(e3, t3, i3) {
          const a3 = new RefSet(), n3 = e3, s3 = { dict: null, ref: null };
          for (; e3 instanceof Dict && !a3.has(t3) && (a3.put(t3), !e3.has("T")); ) {
            if (!((t3 = e3.getRaw("Parent")) instanceof Ref))
              return s3;
            e3 = i3.fetch(t3);
          }
          return e3 instanceof Dict && e3 !== n3 && (s3.dict = e3, s3.ref = t3), s3;
        }(e2, this.ref, i2);
        if (n2) {
          if (!a2.has(s2)) {
            const e3 = n2.clone();
            return e3.set("V", t2), a2.put(s2, { data: e3 }), e3;
          }
        } else
          e2.set("V", t2);
        return null;
      }
      async save(e2, t2, i2, a2) {
        const n2 = i2?.get(this.data.id), s2 = this._buildFlags(n2?.noView, n2?.noPrint);
        let r2 = n2?.value, o2 = n2?.rotation;
        if (r2 === this.data.fieldValue || void 0 === r2) {
          if (!this._hasValueFromXFA && void 0 === o2 && void 0 === s2)
            return;
          r2 ||= this.data.fieldValue;
        }
        if (void 0 === o2 && !this._hasValueFromXFA && Array.isArray(r2) && Array.isArray(this.data.fieldValue) && isArrayEqual(r2, this.data.fieldValue) && void 0 === s2)
          return;
        void 0 === o2 && (o2 = this.rotation);
        let c2 = null;
        if (!this._needAppearances && (c2 = await this._getAppearance(e2, t2, l2, i2), null === c2 && void 0 === s2))
          return;
        let h2 = false;
        c2?.needAppearances && (h2 = true, c2 = null);
        const { xref: d2 } = e2, u2 = d2.fetchIfRef(this.ref);
        if (!(u2 instanceof Dict))
          return;
        const g2 = new Dict(d2);
        for (const e3 of u2.getKeys())
          "AP" !== e3 && g2.set(e3, u2.getRaw(e3));
        if (void 0 !== s2 && (g2.set("F", s2), null === c2 && !h2)) {
          const e3 = u2.getRaw("AP");
          e3 && g2.set("AP", e3);
        }
        const p2 = { path: this.data.fieldName, value: r2 }, f2 = this.setValue(g2, Array.isArray(r2) ? r2.map(stringToAsciiOrUTF16BE) : stringToAsciiOrUTF16BE(r2), d2, a2);
        this.amendSavedDict(i2, f2 || g2);
        const m2 = this._getMKDict(o2);
        if (m2 && g2.set("MK", m2), a2.put(this.ref, { data: g2, xfa: p2, needAppearances: h2 }), null !== c2) {
          const e3 = d2.getNewTemporaryRef(), t3 = new Dict(d2);
          g2.set("AP", t3), t3.set("N", e3);
          const n3 = this._getSaveFieldResources(d2), s3 = new StringStream(c2), r3 = s3.dict = new Dict(d2);
          r3.setIfName("Subtype", "Form"), r3.set("Resources", n3);
          const l3 = o2 % 180 == 0 ? [0, 0, this.width, this.height] : [0, 0, this.height, this.width];
          r3.set("BBox", l3);
          const h3 = this.getRotationMatrix(i2);
          h3 !== fi && r3.set("Matrix", h3), a2.put(e3, { data: s3, xfa: null, needAppearances: false });
        }
        g2.set("M", `D:${getModificationDate()}`);
      }
      async _getAppearance(e2, t2, i2, a2) {
        if (this.data.password)
          return null;
        const s2 = a2?.get(this.data.id);
        let r2, o2;
        if (s2 && (r2 = s2.formattedValue || s2.value, o2 = s2.rotation), void 0 === o2 && void 0 === r2 && !this._needAppearances && (!this._hasValueFromXFA || this.appearance))
          return null;
        const c2 = this.getBorderAndBackgroundAppearances(a2);
        if (void 0 === r2 && (r2 = this.data.fieldValue, !r2))
          return `/Tx BMC q ${c2}Q EMC`;
        if (Array.isArray(r2) && 1 === r2.length && (r2 = r2[0]), assert$1("string" == typeof r2, "Expected `value` to be a string."), r2 = r2.trimEnd(), this.data.combo) {
          const e3 = this.data.options.find(({ exportValue: e4 }) => r2 === e4);
          r2 = e3?.displayValue || r2;
        }
        if ("" === r2)
          return `/Tx BMC q ${c2}Q EMC`;
        void 0 === o2 && (o2 = this.rotation);
        let h2, d2 = -1;
        this.data.multiLine ? (h2 = r2.split(/\r\n?|\n/).map((e3) => e3.normalize("NFC")), d2 = h2.length) : h2 = [r2.replace(/\r\n?|\n/, "").normalize("NFC")];
        let { width: u2, height: g2 } = this;
        90 !== o2 && 270 !== o2 || ([u2, g2] = [g2, u2]), this._defaultAppearance || (this.data.defaultAppearanceData = parseDefaultAppearance(this._defaultAppearance = "/Helvetica 0 Tf 0 g"));
        let p2, f2, m2, b2 = await WidgetAnnotation._getFontData(e2, t2, this.data.defaultAppearanceData, this._fieldResources.mergedResources);
        const y2 = [];
        let w2 = false;
        for (const e3 of h2) {
          const t3 = b2.encodeString(e3);
          t3.length > 1 && (w2 = true), y2.push(t3.join(""));
        }
        if (w2 && i2 & l2)
          return { needAppearances: true };
        if (w2 && this._isOffscreenCanvasSupported) {
          const i3 = this.data.comb ? "monospace" : "sans-serif", a3 = new FakeUnicodeFont(e2.xref, i3), n2 = a3.createFontResources(h2.join("")), s3 = n2.getRaw("Font");
          if (this._fieldResources.mergedResources.has("Font")) {
            const e3 = this._fieldResources.mergedResources.get("Font");
            for (const t3 of s3.getKeys())
              e3.set(t3, s3.getRaw(t3));
          } else
            this._fieldResources.mergedResources.set("Font", s3);
          const o3 = a3.fontName.name;
          b2 = await WidgetAnnotation._getFontData(e2, t2, { fontName: o3, fontSize: 0 }, n2);
          for (let e3 = 0, t3 = y2.length; e3 < t3; e3++)
            y2[e3] = stringToUTF16String(h2[e3]);
          const l3 = Object.assign(/* @__PURE__ */ Object.create(null), this.data.defaultAppearanceData);
          this.data.defaultAppearanceData.fontSize = 0, this.data.defaultAppearanceData.fontName = o3, [p2, f2, m2] = this._computeFontSize(g2 - 2, u2 - 4, r2, b2, d2), this.data.defaultAppearanceData = l3;
        } else
          this._isOffscreenCanvasSupported || warn$1("_getAppearance: OffscreenCanvas is not supported, annotation may not render correctly."), [p2, f2, m2] = this._computeFontSize(g2 - 2, u2 - 4, r2, b2, d2);
        let x2 = b2.descent;
        x2 = isNaN(x2) ? n * m2 : Math.max(n * m2, Math.abs(x2) * f2);
        const S2 = Math.min(Math.floor((g2 - f2) / 2), 1), v2 = this.data.textAlignment;
        if (this.data.multiLine)
          return this._getMultilineAppearance(p2, y2, b2, f2, u2, g2, v2, 2, S2, x2, m2, a2);
        if (this.data.comb)
          return this._getCombAppearance(p2, b2, y2[0], f2, u2, g2, 2, S2, x2, m2, a2);
        const C2 = S2 + x2;
        if (0 === v2 || v2 > 2)
          return `/Tx BMC q ${c2}BT ` + p2 + ` 1 0 0 1 ${numberToString(2)} ${numberToString(C2)} Tm (${escapeString(y2[0])}) Tj ET Q EMC`;
        return `/Tx BMC q ${c2}BT ` + p2 + ` 1 0 0 1 0 0 Tm ${this._renderText(y2[0], b2, f2, u2, v2, { shift: 0 }, 2, C2)} ET Q EMC`;
      }
      static async _getFontData(e2, t2, i2, a2) {
        const n2 = new OperatorList(), s2 = { font: null, clone() {
          return this;
        } }, { fontName: r2, fontSize: o2 } = i2;
        return await e2.handleSetFont(a2, [r2 && Name.get(r2), o2], null, n2, t2, s2, null), s2.font;
      }
      _getTextWidth(e2, t2) {
        return Math.sumPrecise(t2.charsToGlyphs(e2).map((e3) => e3.width)) / 1e3;
      }
      _computeFontSize(e2, t2, a2, n2, s2) {
        let { fontSize: r2 } = this.data.defaultAppearanceData, o2 = (r2 || 12) * i, l3 = Math.round(e2 / o2);
        if (!r2) {
          const roundWithTwoDigits = /* @__PURE__ */ __name((e3) => Math.floor(100 * e3) / 100, "roundWithTwoDigits");
          if (-1 === s2) {
            const s3 = this._getTextWidth(a2, n2);
            r2 = roundWithTwoDigits(Math.min(e2 / i, t2 / s3)), l3 = 1;
          } else {
            const c3 = a2.split(/\r\n?|\n/), h3 = [];
            for (const e3 of c3) {
              const t3 = n2.encodeString(e3).join(""), i2 = n2.charsToGlyphs(t3), a3 = n2.getCharPositions(t3);
              h3.push({ line: t3, glyphs: i2, positions: a3 });
            }
            const isTooBig = /* @__PURE__ */ __name((i2) => {
              let a3 = 0;
              for (const s3 of h3) {
                if (a3 += this._splitLine(null, n2, i2, t2, s3).length * i2, a3 > e2)
                  return true;
              }
              return false;
            }, "isTooBig");
            for (l3 = Math.max(l3, s2); o2 = e2 / l3, r2 = roundWithTwoDigits(o2 / i), isTooBig(r2); )
              l3++;
          }
          const { fontName: c2, fontColor: h2 } = this.data.defaultAppearanceData;
          this._defaultAppearance = function({ fontSize: e3, fontName: t3, fontColor: i2 }) {
            return `/${escapePDFName(t3)} ${e3} Tf ${getPdfColor(i2, true)}`;
          }({ fontSize: r2, fontName: c2, fontColor: h2 });
        }
        return [this._defaultAppearance, r2, e2 / l3];
      }
      _renderText(e2, t2, i2, a2, n2, s2, r2, o2) {
        let l3;
        if (1 === n2) {
          l3 = (a2 - this._getTextWidth(e2, t2) * i2) / 2;
        } else if (2 === n2) {
          l3 = a2 - this._getTextWidth(e2, t2) * i2 - r2;
        } else
          l3 = r2;
        const c2 = numberToString(l3 - s2.shift);
        return s2.shift = l3, `${c2} ${o2 = numberToString(o2)} Td (${escapeString(e2)}) Tj`;
      }
      _getSaveFieldResources(e2) {
        const { localResources: t2, appearanceResources: i2, acroFormResources: a2 } = this._fieldResources, n2 = this.data.defaultAppearanceData?.fontName;
        if (!n2)
          return t2 || Dict.empty;
        for (const e3 of [t2, i2])
          if (e3 instanceof Dict) {
            const t3 = e3.get("Font");
            if (t3 instanceof Dict && t3.has(n2))
              return e3;
          }
        if (a2 instanceof Dict) {
          const i3 = a2.get("Font");
          if (i3 instanceof Dict && i3.has(n2)) {
            const a3 = new Dict(e2);
            a3.set(n2, i3.getRaw(n2));
            const s2 = new Dict(e2);
            return s2.set("Font", a3), Dict.merge({ xref: e2, dictArray: [s2, t2], mergeSubDicts: true });
          }
        }
        return t2 || Dict.empty;
      }
      getFieldObject() {
        return null;
      }
    };
    __name(WidgetAnnotation, "WidgetAnnotation");
    TextWidgetAnnotation = class extends WidgetAnnotation {
      constructor(e2) {
        super(e2);
        const { dict: t2 } = e2;
        t2.has("PMD") && (this.flags |= E, this.data.hidden = true, warn$1("Barcodes are not supported")), this.data.hasOwnCanvas = this.data.readOnly && !this.data.noHTML, this._hasText = true, "string" != typeof this.data.fieldValue && (this.data.fieldValue = "");
        let i2 = getInheritableProperty({ dict: t2, key: "Q" });
        (!Number.isInteger(i2) || i2 < 0 || i2 > 2) && (i2 = null), this.data.textAlignment = i2;
        let a2 = getInheritableProperty({ dict: t2, key: "MaxLen" });
        (!Number.isInteger(a2) || a2 < 0) && (a2 = 0), this.data.maxLen = a2, this.data.multiLine = this.hasFieldFlag($), this.data.comb = this.hasFieldFlag(K) && !this.data.multiLine && !this.data.password && !this.hasFieldFlag(W) && 0 !== this.data.maxLen, this.data.doNotScroll = this.hasFieldFlag(V);
        const { data: { actions: n2 } } = this;
        if (!n2)
          return;
        const s2 = /^AF(Date|Time)_(?:Keystroke|Format)(?:Ex)?\(['"]?([^'"]+)['"]?\);$/;
        let r2 = false;
        (1 === n2.Format?.length && 1 === n2.Keystroke?.length && s2.test(n2.Format[0]) && s2.test(n2.Keystroke[0]) || 0 === n2.Format?.length && 1 === n2.Keystroke?.length && s2.test(n2.Keystroke[0]) || 0 === n2.Keystroke?.length && 1 === n2.Format?.length && s2.test(n2.Format[0])) && (r2 = true);
        const o2 = [];
        n2.Format && o2.push(...n2.Format), n2.Keystroke && o2.push(...n2.Keystroke), r2 && (delete n2.Keystroke, n2.Format = o2);
        for (const e3 of o2) {
          const t3 = e3.match(s2);
          if (!t3)
            continue;
          const i3 = "Date" === t3[1];
          let a3 = t3[2];
          const n3 = parseInt(a3, 10);
          if (isNaN(n3) || Math.floor(Math.log10(n3)) + 1 !== t3[2].length || (a3 = (i3 ? vs : Cs)[n3] ?? a3), this.data.datetimeFormat = a3, !r2)
            break;
          if (i3) {
            /HH|MM|ss|h/.test(a3) ? (this.data.datetimeType = "datetime-local", this.data.timeStep = /ss/.test(a3) ? 1 : 60) : this.data.datetimeType = "date";
            break;
          }
          this.data.datetimeType = "time", this.data.timeStep = /ss/.test(a3) ? 1 : 60;
          break;
        }
      }
      get hasTextContent() {
        return !!this.appearance && !this._needAppearances;
      }
      _getCombAppearance(e2, t2, i2, a2, n2, s2, r2, o2, l3, c2, h2) {
        const d2 = n2 / this.data.maxLen, u2 = this.getBorderAndBackgroundAppearances(h2), g2 = [], p2 = t2.getCharPositions(i2);
        for (const [e3, t3] of p2)
          g2.push(`(${escapeString(i2.substring(e3, t3))}) Tj`);
        const f2 = g2.join(` ${numberToString(d2)} 0 Td `);
        return `/Tx BMC q ${u2}BT ` + e2 + ` 1 0 0 1 ${numberToString(r2)} ${numberToString(o2 + l3)} Tm ${f2} ET Q EMC`;
      }
      _getMultilineAppearance(e2, t2, i2, a2, n2, s2, r2, o2, l3, c2, h2, d2) {
        const u2 = [], g2 = n2 - 2 * o2, p2 = { shift: 0 };
        for (let e3 = 0, s3 = t2.length; e3 < s3; e3++) {
          const s4 = t2[e3], d3 = this._splitLine(s4, i2, a2, g2);
          for (let t3 = 0, s5 = d3.length; t3 < s5; t3++) {
            const s6 = d3[t3], g3 = 0 === e3 && 0 === t3 ? -l3 - (h2 - c2) : -h2;
            u2.push(this._renderText(s6, i2, a2, n2, r2, p2, o2, g3));
          }
        }
        const f2 = this.getBorderAndBackgroundAppearances(d2), m2 = u2.join("\n");
        return `/Tx BMC q ${f2}BT ` + e2 + ` 1 0 0 1 0 ${numberToString(s2)} Tm ${m2} ET Q EMC`;
      }
      _splitLine(e2, t2, i2, a2, n2 = {}) {
        e2 = n2.line || e2;
        const s2 = n2.glyphs || t2.charsToGlyphs(e2);
        if (s2.length <= 1)
          return [e2];
        const r2 = n2.positions || t2.getCharPositions(e2), o2 = i2 / 1e3, l3 = [];
        let c2 = -1, h2 = -1, d2 = -1, u2 = 0, g2 = 0;
        for (let t3 = 0, i3 = s2.length; t3 < i3; t3++) {
          const [i4, n3] = r2[t3], p2 = s2[t3], f2 = p2.width * o2;
          " " === p2.unicode ? g2 + f2 > a2 ? (l3.push(e2.substring(u2, i4)), u2 = i4, g2 = f2, c2 = -1, d2 = -1) : (g2 += f2, c2 = i4, h2 = n3, d2 = t3) : g2 + f2 > a2 ? -1 !== c2 ? (l3.push(e2.substring(u2, h2)), u2 = h2, t3 = d2 + 1, c2 = -1, g2 = 0) : (l3.push(e2.substring(u2, i4)), u2 = i4, g2 = f2) : g2 += f2;
        }
        return u2 < e2.length && l3.push(e2.substring(u2, e2.length)), l3;
      }
      async extractTextContent(e2, t2, i2) {
        await super.extractTextContent(e2, t2, i2);
        const a2 = this.data.textContent;
        if (!a2)
          return;
        const n2 = a2.join("\n");
        if (n2 === this.data.fieldValue)
          return;
        const s2 = n2.replaceAll(/([.*+?^${}()|[\]\\])|(\s+)/g, (e3, t3) => t3 ? `\\${t3}` : "\\s+");
        new RegExp(`^\\s*${s2}\\s*$`).test(this.data.fieldValue) && (this.data.textContent = this.data.fieldValue.split("\n"));
      }
      getFieldObject() {
        return { id: this.data.id, value: this.data.fieldValue, defaultValue: this.data.defaultFieldValue || "", multiline: this.data.multiLine, password: this.data.password, charLimit: this.data.maxLen, comb: this.data.comb, editable: !this.data.readOnly, hidden: this.data.hidden, name: this.data.fieldName, rect: this.data.rect, actions: this.data.actions, page: this.data.pageIndex, strokeColor: this.data.borderColor, fillColor: this.data.backgroundColor, rotation: this.rotation, datetimeFormat: this.data.datetimeFormat, hasDatetimeHTML: !!this.data.datetimeType, type: "text" };
      }
    };
    __name(TextWidgetAnnotation, "TextWidgetAnnotation");
    ButtonWidgetAnnotation = class extends WidgetAnnotation {
      constructor(e2) {
        super(e2), this.checkedAppearance = null, this.uncheckedAppearance = null;
        const t2 = this.hasFieldFlag(q), i2 = this.hasFieldFlag(X);
        this.data.checkBox = !t2 && !i2, this.data.radioButton = t2 && !i2, this.data.pushButton = i2, this.data.isTooltipOnly = false, this.data.checkBox ? this._processCheckBox(e2) : this.data.radioButton ? this._processRadioButton(e2) : this.data.pushButton ? (this.data.hasOwnCanvas = true, this.data.noHTML = false, this._processPushButton(e2)) : warn$1("Invalid field flags for button widget annotation");
      }
      async getOperatorList(e2, t2, i2, a2) {
        if (this.data.pushButton)
          return super.getOperatorList(e2, t2, i2, false, a2);
        let n2 = null, s2 = null;
        if (a2) {
          const e3 = a2.get(this.data.id);
          n2 = e3 ? e3.value : null, s2 = e3 ? e3.rotation : null;
        }
        if (null === n2 && this.appearance)
          return super.getOperatorList(e2, t2, i2, a2);
        null == n2 && (n2 = this.data.checkBox ? this.data.fieldValue === this.data.exportValue : this.data.fieldValue === this.data.buttonValue);
        const r2 = n2 ? this.checkedAppearance : this.uncheckedAppearance;
        if (r2) {
          const n3 = this.appearance, o2 = lookupMatrix(r2.dict.getArray("Matrix"), fi);
          s2 && r2.dict.set("Matrix", this.getRotationMatrix(a2)), this.appearance = r2;
          const l3 = super.getOperatorList(e2, t2, i2, a2);
          return this.appearance = n3, r2.dict.set("Matrix", o2), l3;
        }
        return { opList: new OperatorList(), separateForm: false, separateCanvas: false };
      }
      async save(e2, t2, i2, a2) {
        this.data.checkBox ? this._saveCheckbox(e2, t2, i2, a2) : this.data.radioButton && this._saveRadioButton(e2, t2, i2, a2);
      }
      async _saveCheckbox(e2, t2, i2, a2) {
        if (!i2)
          return;
        const n2 = i2.get(this.data.id), s2 = this._buildFlags(n2?.noView, n2?.noPrint);
        let r2 = n2?.rotation, o2 = n2?.value;
        if (void 0 === r2 && void 0 === s2) {
          if (void 0 === o2)
            return;
          if (this.data.fieldValue === this.data.exportValue === o2)
            return;
        }
        let l3 = e2.xref.fetchIfRef(this.ref);
        if (!(l3 instanceof Dict))
          return;
        l3 = l3.clone(), void 0 === r2 && (r2 = this.rotation), void 0 === o2 && (o2 = this.data.fieldValue === this.data.exportValue);
        const c2 = { path: this.data.fieldName, value: o2 ? this.data.exportValue : "" }, h2 = Name.get(o2 ? this.data.exportValue : "Off");
        this.setValue(l3, h2, e2.xref, a2), l3.set("AS", h2), l3.set("M", `D:${getModificationDate()}`), void 0 !== s2 && l3.set("F", s2);
        const d2 = this._getMKDict(r2);
        d2 && l3.set("MK", d2), a2.put(this.ref, { data: l3, xfa: c2, needAppearances: false });
      }
      async _saveRadioButton(e2, t2, i2, a2) {
        if (!i2)
          return;
        const n2 = i2.get(this.data.id), s2 = this._buildFlags(n2?.noView, n2?.noPrint);
        let r2 = n2?.rotation, o2 = n2?.value;
        if (void 0 === r2 && void 0 === s2) {
          if (void 0 === o2)
            return;
          if (this.data.fieldValue === this.data.buttonValue === o2)
            return;
        }
        let l3 = e2.xref.fetchIfRef(this.ref);
        if (!(l3 instanceof Dict))
          return;
        l3 = l3.clone(), void 0 === o2 && (o2 = this.data.fieldValue === this.data.buttonValue), void 0 === r2 && (r2 = this.rotation);
        const c2 = { path: this.data.fieldName, value: o2 ? this.data.buttonValue : "" }, h2 = Name.get(o2 ? this.data.buttonValue : "Off");
        o2 && this.setValue(l3, h2, e2.xref, a2), l3.set("AS", h2), l3.set("M", `D:${getModificationDate()}`), void 0 !== s2 && l3.set("F", s2);
        const d2 = this._getMKDict(r2);
        d2 && l3.set("MK", d2), a2.put(this.ref, { data: l3, xfa: c2, needAppearances: false });
      }
      _getDefaultCheckedAppearance(e2, t2) {
        const { width: i2, height: a2 } = this, n2 = [0, 0, i2, a2], s2 = 0.8 * Math.min(i2, a2);
        let r2, o2;
        "check" === t2 ? (r2 = { width: 0.755 * s2, height: 0.705 * s2 }, o2 = "3") : "disc" === t2 ? (r2 = { width: 0.791 * s2, height: 0.705 * s2 }, o2 = "l") : unreachable$1(`_getDefaultCheckedAppearance - unsupported type: ${t2}`);
        const l3 = `q BT /PdfJsZaDb ${s2} Tf 0 g ${numberToString((i2 - r2.width) / 2)} ${numberToString((a2 - r2.height) / 2)} Td (${o2}) Tj ET Q`, c2 = new Dict(e2.xref);
        c2.set("FormType", 1), c2.setIfName("Subtype", "Form"), c2.setIfName("Type", "XObject"), c2.set("BBox", n2), c2.set("Matrix", [1, 0, 0, 1, 0, 0]), c2.set("Length", l3.length);
        const h2 = new Dict(e2.xref), d2 = new Dict(e2.xref);
        d2.set("PdfJsZaDb", this.fallbackFontDict), h2.set("Font", d2), c2.set("Resources", h2), this.checkedAppearance = new StringStream(l3), this.checkedAppearance.dict = c2, this._streams.push(this.checkedAppearance);
      }
      _processCheckBox(e2) {
        const t2 = e2.dict.get("AP");
        if (!(t2 instanceof Dict))
          return;
        const i2 = t2.get("N");
        if (!(i2 instanceof Dict))
          return;
        const a2 = this._decodeFormValue(e2.dict.get("AS"));
        "string" == typeof a2 && (this.data.fieldValue = a2);
        const n2 = null !== this.data.fieldValue && "Off" !== this.data.fieldValue ? this.data.fieldValue : "Yes", s2 = this._decodeFormValue(i2.getKeys());
        if (0 === s2.length)
          s2.push("Off", n2);
        else if (1 === s2.length)
          "Off" === s2[0] ? s2.push(n2) : s2.unshift("Off");
        else if (s2.includes(n2))
          s2.length = 0, s2.push("Off", n2);
        else {
          const e3 = s2.find((e4) => "Off" !== e4);
          s2.length = 0, s2.push("Off", e3);
        }
        s2.includes(this.data.fieldValue) || (this.data.fieldValue = "Off"), this.data.exportValue = s2[1];
        const r2 = i2.get(this.data.exportValue);
        this.checkedAppearance = r2 instanceof BaseStream ? r2 : null;
        const o2 = i2.get("Off");
        this.uncheckedAppearance = o2 instanceof BaseStream ? o2 : null, this.checkedAppearance ? this._streams.push(this.checkedAppearance) : this._getDefaultCheckedAppearance(e2, "check"), this.uncheckedAppearance && this._streams.push(this.uncheckedAppearance), this._fallbackFontDict = this.fallbackFontDict, null === this.data.defaultFieldValue && (this.data.defaultFieldValue = "Off");
      }
      _processRadioButton(e2) {
        this.data.buttonValue = null;
        const t2 = e2.dict.get("Parent");
        if (t2 instanceof Dict) {
          this.parent = e2.dict.getRaw("Parent");
          const i3 = t2.get("V");
          i3 instanceof Name && (this.data.fieldValue = this._decodeFormValue(i3));
        }
        const i2 = e2.dict.get("AP");
        if (!(i2 instanceof Dict))
          return;
        const a2 = i2.get("N");
        if (!(a2 instanceof Dict))
          return;
        for (const e3 of a2.getKeys())
          if ("Off" !== e3) {
            this.data.buttonValue = this._decodeFormValue(e3);
            break;
          }
        const n2 = a2.get(this.data.buttonValue);
        this.checkedAppearance = n2 instanceof BaseStream ? n2 : null;
        const s2 = a2.get("Off");
        this.uncheckedAppearance = s2 instanceof BaseStream ? s2 : null, this.checkedAppearance ? this._streams.push(this.checkedAppearance) : this._getDefaultCheckedAppearance(e2, "disc"), this.uncheckedAppearance && this._streams.push(this.uncheckedAppearance), this._fallbackFontDict = this.fallbackFontDict, null === this.data.defaultFieldValue && (this.data.defaultFieldValue = "Off");
      }
      _processPushButton(e2) {
        const { dict: t2, annotationGlobals: i2 } = e2;
        t2.has("A") || t2.has("AA") || this.data.alternativeText ? (this.data.isTooltipOnly = !t2.has("A") && !t2.has("AA"), Catalog.parseDestDictionary({ destDict: t2, resultObj: this.data, docBaseUrl: i2.baseUrl, docAttachments: i2.attachments })) : warn$1("Push buttons without action dictionaries are not supported");
      }
      getFieldObject() {
        let e2, t2 = "button";
        return this.data.checkBox ? (t2 = "checkbox", e2 = this.data.exportValue) : this.data.radioButton && (t2 = "radiobutton", e2 = this.data.buttonValue), { id: this.data.id, value: this.data.fieldValue || "Off", defaultValue: this.data.defaultFieldValue, exportValues: e2, editable: !this.data.readOnly, name: this.data.fieldName, rect: this.data.rect, hidden: this.data.hidden, actions: this.data.actions, page: this.data.pageIndex, strokeColor: this.data.borderColor, fillColor: this.data.backgroundColor, rotation: this.rotation, type: t2 };
      }
      get fallbackFontDict() {
        const e2 = new Dict();
        return e2.setIfName("BaseFont", "ZapfDingbats"), e2.setIfName("Type", "FallbackType"), e2.setIfName("Subtype", "FallbackType"), e2.setIfName("Encoding", "ZapfDingbatsEncoding"), shadow$1(this, "fallbackFontDict", e2);
      }
    };
    __name(ButtonWidgetAnnotation, "ButtonWidgetAnnotation");
    ChoiceWidgetAnnotation = class extends WidgetAnnotation {
      constructor(e2) {
        super(e2);
        const { dict: t2, xref: i2 } = e2;
        this.indices = t2.getArray("I"), this.hasIndices = Array.isArray(this.indices) && this.indices.length > 0, this.data.options = [];
        const a2 = getInheritableProperty({ dict: t2, key: "Opt" });
        if (Array.isArray(a2))
          for (let e3 = 0, t3 = a2.length; e3 < t3; e3++) {
            const t4 = i2.fetchIfRef(a2[e3]), n2 = Array.isArray(t4);
            this.data.options[e3] = { exportValue: this._decodeFormValue(n2 ? i2.fetchIfRef(t4[0]) : t4), displayValue: this._decodeFormValue(n2 ? i2.fetchIfRef(t4[1]) : t4) };
          }
        if (this.hasIndices) {
          this.data.fieldValue = [];
          const e3 = this.data.options.length;
          for (const t3 of this.indices)
            Number.isInteger(t3) && t3 >= 0 && t3 < e3 && this.data.fieldValue.push(this.data.options[t3].exportValue);
        } else
          "string" == typeof this.data.fieldValue ? this.data.fieldValue = [this.data.fieldValue] : this.data.fieldValue ||= [];
        0 === this.data.options.length && this.data.fieldValue.length > 0 && (this.data.options = this.data.fieldValue.map((e3) => ({ exportValue: e3, displayValue: e3 }))), this.data.combo = this.hasFieldFlag(z), this.data.multiSelect = this.hasFieldFlag(G), this._hasText = true;
      }
      getFieldObject() {
        const e2 = this.data.combo ? "combobox" : "listbox", t2 = this.data.fieldValue.length > 0 ? this.data.fieldValue[0] : null;
        return { id: this.data.id, value: t2, defaultValue: this.data.defaultFieldValue, editable: !this.data.readOnly, name: this.data.fieldName, rect: this.data.rect, numItems: this.data.fieldValue.length, multipleSelection: this.data.multiSelect, hidden: this.data.hidden, actions: this.data.actions, items: this.data.options, page: this.data.pageIndex, strokeColor: this.data.borderColor, fillColor: this.data.backgroundColor, rotation: this.rotation, type: e2 };
      }
      amendSavedDict(e2, t2) {
        if (!this.hasIndices)
          return;
        let i2 = e2?.get(this.data.id)?.value;
        Array.isArray(i2) || (i2 = [i2]);
        const a2 = [], { options: n2 } = this.data;
        for (let e3 = 0, t3 = 0, s2 = n2.length; e3 < s2; e3++)
          n2[e3].exportValue === i2[t3] && (a2.push(e3), t3 += 1);
        t2.set("I", a2);
      }
      async _getAppearance(e2, t2, a2, n2) {
        if (this.data.combo)
          return super._getAppearance(e2, t2, a2, n2);
        let s2, r2;
        const o2 = n2?.get(this.data.id);
        if (o2 && (r2 = o2.rotation, s2 = o2.value), void 0 === r2 && void 0 === s2 && !this._needAppearances)
          return null;
        void 0 === s2 ? s2 = this.data.fieldValue : Array.isArray(s2) || (s2 = [s2]);
        let { width: l3, height: c2 } = this;
        90 !== r2 && 270 !== r2 || ([l3, c2] = [c2, l3]);
        const h2 = this.data.options.length, d2 = [];
        for (let e3 = 0; e3 < h2; e3++) {
          const { exportValue: t3 } = this.data.options[e3];
          s2.includes(t3) && d2.push(e3);
        }
        this._defaultAppearance || (this.data.defaultAppearanceData = parseDefaultAppearance(this._defaultAppearance = "/Helvetica 0 Tf 0 g"));
        const u2 = await WidgetAnnotation._getFontData(e2, t2, this.data.defaultAppearanceData, this._fieldResources.mergedResources);
        let g2, { fontSize: p2 } = this.data.defaultAppearanceData;
        if (p2)
          g2 = this._defaultAppearance;
        else {
          const e3 = (c2 - 1) / h2;
          let t3, i2 = -1;
          for (const { displayValue: e4 } of this.data.options) {
            const a3 = this._getTextWidth(e4, u2);
            a3 > i2 && (i2 = a3, t3 = e4);
          }
          [g2, p2] = this._computeFontSize(e3, l3 - 4, t3, u2, -1);
        }
        const f2 = p2 * i, m2 = (f2 - p2) / 2, b2 = Math.floor(c2 / f2);
        let y2 = 0;
        if (d2.length > 0) {
          const e3 = Math.min(...d2), t3 = Math.max(...d2);
          y2 = Math.max(0, t3 - b2 + 1), y2 > e3 && (y2 = e3);
        }
        const w2 = Math.min(y2 + b2 + 1, h2), x2 = ["/Tx BMC q", `1 1 ${l3} ${c2} re W n`];
        if (d2.length) {
          x2.push("0.600006 0.756866 0.854904 rg");
          for (const e3 of d2)
            y2 <= e3 && e3 < w2 && x2.push(`1 ${c2 - (e3 - y2 + 1) * f2} ${l3} ${f2} re f`);
        }
        x2.push("BT", g2, `1 0 0 1 0 ${c2} Tm`);
        const S2 = { shift: 0 };
        for (let e3 = y2; e3 < w2; e3++) {
          const { displayValue: t3 } = this.data.options[e3], i2 = e3 === y2 ? m2 : 0;
          x2.push(this._renderText(t3, u2, p2, l3, 0, S2, 2, -f2 + i2));
        }
        return x2.push("ET Q EMC"), x2.join("\n");
      }
    };
    __name(ChoiceWidgetAnnotation, "ChoiceWidgetAnnotation");
    SignatureWidgetAnnotation = class extends WidgetAnnotation {
      constructor(e2) {
        super(e2), this.data.fieldValue = null, this.data.hasOwnCanvas = this.data.noRotate, this.data.noHTML = !this.data.hasOwnCanvas;
      }
      getFieldObject() {
        return { id: this.data.id, value: null, page: this.data.pageIndex, type: "signature" };
      }
    };
    __name(SignatureWidgetAnnotation, "SignatureWidgetAnnotation");
    TextAnnotation = class extends MarkupAnnotation {
      constructor(e2) {
        super(e2), this.data.noRotate = true, this.data.hasOwnCanvas = this.data.noRotate, this.data.noHTML = false;
        const { dict: t2 } = e2;
        this.data.annotationType = T.TEXT, this.data.hasAppearance ? this.data.name = "NoIcon" : (this.data.rect[1] = this.data.rect[3] - 22, this.data.rect[2] = this.data.rect[0] + 22, this.data.name = t2.has("Name") ? t2.get("Name").name : "Note"), t2.has("State") ? (this.data.state = t2.get("State") || null, this.data.stateModel = t2.get("StateModel") || null) : (this.data.state = null, this.data.stateModel = null);
      }
    };
    __name(TextAnnotation, "TextAnnotation");
    LinkAnnotation = class extends Annotation {
      constructor(e2) {
        super(e2);
        const { dict: t2, annotationGlobals: i2 } = e2;
        this.data.annotationType = T.LINK, this.data.noHTML = false;
        const a2 = getQuadPoints(t2, this.rectangle);
        a2 && (this.data.quadPoints = a2), this.data.borderColor ||= this.data.color, Catalog.parseDestDictionary({ destDict: t2, resultObj: this.data, docBaseUrl: i2.baseUrl, docAttachments: i2.attachments });
      }
      get overlaysTextContent() {
        return true;
      }
    };
    __name(LinkAnnotation, "LinkAnnotation");
    PopupAnnotation = class extends Annotation {
      constructor(e2) {
        super(e2);
        const { dict: t2 } = e2;
        this.data.annotationType = T.POPUP, this.data.noHTML = false, 0 !== this.width && 0 !== this.height || (this.data.rect = null);
        let i2 = t2.get("Parent");
        if (!i2)
          return void warn$1("Popup annotation has a missing or invalid parent annotation.");
        this.data.parentRect = lookupNormalRect(i2.getArray("Rect"), null), this.data.creationDate = i2.get("CreationDate") || "";
        if (isName(i2.get("RT"), F) && (i2 = i2.get("IRT")), i2.has("M") ? (this.setModificationDate(i2.get("M")), this.data.modificationDate = this.modificationDate) : this.data.modificationDate = null, i2.has("C") ? (this.setColor(i2.getArray("C")), this.data.color = this.color) : this.data.color = null, !this.viewable) {
          const e3 = i2.get("F");
          this._isViewable(e3) && this.setFlags(e3);
        }
        this.setTitle(i2.get("T")), this.data.titleObj = this._title, this.setContents(i2.get("Contents")), this.data.contentsObj = this._contents, i2.has("RC") && (this.data.richText = XFAFactory.getRichTextAsHtml(i2.get("RC"))), this.data.open = !!t2.get("Open");
      }
      static createNewDict(e2, t2, i2) {
        const { oldAnnotation: a2, rect: n2, parent: s2 } = e2, r2 = a2 || new Dict(t2);
        return r2.setIfNotExists("Type", Name.get("Annot")), r2.setIfNotExists("Subtype", Name.get("Popup")), r2.setIfNotExists("Open", false), r2.setIfArray("Rect", n2), r2.set("Parent", s2), r2;
      }
      static async createNewAppearanceStream(e2, t2, i2) {
        return null;
      }
    };
    __name(PopupAnnotation, "PopupAnnotation");
    FreeTextAnnotation = class extends MarkupAnnotation {
      constructor(e2) {
        super(e2), this.data.hasOwnCanvas = this.data.noRotate, this.data.isEditable = !this.data.noHTML, this.data.noHTML = false;
        const { annotationGlobals: t2, evaluatorOptions: i2, xref: a2 } = e2;
        if (this.data.annotationType = T.FREETEXT, this.setDefaultAppearance(e2), this._hasAppearance = !!this.appearance, this._hasAppearance) {
          const { fontColor: e3, fontSize: n2 } = function(e4, t3, i3, a3) {
            return new AppearanceStreamEvaluator(e4, t3, i3, a3).parse();
          }(this.appearance, i2, a2, t2.globalColorSpaceCache);
          this.data.defaultAppearanceData.fontColor = e3, this.data.defaultAppearanceData.fontSize = n2 || 10;
        } else {
          this.data.defaultAppearanceData.fontSize ||= 10;
          const { fontColor: t3, fontSize: i3 } = this.data.defaultAppearanceData;
          if (this._contents.str) {
            this.data.textContent = this._contents.str.split(/\r\n?|\n/).map((e4) => e4.trimEnd());
            const { coords: e3, bbox: t4, matrix: a3 } = FakeUnicodeFont.getFirstPositionInfo(this.rectangle, this.rotation, i3);
            this.data.textPosition = this._transformPoint(e3, t4, a3);
          }
          if (this._isOffscreenCanvasSupported) {
            const n2 = e2.dict.get("CA"), s2 = new FakeUnicodeFont(a2, "sans-serif");
            this.appearance = s2.createAppearance(this._contents.str, this.rectangle, this.rotation, i3, t3, n2), this._streams.push(this.appearance);
          } else
            warn$1("FreeTextAnnotation: OffscreenCanvas is not supported, annotation may not render correctly.");
        }
      }
      get hasTextContent() {
        return this._hasAppearance;
      }
      static createNewDict(e2, t2, { apRef: i2, ap: a2 }) {
        const { color: n2, date: s2, fontSize: r2, oldAnnotation: o2, rect: l3, rotation: c2, user: h2, value: d2 } = e2, u2 = o2 || new Dict(t2);
        u2.setIfNotExists("Type", Name.get("Annot")), u2.setIfNotExists("Subtype", Name.get("FreeText")), u2.set(o2 ? "M" : "CreationDate", `D:${getModificationDate(s2)}`), o2 && u2.delete("RC"), u2.setIfArray("Rect", l3);
        const g2 = `/Helv ${r2} Tf ${getPdfColor(n2, true)}`;
        if (u2.set("DA", g2), u2.setIfDefined("Contents", stringToAsciiOrUTF16BE(d2)), u2.setIfNotExists("F", 4), u2.setIfNotExists("Border", [0, 0, 0]), u2.setIfNumber("Rotate", c2), u2.setIfDefined("T", stringToAsciiOrUTF16BE(h2)), i2 || a2) {
          const e3 = new Dict(t2);
          u2.set("AP", e3), e3.set("N", i2 || a2);
        }
        return u2;
      }
      static async createNewAppearanceStream(e2, t2, a2) {
        const { baseFontRef: n2, evaluator: s2, task: r2 } = a2, { color: o2, fontSize: l3, rect: c2, rotation: h2, value: d2 } = e2;
        if (!o2)
          return null;
        const u2 = new Dict(t2), g2 = new Dict(t2);
        if (n2)
          g2.set("Helv", n2);
        else {
          const e3 = new Dict(t2);
          e3.setIfName("BaseFont", "Helvetica"), e3.setIfName("Type", "Font"), e3.setIfName("Subtype", "Type1"), e3.setIfName("Encoding", "WinAnsiEncoding"), g2.set("Helv", e3);
        }
        u2.set("Font", g2);
        const p2 = await WidgetAnnotation._getFontData(s2, r2, { fontName: "Helv", fontSize: l3 }, u2), [f2, m2, b2, y2] = c2;
        let w2 = b2 - f2, x2 = y2 - m2;
        h2 % 180 != 0 && ([w2, x2] = [x2, w2]);
        const S2 = d2.split("\n"), v2 = l3 / 1e3;
        let C2 = -1 / 0;
        const k2 = [];
        for (let e3 of S2) {
          const t3 = p2.encodeString(e3);
          if (t3.length > 1)
            return null;
          e3 = t3.join(""), k2.push(e3);
          let i2 = 0;
          const a3 = p2.charsToGlyphs(e3);
          for (const e4 of a3)
            i2 += e4.width * v2;
          C2 = Math.max(C2, i2);
        }
        let T2 = 1;
        C2 > w2 && (T2 = w2 / C2);
        let F2 = 1;
        const M2 = i * l3, D2 = 1 * l3, E2 = M2 * S2.length;
        E2 > x2 && (F2 = x2 / E2);
        const O2 = l3 * Math.min(T2, F2);
        let _2, R2, N2;
        switch (h2) {
          case 0:
            N2 = [1, 0, 0, 1], R2 = [c2[0], c2[1], w2, x2], _2 = [c2[0], c2[3] - D2];
            break;
          case 90:
            N2 = [0, 1, -1, 0], R2 = [c2[1], -c2[2], w2, x2], _2 = [c2[1], -c2[0] - D2];
            break;
          case 180:
            N2 = [-1, 0, 0, -1], R2 = [-c2[2], -c2[3], w2, x2], _2 = [-c2[2], -c2[1] - D2];
            break;
          case 270:
            N2 = [0, -1, 1, 0], R2 = [-c2[3], c2[0], w2, x2], _2 = [-c2[3], c2[2] - D2];
        }
        const L2 = ["q", `${N2.join(" ")} 0 0 cm`, `${R2.join(" ")} re W n`, "BT", `${getPdfColor(o2, true)}`, `0 Tc /Helv ${numberToString(O2)} Tf`];
        L2.push(`${_2.join(" ")} Td (${escapeString(k2[0])}) Tj`);
        const U2 = numberToString(M2);
        for (let e3 = 1, t3 = k2.length; e3 < t3; e3++) {
          const t4 = k2[e3];
          L2.push(`0 -${U2} Td (${escapeString(t4)}) Tj`);
        }
        L2.push("ET", "Q");
        const j2 = L2.join("\n"), $2 = new Dict(t2);
        $2.set("FormType", 1), $2.setIfName("Subtype", "Form"), $2.setIfName("Type", "XObject"), $2.set("BBox", c2), $2.set("Resources", u2), $2.set("Matrix", [1, 0, 0, 1, -c2[0], -c2[1]]);
        const H2 = new StringStream(j2);
        return H2.dict = $2, H2;
      }
    };
    __name(FreeTextAnnotation, "FreeTextAnnotation");
    LineAnnotation = class extends MarkupAnnotation {
      constructor(e2) {
        super(e2);
        const { dict: t2, xref: i2 } = e2;
        this.data.annotationType = T.LINE, this.data.hasOwnCanvas = this.data.noRotate, this.data.noHTML = false;
        const a2 = lookupRect(t2.getArray("L"), [0, 0, 0, 0]);
        if (this.data.lineCoordinates = ni.normalizeRect(a2), this.setLineEndings(t2.getArray("LE")), this.data.lineEndings = this.lineEndings, !this.appearance) {
          const e3 = getPdfColorArray(this.color, [0, 0, 0]), n2 = t2.get("CA"), s2 = getPdfColorArray(getRgbColor(t2.getArray("IC"), null)), r2 = s2 ? n2 : null, o2 = this.borderStyle.width || 1, l3 = 2 * o2, c2 = [this.data.lineCoordinates[0] - l3, this.data.lineCoordinates[1] - l3, this.data.lineCoordinates[2] + l3, this.data.lineCoordinates[3] + l3];
          ni.intersect(this.rectangle, c2) || (this.rectangle = c2), this._setDefaultAppearance({ xref: i2, extra: `${o2} w`, strokeColor: e3, fillColor: s2, strokeAlpha: n2, fillAlpha: r2, pointsCallback: (e4, t3) => (e4.push(`${a2[0]} ${a2[1]} m`, `${a2[2]} ${a2[3]} l`, "S"), [t3[0] - o2, t3[7] - o2, t3[2] + o2, t3[3] + o2]) });
        }
      }
    };
    __name(LineAnnotation, "LineAnnotation");
    SquareAnnotation = class extends MarkupAnnotation {
      constructor(e2) {
        super(e2);
        const { dict: t2, xref: i2 } = e2;
        if (this.data.annotationType = T.SQUARE, this.data.hasOwnCanvas = this.data.noRotate, this.data.noHTML = false, !this.appearance) {
          const e3 = getPdfColorArray(this.color, [0, 0, 0]), a2 = t2.get("CA"), n2 = getPdfColorArray(getRgbColor(t2.getArray("IC"), null)), s2 = n2 ? a2 : null;
          if (0 === this.borderStyle.width && !n2)
            return;
          this._setDefaultAppearance({ xref: i2, extra: `${this.borderStyle.width} w`, strokeColor: e3, fillColor: n2, strokeAlpha: a2, fillAlpha: s2, pointsCallback: (e4, t3) => {
            const i3 = t3[4] + this.borderStyle.width / 2, a3 = t3[5] + this.borderStyle.width / 2, s3 = t3[6] - t3[4] - this.borderStyle.width, r2 = t3[3] - t3[7] - this.borderStyle.width;
            return e4.push(`${i3} ${a3} ${s3} ${r2} re`), n2 ? e4.push("B") : e4.push("S"), [t3[0], t3[7], t3[2], t3[3]];
          } });
        }
      }
    };
    __name(SquareAnnotation, "SquareAnnotation");
    CircleAnnotation = class extends MarkupAnnotation {
      constructor(e2) {
        super(e2);
        const { dict: t2, xref: i2 } = e2;
        if (this.data.annotationType = T.CIRCLE, !this.appearance) {
          const e3 = getPdfColorArray(this.color, [0, 0, 0]), a2 = t2.get("CA"), n2 = getPdfColorArray(getRgbColor(t2.getArray("IC"), null)), s2 = n2 ? a2 : null;
          if (0 === this.borderStyle.width && !n2)
            return;
          const r2 = 4 / 3 * Math.tan(Math.PI / 8);
          this._setDefaultAppearance({ xref: i2, extra: `${this.borderStyle.width} w`, strokeColor: e3, fillColor: n2, strokeAlpha: a2, fillAlpha: s2, pointsCallback: (e4, t3) => {
            const i3 = t3[0] + this.borderStyle.width / 2, a3 = t3[1] - this.borderStyle.width / 2, s3 = t3[6] - this.borderStyle.width / 2, o2 = t3[7] + this.borderStyle.width / 2, l3 = i3 + (s3 - i3) / 2, c2 = a3 + (o2 - a3) / 2, h2 = (s3 - i3) / 2 * r2, d2 = (o2 - a3) / 2 * r2;
            return e4.push(`${l3} ${o2} m`, `${l3 + h2} ${o2} ${s3} ${c2 + d2} ${s3} ${c2} c`, `${s3} ${c2 - d2} ${l3 + h2} ${a3} ${l3} ${a3} c`, `${l3 - h2} ${a3} ${i3} ${c2 - d2} ${i3} ${c2} c`, `${i3} ${c2 + d2} ${l3 - h2} ${o2} ${l3} ${o2} c`, "h"), n2 ? e4.push("B") : e4.push("S"), [t3[0], t3[7], t3[2], t3[3]];
          } });
        }
      }
    };
    __name(CircleAnnotation, "CircleAnnotation");
    PolylineAnnotation = class extends MarkupAnnotation {
      constructor(e2) {
        super(e2);
        const { dict: t2, xref: i2 } = e2;
        this.data.annotationType = T.POLYLINE, this.data.hasOwnCanvas = this.data.noRotate, this.data.noHTML = false, this.data.vertices = null, this instanceof PolygonAnnotation || (this.setLineEndings(t2.getArray("LE")), this.data.lineEndings = this.lineEndings);
        const a2 = t2.getArray("Vertices");
        if (!isNumberArray(a2, null))
          return;
        const n2 = this.data.vertices = Float32Array.from(a2);
        if (!this.appearance) {
          const e3 = getPdfColorArray(this.color, [0, 0, 0]), a3 = t2.get("CA");
          let s2, r2 = getRgbColor(t2.getArray("IC"), null);
          r2 && (r2 = getPdfColorArray(r2)), s2 = r2 ? this.color ? r2.every((t3, i3) => t3 === e3[i3]) ? "f" : "B" : "f" : "S";
          const o2 = this.borderStyle.width || 1, l3 = 2 * o2, c2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (let e4 = 0, t3 = n2.length; e4 < t3; e4 += 2)
            ni.rectBoundingBox(n2[e4] - l3, n2[e4 + 1] - l3, n2[e4] + l3, n2[e4 + 1] + l3, c2);
          ni.intersect(this.rectangle, c2) || (this.rectangle = c2), this._setDefaultAppearance({ xref: i2, extra: `${o2} w`, strokeColor: e3, strokeAlpha: a3, fillColor: r2, fillAlpha: r2 ? a3 : null, pointsCallback: (e4, t3) => {
            for (let t4 = 0, i3 = n2.length; t4 < i3; t4 += 2)
              e4.push(`${n2[t4]} ${n2[t4 + 1]} ${0 === t4 ? "m" : "l"}`);
            return e4.push(s2), [t3[0], t3[7], t3[2], t3[3]];
          } });
        }
      }
    };
    __name(PolylineAnnotation, "PolylineAnnotation");
    PolygonAnnotation = class extends PolylineAnnotation {
      constructor(e2) {
        super(e2), this.data.annotationType = T.POLYGON;
      }
    };
    __name(PolygonAnnotation, "PolygonAnnotation");
    CaretAnnotation = class extends MarkupAnnotation {
      constructor(e2) {
        super(e2), this.data.annotationType = T.CARET;
      }
    };
    __name(CaretAnnotation, "CaretAnnotation");
    InkAnnotation = class extends MarkupAnnotation {
      constructor(e2) {
        super(e2), this.data.hasOwnCanvas = this.data.noRotate, this.data.noHTML = false;
        const { dict: t2, xref: i2 } = e2;
        this.data.annotationType = T.INK, this.data.inkLists = [], this.data.isEditable = !this.data.noHTML, this.data.noHTML = false, this.data.opacity = t2.get("CA") || 1;
        const a2 = t2.getArray("InkList");
        if (Array.isArray(a2)) {
          for (let e3 = 0, t3 = a2.length; e3 < t3; ++e3) {
            if (!Array.isArray(a2[e3]))
              continue;
            const t4 = new Float32Array(a2[e3].length);
            this.data.inkLists.push(t4);
            for (let n2 = 0, s2 = a2[e3].length; n2 < s2; n2 += 2) {
              const s3 = i2.fetchIfRef(a2[e3][n2]), r2 = i2.fetchIfRef(a2[e3][n2 + 1]);
              "number" == typeof s3 && "number" == typeof r2 && (t4[n2] = s3, t4[n2 + 1] = r2);
            }
          }
          if (!this.appearance) {
            const e3 = getPdfColorArray(this.color, [0, 0, 0]), a3 = t2.get("CA"), n2 = this.borderStyle.width || 1, s2 = 2 * n2, r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
            for (const e4 of this.data.inkLists)
              for (let t3 = 0, i3 = e4.length; t3 < i3; t3 += 2)
                ni.rectBoundingBox(e4[t3] - s2, e4[t3 + 1] - s2, e4[t3] + s2, e4[t3 + 1] + s2, r2);
            ni.intersect(this.rectangle, r2) || (this.rectangle = r2), this._setDefaultAppearance({ xref: i2, extra: `${n2} w`, strokeColor: e3, strokeAlpha: a3, pointsCallback: (e4, t3) => {
              for (const t4 of this.data.inkLists) {
                for (let i3 = 0, a4 = t4.length; i3 < a4; i3 += 2)
                  e4.push(`${t4[i3]} ${t4[i3 + 1]} ${0 === i3 ? "m" : "l"}`);
                e4.push("S");
              }
              return [t3[0], t3[7], t3[2], t3[3]];
            } });
          }
        }
      }
      static createNewDict(e2, t2, { apRef: i2, ap: a2 }) {
        const { oldAnnotation: n2, color: s2, date: r2, opacity: o2, paths: l3, outlines: c2, rect: h2, rotation: d2, thickness: u2, user: g2 } = e2, p2 = n2 || new Dict(t2);
        if (p2.setIfNotExists("Type", Name.get("Annot")), p2.setIfNotExists("Subtype", Name.get("Ink")), p2.set(n2 ? "M" : "CreationDate", `D:${getModificationDate(r2)}`), p2.setIfArray("Rect", h2), p2.setIfArray("InkList", c2?.points || l3?.points), p2.setIfNotExists("F", 4), p2.setIfNumber("Rotate", d2), p2.setIfDefined("T", stringToAsciiOrUTF16BE(g2)), c2 && p2.setIfName("IT", "InkHighlight"), u2 > 0) {
          const e3 = new Dict(t2);
          p2.set("BS", e3), e3.set("W", u2);
        }
        if (p2.setIfArray("C", getPdfColorArray(s2)), p2.setIfNumber("CA", o2), a2 || i2) {
          const e3 = new Dict(t2);
          p2.set("AP", e3), e3.set("N", i2 || a2);
        }
        return p2;
      }
      static async createNewAppearanceStream(e2, t2, i2) {
        if (e2.outlines)
          return this.createNewAppearanceStreamForHighlight(e2, t2, i2);
        const { color: a2, rect: n2, paths: s2, thickness: r2, opacity: o2 } = e2;
        if (!a2)
          return null;
        const l3 = [`${r2} w 1 J 1 j`, `${getPdfColor(a2, false)}`];
        1 !== o2 && l3.push("/R0 gs");
        for (const e3 of s2.lines) {
          l3.push(`${numberToString(e3[4])} ${numberToString(e3[5])} m`);
          for (let t3 = 6, i3 = e3.length; t3 < i3; t3 += 6)
            if (isNaN(e3[t3]))
              l3.push(`${numberToString(e3[t3 + 4])} ${numberToString(e3[t3 + 5])} l`);
            else {
              const [i4, a3, n3, s3, r3, o3] = e3.slice(t3, t3 + 6);
              l3.push([i4, a3, n3, s3, r3, o3].map(numberToString).join(" ") + " c");
            }
          6 === e3.length && l3.push(`${numberToString(e3[4])} ${numberToString(e3[5])} l`);
        }
        l3.push("S");
        const c2 = l3.join("\n"), h2 = new Dict(t2);
        if (h2.set("FormType", 1), h2.setIfName("Subtype", "Form"), h2.setIfName("Type", "XObject"), h2.set("BBox", n2), h2.set("Length", c2.length), 1 !== o2) {
          const e3 = new Dict(t2), i3 = new Dict(t2), a3 = new Dict(t2);
          a3.set("CA", o2), a3.setIfName("Type", "ExtGState"), i3.set("R0", a3), e3.set("ExtGState", i3), h2.set("Resources", e3);
        }
        const d2 = new StringStream(c2);
        return d2.dict = h2, d2;
      }
      static async createNewAppearanceStreamForHighlight(e2, t2, i2) {
        const { color: a2, rect: n2, outlines: { outline: s2 }, opacity: r2 } = e2;
        if (!a2)
          return null;
        const o2 = [`${getPdfColor(a2, true)}`, "/R0 gs"];
        o2.push(`${numberToString(s2[4])} ${numberToString(s2[5])} m`);
        for (let e3 = 6, t3 = s2.length; e3 < t3; e3 += 6)
          if (isNaN(s2[e3]))
            o2.push(`${numberToString(s2[e3 + 4])} ${numberToString(s2[e3 + 5])} l`);
          else {
            const [t4, i3, a3, n3, r3, l4] = s2.slice(e3, e3 + 6);
            o2.push([t4, i3, a3, n3, r3, l4].map(numberToString).join(" ") + " c");
          }
        o2.push("h f");
        const l3 = o2.join("\n"), c2 = new Dict(t2);
        c2.set("FormType", 1), c2.setIfName("Subtype", "Form"), c2.setIfName("Type", "XObject"), c2.set("BBox", n2), c2.set("Length", l3.length);
        const h2 = new Dict(t2), d2 = new Dict(t2);
        h2.set("ExtGState", d2), c2.set("Resources", h2);
        const u2 = new Dict(t2);
        d2.set("R0", u2), u2.setIfName("BM", "Multiply"), 1 !== r2 && (u2.set("ca", r2), u2.setIfName("Type", "ExtGState"));
        const g2 = new StringStream(l3);
        return g2.dict = c2, g2;
      }
    };
    __name(InkAnnotation, "InkAnnotation");
    HighlightAnnotation = class extends MarkupAnnotation {
      constructor(e2) {
        super(e2);
        const { dict: t2, xref: i2 } = e2;
        this.data.annotationType = T.HIGHLIGHT, this.data.isEditable = !this.data.noHTML, this.data.noHTML = false, this.data.opacity = t2.get("CA") || 1;
        if (this.data.quadPoints = getQuadPoints(t2, null)) {
          const e3 = this.appearance?.dict.get("Resources");
          if (!this.appearance || !e3?.has("ExtGState")) {
            this.appearance && warn$1("HighlightAnnotation - ignoring built-in appearance stream.");
            const e4 = getPdfColorArray(this.color, [1, 1, 0]), a2 = t2.get("CA");
            this._setDefaultAppearance({ xref: i2, fillColor: e4, blendMode: "Multiply", fillAlpha: a2, pointsCallback: (e5, t3) => (e5.push(`${t3[0]} ${t3[1]} m`, `${t3[2]} ${t3[3]} l`, `${t3[6]} ${t3[7]} l`, `${t3[4]} ${t3[5]} l`, "f"), [t3[0], t3[7], t3[2], t3[3]]) });
          }
        } else
          this.data.popupRef = null;
      }
      get overlaysTextContent() {
        return true;
      }
      static createNewDict(e2, t2, { apRef: i2, ap: a2 }) {
        const { color: n2, date: s2, oldAnnotation: r2, opacity: o2, rect: l3, rotation: c2, user: h2, quadPoints: d2 } = e2, u2 = r2 || new Dict(t2);
        if (u2.setIfNotExists("Type", Name.get("Annot")), u2.setIfNotExists("Subtype", Name.get("Highlight")), u2.set(r2 ? "M" : "CreationDate", `D:${getModificationDate(s2)}`), u2.setIfArray("Rect", l3), u2.setIfNotExists("F", 4), u2.setIfNotExists("Border", [0, 0, 0]), u2.setIfNumber("Rotate", c2), u2.setIfArray("QuadPoints", d2), u2.setIfArray("C", getPdfColorArray(n2)), u2.setIfNumber("CA", o2), u2.setIfDefined("T", stringToAsciiOrUTF16BE(h2)), i2 || a2) {
          const e3 = new Dict(t2);
          u2.set("AP", e3), e3.set("N", i2 || a2);
        }
        return u2;
      }
      static async createNewAppearanceStream(e2, t2, i2) {
        const { color: a2, rect: n2, outlines: s2, opacity: r2 } = e2;
        if (!a2)
          return null;
        const o2 = [`${getPdfColor(a2, true)}`, "/R0 gs"], l3 = [];
        for (const e3 of s2) {
          l3.length = 0, l3.push(`${numberToString(e3[0])} ${numberToString(e3[1])} m`);
          for (let t3 = 2, i3 = e3.length; t3 < i3; t3 += 2)
            l3.push(`${numberToString(e3[t3])} ${numberToString(e3[t3 + 1])} l`);
          l3.push("h"), o2.push(l3.join("\n"));
        }
        o2.push("f*");
        const c2 = o2.join("\n"), h2 = new Dict(t2);
        h2.set("FormType", 1), h2.setIfName("Subtype", "Form"), h2.setIfName("Type", "XObject"), h2.set("BBox", n2), h2.set("Length", c2.length);
        const d2 = new Dict(t2), u2 = new Dict(t2);
        d2.set("ExtGState", u2), h2.set("Resources", d2);
        const g2 = new Dict(t2);
        u2.set("R0", g2), g2.setIfName("BM", "Multiply"), 1 !== r2 && (g2.set("ca", r2), g2.setIfName("Type", "ExtGState"));
        const p2 = new StringStream(c2);
        return p2.dict = h2, p2;
      }
    };
    __name(HighlightAnnotation, "HighlightAnnotation");
    UnderlineAnnotation = class extends MarkupAnnotation {
      constructor(e2) {
        super(e2);
        const { dict: t2, xref: i2 } = e2;
        this.data.annotationType = T.UNDERLINE;
        if (this.data.quadPoints = getQuadPoints(t2, null)) {
          if (!this.appearance) {
            const e3 = getPdfColorArray(this.color, [0, 0, 0]), a2 = t2.get("CA");
            this._setDefaultAppearance({ xref: i2, extra: "[] 0 d 0.571 w", strokeColor: e3, strokeAlpha: a2, pointsCallback: (e4, t3) => (e4.push(`${t3[4]} ${t3[5] + 1.3} m`, `${t3[6]} ${t3[7] + 1.3} l`, "S"), [t3[0], t3[7], t3[2], t3[3]]) });
          }
        } else
          this.data.popupRef = null;
      }
      get overlaysTextContent() {
        return true;
      }
    };
    __name(UnderlineAnnotation, "UnderlineAnnotation");
    SquigglyAnnotation = class extends MarkupAnnotation {
      constructor(e2) {
        super(e2);
        const { dict: t2, xref: i2 } = e2;
        this.data.annotationType = T.SQUIGGLY;
        if (this.data.quadPoints = getQuadPoints(t2, null)) {
          if (!this.appearance) {
            const e3 = getPdfColorArray(this.color, [0, 0, 0]), a2 = t2.get("CA");
            this._setDefaultAppearance({ xref: i2, extra: "[] 0 d 1 w", strokeColor: e3, strokeAlpha: a2, pointsCallback: (e4, t3) => {
              const i3 = (t3[1] - t3[5]) / 6;
              let a3 = i3, n2 = t3[4];
              const s2 = t3[5], r2 = t3[6];
              e4.push(`${n2} ${s2 + a3} m`);
              do {
                n2 += 2, a3 = 0 === a3 ? i3 : 0, e4.push(`${n2} ${s2 + a3} l`);
              } while (n2 < r2);
              return e4.push("S"), [t3[4], s2 - 2 * i3, r2, s2 + 2 * i3];
            } });
          }
        } else
          this.data.popupRef = null;
      }
      get overlaysTextContent() {
        return true;
      }
    };
    __name(SquigglyAnnotation, "SquigglyAnnotation");
    StrikeOutAnnotation = class extends MarkupAnnotation {
      constructor(e2) {
        super(e2);
        const { dict: t2, xref: i2 } = e2;
        this.data.annotationType = T.STRIKEOUT;
        if (this.data.quadPoints = getQuadPoints(t2, null)) {
          if (!this.appearance) {
            const e3 = getPdfColorArray(this.color, [0, 0, 0]), a2 = t2.get("CA");
            this._setDefaultAppearance({ xref: i2, extra: "[] 0 d 1 w", strokeColor: e3, strokeAlpha: a2, pointsCallback: (e4, t3) => (e4.push((t3[0] + t3[4]) / 2 + " " + (t3[1] + t3[5]) / 2 + " m", (t3[2] + t3[6]) / 2 + " " + (t3[3] + t3[7]) / 2 + " l", "S"), [t3[0], t3[7], t3[2], t3[3]]) });
          }
        } else
          this.data.popupRef = null;
      }
      get overlaysTextContent() {
        return true;
      }
    };
    __name(StrikeOutAnnotation, "StrikeOutAnnotation");
    StampAnnotation = class extends MarkupAnnotation {
      constructor(e2) {
        super(e2);
        __privateAdd(this, _fe, null);
        this.data.annotationType = T.STAMP, this.data.hasOwnCanvas = this.data.noRotate, this.data.isEditable = !this.data.noHTML, this.data.noHTML = false;
      }
      mustBeViewedWhenEditing(e2, t2 = null) {
        return e2 ? !this.data.isEditable || (__privateGet(this, _fe) ?? __privateSet(this, _fe, this.data.hasOwnCanvas), this.data.hasOwnCanvas = true, true) : (null !== __privateGet(this, _fe) && (this.data.hasOwnCanvas = __privateGet(this, _fe), __privateSet(this, _fe, null)), !t2?.has(this.data.id));
      }
      static async createImage(e2, t2) {
        const { width: i2, height: a2 } = e2, n2 = new OffscreenCanvas(i2, a2), s2 = n2.getContext("2d", { alpha: true });
        s2.drawImage(e2, 0, 0);
        const r2 = s2.getImageData(0, 0, i2, a2).data, o2 = new Uint32Array(r2.buffer), l3 = o2.some(FeatureTest.isLittleEndian ? (e3) => e3 >>> 24 != 255 : (e3) => !!(255 & ~e3));
        l3 && (s2.fillStyle = "white", s2.fillRect(0, 0, i2, a2), s2.drawImage(e2, 0, 0));
        const c2 = n2.convertToBlob({ type: "image/jpeg", quality: 1 }).then((e3) => e3.arrayBuffer()), h2 = Name.get("XObject"), d2 = Name.get("Image"), u2 = new Dict(t2);
        u2.set("Type", h2), u2.set("Subtype", d2), u2.set("BitsPerComponent", 8), u2.setIfName("ColorSpace", "DeviceRGB"), u2.setIfName("Filter", "DCTDecode"), u2.set("BBox", [0, 0, i2, a2]), u2.set("Width", i2), u2.set("Height", a2);
        let g2 = null;
        if (l3) {
          const e3 = new Uint8Array(o2.length);
          if (FeatureTest.isLittleEndian)
            for (let t3 = 0, i3 = o2.length; t3 < i3; t3++)
              e3[t3] = o2[t3] >>> 24;
          else
            for (let t3 = 0, i3 = o2.length; t3 < i3; t3++)
              e3[t3] = 255 & o2[t3];
          const n3 = new Dict(t2);
          n3.set("Type", h2), n3.set("Subtype", d2), n3.set("BitsPerComponent", 8), n3.setIfName("ColorSpace", "DeviceGray"), n3.set("Width", i2), n3.set("Height", a2), g2 = new Stream(e3, 0, 0, n3);
        }
        return { imageStream: new Stream(await c2, 0, 0, u2), smaskStream: g2, width: i2, height: a2 };
      }
      static createNewDict(e2, t2, { apRef: i2, ap: a2 }) {
        const { date: n2, oldAnnotation: s2, rect: r2, rotation: o2, user: l3 } = e2, c2 = s2 || new Dict(t2);
        if (c2.setIfNotExists("Type", Name.get("Annot")), c2.setIfNotExists("Subtype", Name.get("Stamp")), c2.set(s2 ? "M" : "CreationDate", `D:${getModificationDate(n2)}`), c2.setIfArray("Rect", r2), c2.setIfNotExists("F", 4), c2.setIfNotExists("Border", [0, 0, 0]), c2.setIfNumber("Rotate", o2), c2.setIfDefined("T", stringToAsciiOrUTF16BE(l3)), i2 || a2) {
          const e3 = new Dict(t2);
          c2.set("AP", e3), e3.set("N", i2 || a2);
        }
        return c2;
      }
      static async createNewAppearanceStream(e2, t2, i2) {
        if (e2.oldAnnotation)
          return null;
        if (e2.isSignature)
          return __privateMethod(this, _me, me_fn).call(this, e2, t2);
        const { rotation: a2 } = e2, { imageRef: n2, width: s2, height: r2 } = i2.image, o2 = new Dict(t2), l3 = new Dict(t2);
        o2.set("XObject", l3), l3.set("Im0", n2);
        const c2 = `q ${s2} 0 0 ${r2} 0 0 cm /Im0 Do Q`, h2 = new Dict(t2);
        if (h2.set("FormType", 1), h2.setIfName("Subtype", "Form"), h2.setIfName("Type", "XObject"), h2.set("BBox", [0, 0, s2, r2]), h2.set("Resources", o2), a2) {
          const e3 = getRotationMatrix(a2, s2, r2);
          h2.set("Matrix", e3);
        }
        const d2 = new StringStream(c2);
        return d2.dict = h2, d2;
      }
    };
    __name(StampAnnotation, "StampAnnotation");
    _fe = new WeakMap();
    _me = new WeakSet();
    me_fn = /* @__PURE__ */ __name(async function(e2, t2) {
      const { areContours: i2, color: a2, rect: n2, lines: s2, thickness: r2 } = e2;
      if (!a2)
        return null;
      const o2 = [`${r2} w 1 J 1 j`, `${getPdfColor(a2, i2)}`];
      for (const e3 of s2) {
        o2.push(`${numberToString(e3[4])} ${numberToString(e3[5])} m`);
        for (let t3 = 6, i3 = e3.length; t3 < i3; t3 += 6)
          if (isNaN(e3[t3]))
            o2.push(`${numberToString(e3[t3 + 4])} ${numberToString(e3[t3 + 5])} l`);
          else {
            const [i4, a3, n3, s3, r3, l4] = e3.slice(t3, t3 + 6);
            o2.push([i4, a3, n3, s3, r3, l4].map(numberToString).join(" ") + " c");
          }
        6 === e3.length && o2.push(`${numberToString(e3[4])} ${numberToString(e3[5])} l`);
      }
      o2.push(i2 ? "F" : "S");
      const l3 = o2.join("\n"), c2 = new Dict(t2);
      c2.set("FormType", 1), c2.setIfName("Subtype", "Form"), c2.setIfName("Type", "XObject"), c2.set("BBox", n2), c2.set("Length", l3.length);
      const h2 = new StringStream(l3);
      return h2.dict = c2, h2;
    }, "#me");
    __privateAdd(StampAnnotation, _me);
    FileAttachmentAnnotation = class extends MarkupAnnotation {
      constructor(e2) {
        super(e2);
        const { dict: t2, xref: i2 } = e2, a2 = new FileSpec(t2.get("FS"), i2);
        this.data.annotationType = T.FILEATTACHMENT, this.data.hasOwnCanvas = this.data.noRotate, this.data.noHTML = false, this.data.file = a2.serializable;
        const n2 = t2.get("Name");
        this.data.name = n2 instanceof Name ? stringToPDFString(n2.name) : "PushPin";
        const s2 = t2.get("ca");
        this.data.fillAlpha = "number" == typeof s2 && s2 >= 0 && s2 <= 1 ? s2 : null;
      }
    };
    __name(FileAttachmentAnnotation, "FileAttachmentAnnotation");
    rl = { get r() {
      return shadow$1(this, "r", new Uint8Array([7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21]));
    }, get k() {
      return shadow$1(this, "k", new Int32Array([-680876936, -389564586, 606105819, -1044525330, -176418897, 1200080426, -1473231341, -45705983, 1770035416, -1958414417, -42063, -1990404162, 1804603682, -40341101, -1502002290, 1236535329, -165796510, -1069501632, 643717713, -373897302, -701558691, 38016083, -660478335, -405537848, 568446438, -1019803690, -187363961, 1163531501, -1444681467, -51403784, 1735328473, -1926607734, -378558, -2022574463, 1839030562, -35309556, -1530992060, 1272893353, -155497632, -1094730640, 681279174, -358537222, -722521979, 76029189, -640364487, -421815835, 530742520, -995338651, -198630844, 1126891415, -1416354905, -57434055, 1700485571, -1894986606, -1051523, -2054922799, 1873313359, -30611744, -1560198380, 1309151649, -145523070, -1120210379, 718787259, -343485551]));
    } };
    __name(calculateMD5, "calculateMD5");
    __name(decodeString, "decodeString");
    DatasetXMLParser = class extends SimpleXMLParser {
      constructor(e2) {
        super(e2), this.node = null;
      }
      onEndElement(e2) {
        const t2 = super.onEndElement(e2);
        if (t2 && "xfa:datasets" === e2)
          throw this.node = t2, new Error("Aborting DatasetXMLParser.");
      }
    };
    __name(DatasetXMLParser, "DatasetXMLParser");
    DatasetReader = class {
      constructor(e2) {
        if (e2.datasets)
          this.node = new SimpleXMLParser({ hasAttributes: true }).parseFromString(e2.datasets).documentElement;
        else {
          const t2 = new DatasetXMLParser({ hasAttributes: true });
          try {
            t2.parseFromString(e2["xdp:xdp"]);
          } catch {
          }
          this.node = t2.node;
        }
      }
      getValue(e2) {
        if (!this.node || !e2)
          return "";
        const t2 = this.node.searchNode(parseXFAPath(e2), 0);
        if (!t2)
          return "";
        const i2 = t2.firstChild;
        return "value" === i2?.nodeName ? t2.children.map((e3) => decodeString(e3.textContent)) : decodeString(t2.textContent);
      }
    };
    __name(DatasetReader, "DatasetReader");
    SingleIntersector = class {
      #be;
      #ye = 1 / 0;
      #we = 1 / 0;
      #Ae = -1 / 0;
      #xe = -1 / 0;
      #Se = null;
      #ve = [];
      #Ce = [];
      #ke = -1;
      #Te = false;
      constructor(e2) {
        this.#be = e2;
        const t2 = e2.data.quadPoints;
        if (t2) {
          for (let e3 = 0, i2 = t2.length; e3 < i2; e3 += 8)
            this.#ye = Math.min(this.#ye, t2[e3]), this.#Ae = Math.max(this.#Ae, t2[e3 + 2]), this.#we = Math.min(this.#we, t2[e3 + 5]), this.#xe = Math.max(this.#xe, t2[e3 + 1]);
          t2.length > 8 && (this.#Se = t2);
        } else
          [this.#ye, this.#we, this.#Ae, this.#xe] = e2.data.rect;
      }
      overlaps(e2) {
        return !(this.#ye >= e2.#Ae || this.#Ae <= e2.#ye || this.#we >= e2.#xe || this.#xe <= e2.#we);
      }
      #Ie(e2, t2) {
        if (this.#ye >= e2 || this.#Ae <= e2 || this.#we >= t2 || this.#xe <= t2)
          return false;
        const i2 = this.#Se;
        if (!i2)
          return true;
        if (this.#ke >= 0) {
          const a2 = this.#ke;
          if (!(i2[a2] >= e2 || i2[a2 + 2] <= e2 || i2[a2 + 5] >= t2 || i2[a2 + 1] <= t2))
            return true;
          this.#ke = -1;
        }
        for (let a2 = 0, n2 = i2.length; a2 < n2; a2 += 8)
          if (!(i2[a2] >= e2 || i2[a2 + 2] <= e2 || i2[a2 + 5] >= t2 || i2[a2 + 1] <= t2))
            return this.#ke = a2, true;
        return false;
      }
      addGlyph(e2, t2, i2) {
        return this.#Ie(e2, t2) ? (this.#Ce.length > 0 && (this.#ve.push(this.#Ce.join("")), this.#Ce.length = 0), this.#ve.push(i2), this.#Te = true, true) : (this.disableExtraChars(), false);
      }
      addExtraChar(e2) {
        this.#Te && this.#Ce.push(e2);
      }
      disableExtraChars() {
        this.#Te && (this.#Te = false, this.#Ce.length = 0);
      }
      setText() {
        this.#be.data.overlaidText = this.#ve.join("");
      }
    };
    __name(SingleIntersector, "SingleIntersector");
    Intersector = class {
      #Fe = /* @__PURE__ */ new Map();
      constructor(e2) {
        for (const t2 of e2) {
          if (!t2.data.quadPoints && !t2.data.rect)
            continue;
          const e3 = new SingleIntersector(t2);
          for (const [t3, i2] of this.#Fe)
            t3.overlaps(e3) && (i2 ? i2.add(e3) : this.#Fe.set(t3, /* @__PURE__ */ new Set([e3])));
          this.#Fe.set(e3, null);
        }
      }
      addGlyph(e2, t2, i2, a2) {
        const n2 = e2[4] + t2 / 2, s2 = e2[5] + i2 / 2;
        let r2;
        for (const [e3, t3] of this.#Fe)
          r2 ? r2.has(e3) ? e3.addGlyph(n2, s2, a2) : e3.disableExtraChars() : e3.addGlyph(n2, s2, a2) && (r2 = t3);
      }
      addExtraChar(e2) {
        for (const t2 of this.#Fe.keys())
          t2.addExtraChar(e2);
      }
      setText() {
        for (const e2 of this.#Fe.keys())
          e2.setText();
      }
    };
    __name(Intersector, "Intersector");
    Word64 = class {
      constructor(e2, t2) {
        this.high = 0 | e2, this.low = 0 | t2;
      }
      and(e2) {
        this.high &= e2.high, this.low &= e2.low;
      }
      xor(e2) {
        this.high ^= e2.high, this.low ^= e2.low;
      }
      shiftRight(e2) {
        e2 >= 32 ? (this.low = this.high >>> e2 - 32 | 0, this.high = 0) : (this.low = this.low >>> e2 | this.high << 32 - e2, this.high = this.high >>> e2 | 0);
      }
      rotateRight(e2) {
        let t2, i2;
        32 & e2 ? (i2 = this.low, t2 = this.high) : (t2 = this.low, i2 = this.high), e2 &= 31, this.low = t2 >>> e2 | i2 << 32 - e2, this.high = i2 >>> e2 | t2 << 32 - e2;
      }
      not() {
        this.high = ~this.high, this.low = ~this.low;
      }
      add(e2) {
        const t2 = (this.low >>> 0) + (e2.low >>> 0);
        let i2 = (this.high >>> 0) + (e2.high >>> 0);
        t2 > 4294967295 && (i2 += 1), this.low = 0 | t2, this.high = 0 | i2;
      }
      copyTo(e2, t2) {
        e2[t2] = this.high >>> 24 & 255, e2[t2 + 1] = this.high >> 16 & 255, e2[t2 + 2] = this.high >> 8 & 255, e2[t2 + 3] = 255 & this.high, e2[t2 + 4] = this.low >>> 24 & 255, e2[t2 + 5] = this.low >> 16 & 255, e2[t2 + 6] = this.low >> 8 & 255, e2[t2 + 7] = 255 & this.low;
      }
      assign(e2) {
        this.high = e2.high, this.low = e2.low;
      }
    };
    __name(Word64, "Word64");
    ol = { get k() {
      return shadow$1(this, "k", [new Word64(1116352408, 3609767458), new Word64(1899447441, 602891725), new Word64(3049323471, 3964484399), new Word64(3921009573, 2173295548), new Word64(961987163, 4081628472), new Word64(1508970993, 3053834265), new Word64(2453635748, 2937671579), new Word64(2870763221, 3664609560), new Word64(3624381080, 2734883394), new Word64(310598401, 1164996542), new Word64(607225278, 1323610764), new Word64(1426881987, 3590304994), new Word64(1925078388, 4068182383), new Word64(2162078206, 991336113), new Word64(2614888103, 633803317), new Word64(3248222580, 3479774868), new Word64(3835390401, 2666613458), new Word64(4022224774, 944711139), new Word64(264347078, 2341262773), new Word64(604807628, 2007800933), new Word64(770255983, 1495990901), new Word64(1249150122, 1856431235), new Word64(1555081692, 3175218132), new Word64(1996064986, 2198950837), new Word64(2554220882, 3999719339), new Word64(2821834349, 766784016), new Word64(2952996808, 2566594879), new Word64(3210313671, 3203337956), new Word64(3336571891, 1034457026), new Word64(3584528711, 2466948901), new Word64(113926993, 3758326383), new Word64(338241895, 168717936), new Word64(666307205, 1188179964), new Word64(773529912, 1546045734), new Word64(1294757372, 1522805485), new Word64(1396182291, 2643833823), new Word64(1695183700, 2343527390), new Word64(1986661051, 1014477480), new Word64(2177026350, 1206759142), new Word64(2456956037, 344077627), new Word64(2730485921, 1290863460), new Word64(2820302411, 3158454273), new Word64(3259730800, 3505952657), new Word64(3345764771, 106217008), new Word64(3516065817, 3606008344), new Word64(3600352804, 1432725776), new Word64(4094571909, 1467031594), new Word64(275423344, 851169720), new Word64(430227734, 3100823752), new Word64(506948616, 1363258195), new Word64(659060556, 3750685593), new Word64(883997877, 3785050280), new Word64(958139571, 3318307427), new Word64(1322822218, 3812723403), new Word64(1537002063, 2003034995), new Word64(1747873779, 3602036899), new Word64(1955562222, 1575990012), new Word64(2024104815, 1125592928), new Word64(2227730452, 2716904306), new Word64(2361852424, 442776044), new Word64(2428436474, 593698344), new Word64(2756734187, 3733110249), new Word64(3204031479, 2999351573), new Word64(3329325298, 3815920427), new Word64(3391569614, 3928383900), new Word64(3515267271, 566280711), new Word64(3940187606, 3454069534), new Word64(4118630271, 4000239992), new Word64(116418474, 1914138554), new Word64(174292421, 2731055270), new Word64(289380356, 3203993006), new Word64(460393269, 320620315), new Word64(685471733, 587496836), new Word64(852142971, 1086792851), new Word64(1017036298, 365543100), new Word64(1126000580, 2618297676), new Word64(1288033470, 3409855158), new Word64(1501505948, 4234509866), new Word64(1607167915, 987167468), new Word64(1816402316, 1246189591)]);
    } };
    __name(ch, "ch");
    __name(maj, "maj");
    __name(sigma, "sigma");
    __name(sigmaPrime, "sigmaPrime");
    __name(littleSigma, "littleSigma");
    __name(littleSigmaPrime, "littleSigmaPrime");
    __name(calculateSHA512, "calculateSHA512");
    __name(calculateSHA384, "calculateSHA384");
    ll = { get k() {
      return shadow$1(this, "k", [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);
    } };
    __name(rotr, "rotr");
    __name(calculate_sha256_ch, "calculate_sha256_ch");
    __name(calculate_sha256_maj, "calculate_sha256_maj");
    __name(calculate_sha256_sigma, "calculate_sha256_sigma");
    __name(calculate_sha256_sigmaPrime, "calculate_sha256_sigmaPrime");
    __name(calculate_sha256_littleSigma, "calculate_sha256_littleSigma");
    __name(calculate_sha256_littleSigmaPrime, "calculate_sha256_littleSigmaPrime");
    __name(calculateSHA256, "calculateSHA256");
    DecryptStream = class extends DecodeStream {
      constructor(e2, t2, i2) {
        super(t2), this.str = e2, this.dict = e2.dict, this.decrypt = i2, this.nextChunk = null, this.initialized = false;
      }
      readBlock() {
        let e2;
        if (this.initialized ? e2 = this.nextChunk : (e2 = this.str.getBytes(512), this.initialized = true), !e2?.length)
          return void (this.eof = true);
        this.nextChunk = this.str.getBytes(512);
        const t2 = this.nextChunk?.length > 0;
        e2 = (0, this.decrypt)(e2, !t2);
        const i2 = this.bufferLength, a2 = i2 + e2.length;
        this.ensureBuffer(a2).set(e2, i2), this.bufferLength = a2;
      }
    };
    __name(DecryptStream, "DecryptStream");
    ARCFourCipher = class {
      constructor(e2) {
        this.a = 0, this.b = 0;
        const t2 = new Uint8Array(256), i2 = e2.length;
        for (let e3 = 0; e3 < 256; ++e3)
          t2[e3] = e3;
        for (let a2 = 0, n2 = 0; a2 < 256; ++a2) {
          const s2 = t2[a2];
          n2 = n2 + s2 + e2[a2 % i2] & 255, t2[a2] = t2[n2], t2[n2] = s2;
        }
        this.s = t2;
      }
      encryptBlock(e2) {
        let t2 = this.a, i2 = this.b;
        const a2 = this.s, n2 = e2.length, s2 = new Uint8Array(n2);
        for (let r2 = 0; r2 < n2; ++r2) {
          t2 = t2 + 1 & 255;
          const n3 = a2[t2];
          i2 = i2 + n3 & 255;
          const o2 = a2[i2];
          a2[t2] = o2, a2[i2] = n3, s2[r2] = e2[r2] ^ a2[n3 + o2 & 255];
        }
        return this.a = t2, this.b = i2, s2;
      }
      decryptBlock(e2) {
        return this.encryptBlock(e2);
      }
      encrypt(e2) {
        return this.encryptBlock(e2);
      }
    };
    __name(ARCFourCipher, "ARCFourCipher");
    NullCipher = class {
      decryptBlock(e2) {
        return e2;
      }
      encrypt(e2) {
        return e2;
      }
    };
    __name(NullCipher, "NullCipher");
    AESBaseCipher = class {
      _s = new Uint8Array([99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22]);
      _inv_s = new Uint8Array([82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125]);
      _mix = new Uint32Array([0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795]);
      _mixCol = new Uint8Array(256).map((e2, t2) => t2 < 128 ? t2 << 1 : t2 << 1 ^ 27);
      constructor() {
        this.buffer = new Uint8Array(16), this.bufferPosition = 0;
      }
      _expandKey(e2) {
        unreachable$1("Cannot call `_expandKey` on the base class");
      }
      _decrypt(e2, t2) {
        let i2, a2, n2;
        const s2 = new Uint8Array(16);
        s2.set(e2);
        for (let e3 = 0, i3 = this._keySize; e3 < 16; ++e3, ++i3)
          s2[e3] ^= t2[i3];
        for (let e3 = this._cyclesOfRepetition - 1; e3 >= 1; --e3) {
          i2 = s2[13], s2[13] = s2[9], s2[9] = s2[5], s2[5] = s2[1], s2[1] = i2, i2 = s2[14], a2 = s2[10], s2[14] = s2[6], s2[10] = s2[2], s2[6] = i2, s2[2] = a2, i2 = s2[15], a2 = s2[11], n2 = s2[7], s2[15] = s2[3], s2[11] = i2, s2[7] = a2, s2[3] = n2;
          for (let e4 = 0; e4 < 16; ++e4)
            s2[e4] = this._inv_s[s2[e4]];
          for (let i3 = 0, a3 = 16 * e3; i3 < 16; ++i3, ++a3)
            s2[i3] ^= t2[a3];
          for (let e4 = 0; e4 < 16; e4 += 4) {
            const t3 = this._mix[s2[e4]], a3 = this._mix[s2[e4 + 1]], n3 = this._mix[s2[e4 + 2]], r2 = this._mix[s2[e4 + 3]];
            i2 = t3 ^ a3 >>> 8 ^ a3 << 24 ^ n3 >>> 16 ^ n3 << 16 ^ r2 >>> 24 ^ r2 << 8, s2[e4] = i2 >>> 24 & 255, s2[e4 + 1] = i2 >> 16 & 255, s2[e4 + 2] = i2 >> 8 & 255, s2[e4 + 3] = 255 & i2;
          }
        }
        i2 = s2[13], s2[13] = s2[9], s2[9] = s2[5], s2[5] = s2[1], s2[1] = i2, i2 = s2[14], a2 = s2[10], s2[14] = s2[6], s2[10] = s2[2], s2[6] = i2, s2[2] = a2, i2 = s2[15], a2 = s2[11], n2 = s2[7], s2[15] = s2[3], s2[11] = i2, s2[7] = a2, s2[3] = n2;
        for (let e3 = 0; e3 < 16; ++e3)
          s2[e3] = this._inv_s[s2[e3]], s2[e3] ^= t2[e3];
        return s2;
      }
      _encrypt(e2, t2) {
        const i2 = this._s;
        let a2, n2, s2;
        const r2 = new Uint8Array(16);
        r2.set(e2);
        for (let e3 = 0; e3 < 16; ++e3)
          r2[e3] ^= t2[e3];
        for (let e3 = 1; e3 < this._cyclesOfRepetition; e3++) {
          for (let e4 = 0; e4 < 16; ++e4)
            r2[e4] = i2[r2[e4]];
          s2 = r2[1], r2[1] = r2[5], r2[5] = r2[9], r2[9] = r2[13], r2[13] = s2, s2 = r2[2], n2 = r2[6], r2[2] = r2[10], r2[6] = r2[14], r2[10] = s2, r2[14] = n2, s2 = r2[3], n2 = r2[7], a2 = r2[11], r2[3] = r2[15], r2[7] = s2, r2[11] = n2, r2[15] = a2;
          for (let e4 = 0; e4 < 16; e4 += 4) {
            const t3 = r2[e4], i3 = r2[e4 + 1], n3 = r2[e4 + 2], s3 = r2[e4 + 3];
            a2 = t3 ^ i3 ^ n3 ^ s3, r2[e4] ^= a2 ^ this._mixCol[t3 ^ i3], r2[e4 + 1] ^= a2 ^ this._mixCol[i3 ^ n3], r2[e4 + 2] ^= a2 ^ this._mixCol[n3 ^ s3], r2[e4 + 3] ^= a2 ^ this._mixCol[s3 ^ t3];
          }
          for (let i3 = 0, a3 = 16 * e3; i3 < 16; ++i3, ++a3)
            r2[i3] ^= t2[a3];
        }
        for (let e3 = 0; e3 < 16; ++e3)
          r2[e3] = i2[r2[e3]];
        s2 = r2[1], r2[1] = r2[5], r2[5] = r2[9], r2[9] = r2[13], r2[13] = s2, s2 = r2[2], n2 = r2[6], r2[2] = r2[10], r2[6] = r2[14], r2[10] = s2, r2[14] = n2, s2 = r2[3], n2 = r2[7], a2 = r2[11], r2[3] = r2[15], r2[7] = s2, r2[11] = n2, r2[15] = a2;
        for (let e3 = 0, i3 = this._keySize; e3 < 16; ++e3, ++i3)
          r2[e3] ^= t2[i3];
        return r2;
      }
      _decryptBlock2(e2, t2) {
        const i2 = e2.length;
        let a2 = this.buffer, n2 = this.bufferPosition;
        const s2 = [];
        let r2 = this.iv;
        for (let t3 = 0; t3 < i2; ++t3) {
          if (a2[n2] = e2[t3], ++n2, n2 < 16)
            continue;
          const i3 = this._decrypt(a2, this._key);
          for (let e3 = 0; e3 < 16; ++e3)
            i3[e3] ^= r2[e3];
          r2 = a2, s2.push(i3), a2 = new Uint8Array(16), n2 = 0;
        }
        if (this.buffer = a2, this.bufferLength = n2, this.iv = r2, 0 === s2.length)
          return new Uint8Array(0);
        let o2 = 16 * s2.length;
        if (t2) {
          const e3 = s2.at(-1);
          let t3 = e3[15];
          if (t3 <= 16) {
            for (let i3 = 15, a3 = 16 - t3; i3 >= a3; --i3)
              if (e3[i3] !== t3) {
                t3 = 0;
                break;
              }
            o2 -= t3, s2[s2.length - 1] = e3.subarray(0, 16 - t3);
          }
        }
        const l3 = new Uint8Array(o2);
        for (let e3 = 0, t3 = 0, i3 = s2.length; e3 < i3; ++e3, t3 += 16)
          l3.set(s2[e3], t3);
        return l3;
      }
      decryptBlock(e2, t2, i2 = null) {
        const a2 = e2.length, n2 = this.buffer;
        let s2 = this.bufferPosition;
        if (i2)
          this.iv = i2;
        else {
          for (let t3 = 0; s2 < 16 && t3 < a2; ++t3, ++s2)
            n2[s2] = e2[t3];
          if (s2 < 16)
            return this.bufferLength = s2, new Uint8Array(0);
          this.iv = n2, e2 = e2.subarray(16);
        }
        return this.buffer = new Uint8Array(16), this.bufferLength = 0, this.decryptBlock = this._decryptBlock2, this.decryptBlock(e2, t2);
      }
      encrypt(e2, t2) {
        const i2 = e2.length;
        let a2 = this.buffer, n2 = this.bufferPosition;
        const s2 = [];
        t2 ||= new Uint8Array(16);
        for (let r3 = 0; r3 < i2; ++r3) {
          if (a2[n2] = e2[r3], ++n2, n2 < 16)
            continue;
          for (let e3 = 0; e3 < 16; ++e3)
            a2[e3] ^= t2[e3];
          const i3 = this._encrypt(a2, this._key);
          t2 = i3, s2.push(i3), a2 = new Uint8Array(16), n2 = 0;
        }
        if (this.buffer = a2, this.bufferLength = n2, this.iv = t2, 0 === s2.length)
          return new Uint8Array(0);
        const r2 = 16 * s2.length, o2 = new Uint8Array(r2);
        for (let e3 = 0, t3 = 0, i3 = s2.length; e3 < i3; ++e3, t3 += 16)
          o2.set(s2[e3], t3);
        return o2;
      }
    };
    __name(AESBaseCipher, "AESBaseCipher");
    AES128Cipher = class extends AESBaseCipher {
      _rcon = new Uint8Array([141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141]);
      constructor(e2) {
        super(), this._cyclesOfRepetition = 10, this._keySize = 160, this._key = this._expandKey(e2);
      }
      _expandKey(e2) {
        const t2 = this._s, i2 = this._rcon, a2 = new Uint8Array(176);
        a2.set(e2);
        for (let e3 = 16, n2 = 1; e3 < 176; ++n2) {
          let s2 = a2[e3 - 3], r2 = a2[e3 - 2], o2 = a2[e3 - 1], l3 = a2[e3 - 4];
          s2 = t2[s2], r2 = t2[r2], o2 = t2[o2], l3 = t2[l3], s2 ^= i2[n2];
          for (let t3 = 0; t3 < 4; ++t3)
            a2[e3] = s2 ^= a2[e3 - 16], e3++, a2[e3] = r2 ^= a2[e3 - 16], e3++, a2[e3] = o2 ^= a2[e3 - 16], e3++, a2[e3] = l3 ^= a2[e3 - 16], e3++;
        }
        return a2;
      }
    };
    __name(AES128Cipher, "AES128Cipher");
    AES256Cipher = class extends AESBaseCipher {
      constructor(e2) {
        super(), this._cyclesOfRepetition = 14, this._keySize = 224, this._key = this._expandKey(e2);
      }
      _expandKey(e2) {
        const t2 = this._s, i2 = new Uint8Array(240);
        i2.set(e2);
        let a2, n2, s2, r2, o2 = 1;
        for (let e3 = 32, l3 = 1; e3 < 240; ++l3) {
          e3 % 32 == 16 ? (a2 = t2[a2], n2 = t2[n2], s2 = t2[s2], r2 = t2[r2]) : e3 % 32 == 0 && (a2 = i2[e3 - 3], n2 = i2[e3 - 2], s2 = i2[e3 - 1], r2 = i2[e3 - 4], a2 = t2[a2], n2 = t2[n2], s2 = t2[s2], r2 = t2[r2], a2 ^= o2, (o2 <<= 1) >= 256 && (o2 = 255 & (27 ^ o2)));
          for (let t3 = 0; t3 < 4; ++t3)
            i2[e3] = a2 ^= i2[e3 - 32], e3++, i2[e3] = n2 ^= i2[e3 - 32], e3++, i2[e3] = s2 ^= i2[e3 - 32], e3++, i2[e3] = r2 ^= i2[e3 - 32], e3++;
        }
        return i2;
      }
    };
    __name(AES256Cipher, "AES256Cipher");
    PDFBase = class {
      _hash(e2, t2, i2) {
        unreachable$1("Abstract method `_hash` called");
      }
      checkOwnerPassword(e2, t2, i2, a2) {
        const n2 = new Uint8Array(e2.length + 56);
        n2.set(e2, 0), n2.set(t2, e2.length), n2.set(i2, e2.length + t2.length);
        return isArrayEqual(this._hash(e2, n2, i2), a2);
      }
      checkUserPassword(e2, t2, i2) {
        const a2 = new Uint8Array(e2.length + 8);
        a2.set(e2, 0), a2.set(t2, e2.length);
        return isArrayEqual(this._hash(e2, a2, []), i2);
      }
      getOwnerKey(e2, t2, i2, a2) {
        const n2 = new Uint8Array(e2.length + 56);
        n2.set(e2, 0), n2.set(t2, e2.length), n2.set(i2, e2.length + t2.length);
        const s2 = this._hash(e2, n2, i2);
        return new AES256Cipher(s2).decryptBlock(a2, false, new Uint8Array(16));
      }
      getUserKey(e2, t2, i2) {
        const a2 = new Uint8Array(e2.length + 8);
        a2.set(e2, 0), a2.set(t2, e2.length);
        const n2 = this._hash(e2, a2, []);
        return new AES256Cipher(n2).decryptBlock(i2, false, new Uint8Array(16));
      }
    };
    __name(PDFBase, "PDFBase");
    PDF17 = class extends PDFBase {
      _hash(e2, t2, i2) {
        return calculateSHA256(t2, 0, t2.length);
      }
    };
    __name(PDF17, "PDF17");
    PDF20 = class extends PDFBase {
      _hash(e2, t2, i2) {
        let a2 = calculateSHA256(t2, 0, t2.length).subarray(0, 32), n2 = [0], s2 = 0;
        for (; s2 < 64 || n2.at(-1) > s2 - 32; ) {
          const t3 = e2.length + a2.length + i2.length, r2 = new Uint8Array(t3);
          let o2 = 0;
          r2.set(e2, o2), o2 += e2.length, r2.set(a2, o2), o2 += a2.length, r2.set(i2, o2);
          const l3 = new Uint8Array(64 * t3);
          for (let e3 = 0, i3 = 0; e3 < 64; e3++, i3 += t3)
            l3.set(r2, i3);
          n2 = new AES128Cipher(a2.subarray(0, 16)).encrypt(l3, a2.subarray(16, 32));
          const c2 = Math.sumPrecise(n2.slice(0, 16)) % 3;
          0 === c2 ? a2 = calculateSHA256(n2, 0, n2.length) : 1 === c2 ? a2 = calculateSHA384(n2, 0, n2.length) : 2 === c2 && (a2 = calculateSHA512(n2, 0, n2.length)), s2++;
        }
        return a2.subarray(0, 32);
      }
    };
    __name(PDF20, "PDF20");
    CipherTransform = class {
      constructor(e2, t2) {
        this.StringCipherConstructor = e2, this.StreamCipherConstructor = t2;
      }
      createStream(e2, t2) {
        const i2 = new this.StreamCipherConstructor();
        return new DecryptStream(e2, t2, function(e3, t3) {
          return i2.decryptBlock(e3, t3);
        });
      }
      decryptString(e2) {
        const t2 = new this.StringCipherConstructor();
        let i2 = stringToBytes$1(e2);
        return i2 = t2.decryptBlock(i2, true), bytesToString$1(i2);
      }
      encryptString(e2) {
        const t2 = new this.StringCipherConstructor();
        if (t2 instanceof AESBaseCipher) {
          const i3 = 16 - e2.length % 16;
          e2 += String.fromCharCode(i3).repeat(i3);
          const a2 = new Uint8Array(16);
          crypto.getRandomValues(a2);
          let n2 = stringToBytes$1(e2);
          n2 = t2.encrypt(n2, a2);
          const s2 = new Uint8Array(16 + n2.length);
          return s2.set(a2), s2.set(n2, 16), bytesToString$1(s2);
        }
        let i2 = stringToBytes$1(e2);
        return i2 = t2.encrypt(i2), bytesToString$1(i2);
      }
    };
    __name(CipherTransform, "CipherTransform");
    CipherTransformFactory = class {
      static get _defaultPasswordBytes() {
        return shadow$1(this, "_defaultPasswordBytes", new Uint8Array([40, 191, 78, 94, 78, 117, 138, 65, 100, 0, 78, 86, 255, 250, 1, 8, 46, 46, 0, 182, 208, 104, 62, 128, 47, 12, 169, 254, 100, 83, 105, 122]));
      }
      #Me(e2, t2, i2, a2, n2, s2, r2, o2, l3, c2, h2, d2) {
        if (t2) {
          const e3 = Math.min(127, t2.length);
          t2 = t2.subarray(0, e3);
        } else
          t2 = [];
        const u2 = 6 === e2 ? new PDF20() : new PDF17();
        return u2.checkUserPassword(t2, o2, r2) ? u2.getUserKey(t2, l3, h2) : t2.length && u2.checkOwnerPassword(t2, a2, s2, i2) ? u2.getOwnerKey(t2, n2, s2, c2) : null;
      }
      #De(e2, t2, i2, a2, n2, s2, r2, o2) {
        const l3 = 40 + i2.length + e2.length, c2 = new Uint8Array(l3);
        let h2, d2, u2 = 0;
        if (t2)
          for (d2 = Math.min(32, t2.length); u2 < d2; ++u2)
            c2[u2] = t2[u2];
        for (h2 = 0; u2 < 32; )
          c2[u2++] = CipherTransformFactory._defaultPasswordBytes[h2++];
        c2.set(i2, u2), u2 += i2.length, c2[u2++] = 255 & n2, c2[u2++] = n2 >> 8 & 255, c2[u2++] = n2 >> 16 & 255, c2[u2++] = n2 >>> 24 & 255, c2.set(e2, u2), u2 += e2.length, s2 >= 4 && !o2 && (c2.fill(255, u2, u2 + 4), u2 += 4);
        let g2 = calculateMD5(c2, 0, u2);
        const p2 = r2 >> 3;
        if (s2 >= 3)
          for (h2 = 0; h2 < 50; ++h2)
            g2 = calculateMD5(g2, 0, p2);
        const f2 = g2.subarray(0, p2);
        let m2, b2;
        if (s2 >= 3) {
          u2 = 0, c2.set(CipherTransformFactory._defaultPasswordBytes, u2), u2 += 32, c2.set(e2, u2), u2 += e2.length, m2 = new ARCFourCipher(f2), b2 = m2.encryptBlock(calculateMD5(c2, 0, u2)), d2 = f2.length;
          const t3 = new Uint8Array(d2);
          for (h2 = 1; h2 <= 19; ++h2) {
            for (let e3 = 0; e3 < d2; ++e3)
              t3[e3] = f2[e3] ^ h2;
            m2 = new ARCFourCipher(t3), b2 = m2.encryptBlock(b2);
          }
        } else
          m2 = new ARCFourCipher(f2), b2 = m2.encryptBlock(CipherTransformFactory._defaultPasswordBytes);
        return b2.every((e3, t3) => a2[t3] === e3) ? f2 : null;
      }
      #Ee(e2, t2, i2, a2) {
        const n2 = new Uint8Array(32);
        let s2 = 0;
        const r2 = Math.min(32, e2.length);
        for (; s2 < r2; ++s2)
          n2[s2] = e2[s2];
        let o2 = 0;
        for (; s2 < 32; )
          n2[s2++] = CipherTransformFactory._defaultPasswordBytes[o2++];
        let l3 = calculateMD5(n2, 0, s2);
        const c2 = a2 >> 3;
        if (i2 >= 3)
          for (o2 = 0; o2 < 50; ++o2)
            l3 = calculateMD5(l3, 0, l3.length);
        let h2, d2;
        if (i2 >= 3) {
          d2 = t2;
          const e3 = new Uint8Array(c2);
          for (o2 = 19; o2 >= 0; o2--) {
            for (let t3 = 0; t3 < c2; ++t3)
              e3[t3] = l3[t3] ^ o2;
            h2 = new ARCFourCipher(e3), d2 = h2.encryptBlock(d2);
          }
        } else
          h2 = new ARCFourCipher(l3.subarray(0, c2)), d2 = h2.encryptBlock(t2);
        return d2;
      }
      #Oe(e2, t2, i2, a2 = false) {
        const n2 = i2.length, s2 = new Uint8Array(n2 + 9);
        s2.set(i2);
        let r2 = n2;
        s2[r2++] = 255 & e2, s2[r2++] = e2 >> 8 & 255, s2[r2++] = e2 >> 16 & 255, s2[r2++] = 255 & t2, s2[r2++] = t2 >> 8 & 255, a2 && (s2[r2++] = 115, s2[r2++] = 65, s2[r2++] = 108, s2[r2++] = 84);
        return calculateMD5(s2, 0, r2).subarray(0, Math.min(n2 + 5, 16));
      }
      #_e(e2, t2, i2, a2, n2) {
        if (!(t2 instanceof Name))
          throw new ti("Invalid crypt filter name.");
        const s2 = this, r2 = e2.get(t2.name), o2 = r2?.get("CFM");
        if (!o2 || "None" === o2.name)
          return function() {
            return new NullCipher();
          };
        if ("V2" === o2.name)
          return function() {
            return new ARCFourCipher(s2.#Oe(i2, a2, n2, false));
          };
        if ("AESV2" === o2.name)
          return function() {
            return new AES128Cipher(s2.#Oe(i2, a2, n2, true));
          };
        if ("AESV3" === o2.name)
          return function() {
            return new AES256Cipher(n2);
          };
        throw new ti("Unknown crypto method");
      }
      constructor(e2, t2, i2) {
        const a2 = e2.get("Filter");
        if (!isName(a2, "Standard"))
          throw new ti("unknown encryption method");
        this.filterName = a2.name, this.dict = e2;
        const n2 = e2.get("V");
        if (!Number.isInteger(n2) || 1 !== n2 && 2 !== n2 && 4 !== n2 && 5 !== n2)
          throw new ti("unsupported encryption algorithm");
        this.algorithm = n2;
        let s2 = e2.get("Length");
        if (!s2)
          if (n2 <= 3)
            s2 = 40;
          else {
            const t3 = e2.get("CF"), i3 = e2.get("StmF");
            if (t3 instanceof Dict && i3 instanceof Name) {
              t3.suppressEncryption = true;
              const e3 = t3.get(i3.name);
              s2 = e3?.get("Length") || 128, s2 < 40 && (s2 <<= 3);
            }
          }
        if (!Number.isInteger(s2) || s2 < 40 || s2 % 8 != 0)
          throw new ti("invalid key length");
        const r2 = stringToBytes$1(e2.get("O")), o2 = stringToBytes$1(e2.get("U")), l3 = r2.subarray(0, 32), c2 = o2.subarray(0, 32), h2 = e2.get("P"), d2 = e2.get("R"), u2 = (4 === n2 || 5 === n2) && false !== e2.get("EncryptMetadata");
        this.encryptMetadata = u2;
        const g2 = stringToBytes$1(t2);
        let p2, f2;
        if (i2) {
          if (6 === d2)
            try {
              i2 = utf8StringToString(i2);
            } catch {
              warn$1("CipherTransformFactory: Unable to convert UTF8 encoded password.");
            }
          p2 = stringToBytes$1(i2);
        }
        if (5 !== n2)
          f2 = this.#De(g2, p2, l3, c2, h2, d2, s2, u2);
        else {
          const t3 = r2.subarray(32, 40), i3 = r2.subarray(40, 48), a3 = o2.subarray(0, 48), n3 = o2.subarray(32, 40), s3 = o2.subarray(40, 48), h3 = stringToBytes$1(e2.get("OE")), u3 = stringToBytes$1(e2.get("UE")), g3 = stringToBytes$1(e2.get("Perms"));
          f2 = this.#Me(d2, p2, l3, t3, i3, a3, c2, n3, s3, h3, u3, g3);
        }
        if (!f2) {
          if (!i2)
            throw new Jt("No password given", Gt);
          const e3 = this.#Ee(p2, l3, d2, s2);
          f2 = this.#De(g2, e3, l3, c2, h2, d2, s2, u2);
        }
        if (!f2)
          throw new Jt("Incorrect Password", Vt);
        if (4 === n2 && f2.length < 16 ? (this.encryptionKey = new Uint8Array(16), this.encryptionKey.set(f2)) : this.encryptionKey = f2, n2 >= 4) {
          const t3 = e2.get("CF");
          t3 instanceof Dict && (t3.suppressEncryption = true), this.cf = t3, this.stmf = e2.get("StmF") || Name.get("Identity"), this.strf = e2.get("StrF") || Name.get("Identity"), this.eff = e2.get("EFF") || this.stmf;
        }
      }
      createCipherTransform(e2, t2) {
        if (4 === this.algorithm || 5 === this.algorithm)
          return new CipherTransform(this.#_e(this.cf, this.strf, e2, t2, this.encryptionKey), this.#_e(this.cf, this.stmf, e2, t2, this.encryptionKey));
        const i2 = this.#Oe(e2, t2, this.encryptionKey, false), cipherConstructor = /* @__PURE__ */ __name(function() {
          return new ARCFourCipher(i2);
        }, "cipherConstructor");
        return new CipherTransform(cipherConstructor, cipherConstructor);
      }
    };
    __name(CipherTransformFactory, "CipherTransformFactory");
    XRef = class {
      #Pe = null;
      constructor(e2, t2) {
        this.stream = e2, this.pdfManager = t2, this.entries = [], this._xrefStms = /* @__PURE__ */ new Set(), this._cacheMap = /* @__PURE__ */ new Map(), this._pendingRefs = new RefSet(), this._newPersistentRefNum = null, this._newTemporaryRefNum = null, this._persistentRefsCache = null;
      }
      getNewPersistentRef(e2) {
        null === this._newPersistentRefNum && (this._newPersistentRefNum = this.entries.length || 1);
        const t2 = this._newPersistentRefNum++;
        return this._cacheMap.set(t2, e2), Ref.get(t2, 0);
      }
      getNewTemporaryRef() {
        if (null === this._newTemporaryRefNum && (this._newTemporaryRefNum = this.entries.length || 1, this._newPersistentRefNum)) {
          this._persistentRefsCache = /* @__PURE__ */ new Map();
          for (let e2 = this._newTemporaryRefNum; e2 < this._newPersistentRefNum; e2++)
            this._persistentRefsCache.set(e2, this._cacheMap.get(e2)), this._cacheMap.delete(e2);
        }
        return Ref.get(this._newTemporaryRefNum++, 0);
      }
      resetNewTemporaryRef() {
        if (this._newTemporaryRefNum = null, this._persistentRefsCache)
          for (const [e2, t2] of this._persistentRefsCache)
            this._cacheMap.set(e2, t2);
        this._persistentRefsCache = null;
      }
      setStartXRef(e2) {
        this.startXRefQueue = [e2];
      }
      parse(e2 = false) {
        let t2, i2, a2;
        e2 ? (warn$1("Indexing all PDF objects"), t2 = this.indexObjects()) : t2 = this.readXRef(), t2.assignXref(this), this.trailer = t2;
        try {
          i2 = t2.get("Encrypt");
        } catch (e3) {
          if (e3 instanceof MissingDataException)
            throw e3;
          warn$1(`XRef.parse - Invalid "Encrypt" reference: "${e3}".`);
        }
        if (i2 instanceof Dict) {
          const e3 = t2.get("ID"), a3 = e3?.length ? e3[0] : "";
          i2.suppressEncryption = true, this.encrypt = new CipherTransformFactory(i2, a3, this.pdfManager.password);
        }
        try {
          a2 = t2.get("Root");
        } catch (e3) {
          if (e3 instanceof MissingDataException)
            throw e3;
          warn$1(`XRef.parse - Invalid "Root" reference: "${e3}".`);
        }
        if (a2 instanceof Dict)
          try {
            if (a2.get("Pages") instanceof Dict)
              return void (this.root = a2);
          } catch (e3) {
            if (e3 instanceof MissingDataException)
              throw e3;
            warn$1(`XRef.parse - Invalid "Pages" reference: "${e3}".`);
          }
        if (!e2)
          throw new XRefParseException();
        throw new Qt("Invalid Root reference.");
      }
      processXRefTable(e2) {
        "tableState" in this || (this.tableState = { entryNum: 0, streamPos: e2.lexer.stream.pos, parserBuf1: e2.buf1, parserBuf2: e2.buf2 });
        if (!isCmd(this.readXRefTable(e2), "trailer"))
          throw new ti("Invalid XRef table: could not find trailer dictionary");
        let t2 = e2.getObj();
        if (t2 instanceof Dict || !t2.dict || (t2 = t2.dict), !(t2 instanceof Dict))
          throw new ti("Invalid XRef table: could not parse trailer dictionary");
        return delete this.tableState, t2;
      }
      readXRefTable(e2) {
        const t2 = e2.lexer.stream, i2 = this.tableState;
        let a2;
        for (t2.pos = i2.streamPos, e2.buf1 = i2.parserBuf1, e2.buf2 = i2.parserBuf2; ; ) {
          if (!("firstEntryNum" in i2) || !("entryCount" in i2)) {
            if (isCmd(a2 = e2.getObj(), "trailer"))
              break;
            i2.firstEntryNum = a2, i2.entryCount = e2.getObj();
          }
          let n2 = i2.firstEntryNum;
          const s2 = i2.entryCount;
          if (!Number.isInteger(n2) || !Number.isInteger(s2))
            throw new ti("Invalid XRef table: wrong types in subsection header");
          for (let a3 = i2.entryNum; a3 < s2; a3++) {
            i2.streamPos = t2.pos, i2.entryNum = a3, i2.parserBuf1 = e2.buf1, i2.parserBuf2 = e2.buf2;
            const r2 = {};
            r2.offset = e2.getObj(), r2.gen = e2.getObj();
            const o2 = e2.getObj();
            if (o2 instanceof Cmd)
              switch (o2.cmd) {
                case "f":
                  r2.free = true;
                  break;
                case "n":
                  r2.uncompressed = true;
              }
            if (!Number.isInteger(r2.offset) || !Number.isInteger(r2.gen) || !r2.free && !r2.uncompressed)
              throw new ti(`Invalid entry in XRef subsection: ${n2}, ${s2}`);
            0 === a3 && r2.free && 1 === n2 && (n2 = 0), this.entries[a3 + n2] || (this.entries[a3 + n2] = r2);
          }
          i2.entryNum = 0, i2.streamPos = t2.pos, i2.parserBuf1 = e2.buf1, i2.parserBuf2 = e2.buf2, delete i2.firstEntryNum, delete i2.entryCount;
        }
        if (this.entries[0] && !this.entries[0].free)
          throw new ti("Invalid XRef table: unexpected first object");
        return a2;
      }
      processXRefStream(e2) {
        if (!("streamState" in this)) {
          const { dict: t2, pos: i2 } = e2, a2 = t2.get("W"), n2 = t2.get("Index") || [0, t2.get("Size")];
          this.streamState = { entryRanges: n2, byteWidths: a2, entryNum: 0, streamPos: i2 };
        }
        return this.readXRefStream(e2), delete this.streamState, e2.dict;
      }
      readXRefStream(e2) {
        const t2 = this.streamState;
        e2.pos = t2.streamPos;
        const [i2, a2, n2] = t2.byteWidths, s2 = t2.entryRanges;
        for (; s2.length > 0; ) {
          const [r2, o2] = s2;
          if (!Number.isInteger(r2) || !Number.isInteger(o2))
            throw new ti(`Invalid XRef range fields: ${r2}, ${o2}`);
          if (!Number.isInteger(i2) || !Number.isInteger(a2) || !Number.isInteger(n2))
            throw new ti(`Invalid XRef entry fields length: ${r2}, ${o2}`);
          for (let s3 = t2.entryNum; s3 < o2; ++s3) {
            t2.entryNum = s3, t2.streamPos = e2.pos;
            let o3 = 0, l3 = 0, c2 = 0;
            for (let t3 = 0; t3 < i2; ++t3) {
              const t4 = e2.getByte();
              if (-1 === t4)
                throw new ti("Invalid XRef byteWidths 'type'.");
              o3 = o3 << 8 | t4;
            }
            0 === i2 && (o3 = 1);
            for (let t3 = 0; t3 < a2; ++t3) {
              const t4 = e2.getByte();
              if (-1 === t4)
                throw new ti("Invalid XRef byteWidths 'offset'.");
              l3 = l3 << 8 | t4;
            }
            for (let t3 = 0; t3 < n2; ++t3) {
              const t4 = e2.getByte();
              if (-1 === t4)
                throw new ti("Invalid XRef byteWidths 'generation'.");
              c2 = c2 << 8 | t4;
            }
            const h2 = {};
            switch (h2.offset = l3, h2.gen = c2, o3) {
              case 0:
                h2.free = true;
                break;
              case 1:
                h2.uncompressed = true;
                break;
              case 2:
                break;
              default:
                throw new ti(`Invalid XRef entry type: ${o3}`);
            }
            this.entries[r2 + s3] || (this.entries[r2 + s3] = h2);
          }
          t2.entryNum = 0, t2.streamPos = e2.pos, s2.splice(0, 2);
        }
      }
      indexObjects() {
        function readToken(e3, t3) {
          let i3 = "", a3 = e3[t3];
          for (; 10 !== a3 && 13 !== a3 && 60 !== a3 && !(++t3 >= e3.length); )
            i3 += String.fromCharCode(a3), a3 = e3[t3];
          return i3;
        }
        __name(readToken, "readToken");
        function skipUntil(e3, t3, i3) {
          const a3 = i3.length, n3 = e3.length;
          let s3 = 0;
          for (; t3 < n3; ) {
            let n4 = 0;
            for (; n4 < a3 && e3[t3 + n4] === i3[n4]; )
              ++n4;
            if (n4 >= a3)
              break;
            t3++, s3++;
          }
          return s3;
        }
        __name(skipUntil, "skipUntil");
        const e2 = /\b(endobj|\d+\s+\d+\s+obj|xref|trailer\s*<<)\b/g, t2 = /\b(startxref|\d+\s+\d+\s+obj)\b/g, i2 = /^(\d+)\s+(\d+)\s+obj\b/, a2 = new Uint8Array([116, 114, 97, 105, 108, 101, 114]), n2 = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]), s2 = new Uint8Array([47, 88, 82, 101, 102]);
        this.entries.length = 0, this._cacheMap.clear();
        const r2 = this.stream;
        r2.pos = 0;
        const o2 = r2.getBytes(), l3 = bytesToString$1(o2), c2 = o2.length;
        let h2 = r2.start;
        const d2 = [], u2 = [];
        for (; h2 < c2; ) {
          let g3 = o2[h2];
          if (9 === g3 || 10 === g3 || 13 === g3 || 32 === g3) {
            ++h2;
            continue;
          }
          if (37 === g3) {
            do {
              if (++h2, h2 >= c2)
                break;
              g3 = o2[h2];
            } while (10 !== g3 && 13 !== g3);
            continue;
          }
          const p3 = readToken(o2, h2);
          let f3;
          if (p3.startsWith("xref") && (4 === p3.length || /\s/.test(p3[4])))
            h2 += skipUntil(o2, h2, a2), d2.push(h2), h2 += skipUntil(o2, h2, n2);
          else if (f3 = i2.exec(p3)) {
            const t3 = 0 | f3[1], i3 = 0 | f3[2], a3 = h2 + p3.length;
            let n3, d3 = false;
            if (this.entries[t3]) {
              if (this.entries[t3].gen === i3)
                try {
                  new Parser({ lexer: new Lexer(r2.makeSubStream(a3)) }).getObj(), d3 = true;
                } catch (e3) {
                  e3 instanceof ParserEOFException ? warn$1(`indexObjects -- checking object (${p3}): "${e3}".`) : d3 = true;
                }
            } else
              d3 = true;
            d3 && (this.entries[t3] = { offset: h2 - r2.start, gen: i3, uncompressed: true }), e2.lastIndex = a3;
            const g4 = e2.exec(l3);
            if (g4) {
              n3 = e2.lastIndex + 1 - h2, "endobj" !== g4[1] && (warn$1(`indexObjects: Found "${g4[1]}" inside of another "obj", caused by missing "endobj" -- trying to recover.`), n3 -= g4[1].length + 1);
            } else
              n3 = c2 - h2;
            const m3 = o2.subarray(h2, h2 + n3), b2 = skipUntil(m3, 0, s2);
            b2 < n3 && m3[b2 + 5] < 64 && (u2.push(h2 - r2.start), this._xrefStms.add(h2 - r2.start)), h2 += n3;
          } else if (p3.startsWith("trailer") && (7 === p3.length || /\s/.test(p3[7]))) {
            d2.push(h2);
            const e3 = h2 + p3.length;
            let i3;
            t2.lastIndex = e3;
            const a3 = t2.exec(l3);
            if (a3) {
              i3 = t2.lastIndex + 1 - h2, "startxref" !== a3[1] && (warn$1(`indexObjects: Found "${a3[1]}" after "trailer", caused by missing "startxref" -- trying to recover.`), i3 -= a3[1].length + 1);
            } else
              i3 = c2 - h2;
            h2 += i3;
          } else
            h2 += p3.length + 1;
        }
        for (const e3 of u2)
          this.startXRefQueue.push(e3), this.readXRef(true);
        const g2 = [];
        let p2, f2, m2 = false;
        for (const e3 of d2) {
          r2.pos = e3;
          const t3 = new Parser({ lexer: new Lexer(r2), xref: this, allowStreams: true, recoveryMode: true });
          if (!isCmd(t3.getObj(), "trailer"))
            continue;
          const i3 = t3.getObj();
          i3 instanceof Dict && (g2.push(i3), i3.has("Encrypt") && (m2 = true));
        }
        for (const e3 of [...g2, "genFallback", ...g2]) {
          if ("genFallback" === e3) {
            if (!f2)
              break;
            this._generationFallback = true;
            continue;
          }
          let t3 = false;
          try {
            const i3 = e3.get("Root");
            if (!(i3 instanceof Dict))
              continue;
            const a3 = i3.get("Pages");
            if (!(a3 instanceof Dict))
              continue;
            const n3 = a3.get("Count");
            Number.isInteger(n3) && (t3 = true);
          } catch (e4) {
            f2 = e4;
            continue;
          }
          if (t3 && (!m2 || e3.has("Encrypt")) && e3.has("ID"))
            return e3;
          p2 = e3;
        }
        if (p2)
          return p2;
        if (this.topDict)
          return this.topDict;
        if (!g2.length)
          for (const e3 in this.entries) {
            if (!Object.hasOwn(this.entries, e3))
              continue;
            const t3 = this.entries[e3], i3 = Ref.get(parseInt(e3), t3.gen);
            let a3;
            try {
              a3 = this.fetch(i3);
            } catch {
              continue;
            }
            if (a3 instanceof BaseStream && (a3 = a3.dict), a3 instanceof Dict && a3.has("Root"))
              return a3;
          }
        throw new Qt("Invalid PDF structure.");
      }
      readXRef(e2 = false) {
        const t2 = this.stream, i2 = /* @__PURE__ */ new Set();
        for (; this.startXRefQueue.length; ) {
          try {
            const e3 = this.startXRefQueue[0];
            if (i2.has(e3)) {
              warn$1("readXRef - skipping XRef table since it was already parsed."), this.startXRefQueue.shift();
              continue;
            }
            i2.add(e3), t2.pos = e3 + t2.start;
            const a2 = new Parser({ lexer: new Lexer(t2), xref: this, allowStreams: true });
            let n2, s2 = a2.getObj();
            if (isCmd(s2, "xref"))
              n2 = this.processXRefTable(a2), this.topDict || (this.topDict = n2), s2 = n2.get("XRefStm"), Number.isInteger(s2) && !this._xrefStms.has(s2) && (this._xrefStms.add(s2), this.startXRefQueue.push(s2), this.#Pe ??= s2);
            else {
              if (!Number.isInteger(s2))
                throw new ti("Invalid XRef stream header");
              if (!(Number.isInteger(a2.getObj()) && isCmd(a2.getObj(), "obj") && (s2 = a2.getObj()) instanceof BaseStream))
                throw new ti("Invalid XRef stream");
              if (n2 = this.processXRefStream(s2), this.topDict || (this.topDict = n2), !n2)
                throw new ti("Failed to read XRef stream");
            }
            s2 = n2.get("Prev"), Number.isInteger(s2) ? this.startXRefQueue.push(s2) : s2 instanceof Ref && this.startXRefQueue.push(s2.num);
          } catch (e3) {
            if (e3 instanceof MissingDataException)
              throw e3;
            info$1("(while reading XRef): " + e3);
          }
          this.startXRefQueue.shift();
        }
        if (this.topDict)
          return this.topDict;
        if (!e2)
          throw new XRefParseException();
      }
      get lastXRefStreamPos() {
        return this.#Pe ?? (this._xrefStms.size > 0 ? Math.max(...this._xrefStms) : null);
      }
      getEntry(e2) {
        const t2 = this.entries[e2];
        return t2 && !t2.free && t2.offset ? t2 : null;
      }
      fetchIfRef(e2, t2 = false) {
        return e2 instanceof Ref ? this.fetch(e2, t2) : e2;
      }
      fetch(e2, t2 = false) {
        if (!(e2 instanceof Ref))
          throw new Error("ref object is not a reference");
        const i2 = e2.num, a2 = this._cacheMap.get(i2);
        if (void 0 !== a2)
          return a2 instanceof Dict && !a2.objId && (a2.objId = e2.toString()), a2;
        let n2 = this.getEntry(i2);
        if (null === n2)
          return n2;
        if (this._pendingRefs.has(e2))
          return this._pendingRefs.remove(e2), warn$1(`Ignoring circular reference: ${e2}.`), li;
        this._pendingRefs.put(e2);
        try {
          n2 = n2.uncompressed ? this.fetchUncompressed(e2, n2, t2) : this.fetchCompressed(e2, n2, t2), this._pendingRefs.remove(e2);
        } catch (t3) {
          throw this._pendingRefs.remove(e2), t3;
        }
        return n2 instanceof Dict ? n2.objId = e2.toString() : n2 instanceof BaseStream && (n2.dict.objId = e2.toString()), n2;
      }
      fetchUncompressed(e2, t2, i2 = false) {
        const a2 = e2.gen;
        let n2 = e2.num;
        if (t2.gen !== a2) {
          const s3 = `Inconsistent generation in XRef: ${e2}`;
          if (this._generationFallback && t2.gen < a2)
            return warn$1(s3), this.fetchUncompressed(Ref.get(n2, t2.gen), t2, i2);
          throw new XRefEntryException(s3);
        }
        const s2 = this.stream.makeSubStream(t2.offset + this.stream.start), r2 = new Parser({ lexer: new Lexer(s2), xref: this, allowStreams: true }), o2 = r2.getObj(), l3 = r2.getObj(), c2 = r2.getObj();
        if (o2 !== n2 || l3 !== a2 || !(c2 instanceof Cmd))
          throw new XRefEntryException(`Bad (uncompressed) XRef entry: ${e2}`);
        if ("obj" !== c2.cmd) {
          if (c2.cmd.startsWith("obj") && (n2 = parseInt(c2.cmd.substring(3), 10), !Number.isNaN(n2)))
            return n2;
          throw new XRefEntryException(`Bad (uncompressed) XRef entry: ${e2}`);
        }
        return (t2 = this.encrypt && !i2 ? r2.getObj(this.encrypt.createCipherTransform(n2, a2)) : r2.getObj()) instanceof BaseStream || this._cacheMap.set(n2, t2), t2;
      }
      fetchCompressed(e2, t2, i2 = false) {
        const a2 = t2.offset, n2 = this.fetch(Ref.get(a2, 0));
        if (!(n2 instanceof BaseStream))
          throw new ti("bad ObjStm stream");
        const s2 = n2.dict.get("First"), r2 = n2.dict.get("N");
        if (!Number.isInteger(s2) || !Number.isInteger(r2))
          throw new ti("invalid first and n parameters for ObjStm stream");
        let o2 = new Parser({ lexer: new Lexer(n2), xref: this, allowStreams: true });
        const l3 = new Array(r2), c2 = new Array(r2);
        for (let e3 = 0; e3 < r2; ++e3) {
          const t3 = o2.getObj();
          if (!Number.isInteger(t3))
            throw new ti(`invalid object number in the ObjStm stream: ${t3}`);
          const i3 = o2.getObj();
          if (!Number.isInteger(i3))
            throw new ti(`invalid object offset in the ObjStm stream: ${i3}`);
          l3[e3] = t3;
          const n3 = this.getEntry(t3);
          n3?.offset === a2 && n3.gen !== e3 && (n3.gen = e3), c2[e3] = i3;
        }
        const h2 = (n2.start || 0) + s2, d2 = new Array(r2);
        for (let e3 = 0; e3 < r2; ++e3) {
          const t3 = e3 < r2 - 1 ? c2[e3 + 1] - c2[e3] : void 0;
          if (t3 < 0)
            throw new ti("Invalid offset in the ObjStm stream.");
          o2 = new Parser({ lexer: new Lexer(n2.makeSubStream(h2 + c2[e3], t3, n2.dict)), xref: this, allowStreams: true });
          const i3 = o2.getObj();
          if (d2[e3] = i3, i3 instanceof BaseStream)
            continue;
          const s3 = l3[e3], u2 = this.entries[s3];
          u2 && u2.offset === a2 && u2.gen === e3 && this._cacheMap.set(s3, i3);
        }
        if (void 0 === (t2 = d2[t2.gen]))
          throw new XRefEntryException(`Bad (compressed) XRef entry: ${e2}`);
        return t2;
      }
      async fetchIfRefAsync(e2, t2) {
        return e2 instanceof Ref ? this.fetchAsync(e2, t2) : e2;
      }
      async fetchAsync(e2, t2) {
        try {
          return this.fetch(e2, t2);
        } catch (i2) {
          if (!(i2 instanceof MissingDataException))
            throw i2;
          return await this.pdfManager.requestRange(i2.begin, i2.end), this.fetchAsync(e2, t2);
        }
      }
      getCatalogObj() {
        return this.root;
      }
    };
    __name(XRef, "XRef");
    cl = [0, 0, 612, 792];
    Page = class {
      #Re = false;
      #Be = null;
      constructor({ pdfManager: e2, xref: t2, pageIndex: i2, pageDict: a2, ref: n2, globalIdFactory: s2, fontCache: r2, builtInCMapCache: o2, standardFontDataCache: l3, globalColorSpaceCache: c2, globalImageCache: h2, systemFontCache: d2, nonBlendModesSet: u2, xfaFactory: g2 }) {
        this.pdfManager = e2, this.pageIndex = i2, this.pageDict = a2, this.xref = t2, this.ref = n2, this.fontCache = r2, this.builtInCMapCache = o2, this.standardFontDataCache = l3, this.globalColorSpaceCache = c2, this.globalImageCache = h2, this.systemFontCache = d2, this.nonBlendModesSet = u2, this.evaluatorOptions = e2.evaluatorOptions, this.xfaFactory = g2;
        const p2 = { obj: 0 };
        this._localIdFactory = class extends s2 {
          static createObjId() {
            return `p${i2}_${++p2.obj}`;
          }
          static getPageObjId() {
            return `p${n2.toString()}`;
          }
        };
      }
      #Ne(e2) {
        return new PartialEvaluator({ xref: this.xref, handler: e2, pageIndex: this.pageIndex, idFactory: this._localIdFactory, fontCache: this.fontCache, builtInCMapCache: this.builtInCMapCache, standardFontDataCache: this.standardFontDataCache, globalColorSpaceCache: this.globalColorSpaceCache, globalImageCache: this.globalImageCache, systemFontCache: this.systemFontCache, options: this.evaluatorOptions });
      }
      #Le(e2, t2 = false) {
        const i2 = getInheritableProperty({ dict: this.pageDict, key: e2, getArray: t2, stopWhenFound: false });
        return Array.isArray(i2) ? 1 !== i2.length && i2[0] instanceof Dict ? Dict.merge({ xref: this.xref, dictArray: i2 }) : i2[0] : i2;
      }
      get content() {
        return this.pageDict.getArray("Contents");
      }
      get resources() {
        const e2 = this.#Le("Resources");
        return shadow$1(this, "resources", e2 instanceof Dict ? e2 : Dict.empty);
      }
      #Ue(e2) {
        if (this.xfaData)
          return this.xfaData.bbox;
        const t2 = lookupNormalRect(this.#Le(e2, true), null);
        if (t2) {
          if (t2[2] - t2[0] > 0 && t2[3] - t2[1] > 0)
            return t2;
          warn$1(`Empty, or invalid, /${e2} entry.`);
        }
        return null;
      }
      get mediaBox() {
        return shadow$1(this, "mediaBox", this.#Ue("MediaBox") || cl);
      }
      get cropBox() {
        return shadow$1(this, "cropBox", this.#Ue("CropBox") || this.mediaBox);
      }
      get userUnit() {
        const e2 = this.pageDict.get("UserUnit");
        return shadow$1(this, "userUnit", "number" == typeof e2 && e2 > 0 ? e2 : 1);
      }
      get view() {
        const { cropBox: e2, mediaBox: t2 } = this;
        if (e2 !== t2 && !isArrayEqual(e2, t2)) {
          const i2 = ni.intersect(e2, t2);
          if (i2 && i2[2] - i2[0] > 0 && i2[3] - i2[1] > 0)
            return shadow$1(this, "view", i2);
          warn$1("Empty /CropBox and /MediaBox intersection.");
        }
        return shadow$1(this, "view", t2);
      }
      get rotate() {
        let e2 = this.#Le("Rotate") || 0;
        return e2 % 90 != 0 ? e2 = 0 : e2 >= 360 ? e2 %= 360 : e2 < 0 && (e2 = (e2 % 360 + 360) % 360), shadow$1(this, "rotate", e2);
      }
      #je(e2, t2) {
        if (!this.evaluatorOptions.ignoreErrors)
          throw e2;
        warn$1(`getContentStream - ignoring sub-stream (${t2}): "${e2}".`);
      }
      async getContentStream() {
        const e2 = await this.pdfManager.ensure(this, "content");
        return e2 instanceof BaseStream ? e2 : Array.isArray(e2) ? new StreamsSequenceStream(e2, this.#je.bind(this)) : new NullStream();
      }
      get xfaData() {
        return shadow$1(this, "xfaData", this.xfaFactory ? { bbox: this.xfaFactory.getBoundingBox(this.pageIndex) } : null);
      }
      async #$e(e2, t2, i2) {
        const a2 = [];
        for (const n2 of e2)
          if (n2.id) {
            const e3 = Ref.fromString(n2.id);
            if (!e3) {
              warn$1(`A non-linked annotation cannot be modified: ${n2.id}`);
              continue;
            }
            if (n2.deleted) {
              if (t2.put(e3, e3), n2.popupRef) {
                const e4 = Ref.fromString(n2.popupRef);
                e4 && t2.put(e4, e4);
              }
              continue;
            }
            if (n2.popup?.deleted) {
              const e4 = Ref.fromString(n2.popupRef);
              e4 && t2.put(e4, e4);
            }
            i2?.put(e3), n2.ref = e3, a2.push(this.xref.fetchAsync(e3).then((e4) => {
              e4 instanceof Dict && (n2.oldAnnotation = e4.clone());
            }, () => {
              warn$1(`Cannot fetch \`oldAnnotation\` for: ${e3}.`);
            })), delete n2.id;
          }
        await Promise.all(a2);
      }
      async saveNewAnnotations(e2, t2, i2, a2, n2) {
        if (this.xfaFactory)
          throw new Error("XFA: Cannot save new annotations.");
        const s2 = this.#Ne(e2), r2 = new RefSetCache(), o2 = new RefSet();
        await this.#$e(i2, r2, o2);
        const l3 = this.pageDict, c2 = this.annotations.filter((e3) => !(e3 instanceof Ref && r2.has(e3))), h2 = await AnnotationFactory.saveNewAnnotations(s2, t2, i2, a2, n2);
        for (const { ref: e3 } of h2.annotations)
          e3 instanceof Ref && !o2.has(e3) && c2.push(e3);
        const d2 = l3.clone();
        d2.set("Annots", c2), n2.put(this.ref, { data: d2 });
        for (const e3 of r2)
          n2.put(e3, { data: null });
      }
      async save(e2, t2, i2, a2) {
        const n2 = this.#Ne(e2), s2 = await this._parsedAnnotations, r2 = [];
        for (const e3 of s2)
          r2.push(e3.save(n2, t2, i2, a2).catch(function(e4) {
            return warn$1(`save - ignoring annotation data during "${t2.name}" task: "${e4}".`), null;
          }));
        return Promise.all(r2);
      }
      async loadResources(e2) {
        await (this.#Be ??= this.pdfManager.ensure(this, "resources")), await ObjectLoader.load(this.resources, e2, this.xref);
      }
      async #He(e2, t2) {
        const i2 = e2?.get("Resources");
        return i2 instanceof Dict && i2.size ? (await ObjectLoader.load(i2, t2, this.xref), Dict.merge({ xref: this.xref, dictArray: [i2, this.resources], mergeSubDicts: true })) : this.resources;
      }
      async getOperatorList({ handler: e2, sink: t2, task: i2, intent: a2, cacheKey: n2, annotationStorage: l3 = null, modifiedIds: u2 = null }) {
        const p2 = this.getContentStream(), f2 = this.loadResources(mi), m2 = this.#Ne(e2), b2 = this.xfaFactory ? null : getNewAnnotationsMap(l3), y2 = b2?.get(this.pageIndex);
        let w2 = Promise.resolve(null), x2 = null;
        if (y2) {
          const e3 = this.pdfManager.ensureDoc("annotationGlobals");
          let t3;
          const a3 = /* @__PURE__ */ new Set();
          for (const { bitmapId: e4, bitmap: t4 } of y2)
            !e4 || t4 || a3.has(e4) || a3.add(e4);
          const { isOffscreenCanvasSupported: n3 } = this.evaluatorOptions;
          if (a3.size > 0) {
            const e4 = y2.slice();
            for (const [t4, i3] of l3)
              t4.startsWith(g) && i3.bitmap && a3.has(i3.bitmapId) && e4.push(i3);
            t3 = AnnotationFactory.generateImages(e4, this.xref, n3);
          } else
            t3 = AnnotationFactory.generateImages(y2, this.xref, n3);
          x2 = new RefSet(), w2 = Promise.all([e3, this.#$e(y2, x2, null)]).then(([e4]) => e4 ? AnnotationFactory.printNewAnnotations(e4, m2, i2, y2, t3) : null);
        }
        const S2 = Promise.all([p2, f2]).then(async ([s2]) => {
          const r2 = await this.#He(s2.dict, mi), o2 = new OperatorList(a2, t2);
          return e2.send("StartRenderPage", { transparency: m2.hasBlendModes(r2, this.nonBlendModesSet), pageIndex: this.pageIndex, cacheKey: n2 }), await m2.getOperatorList({ stream: s2, task: i2, resources: r2, operatorList: o2 }), o2;
        });
        let [v2, C2, k2] = await Promise.all([S2, this._parsedAnnotations, w2]);
        if (k2) {
          C2 = C2.filter((e3) => !(e3.ref && x2.has(e3.ref)));
          for (let e3 = 0, t3 = k2.length; e3 < t3; e3++) {
            const i3 = k2[e3];
            if (i3.refToReplace) {
              const a3 = C2.findIndex((e4) => e4.ref && isRefsEqual(e4.ref, i3.refToReplace));
              a3 >= 0 && (C2.splice(a3, 1, i3), k2.splice(e3--, 1), t3--);
            }
          }
          C2 = C2.concat(k2);
        }
        if (0 === C2.length || a2 & h)
          return v2.flush(true), { length: v2.totalLength };
        const T2 = !!(a2 & c), F2 = !!(a2 & d), M2 = !!(a2 & s), D2 = !!(a2 & r), E2 = !!(a2 & o), O2 = [];
        for (const e3 of C2)
          (M2 || D2 && e3.mustBeViewed(l3, T2) && e3.mustBeViewedWhenEditing(F2, u2) || E2 && e3.mustBePrinted(l3)) && O2.push(e3.getOperatorList(m2, i2, a2, l3).catch(function(e4) {
            return warn$1(`getOperatorList - ignoring annotation data during "${i2.name}" task: "${e4}".`), { opList: null, separateForm: false, separateCanvas: false };
          }));
        const _2 = await Promise.all(O2);
        let R2 = false, N2 = false;
        for (const { opList: e3, separateForm: t3, separateCanvas: i3 } of _2)
          v2.addOpList(e3), R2 ||= t3, N2 ||= i3;
        return v2.flush(true, { form: R2, canvas: N2 }), { length: v2.totalLength };
      }
      async extractTextContent({ handler: e2, task: t2, includeMarkedContent: i2, disableNormalization: a2, sink: n2, intersector: s2 = null }) {
        const r2 = this.getContentStream(), o2 = this.loadResources(bi), l3 = this.pdfManager.ensureCatalog("lang"), [c2, , h2] = await Promise.all([r2, o2, l3]), d2 = await this.#He(c2.dict, bi);
        return this.#Ne(e2).getTextContent({ stream: c2, task: t2, resources: d2, includeMarkedContent: i2, disableNormalization: a2, sink: n2, viewBox: this.view, lang: h2, intersector: s2 });
      }
      async getStructTree() {
        const e2 = await this.pdfManager.ensureCatalog("structTreeRoot");
        if (!e2)
          return null;
        await this._parsedAnnotations;
        try {
          const t2 = await this.pdfManager.ensure(this, "_parseStructTree", [e2]);
          return await this.pdfManager.ensure(t2, "serializable");
        } catch (e3) {
          return warn$1(`getStructTree: "${e3}".`), null;
        }
      }
      _parseStructTree(e2) {
        const t2 = new StructTreePage(e2, this.pageDict);
        return t2.parse(this.ref), t2;
      }
      async getAnnotationsData(e2, t2, i2) {
        const a2 = await this._parsedAnnotations;
        if (0 === a2.length)
          return a2;
        const n2 = [], l3 = [];
        let c2;
        const h2 = !!(i2 & s), d2 = !!(i2 & r), u2 = !!(i2 & o), g2 = [];
        for (const i3 of a2) {
          const a3 = h2 || d2 && i3.viewable;
          (a3 || u2 && i3.printable) && n2.push(i3.data), i3.hasTextContent && a3 ? (c2 ??= this.#Ne(e2), l3.push(i3.extractTextContent(c2, t2, [-1 / 0, -1 / 0, 1 / 0, 1 / 0]).catch(function(e3) {
            warn$1(`getAnnotationsData - ignoring textContent during "${t2.name}" task: "${e3}".`);
          }))) : i3.overlaysTextContent && a3 && g2.push(i3);
        }
        if (g2.length > 0) {
          const i3 = new Intersector(g2);
          l3.push(this.extractTextContent({ handler: e2, task: t2, includeMarkedContent: false, disableNormalization: false, sink: null, viewBox: this.view, lang: null, intersector: i3 }).then(() => {
            i3.setText();
          }));
        }
        return await Promise.all(l3), n2;
      }
      get annotations() {
        const e2 = this.#Le("Annots");
        return shadow$1(this, "annotations", Array.isArray(e2) ? e2 : []);
      }
      get _parsedAnnotations() {
        const e2 = this.pdfManager.ensure(this, "annotations").then(async (e3) => {
          if (0 === e3.length)
            return e3;
          const [t2, i2] = await Promise.all([this.pdfManager.ensureDoc("annotationGlobals"), this.pdfManager.ensureDoc("fieldObjects")]);
          if (!t2)
            return [];
          const a2 = i2?.orphanFields, n2 = [];
          for (const i3 of e3)
            n2.push(AnnotationFactory.create(this.xref, i3, t2, this._localIdFactory, false, a2, null, this.ref).catch(function(e4) {
              return warn$1(`_parsedAnnotations: "${e4}".`), null;
            }));
          const s2 = [];
          let r2, o2;
          for (const e4 of await Promise.all(n2))
            e4 && (e4 instanceof WidgetAnnotation ? (o2 ||= []).push(e4) : e4 instanceof PopupAnnotation ? (r2 ||= []).push(e4) : s2.push(e4));
          return o2 && s2.push(...o2), r2 && s2.push(...r2), s2;
        });
        return this.#Re = true, shadow$1(this, "_parsedAnnotations", e2);
      }
      get jsActions() {
        return shadow$1(this, "jsActions", collectActions(this.xref, this.pageDict, ae));
      }
      async collectAnnotationsByType(e2, t2, i2, a2, n2) {
        const { pageIndex: s2 } = this;
        if (this.#Re) {
          const e3 = await this._parsedAnnotations;
          for (const { data: t3 } of e3)
            i2 && !i2.has(t3.annotationType) || (t3.pageIndex = s2, a2.push(Promise.resolve(t3)));
          return;
        }
        const r2 = await this.pdfManager.ensure(this, "annotations");
        for (const o2 of r2)
          a2.push(AnnotationFactory.create(this.xref, o2, n2, this._localIdFactory, false, null, i2, this.ref).then(async (i3) => {
            if (!i3)
              return null;
            if (i3.data.pageIndex = s2, i3.hasTextContent && i3.viewable) {
              const a3 = this.#Ne(e2);
              await i3.extractTextContent(a3, t2, [-1 / 0, -1 / 0, 1 / 0, 1 / 0]);
            }
            return i3.data;
          }).catch(function(e3) {
            return warn$1(`collectAnnotationsByType: "${e3}".`), null;
          }));
      }
    };
    __name(Page, "Page");
    hl = new Uint8Array([37, 80, 68, 70, 45]);
    dl = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]);
    ul = new Uint8Array([101, 110, 100, 111, 98, 106]);
    __name(find, "find");
    PDFDocument = class {
      #qe = /* @__PURE__ */ new Map();
      #Xe = null;
      constructor(e2, t2) {
        if (t2.length <= 0)
          throw new Qt("The PDF file is empty, i.e. its size is zero bytes.");
        this.pdfManager = e2, this.stream = t2, this.xref = new XRef(t2, e2);
        const i2 = { font: 0 };
        this._globalIdFactory = class {
          static getDocId() {
            return `g_${e2.docId}`;
          }
          static createFontId() {
            return "f" + ++i2.font;
          }
          static createObjId() {
            unreachable$1("Abstract method `createObjId` called.");
          }
          static getPageObjId() {
            unreachable$1("Abstract method `getPageObjId` called.");
          }
        };
      }
      parse(e2) {
        this.xref.parse(e2), this.catalog = new Catalog(this.pdfManager, this.xref);
      }
      get linearization() {
        let e2 = null;
        try {
          e2 = Linearization.create(this.stream);
        } catch (e3) {
          if (e3 instanceof MissingDataException)
            throw e3;
          info$1(e3);
        }
        return shadow$1(this, "linearization", e2);
      }
      get startXRef() {
        const e2 = this.stream;
        let t2 = 0;
        if (this.linearization) {
          if (e2.reset(), find(e2, ul)) {
            e2.skip(6);
            let i2 = e2.peekByte();
            for (; isWhiteSpace(i2); )
              e2.pos++, i2 = e2.peekByte();
            t2 = e2.pos - e2.start;
          }
        } else {
          const i2 = 1024, a2 = dl.length;
          let n2 = false, s2 = e2.end;
          for (; !n2 && s2 > 0; )
            s2 -= i2 - a2, s2 < 0 && (s2 = 0), e2.pos = s2, n2 = find(e2, dl, i2, true);
          if (n2) {
            let i3;
            e2.skip(9);
            do {
              i3 = e2.getByte();
            } while (isWhiteSpace(i3));
            let a3 = "";
            for (; i3 >= 32 && i3 <= 57; )
              a3 += String.fromCharCode(i3), i3 = e2.getByte();
            t2 = parseInt(a3, 10), isNaN(t2) && (t2 = 0);
          }
        }
        return shadow$1(this, "startXRef", t2);
      }
      checkHeader() {
        const e2 = this.stream;
        if (e2.reset(), !find(e2, hl))
          return;
        e2.moveStart(), e2.skip(hl.length);
        let t2, i2 = "";
        for (; (t2 = e2.getByte()) > 32 && i2.length < 7; )
          i2 += String.fromCharCode(t2);
        gi.test(i2) ? this.#Xe = i2 : warn$1(`Invalid PDF header version: ${i2}`);
      }
      parseStartXRef() {
        this.xref.setStartXRef(this.startXRef);
      }
      get numPages() {
        let e2 = 0;
        return e2 = this.catalog.hasActualNumPages ? this.catalog.numPages : this.xfaFactory ? this.xfaFactory.getNumPages() : this.linearization ? this.linearization.numPages : this.catalog.numPages, shadow$1(this, "numPages", e2);
      }
      #ze(e2, t2 = 0) {
        return !!Array.isArray(e2) && e2.every((e3) => {
          if (!((e3 = this.xref.fetchIfRef(e3)) instanceof Dict))
            return false;
          if (e3.has("Kids"))
            return ++t2 > 10 ? (warn$1("#hasOnlyDocumentSignatures: maximum recursion depth reached"), false) : this.#ze(e3.get("Kids"), t2);
          const i2 = isName(e3.get("FT"), "Sig"), a2 = e3.get("Rect"), n2 = Array.isArray(a2) && a2.every((e4) => 0 === e4);
          return i2 && n2;
        });
      }
      #We(e2, t2, i2 = new RefSet()) {
        if (Array.isArray(e2))
          for (let a2 of e2) {
            if (a2 instanceof Ref) {
              if (i2.has(a2))
                continue;
              i2.put(a2);
            }
            if (a2 = this.xref.fetchIfRef(a2), !(a2 instanceof Dict))
              continue;
            if (a2.has("Kids")) {
              this.#We(a2.get("Kids"), t2, i2);
              continue;
            }
            if (!isName(a2.get("FT"), "Sig"))
              continue;
            const e3 = a2.get("V");
            if (!(e3 instanceof Dict))
              continue;
            const n2 = e3.get("SubFilter");
            n2 instanceof Name && t2.add(n2.name);
          }
      }
      get _xfaStreams() {
        const { acroForm: e2 } = this.catalog;
        if (!e2)
          return null;
        const t2 = e2.get("XFA"), i2 = new Map(["xdp:xdp", "template", "datasets", "config", "connectionSet", "localeSet", "stylesheet", "/xdp:xdp"].map((e3) => [e3, null]));
        if (t2 instanceof BaseStream && !t2.isEmpty)
          return i2.set("xdp:xdp", t2), i2;
        if (!Array.isArray(t2) || 0 === t2.length)
          return null;
        for (let e3 = 0, a2 = t2.length; e3 < a2; e3 += 2) {
          let n2;
          if (n2 = 0 === e3 ? "xdp:xdp" : e3 === a2 - 2 ? "/xdp:xdp" : t2[e3], !i2.has(n2))
            continue;
          const s2 = this.xref.fetchIfRef(t2[e3 + 1]);
          s2 instanceof BaseStream && !s2.isEmpty && i2.set(n2, s2);
        }
        return i2;
      }
      get xfaDatasets() {
        const e2 = this._xfaStreams;
        if (!e2)
          return shadow$1(this, "xfaDatasets", null);
        for (const t2 of ["datasets", "xdp:xdp"]) {
          const i2 = e2.get(t2);
          if (i2)
            try {
              const e3 = stringToUTF8String$1(i2.getString());
              return shadow$1(this, "xfaDatasets", new DatasetReader({ [t2]: e3 }));
            } catch {
              warn$1("XFA - Invalid utf-8 string.");
              break;
            }
        }
        return shadow$1(this, "xfaDatasets", null);
      }
      get xfaData() {
        const e2 = this._xfaStreams;
        if (!e2)
          return null;
        const t2 = /* @__PURE__ */ Object.create(null);
        for (const [i2, a2] of e2)
          if (a2)
            try {
              t2[i2] = stringToUTF8String$1(a2.getString());
            } catch {
              return warn$1("XFA - Invalid utf-8 string."), null;
            }
        return t2;
      }
      get xfaFactory() {
        let e2;
        return this.pdfManager.enableXfa && this.catalog.needsRendering && this.formInfo.hasXfa && !this.formInfo.hasAcroForm && (e2 = this.xfaData), shadow$1(this, "xfaFactory", e2 ? new XFAFactory(e2) : null);
      }
      get isPureXfa() {
        return !!this.xfaFactory && this.xfaFactory.isValid();
      }
      get htmlForXfa() {
        return this.xfaFactory ? this.xfaFactory.getPages() : null;
      }
      async #Ge() {
        const e2 = await this.pdfManager.ensureCatalog("xfaImages");
        e2 && this.xfaFactory.setImages(e2);
      }
      async #Ve(e2, t2) {
        const i2 = await this.pdfManager.ensureCatalog("acroForm");
        if (!i2)
          return;
        const a2 = await i2.getAsync("DR");
        if (!(a2 instanceof Dict))
          return;
        await ObjectLoader.load(a2, ["Font"], this.xref);
        const n2 = a2.get("Font");
        if (!(n2 instanceof Dict))
          return;
        const s2 = Object.assign(/* @__PURE__ */ Object.create(null), this.pdfManager.evaluatorOptions, { useSystemFonts: false }), { builtInCMapCache: r2, fontCache: o2, standardFontDataCache: l3 } = this.catalog, c2 = new PartialEvaluator({ xref: this.xref, handler: e2, pageIndex: -1, idFactory: this._globalIdFactory, fontCache: o2, builtInCMapCache: r2, standardFontDataCache: l3, options: s2 }), h2 = new OperatorList(), d2 = [], u2 = { get font() {
          return d2.at(-1);
        }, set font(e3) {
          d2.push(e3);
        }, clone() {
          return this;
        } }, parseFont = /* @__PURE__ */ __name((e3, i3, n3) => c2.handleSetFont(a2, [Name.get(e3), 1], null, h2, t2, u2, i3, n3).catch((e4) => (warn$1(`loadXfaFonts: "${e4}".`), null)), "parseFont"), g2 = [];
        for (const [e3, t3] of n2) {
          const i3 = t3.get("FontDescriptor");
          if (!(i3 instanceof Dict))
            continue;
          let a3 = i3.get("FontFamily");
          a3 = a3.replaceAll(/[ ]+(\d)/g, "$1");
          const n3 = { fontFamily: a3, fontWeight: i3.get("FontWeight"), italicAngle: -i3.get("ItalicAngle") };
          validateCSSFont(n3) && g2.push(parseFont(e3, null, n3));
        }
        await Promise.all(g2);
        const p2 = this.xfaFactory.setFonts(d2);
        if (!p2)
          return;
        s2.ignoreErrors = true, g2.length = 0, d2.length = 0;
        const f2 = /* @__PURE__ */ new Set();
        for (const e3 of p2)
          getXfaFontName(`${e3}-Regular`) || f2.add(e3);
        f2.size && p2.push("PdfJS-Fallback");
        for (const e3 of p2)
          if (!f2.has(e3))
            for (const t3 of [{ name: "Regular", fontWeight: 400, italicAngle: 0 }, { name: "Bold", fontWeight: 700, italicAngle: 0 }, { name: "Italic", fontWeight: 400, italicAngle: 12 }, { name: "BoldItalic", fontWeight: 700, italicAngle: 12 }]) {
              const i3 = `${e3}-${t3.name}`;
              g2.push(parseFont(i3, getXfaFontDict(i3), { fontFamily: e3, fontWeight: t3.fontWeight, italicAngle: t3.italicAngle }));
            }
        await Promise.all(g2), this.xfaFactory.appendFonts(d2, f2);
      }
      loadXfaResources(e2, t2) {
        return Promise.all([this.#Ve(e2, t2).catch(() => {
        }), this.#Ge()]);
      }
      serializeXfaData(e2) {
        return this.xfaFactory ? this.xfaFactory.serializeData(e2) : null;
      }
      get version() {
        return this.catalog.version || this.#Xe;
      }
      get formInfo() {
        const e2 = { hasFields: false, hasAcroForm: false, hasXfa: false, hasSignatures: false }, { acroForm: t2 } = this.catalog;
        if (!t2)
          return shadow$1(this, "formInfo", e2);
        try {
          const i2 = t2.get("Fields"), a2 = Array.isArray(i2) && i2.length > 0;
          e2.hasFields = a2;
          const n2 = t2.get("XFA");
          e2.hasXfa = Array.isArray(n2) && n2.length > 0 || n2 instanceof BaseStream && !n2.isEmpty;
          const s2 = !!(1 & t2.get("SigFlags")), r2 = s2 && this.#ze(i2);
          e2.hasAcroForm = a2 && !r2, e2.hasSignatures = s2;
        } catch (e3) {
          if (e3 instanceof MissingDataException)
            throw e3;
          warn$1(`Cannot fetch form information: "${e3}".`);
        }
        return shadow$1(this, "formInfo", e2);
      }
      get documentInfo() {
        const { catalog: e2, formInfo: t2, xref: i2 } = this, a2 = { PDFFormatVersion: this.version, Language: e2.lang, EncryptFilterName: i2.encrypt?.filterName ?? null, IsLinearized: !!this.linearization, IsAcroFormPresent: t2.hasAcroForm, IsXFAPresent: t2.hasXfa, IsCollectionPresent: !!e2.collection, IsSignaturesPresent: t2.hasSignatures };
        let n2;
        try {
          n2 = i2.trailer.get("Info");
        } catch (e3) {
          if (e3 instanceof MissingDataException)
            throw e3;
          info$1("The document information dictionary is invalid.");
        }
        if (!(n2 instanceof Dict))
          return shadow$1(this, "documentInfo", a2);
        for (const [e3, t3] of n2) {
          switch (e3) {
            case "Title":
            case "Author":
            case "Subject":
            case "Keywords":
            case "Creator":
            case "Producer":
            case "CreationDate":
            case "ModDate":
              if ("string" == typeof t3) {
                a2[e3] = stringToPDFString(t3);
                continue;
              }
              break;
            case "Trapped":
              if (t3 instanceof Name) {
                a2[e3] = t3;
                continue;
              }
              break;
            default:
              let i3;
              switch (typeof t3) {
                case "string":
                  i3 = stringToPDFString(t3);
                  break;
                case "number":
                case "boolean":
                  i3 = t3;
                  break;
                default:
                  t3 instanceof Name && (i3 = t3);
              }
              if (void 0 === i3) {
                warn$1(`Bad value, for custom key "${e3}", in Info: ${t3}.`);
                continue;
              }
              a2.Custom ??= /* @__PURE__ */ Object.create(null), a2.Custom[e3] = i3;
              continue;
          }
          warn$1(`Bad value, for key "${e3}", in Info: ${t3}.`);
        }
        return shadow$1(this, "documentInfo", a2);
      }
      get fingerprints() {
        const e2 = "\0".repeat(16);
        function validate(t3) {
          return "string" == typeof t3 && 16 === t3.length && t3 !== e2;
        }
        __name(validate, "validate");
        const t2 = this.xref.trailer.get("ID");
        let i2, a2;
        return Array.isArray(t2) && validate(t2[0]) ? (i2 = stringToBytes$1(t2[0]), t2[1] !== t2[0] && validate(t2[1]) && (a2 = stringToBytes$1(t2[1]))) : i2 = calculateMD5(this.stream.getByteRange(0, 1024), 0, 1024), shadow$1(this, "fingerprints", [toHexUtil(i2), a2 ? toHexUtil(a2) : null]);
      }
      async #Ke(e2) {
        const { catalog: t2, linearization: i2, xref: a2 } = this, n2 = Ref.get(i2.objectNumberFirst, 0);
        try {
          const e3 = await a2.fetchAsync(n2);
          if (e3 instanceof Dict) {
            let i3 = e3.getRaw("Type");
            if (i3 instanceof Ref && (i3 = await a2.fetchAsync(i3)), isName(i3, "Page") || !e3.has("Type") && !e3.has("Kids") && e3.has("Contents"))
              return t2.pageKidsCountCache.has(n2) || t2.pageKidsCountCache.put(n2, 1), t2.pageIndexCache.has(n2) || t2.pageIndexCache.put(n2, 0), [e3, n2];
          }
          throw new ti("The Linearization dictionary doesn't point to a valid Page dictionary.");
        } catch (i3) {
          return warn$1(`_getLinearizationPage: "${i3.message}".`), t2.getPageDict(e2);
        }
      }
      getPage(e2) {
        const t2 = this.#qe.get(e2);
        if (t2)
          return t2;
        const { catalog: i2, linearization: a2, xfaFactory: n2 } = this;
        let s2;
        return s2 = n2 ? Promise.resolve([Dict.empty, null]) : a2?.pageFirst === e2 ? this.#Ke(e2) : i2.getPageDict(e2), s2 = s2.then(([t3, a3]) => new Page({ pdfManager: this.pdfManager, xref: this.xref, pageIndex: e2, pageDict: t3, ref: a3, globalIdFactory: this._globalIdFactory, fontCache: i2.fontCache, builtInCMapCache: i2.builtInCMapCache, standardFontDataCache: i2.standardFontDataCache, globalColorSpaceCache: i2.globalColorSpaceCache, globalImageCache: i2.globalImageCache, systemFontCache: i2.systemFontCache, nonBlendModesSet: i2.nonBlendModesSet, xfaFactory: n2 })), this.#qe.set(e2, s2), s2;
      }
      async checkFirstPage(e2 = false) {
        if (!e2)
          try {
            await this.getPage(0);
          } catch (e3) {
            if (e3 instanceof XRefEntryException)
              throw this.#qe.delete(0), await this.cleanup(), new XRefParseException();
          }
      }
      async checkLastPage(e2 = false) {
        const { catalog: t2, pdfManager: i2 } = this;
        let a2;
        t2.setActualNumPages();
        try {
          if (await Promise.all([i2.ensureDoc("xfaFactory"), i2.ensureDoc("linearization"), i2.ensureCatalog("numPages")]), this.xfaFactory)
            return;
          if (a2 = this.linearization ? this.linearization.numPages : t2.numPages, !Number.isInteger(a2))
            throw new ti("Page count is not an integer.");
          if (a2 <= 1)
            return;
          await this.getPage(a2 - 1);
        } catch (n2) {
          if (this.#qe.delete(a2 - 1), await this.cleanup(), n2 instanceof XRefEntryException && !e2)
            throw new XRefParseException();
          let s2;
          warn$1(`checkLastPage - invalid /Pages tree /Count: ${a2}.`);
          try {
            s2 = await t2.getAllPageDicts(e2);
          } catch (i3) {
            if (i3 instanceof XRefEntryException && !e2)
              throw new XRefParseException();
            return void t2.setActualNumPages(1);
          }
          for (const [e3, [a3, n3]] of s2) {
            let s3;
            a3 instanceof Error ? (s3 = Promise.reject(a3), s3.catch(() => {
            })) : s3 = Promise.resolve(new Page({ pdfManager: i2, xref: this.xref, pageIndex: e3, pageDict: a3, ref: n3, globalIdFactory: this._globalIdFactory, fontCache: t2.fontCache, builtInCMapCache: t2.builtInCMapCache, standardFontDataCache: t2.standardFontDataCache, globalColorSpaceCache: this.globalColorSpaceCache, globalImageCache: t2.globalImageCache, systemFontCache: t2.systemFontCache, nonBlendModesSet: t2.nonBlendModesSet, xfaFactory: null })), this.#qe.set(e3, s3);
          }
          t2.setActualNumPages(s2.size);
        }
      }
      async fontFallback(e2, t2) {
        const { catalog: i2, pdfManager: a2 } = this;
        for (const n2 of await Promise.all(i2.fontCache))
          if (n2.loadedName === e2)
            return void n2.fallback(t2, a2.evaluatorOptions);
      }
      async cleanup(e2 = false) {
        return this.catalog ? this.catalog.cleanup(e2) : clearGlobalCaches();
      }
      async #Ye(e2, t2, i2, a2, n2, s2, r2) {
        const { xref: o2 } = this;
        if (!(i2 instanceof Ref) || s2.has(i2))
          return;
        s2.put(i2);
        const l3 = await o2.fetchAsync(i2);
        if (!(l3 instanceof Dict))
          return;
        let c2 = await l3.getAsync("Subtype");
        if (c2 = c2 instanceof Name ? c2.name : null, "Link" === c2)
          return;
        if (l3.has("T")) {
          const t3 = stringToPDFString(await l3.getAsync("T"));
          e2 = "" === e2 ? t3 : `${e2}.${t3}`;
        } else {
          let i3 = l3;
          for (; ; ) {
            if (i3 = i3.getRaw("Parent") || t2, i3 instanceof Ref) {
              if (s2.has(i3))
                break;
              i3 = await o2.fetchAsync(i3);
            }
            if (!(i3 instanceof Dict))
              break;
            if (i3.has("T")) {
              const t3 = stringToPDFString(await i3.getAsync("T"));
              e2 = "" === e2 ? t3 : `${e2}.${t3}`;
              break;
            }
          }
        }
        if (t2 && !l3.has("Parent") && isName(l3.get("Subtype"), "Widget") && r2.put(i2, t2), a2.has(e2) || a2.set(e2, []), a2.get(e2).push(AnnotationFactory.create(o2, i2, n2, null, true, r2, null, null).then((e3) => e3?.getFieldObject()).catch(function(e3) {
          return warn$1(`#collectFieldObjects: "${e3}".`), null;
        })), !l3.has("Kids"))
          return;
        const h2 = await l3.getAsync("Kids");
        if (Array.isArray(h2))
          for (const t3 of h2)
            await this.#Ye(e2, i2, t3, a2, n2, s2, r2);
      }
      get fieldObjects() {
        return shadow$1(this, "fieldObjects", this.pdfManager.ensureDoc("formInfo").then(async (e2) => {
          if (!e2.hasFields)
            return null;
          const t2 = await this.annotationGlobals;
          if (!t2)
            return null;
          const { acroForm: i2 } = t2, a2 = new RefSet(), n2 = /* @__PURE__ */ Object.create(null), s2 = /* @__PURE__ */ new Map(), r2 = new RefSetCache();
          for (const e3 of i2.get("Fields"))
            await this.#Ye("", null, e3, s2, t2, a2, r2);
          const o2 = [];
          for (const [e3, t3] of s2)
            o2.push(Promise.all(t3).then((t4) => {
              (t4 = t4.filter((e4) => !!e4)).length > 0 && (n2[e3] = t4);
            }));
          return await Promise.all(o2), { allFields: objectSize(n2) > 0 ? n2 : null, orphanFields: r2 };
        }));
      }
      get hasJSActions() {
        return shadow$1(this, "hasJSActions", this.pdfManager.ensureDoc("_parseHasJSActions"));
      }
      async _parseHasJSActions() {
        const [e2, t2] = await Promise.all([this.pdfManager.ensureCatalog("jsActions"), this.pdfManager.ensureDoc("fieldObjects")]);
        return !!e2 || !!t2?.allFields && Object.values(t2.allFields).some((e3) => e3.some((e4) => null !== e4.actions));
      }
      get calculationOrderIds() {
        const e2 = this.catalog.acroForm?.get("CO");
        if (!Array.isArray(e2) || 0 === e2.length)
          return shadow$1(this, "calculationOrderIds", null);
        const t2 = [];
        for (const i2 of e2)
          i2 instanceof Ref && t2.push(i2.toString());
        return shadow$1(this, "calculationOrderIds", t2.length ? t2 : null);
      }
      get annotationGlobals() {
        return shadow$1(this, "annotationGlobals", AnnotationFactory.createGlobals(this.pdfManager));
      }
    };
    __name(PDFDocument, "PDFDocument");
    BasePdfManager = class {
      constructor({ docBaseUrl: e2, docId: t2, enableXfa: i2, evaluatorOptions: a2, handler: n2, password: s2 }) {
        this._docBaseUrl = function(e3) {
          if (e3) {
            const t3 = createValidAbsoluteUrl$1(e3);
            if (t3)
              return t3.href;
            warn$1(`Invalid absolute docBaseUrl: "${e3}".`);
          }
          return null;
        }(e2), this._docId = t2, this._password = s2, this.enableXfa = i2, a2.isOffscreenCanvasSupported &&= FeatureTest.isOffscreenCanvasSupported, a2.isImageDecoderSupported &&= FeatureTest.isImageDecoderSupported, this.evaluatorOptions = Object.freeze(a2), ImageResizer.setOptions(a2), JpegStream.setOptions(a2), OperatorList.setOptions(a2);
        const r2 = { ...a2, handler: n2 };
        JpxImage.setOptions(r2), IccColorSpace.setOptions(r2), CmykICCBasedCS.setOptions(r2);
      }
      get docId() {
        return this._docId;
      }
      get password() {
        return this._password;
      }
      get docBaseUrl() {
        return this._docBaseUrl;
      }
      ensureDoc(e2, t2) {
        return this.ensure(this.pdfDocument, e2, t2);
      }
      ensureXRef(e2, t2) {
        return this.ensure(this.pdfDocument.xref, e2, t2);
      }
      ensureCatalog(e2, t2) {
        return this.ensure(this.pdfDocument.catalog, e2, t2);
      }
      getPage(e2) {
        return this.pdfDocument.getPage(e2);
      }
      fontFallback(e2, t2) {
        return this.pdfDocument.fontFallback(e2, t2);
      }
      cleanup(e2 = false) {
        return this.pdfDocument.cleanup(e2);
      }
      async ensure(e2, t2, i2) {
        unreachable$1("Abstract method `ensure` called");
      }
      requestRange(e2, t2) {
        unreachable$1("Abstract method `requestRange` called");
      }
      requestLoadedStream(e2 = false) {
        unreachable$1("Abstract method `requestLoadedStream` called");
      }
      sendProgressiveData(e2) {
        unreachable$1("Abstract method `sendProgressiveData` called");
      }
      updatePassword(e2) {
        this._password = e2;
      }
      terminate(e2) {
        unreachable$1("Abstract method `terminate` called");
      }
    };
    __name(BasePdfManager, "BasePdfManager");
    LocalPdfManager = class extends BasePdfManager {
      constructor(e2) {
        super(e2);
        const t2 = new Stream(e2.source);
        this.pdfDocument = new PDFDocument(this, t2), this._loadedStreamPromise = Promise.resolve(t2);
      }
      async ensure(e2, t2, i2) {
        const a2 = e2[t2];
        return "function" == typeof a2 ? a2.apply(e2, i2) : a2;
      }
      requestRange(e2, t2) {
        return Promise.resolve();
      }
      requestLoadedStream(e2 = false) {
        return this._loadedStreamPromise;
      }
      terminate(e2) {
      }
    };
    __name(LocalPdfManager, "LocalPdfManager");
    NetworkPdfManager = class extends BasePdfManager {
      constructor(e2) {
        super(e2), this.streamManager = new ChunkedStreamManager(e2.source, { msgHandler: e2.handler, length: e2.length, disableAutoFetch: e2.disableAutoFetch, rangeChunkSize: e2.rangeChunkSize }), this.pdfDocument = new PDFDocument(this, this.streamManager.getStream());
      }
      async ensure(e2, t2, i2) {
        try {
          const a2 = e2[t2];
          return "function" == typeof a2 ? a2.apply(e2, i2) : a2;
        } catch (a2) {
          if (!(a2 instanceof MissingDataException))
            throw a2;
          return await this.requestRange(a2.begin, a2.end), this.ensure(e2, t2, i2);
        }
      }
      requestRange(e2, t2) {
        return this.streamManager.requestRange(e2, t2);
      }
      requestLoadedStream(e2 = false) {
        return this.streamManager.requestAllChunks(e2);
      }
      sendProgressiveData(e2) {
        this.streamManager.onReceiveData({ chunk: e2 });
      }
      terminate(e2) {
        this.streamManager.abort(e2);
      }
    };
    __name(NetworkPdfManager, "NetworkPdfManager");
    gl = 1;
    pl = 2;
    fl = 1;
    ml = 2;
    bl = 3;
    yl = 4;
    wl = 5;
    Al = 6;
    xl = 7;
    Sl = 8;
    __name(onFn$1, "onFn$1");
    __name(wrapReason$1, "wrapReason$1");
    vl = /* @__PURE__ */ __name(class {
      #Je = new AbortController();
      constructor(e2, t2, i2) {
        this.sourceName = e2, this.targetName = t2, this.comObj = i2, this.callbackId = 1, this.streamId = 1, this.streamSinks = /* @__PURE__ */ Object.create(null), this.streamControllers = /* @__PURE__ */ Object.create(null), this.callbackCapabilities = /* @__PURE__ */ Object.create(null), this.actionHandler = /* @__PURE__ */ Object.create(null), i2.addEventListener("message", this.#Ze.bind(this), { signal: this.#Je.signal });
      }
      #Ze({ data: e2 }) {
        if (e2.targetName !== this.sourceName)
          return;
        if (e2.stream)
          return void this.#Qe(e2);
        if (e2.callback) {
          const t3 = e2.callbackId, i2 = this.callbackCapabilities[t3];
          if (!i2)
            throw new Error(`Cannot resolve callback ${t3}`);
          if (delete this.callbackCapabilities[t3], e2.callback === gl)
            i2.resolve(e2.data);
          else {
            if (e2.callback !== pl)
              throw new Error("Unexpected callback case");
            i2.reject(wrapReason$1(e2.reason));
          }
          return;
        }
        const t2 = this.actionHandler[e2.action];
        if (!t2)
          throw new Error(`Unknown action from worker: ${e2.action}`);
        if (e2.callbackId) {
          const i2 = this.sourceName, a2 = e2.sourceName, n2 = this.comObj;
          return void Promise.try(t2, e2.data).then(function(t3) {
            n2.postMessage({ sourceName: i2, targetName: a2, callback: gl, callbackId: e2.callbackId, data: t3 });
          }, function(t3) {
            n2.postMessage({ sourceName: i2, targetName: a2, callback: pl, callbackId: e2.callbackId, reason: wrapReason$1(t3) });
          });
        }
        e2.streamId ? this.#et(e2) : t2(e2.data);
      }
      on(e2, t2) {
        const i2 = this.actionHandler;
        if (i2[e2])
          throw new Error(`There is already an actionName called "${e2}"`);
        i2[e2] = t2;
      }
      send(e2, t2, i2) {
        this.comObj.postMessage({ sourceName: this.sourceName, targetName: this.targetName, action: e2, data: t2 }, i2);
      }
      sendWithPromise(e2, t2, i2) {
        const a2 = this.callbackId++, n2 = Promise.withResolvers();
        this.callbackCapabilities[a2] = n2;
        try {
          this.comObj.postMessage({ sourceName: this.sourceName, targetName: this.targetName, action: e2, callbackId: a2, data: t2 }, i2);
        } catch (e3) {
          n2.reject(e3);
        }
        return n2.promise;
      }
      sendWithStream(e2, t2, i2, a2) {
        const n2 = this.streamId++, s2 = this.sourceName, r2 = this.targetName, o2 = this.comObj;
        return new ReadableStream({ start: (i3) => {
          const l3 = Promise.withResolvers();
          return this.streamControllers[n2] = { controller: i3, startCall: l3, pullCall: null, cancelCall: null, isClosed: false }, o2.postMessage({ sourceName: s2, targetName: r2, action: e2, streamId: n2, data: t2, desiredSize: i3.desiredSize }, a2), l3.promise;
        }, pull: (e3) => {
          const t3 = Promise.withResolvers();
          return this.streamControllers[n2].pullCall = t3, o2.postMessage({ sourceName: s2, targetName: r2, stream: Al, streamId: n2, desiredSize: e3.desiredSize }), t3.promise;
        }, cancel: (e3) => {
          assert$1(e3 instanceof Error, "cancel must have a valid reason");
          const t3 = Promise.withResolvers();
          return this.streamControllers[n2].cancelCall = t3, this.streamControllers[n2].isClosed = true, o2.postMessage({ sourceName: s2, targetName: r2, stream: fl, streamId: n2, reason: wrapReason$1(e3) }), t3.promise;
        } }, i2);
      }
      #et(e2) {
        const t2 = e2.streamId, i2 = this.sourceName, a2 = e2.sourceName, n2 = this.comObj, s2 = this, r2 = this.actionHandler[e2.action], o2 = { enqueue(e3, s3 = 1, r3) {
          if (this.isCancelled)
            return;
          const o3 = this.desiredSize;
          this.desiredSize -= s3, o3 > 0 && this.desiredSize <= 0 && (this.sinkCapability = Promise.withResolvers(), this.ready = this.sinkCapability.promise), n2.postMessage({ sourceName: i2, targetName: a2, stream: yl, streamId: t2, chunk: e3 }, r3);
        }, close() {
          this.isCancelled || (this.isCancelled = true, n2.postMessage({ sourceName: i2, targetName: a2, stream: bl, streamId: t2 }), delete s2.streamSinks[t2]);
        }, error(e3) {
          assert$1(e3 instanceof Error, "error must have a valid reason"), this.isCancelled || (this.isCancelled = true, n2.postMessage({ sourceName: i2, targetName: a2, stream: wl, streamId: t2, reason: wrapReason$1(e3) }));
        }, sinkCapability: Promise.withResolvers(), onPull: null, onCancel: null, isCancelled: false, desiredSize: e2.desiredSize, ready: null };
        o2.sinkCapability.resolve(), o2.ready = o2.sinkCapability.promise, this.streamSinks[t2] = o2, Promise.try(r2, e2.data, o2).then(function() {
          n2.postMessage({ sourceName: i2, targetName: a2, stream: Sl, streamId: t2, success: true });
        }, function(e3) {
          n2.postMessage({ sourceName: i2, targetName: a2, stream: Sl, streamId: t2, reason: wrapReason$1(e3) });
        });
      }
      #Qe(e2) {
        const t2 = e2.streamId, i2 = this.sourceName, a2 = e2.sourceName, n2 = this.comObj, s2 = this.streamControllers[t2], r2 = this.streamSinks[t2];
        switch (e2.stream) {
          case Sl:
            e2.success ? s2.startCall.resolve() : s2.startCall.reject(wrapReason$1(e2.reason));
            break;
          case xl:
            e2.success ? s2.pullCall.resolve() : s2.pullCall.reject(wrapReason$1(e2.reason));
            break;
          case Al:
            if (!r2) {
              n2.postMessage({ sourceName: i2, targetName: a2, stream: xl, streamId: t2, success: true });
              break;
            }
            r2.desiredSize <= 0 && e2.desiredSize > 0 && r2.sinkCapability.resolve(), r2.desiredSize = e2.desiredSize, Promise.try(r2.onPull || onFn$1).then(function() {
              n2.postMessage({ sourceName: i2, targetName: a2, stream: xl, streamId: t2, success: true });
            }, function(e3) {
              n2.postMessage({ sourceName: i2, targetName: a2, stream: xl, streamId: t2, reason: wrapReason$1(e3) });
            });
            break;
          case yl:
            if (assert$1(s2, "enqueue should have stream controller"), s2.isClosed)
              break;
            s2.controller.enqueue(e2.chunk);
            break;
          case bl:
            if (assert$1(s2, "close should have stream controller"), s2.isClosed)
              break;
            s2.isClosed = true, s2.controller.close(), this.#tt(s2, t2);
            break;
          case wl:
            assert$1(s2, "error should have stream controller"), s2.controller.error(wrapReason$1(e2.reason)), this.#tt(s2, t2);
            break;
          case ml:
            e2.success ? s2.cancelCall.resolve() : s2.cancelCall.reject(wrapReason$1(e2.reason)), this.#tt(s2, t2);
            break;
          case fl:
            if (!r2)
              break;
            const o2 = wrapReason$1(e2.reason);
            Promise.try(r2.onCancel || onFn$1, o2).then(function() {
              n2.postMessage({ sourceName: i2, targetName: a2, stream: ml, streamId: t2, success: true });
            }, function(e3) {
              n2.postMessage({ sourceName: i2, targetName: a2, stream: ml, streamId: t2, reason: wrapReason$1(e3) });
            }), r2.sinkCapability.reject(o2), r2.isCancelled = true, delete this.streamSinks[t2];
            break;
          default:
            throw new Error("Unexpected stream case");
        }
      }
      async #tt(e2, t2) {
        await Promise.allSettled([e2.startCall?.promise, e2.pullCall?.promise, e2.cancelCall?.promise]), delete this.streamControllers[t2];
      }
      destroy() {
        this.#Je?.abort(), this.#Je = null;
      }
    }, "vl");
    __name(writeObject, "writeObject");
    __name(writeDict, "writeDict");
    __name(writeStream, "writeStream");
    __name(writeArray, "writeArray");
    __name(writeValue, "writeValue");
    __name(writeInt, "writeInt");
    __name(writeString, "writeString");
    __name(updateXFA, "updateXFA");
    __name(getIndexes, "getIndexes");
    __name(computeIDs, "computeIDs");
    __name(incrementalUpdate, "incrementalUpdate");
    PDFWorkerStream = class {
      constructor(e2) {
        this._msgHandler = e2, this._contentLength = null, this._fullRequestReader = null, this._rangeRequestReaders = [];
      }
      getFullReader() {
        return assert$1(!this._fullRequestReader, "PDFWorkerStream.getFullReader can only be called once."), this._fullRequestReader = new PDFWorkerStreamReader(this._msgHandler), this._fullRequestReader;
      }
      getRangeReader(e2, t2) {
        const i2 = new PDFWorkerStreamRangeReader(e2, t2, this._msgHandler);
        return this._rangeRequestReaders.push(i2), i2;
      }
      cancelAllRequests(e2) {
        this._fullRequestReader?.cancel(e2);
        for (const t2 of this._rangeRequestReaders.slice(0))
          t2.cancel(e2);
      }
    };
    __name(PDFWorkerStream, "PDFWorkerStream");
    PDFWorkerStreamReader = class {
      constructor(e2) {
        this._msgHandler = e2, this.onProgress = null, this._contentLength = null, this._isRangeSupported = false, this._isStreamingSupported = false;
        const t2 = this._msgHandler.sendWithStream("GetReader");
        this._reader = t2.getReader(), this._headersReady = this._msgHandler.sendWithPromise("ReaderHeadersReady").then((e3) => {
          this._isStreamingSupported = e3.isStreamingSupported, this._isRangeSupported = e3.isRangeSupported, this._contentLength = e3.contentLength;
        });
      }
      get headersReady() {
        return this._headersReady;
      }
      get contentLength() {
        return this._contentLength;
      }
      get isStreamingSupported() {
        return this._isStreamingSupported;
      }
      get isRangeSupported() {
        return this._isRangeSupported;
      }
      async read() {
        const { value: e2, done: t2 } = await this._reader.read();
        return t2 ? { value: void 0, done: true } : { value: e2.buffer, done: false };
      }
      cancel(e2) {
        this._reader.cancel(e2);
      }
    };
    __name(PDFWorkerStreamReader, "PDFWorkerStreamReader");
    PDFWorkerStreamRangeReader = class {
      constructor(e2, t2, i2) {
        this._msgHandler = i2, this.onProgress = null;
        const a2 = this._msgHandler.sendWithStream("GetRangeReader", { begin: e2, end: t2 });
        this._reader = a2.getReader();
      }
      get isStreamingSupported() {
        return false;
      }
      async read() {
        const { value: e2, done: t2 } = await this._reader.read();
        return t2 ? { value: void 0, done: true } : { value: e2.buffer, done: false };
      }
      cancel(e2) {
        this._reader.cancel(e2);
      }
    };
    __name(PDFWorkerStreamRangeReader, "PDFWorkerStreamRangeReader");
    WorkerTask = class {
      constructor(e2) {
        this.name = e2, this.terminated = false, this._capability = Promise.withResolvers();
      }
      get finished() {
        return this._capability.promise;
      }
      finish() {
        this._capability.resolve();
      }
      terminate() {
        this.terminated = true;
      }
      ensureNotTerminated() {
        if (this.terminated)
          throw new Error("Worker task was terminated");
      }
    };
    __name(WorkerTask, "WorkerTask");
    WorkerMessageHandler = class {
      static {
        "undefined" == typeof window && !e && "undefined" != typeof self && "function" == typeof self.postMessage && "onmessage" in self && this.initializeFromPort(self);
      }
      static setup(e2, t2) {
        let i2 = false;
        e2.on("test", (t3) => {
          i2 || (i2 = true, e2.send("test", t3 instanceof Uint8Array));
        }), e2.on("configure", (e3) => {
          var t3;
          t3 = e3.verbosity, Number.isInteger(t3) && (Kt = t3);
        }), e2.on("GetDocRequest", (e3) => this.createDocumentHandler(e3, t2));
      }
      static createDocumentHandler(e2, t2) {
        let i2, a2 = false, n2 = null;
        const s2 = /* @__PURE__ */ new Set(), r2 = Kt, { docId: o2, apiVersion: l3 } = e2, c2 = "5.4.149";
        if (l3 !== c2)
          throw new Error(`The API version "${l3}" does not match the Worker version "${c2}".`);
        const buildMsg = /* @__PURE__ */ __name((e3, t3) => `The \`${e3}.prototype\` contains unexpected enumerable property "${t3}", thus breaking e.g. \`for...in\` iteration of ${e3}s.`, "buildMsg");
        for (const e3 in {})
          throw new Error(buildMsg("Object", e3));
        for (const e3 in [])
          throw new Error(buildMsg("Array", e3));
        const h2 = o2 + "_worker";
        let d2 = new vl(h2, o2, t2);
        function ensureNotTerminated() {
          if (a2)
            throw new Error("Worker was terminated");
        }
        __name(ensureNotTerminated, "ensureNotTerminated");
        function startWorkerTask(e3) {
          s2.add(e3);
        }
        __name(startWorkerTask, "startWorkerTask");
        function finishWorkerTask(e3) {
          e3.finish(), s2.delete(e3);
        }
        __name(finishWorkerTask, "finishWorkerTask");
        async function loadDocument(e3) {
          await i2.ensureDoc("checkHeader"), await i2.ensureDoc("parseStartXRef"), await i2.ensureDoc("parse", [e3]), await i2.ensureDoc("checkFirstPage", [e3]), await i2.ensureDoc("checkLastPage", [e3]);
          const t3 = await i2.ensureDoc("isPureXfa");
          if (t3) {
            const e4 = new WorkerTask("loadXfaResources");
            startWorkerTask(e4), await i2.ensureDoc("loadXfaResources", [d2, e4]), finishWorkerTask(e4);
          }
          const [a3, n3] = await Promise.all([i2.ensureDoc("numPages"), i2.ensureDoc("fingerprints")]);
          return { numPages: a3, fingerprints: n3, htmlForXfa: t3 ? await i2.ensureDoc("htmlForXfa") : null };
        }
        __name(loadDocument, "loadDocument");
        function setupDoc(e3) {
          function onSuccess(e4) {
            ensureNotTerminated(), d2.send("GetDoc", { pdfInfo: e4 });
          }
          __name(onSuccess, "onSuccess");
          function onFailure(e4) {
            if (ensureNotTerminated(), e4 instanceof Jt) {
              const t3 = new WorkerTask(`PasswordException: response ${e4.code}`);
              startWorkerTask(t3), d2.sendWithPromise("PasswordRequest", e4).then(function({ password: e5 }) {
                finishWorkerTask(t3), i2.updatePassword(e5), pdfManagerReady();
              }).catch(function() {
                finishWorkerTask(t3), d2.send("DocException", e4);
              });
            } else
              d2.send("DocException", wrapReason$1(e4));
          }
          __name(onFailure, "onFailure");
          function pdfManagerReady() {
            ensureNotTerminated(), loadDocument(false).then(onSuccess, function(e4) {
              ensureNotTerminated(), e4 instanceof XRefParseException ? i2.requestLoadedStream().then(function() {
                ensureNotTerminated(), loadDocument(true).then(onSuccess, onFailure);
              }) : onFailure(e4);
            });
          }
          __name(pdfManagerReady, "pdfManagerReady");
          ensureNotTerminated(), async function({ data: e4, password: t3, disableAutoFetch: i3, rangeChunkSize: a3, length: s3, docBaseUrl: r3, enableXfa: l4, evaluatorOptions: c3 }) {
            const h3 = { source: null, disableAutoFetch: i3, docBaseUrl: r3, docId: o2, enableXfa: l4, evaluatorOptions: c3, handler: d2, length: s3, password: t3, rangeChunkSize: a3 };
            if (e4)
              return h3.source = e4, new LocalPdfManager(h3);
            const u2 = new PDFWorkerStream(d2), g2 = u2.getFullReader(), p2 = Promise.withResolvers();
            let f2, m2 = [], b2 = 0;
            return g2.headersReady.then(function() {
              if (g2.isRangeSupported) {
                h3.source = u2, h3.length = g2.contentLength, h3.disableAutoFetch ||= g2.isStreamingSupported, f2 = new NetworkPdfManager(h3);
                for (const e5 of m2)
                  f2.sendProgressiveData(e5);
                m2 = [], p2.resolve(f2), n2 = null;
              }
            }).catch(function(e5) {
              p2.reject(e5), n2 = null;
            }), new Promise(function(e5, t4) {
              const readChunk = /* @__PURE__ */ __name(function({ value: e6, done: i4 }) {
                try {
                  if (ensureNotTerminated(), i4) {
                    if (!f2) {
                      const e7 = arrayBuffersToBytes(m2);
                      m2 = [], s3 && e7.length !== s3 && warn$1("reported HTTP length is different from actual"), h3.source = e7, f2 = new LocalPdfManager(h3), p2.resolve(f2);
                    }
                    return void (n2 = null);
                  }
                  b2 += e6.byteLength, g2.isStreamingSupported || d2.send("DocProgress", { loaded: b2, total: Math.max(b2, g2.contentLength || 0) }), f2 ? f2.sendProgressiveData(e6) : m2.push(e6), g2.read().then(readChunk, t4);
                } catch (e7) {
                  t4(e7);
                }
              }, "readChunk");
              g2.read().then(readChunk, t4);
            }).catch(function(e5) {
              p2.reject(e5), n2 = null;
            }), n2 = /* @__PURE__ */ __name((e5) => {
              u2.cancelAllRequests(e5);
            }, "n"), p2.promise;
          }(e3).then(function(e4) {
            if (a2)
              throw e4.terminate(new ii("Worker was terminated.")), new Error("Worker was terminated");
            i2 = e4, i2.requestLoadedStream(true).then((e5) => {
              d2.send("DataLoaded", { length: e5.bytes.byteLength });
            });
          }).then(pdfManagerReady, onFailure);
        }
        __name(setupDoc, "setupDoc");
        return d2.on("GetPage", function(e3) {
          return i2.getPage(e3.pageIndex).then(function(e4) {
            return Promise.all([i2.ensure(e4, "rotate"), i2.ensure(e4, "ref"), i2.ensure(e4, "userUnit"), i2.ensure(e4, "view")]).then(function([e5, t3, i3, a3]) {
              return { rotate: e5, ref: t3, refStr: t3?.toString() ?? null, userUnit: i3, view: a3 };
            });
          });
        }), d2.on("GetPageIndex", function(e3) {
          const t3 = Ref.get(e3.num, e3.gen);
          return i2.ensureCatalog("getPageIndex", [t3]);
        }), d2.on("GetDestinations", function(e3) {
          return i2.ensureCatalog("destinations");
        }), d2.on("GetDestination", function(e3) {
          return i2.ensureCatalog("getDestination", [e3.id]);
        }), d2.on("GetPageLabels", function(e3) {
          return i2.ensureCatalog("pageLabels");
        }), d2.on("GetPageLayout", function(e3) {
          return i2.ensureCatalog("pageLayout");
        }), d2.on("GetPageMode", function(e3) {
          return i2.ensureCatalog("pageMode");
        }), d2.on("GetViewerPreferences", function(e3) {
          return i2.ensureCatalog("viewerPreferences");
        }), d2.on("GetOpenAction", function(e3) {
          return i2.ensureCatalog("openAction");
        }), d2.on("GetAttachments", function(e3) {
          return i2.ensureCatalog("attachments");
        }), d2.on("GetDocJSActions", function(e3) {
          return i2.ensureCatalog("jsActions");
        }), d2.on("GetPageJSActions", function({ pageIndex: e3 }) {
          return i2.getPage(e3).then((e4) => i2.ensure(e4, "jsActions"));
        }), d2.on("GetAnnotationsByType", async function({ types: e3, pageIndexesToSkip: t3 }) {
          const [a3, n3] = await Promise.all([i2.ensureDoc("numPages"), i2.ensureDoc("annotationGlobals")]);
          if (!n3)
            return null;
          const s3 = [], r3 = [];
          let o3 = null;
          try {
            for (let l4 = 0, c3 = a3; l4 < c3; l4++)
              t3?.has(l4) || (o3 || (o3 = new WorkerTask("GetAnnotationsByType"), startWorkerTask(o3)), s3.push(i2.getPage(l4).then(async (t4) => t4 && t4.collectAnnotationsByType(d2, o3, e3, r3, n3) || [])));
            await Promise.all(s3);
            return (await Promise.all(r3)).filter((e4) => !!e4);
          } finally {
            o3 && finishWorkerTask(o3);
          }
        }), d2.on("GetOutline", function(e3) {
          return i2.ensureCatalog("documentOutline");
        }), d2.on("GetOptionalContentConfig", function(e3) {
          return i2.ensureCatalog("optionalContentConfig");
        }), d2.on("GetPermissions", function(e3) {
          return i2.ensureCatalog("permissions");
        }), d2.on("GetMetadata", function(e3) {
          return Promise.all([i2.ensureDoc("documentInfo"), i2.ensureCatalog("metadata")]);
        }), d2.on("GetMarkInfo", function(e3) {
          return i2.ensureCatalog("markInfo");
        }), d2.on("GetData", function(e3) {
          return i2.requestLoadedStream().then((e4) => e4.bytes);
        }), d2.on("GetAnnotations", function({ pageIndex: e3, intent: t3 }) {
          return i2.getPage(e3).then(function(i3) {
            const a3 = new WorkerTask(`GetAnnotations: page ${e3}`);
            return startWorkerTask(a3), i3.getAnnotationsData(d2, a3, t3).then((e4) => (finishWorkerTask(a3), e4), (e4) => {
              throw finishWorkerTask(a3), e4;
            });
          });
        }), d2.on("GetFieldObjects", function(e3) {
          return i2.ensureDoc("fieldObjects").then((e4) => e4?.allFields || null);
        }), d2.on("HasJSActions", function(e3) {
          return i2.ensureDoc("hasJSActions");
        }), d2.on("GetCalculationOrderIds", function(e3) {
          return i2.ensureDoc("calculationOrderIds");
        }), d2.on("SaveDocument", async function({ isPureXfa: e3, numPages: t3, annotationStorage: a3, filename: n3 }) {
          const s3 = [i2.requestLoadedStream(), i2.ensureCatalog("acroForm"), i2.ensureCatalog("acroFormRef"), i2.ensureDoc("startXRef"), i2.ensureDoc("xref"), i2.ensureDoc("linearization"), i2.ensureCatalog("structTreeRoot")], r3 = new RefSetCache(), o3 = [], l4 = e3 ? null : getNewAnnotationsMap(a3), [c3, h3, u2, g2, p2, f2, m2] = await Promise.all(s3), b2 = p2.trailer.getRaw("Root") || null;
          let y2;
          if (l4) {
            m2 ? await m2.canUpdateStructTree({ pdfManager: i2, newAnnotationsByPage: l4 }) && (y2 = m2) : await StructTreeRoot.canCreateStructureTree({ catalogRef: b2, pdfManager: i2, newAnnotationsByPage: l4 }) && (y2 = null);
            const e4 = AnnotationFactory.generateImages(a3.values(), p2, i2.evaluatorOptions.isOffscreenCanvasSupported), t4 = void 0 === y2 ? o3 : [];
            for (const [a4, n4] of l4)
              t4.push(i2.getPage(a4).then((t5) => {
                const i3 = new WorkerTask(`Save (editor): page ${a4}`);
                return startWorkerTask(i3), t5.saveNewAnnotations(d2, i3, n4, e4, r3).finally(function() {
                  finishWorkerTask(i3);
                });
              }));
            null === y2 ? o3.push(Promise.all(t4).then(async () => {
              await StructTreeRoot.createStructureTree({ newAnnotationsByPage: l4, xref: p2, catalogRef: b2, pdfManager: i2, changes: r3 });
            })) : y2 && o3.push(Promise.all(t4).then(async () => {
              await y2.updateStructureTree({ newAnnotationsByPage: l4, pdfManager: i2, changes: r3 });
            }));
          }
          if (e3)
            o3.push(i2.ensureDoc("serializeXfaData", [a3]));
          else
            for (let e4 = 0; e4 < t3; e4++)
              o3.push(i2.getPage(e4).then(function(t4) {
                const i3 = new WorkerTask(`Save: page ${e4}`);
                return startWorkerTask(i3), t4.save(d2, i3, a3, r3).finally(function() {
                  finishWorkerTask(i3);
                });
              }));
          const w2 = await Promise.all(o3);
          let x2 = null;
          if (e3) {
            if (x2 = w2[0], !x2)
              return c3.bytes;
          } else if (0 === r3.size)
            return c3.bytes;
          const S2 = u2 && h3 instanceof Dict && r3.values().some((e4) => e4.needAppearances), v2 = h3 instanceof Dict && h3.get("XFA") || null;
          let C2 = null, k2 = false;
          if (Array.isArray(v2)) {
            for (let e4 = 0, t4 = v2.length; e4 < t4; e4 += 2)
              "datasets" === v2[e4] && (C2 = v2[e4 + 1], k2 = true);
            null === C2 && (C2 = p2.getNewTemporaryRef());
          } else
            v2 && warn$1("Unsupported XFA type.");
          let T2 = /* @__PURE__ */ Object.create(null);
          if (p2.trailer) {
            const e4 = /* @__PURE__ */ new Map(), t4 = p2.trailer.get("Info") || null;
            if (t4 instanceof Dict)
              for (const [i3, a4] of t4)
                "string" == typeof a4 && e4.set(i3, stringToPDFString(a4));
            T2 = { rootRef: b2, encryptRef: p2.trailer.getRaw("Encrypt") || null, newRef: p2.getNewTemporaryRef(), infoRef: p2.trailer.getRaw("Info") || null, infoMap: e4, fileIds: p2.trailer.get("ID") || null, startXRef: f2 ? g2 : p2.lastXRefStreamPos ?? g2, filename: n3 };
          }
          return incrementalUpdate({ originalData: c3.bytes, xrefInfo: T2, changes: r3, xref: p2, hasXfa: !!v2, xfaDatasetsRef: C2, hasXfaDatasetsEntry: k2, needAppearances: S2, acroFormRef: u2, acroForm: h3, xfaData: x2, useXrefStream: isDict(p2.topDict, "XRef") }).finally(() => {
            p2.resetNewTemporaryRef();
          });
        }), d2.on("GetOperatorList", function(e3, t3) {
          const a3 = e3.pageIndex;
          i2.getPage(a3).then(function(i3) {
            const n3 = new WorkerTask(`GetOperatorList: page ${a3}`);
            startWorkerTask(n3);
            const s3 = r2 >= se ? Date.now() : 0;
            i3.getOperatorList({ handler: d2, sink: t3, task: n3, intent: e3.intent, cacheKey: e3.cacheKey, annotationStorage: e3.annotationStorage, modifiedIds: e3.modifiedIds }).then(function(e4) {
              finishWorkerTask(n3), s3 && info$1(`page=${a3 + 1} - getOperatorList: time=${Date.now() - s3}ms, len=${e4.length}`), t3.close();
            }, function(e4) {
              finishWorkerTask(n3), n3.terminated || t3.error(e4);
            });
          });
        }), d2.on("GetTextContent", function(e3, t3) {
          const { pageIndex: a3, includeMarkedContent: n3, disableNormalization: s3 } = e3;
          i2.getPage(a3).then(function(e4) {
            const i3 = new WorkerTask("GetTextContent: page " + a3);
            startWorkerTask(i3);
            const o3 = r2 >= se ? Date.now() : 0;
            e4.extractTextContent({ handler: d2, task: i3, sink: t3, includeMarkedContent: n3, disableNormalization: s3 }).then(function() {
              finishWorkerTask(i3), o3 && info$1(`page=${a3 + 1} - getTextContent: time=` + (Date.now() - o3) + "ms"), t3.close();
            }, function(e5) {
              finishWorkerTask(i3), i3.terminated || t3.error(e5);
            });
          });
        }), d2.on("GetStructTree", function(e3) {
          return i2.getPage(e3.pageIndex).then((e4) => i2.ensure(e4, "getStructTree"));
        }), d2.on("FontFallback", function(e3) {
          return i2.fontFallback(e3.id, d2);
        }), d2.on("Cleanup", function(e3) {
          return i2.cleanup(true);
        }), d2.on("Terminate", function(e3) {
          a2 = true;
          const t3 = [];
          if (i2) {
            i2.terminate(new ii("Worker was terminated."));
            const e4 = i2.cleanup();
            t3.push(e4), i2 = null;
          } else
            clearGlobalCaches();
          n2?.(new ii("Worker was terminated."));
          for (const e4 of s2)
            t3.push(e4.finished), e4.terminate();
          return Promise.all(t3).then(function() {
            d2.destroy(), d2 = null;
          });
        }), d2.on("Ready", function(t3) {
          setupDoc(e2), e2 = null;
        }), h2;
      }
      static initializeFromPort(e2) {
        const t2 = new vl("worker", "main", e2);
        this.setup(t2, e2), t2.send("ready", null);
      }
    };
    __name(WorkerMessageHandler, "WorkerMessageHandler");
    globalThis.pdfjsWorker = { WorkerMessageHandler };
    Cl = !("object" != typeof process || process + "" != "[object process]" || process.versions.nw || process.versions.electron && process.type && "browser" !== process.type);
    kl = [1e-3, 0, 0, 1e-3, 0, 0];
    Tl = 1.35;
    Il = 1;
    Fl = 2;
    Ml = 4;
    Dl = 16;
    El = 32;
    _l2 = 64;
    Pl = 128;
    Rl = 256;
    Bl = { DISABLE: 0, ENABLE: 1, ENABLE_FORMS: 2, ENABLE_STORAGE: 3 };
    Nl = "pdfjs_internal_editor_";
    Ll = { DISABLE: -1, NONE: 0, FREETEXT: 3, HIGHLIGHT: 9, STAMP: 13, INK: 15, POPUP: 16, SIGNATURE: 101, COMMENT: 102 };
    jl = { RESIZE: 1, CREATE: 2, FREETEXT_SIZE: 11, FREETEXT_COLOR: 12, FREETEXT_OPACITY: 13, INK_COLOR: 21, INK_THICKNESS: 22, INK_OPACITY: 23, HIGHLIGHT_COLOR: 31, HIGHLIGHT_THICKNESS: 32, HIGHLIGHT_FREE: 33, HIGHLIGHT_SHOW_ALL: 34, DRAW_STEP: 41 };
    $l = { PRINT: 4, MODIFY_CONTENTS: 8, COPY: 16, MODIFY_ANNOTATIONS: 32, FILL_INTERACTIVE_FORMS: 256, COPY_FOR_ACCESSIBILITY: 512, ASSEMBLE: 1024, PRINT_HIGH_QUALITY: 2048 };
    Hl = 0;
    ql = 1;
    Xl = 2;
    zl = 3;
    Wl = 3;
    Gl = 4;
    Vl = { GRAYSCALE_1BPP: 1, RGB_24BPP: 2, RGBA_32BPP: 3 };
    Kl = { TEXT: 1, LINK: 2, FREETEXT: 3, LINE: 4, SQUARE: 5, CIRCLE: 6, POLYGON: 7, POLYLINE: 8, HIGHLIGHT: 9, UNDERLINE: 10, SQUIGGLY: 11, STRIKEOUT: 12, STAMP: 13, CARET: 14, INK: 15, POPUP: 16, FILEATTACHMENT: 17, SOUND: 18, MOVIE: 19, WIDGET: 20, SCREEN: 21, PRINTERMARK: 22, TRAPNET: 23, WATERMARK: 24, THREED: 25, REDACT: 26 };
    Yl = 1;
    Jl = 2;
    Zl = 3;
    Ql = 4;
    ec = 5;
    tc = { ERRORS: 0, WARNINGS: 1, INFOS: 5 };
    ic = { dependency: 1, setLineWidth: 2, setLineCap: 3, setLineJoin: 4, setMiterLimit: 5, setDash: 6, setRenderingIntent: 7, setFlatness: 8, setGState: 9, save: 10, restore: 11, transform: 12, moveTo: 13, lineTo: 14, curveTo: 15, curveTo2: 16, curveTo3: 17, closePath: 18, rectangle: 19, stroke: 20, closeStroke: 21, fill: 22, eoFill: 23, fillStroke: 24, eoFillStroke: 25, closeFillStroke: 26, closeEOFillStroke: 27, endPath: 28, clip: 29, eoClip: 30, beginText: 31, endText: 32, setCharSpacing: 33, setWordSpacing: 34, setHScale: 35, setLeading: 36, setFont: 37, setTextRenderingMode: 38, setTextRise: 39, moveText: 40, setLeadingMoveText: 41, setTextMatrix: 42, nextLine: 43, showText: 44, showSpacedText: 45, nextLineShowText: 46, nextLineSetSpacingShowText: 47, setCharWidth: 48, setCharWidthAndBounds: 49, setStrokeColorSpace: 50, setFillColorSpace: 51, setStrokeColor: 52, setStrokeColorN: 53, setFillColor: 54, setFillColorN: 55, setStrokeGray: 56, setFillGray: 57, setStrokeRGBColor: 58, setFillRGBColor: 59, setStrokeCMYKColor: 60, setFillCMYKColor: 61, shadingFill: 62, beginInlineImage: 63, beginImageData: 64, endInlineImage: 65, paintXObject: 66, markPoint: 67, markPointProps: 68, beginMarkedContent: 69, beginMarkedContentProps: 70, endMarkedContent: 71, beginCompat: 72, endCompat: 73, paintFormXObjectBegin: 74, paintFormXObjectEnd: 75, beginGroup: 76, endGroup: 77, beginAnnotation: 80, endAnnotation: 81, paintImageMaskXObject: 83, paintImageMaskXObjectGroup: 84, paintImageXObject: 85, paintInlineImageXObject: 86, paintInlineImageXObjectGroup: 87, paintImageXObjectRepeat: 88, paintImageMaskXObjectRepeat: 89, paintSolidColorImageMask: 90, constructPath: 91, setStrokeTransparent: 92, setFillTransparent: 93, rawFillPath: 94 };
    ac = 0;
    nc = 1;
    sc = 2;
    rc = 3;
    oc = { NEED_PASSWORD: 1, INCORRECT_PASSWORD: 2 };
    lc = tc.WARNINGS;
    __name(setVerbosityLevel, "setVerbosityLevel");
    __name(getVerbosityLevel, "getVerbosityLevel");
    __name(info3, "info");
    __name(warn3, "warn");
    __name(unreachable, "unreachable");
    __name(assert3, "assert");
    __name(createValidAbsoluteUrl, "createValidAbsoluteUrl");
    __name(updateUrlHash, "updateUrlHash");
    __name(shadow, "shadow");
    cc = function() {
      function BaseException(e2, t2) {
        this.message = e2, this.name = t2;
      }
      __name(BaseException, "BaseException");
      return BaseException.prototype = new Error(), BaseException.constructor = BaseException, BaseException;
    }();
    PasswordException = class extends cc {
      constructor(e2, t2) {
        super(e2, "PasswordException"), this.code = t2;
      }
    };
    __name(PasswordException, "PasswordException");
    UnknownErrorException = class extends cc {
      constructor(e2, t2) {
        super(e2, "UnknownErrorException"), this.details = t2;
      }
    };
    __name(UnknownErrorException, "UnknownErrorException");
    InvalidPDFException = class extends cc {
      constructor(e2) {
        super(e2, "InvalidPDFException");
      }
    };
    __name(InvalidPDFException, "InvalidPDFException");
    ResponseException = class extends cc {
      constructor(e2, t2, i2) {
        super(e2, "ResponseException"), this.status = t2, this.missing = i2;
      }
    };
    __name(ResponseException, "ResponseException");
    FormatError = class extends cc {
      constructor(e2) {
        super(e2, "FormatError");
      }
    };
    __name(FormatError, "FormatError");
    AbortException = class extends cc {
      constructor(e2) {
        super(e2, "AbortException");
      }
    };
    __name(AbortException, "AbortException");
    __name(bytesToString, "bytesToString");
    __name(stringToBytes, "stringToBytes");
    util_FeatureTest = class {
      static get isLittleEndian() {
        return shadow(this, "isLittleEndian", function() {
          const e2 = new Uint8Array(4);
          return e2[0] = 1, 1 === new Uint32Array(e2.buffer, 0, 1)[0];
        }());
      }
      static get isEvalSupported() {
        return shadow(this, "isEvalSupported", function() {
          try {
            return new Function(""), true;
          } catch {
            return false;
          }
        }());
      }
      static get isOffscreenCanvasSupported() {
        return shadow(this, "isOffscreenCanvasSupported", "undefined" != typeof OffscreenCanvas);
      }
      static get isImageDecoderSupported() {
        return shadow(this, "isImageDecoderSupported", "undefined" != typeof ImageDecoder);
      }
      static get platform() {
        const { platform: e2, userAgent: t2 } = navigator;
        return shadow(this, "platform", { isAndroid: t2.includes("Android"), isLinux: e2.includes("Linux"), isMac: e2.includes("Mac"), isWindows: e2.includes("Win"), isFirefox: t2.includes("Firefox") });
      }
      static get isCSSRoundSupported() {
        return shadow(this, "isCSSRoundSupported", globalThis.CSS?.supports?.("width: round(1.5px, 1px)"));
      }
    };
    __name(util_FeatureTest, "util_FeatureTest");
    hc = Array.from(Array(256).keys(), (e2) => e2.toString(16).padStart(2, "0"));
    Util = class {
      static makeHexColor(e2, t2, i2) {
        return `#${hc[e2]}${hc[t2]}${hc[i2]}`;
      }
      static domMatrixToTransform(e2) {
        return [e2.a, e2.b, e2.c, e2.d, e2.e, e2.f];
      }
      static scaleMinMax(e2, t2) {
        let i2;
        e2[0] ? (e2[0] < 0 && (i2 = t2[0], t2[0] = t2[2], t2[2] = i2), t2[0] *= e2[0], t2[2] *= e2[0], e2[3] < 0 && (i2 = t2[1], t2[1] = t2[3], t2[3] = i2), t2[1] *= e2[3], t2[3] *= e2[3]) : (i2 = t2[0], t2[0] = t2[1], t2[1] = i2, i2 = t2[2], t2[2] = t2[3], t2[3] = i2, e2[1] < 0 && (i2 = t2[1], t2[1] = t2[3], t2[3] = i2), t2[1] *= e2[1], t2[3] *= e2[1], e2[2] < 0 && (i2 = t2[0], t2[0] = t2[2], t2[2] = i2), t2[0] *= e2[2], t2[2] *= e2[2]), t2[0] += e2[4], t2[1] += e2[5], t2[2] += e2[4], t2[3] += e2[5];
      }
      static transform(e2, t2) {
        return [e2[0] * t2[0] + e2[2] * t2[1], e2[1] * t2[0] + e2[3] * t2[1], e2[0] * t2[2] + e2[2] * t2[3], e2[1] * t2[2] + e2[3] * t2[3], e2[0] * t2[4] + e2[2] * t2[5] + e2[4], e2[1] * t2[4] + e2[3] * t2[5] + e2[5]];
      }
      static multiplyByDOMMatrix(e2, t2) {
        return [e2[0] * t2.a + e2[2] * t2.b, e2[1] * t2.a + e2[3] * t2.b, e2[0] * t2.c + e2[2] * t2.d, e2[1] * t2.c + e2[3] * t2.d, e2[0] * t2.e + e2[2] * t2.f + e2[4], e2[1] * t2.e + e2[3] * t2.f + e2[5]];
      }
      static applyTransform(e2, t2, i2 = 0) {
        const a2 = e2[i2], n2 = e2[i2 + 1];
        e2[i2] = a2 * t2[0] + n2 * t2[2] + t2[4], e2[i2 + 1] = a2 * t2[1] + n2 * t2[3] + t2[5];
      }
      static applyTransformToBezier(e2, t2, i2 = 0) {
        const a2 = t2[0], n2 = t2[1], s2 = t2[2], r2 = t2[3], o2 = t2[4], l3 = t2[5];
        for (let t3 = 0; t3 < 6; t3 += 2) {
          const c2 = e2[i2 + t3], h2 = e2[i2 + t3 + 1];
          e2[i2 + t3] = c2 * a2 + h2 * s2 + o2, e2[i2 + t3 + 1] = c2 * n2 + h2 * r2 + l3;
        }
      }
      static applyInverseTransform(e2, t2) {
        const i2 = e2[0], a2 = e2[1], n2 = t2[0] * t2[3] - t2[1] * t2[2];
        e2[0] = (i2 * t2[3] - a2 * t2[2] + t2[2] * t2[5] - t2[4] * t2[3]) / n2, e2[1] = (-i2 * t2[1] + a2 * t2[0] + t2[4] * t2[1] - t2[5] * t2[0]) / n2;
      }
      static axialAlignedBoundingBox(e2, t2, i2) {
        const a2 = t2[0], n2 = t2[1], s2 = t2[2], r2 = t2[3], o2 = t2[4], l3 = t2[5], c2 = e2[0], h2 = e2[1], d2 = e2[2], u2 = e2[3];
        let g2 = a2 * c2 + o2, p2 = g2, f2 = a2 * d2 + o2, m2 = f2, b2 = r2 * h2 + l3, y2 = b2, w2 = r2 * u2 + l3, x2 = w2;
        if (0 !== n2 || 0 !== s2) {
          const e3 = n2 * c2, t3 = n2 * d2, i3 = s2 * h2, a3 = s2 * u2;
          g2 += i3, m2 += i3, f2 += a3, p2 += a3, b2 += e3, x2 += e3, w2 += t3, y2 += t3;
        }
        i2[0] = Math.min(i2[0], g2, f2, p2, m2), i2[1] = Math.min(i2[1], b2, w2, y2, x2), i2[2] = Math.max(i2[2], g2, f2, p2, m2), i2[3] = Math.max(i2[3], b2, w2, y2, x2);
      }
      static inverseTransform(e2) {
        const t2 = e2[0] * e2[3] - e2[1] * e2[2];
        return [e2[3] / t2, -e2[1] / t2, -e2[2] / t2, e2[0] / t2, (e2[2] * e2[5] - e2[4] * e2[3]) / t2, (e2[4] * e2[1] - e2[5] * e2[0]) / t2];
      }
      static singularValueDecompose2dScale(e2, t2) {
        const i2 = e2[0], a2 = e2[1], n2 = e2[2], s2 = e2[3], r2 = i2 ** 2 + a2 ** 2, o2 = i2 * n2 + a2 * s2, l3 = n2 ** 2 + s2 ** 2, c2 = (r2 + l3) / 2, h2 = Math.sqrt(c2 ** 2 - (r2 * l3 - o2 ** 2));
        t2[0] = Math.sqrt(c2 + h2 || 1), t2[1] = Math.sqrt(c2 - h2 || 1);
      }
      static normalizeRect(e2) {
        const t2 = e2.slice(0);
        return e2[0] > e2[2] && (t2[0] = e2[2], t2[2] = e2[0]), e2[1] > e2[3] && (t2[1] = e2[3], t2[3] = e2[1]), t2;
      }
      static intersect(e2, t2) {
        const i2 = Math.max(Math.min(e2[0], e2[2]), Math.min(t2[0], t2[2])), a2 = Math.min(Math.max(e2[0], e2[2]), Math.max(t2[0], t2[2]));
        if (i2 > a2)
          return null;
        const n2 = Math.max(Math.min(e2[1], e2[3]), Math.min(t2[1], t2[3])), s2 = Math.min(Math.max(e2[1], e2[3]), Math.max(t2[1], t2[3]));
        return n2 > s2 ? null : [i2, n2, a2, s2];
      }
      static pointBoundingBox(e2, t2, i2) {
        i2[0] = Math.min(i2[0], e2), i2[1] = Math.min(i2[1], t2), i2[2] = Math.max(i2[2], e2), i2[3] = Math.max(i2[3], t2);
      }
      static rectBoundingBox(e2, t2, i2, a2, n2) {
        n2[0] = Math.min(n2[0], e2, i2), n2[1] = Math.min(n2[1], t2, a2), n2[2] = Math.max(n2[2], e2, i2), n2[3] = Math.max(n2[3], t2, a2);
      }
      static bezierBoundingBox(e2, t2, i2, a2, n2, s2, r2, o2, l3) {
        l3[0] = Math.min(l3[0], e2, r2), l3[1] = Math.min(l3[1], t2, o2), l3[2] = Math.max(l3[2], e2, r2), l3[3] = Math.max(l3[3], t2, o2), __privateMethod(this, _t3, t_fn2).call(this, e2, i2, n2, r2, t2, a2, s2, o2, 3 * (3 * (i2 - n2) - e2 + r2), 6 * (e2 - 2 * i2 + n2), 3 * (i2 - e2), l3), __privateMethod(this, _t3, t_fn2).call(this, e2, i2, n2, r2, t2, a2, s2, o2, 3 * (3 * (a2 - s2) - t2 + o2), 6 * (t2 - 2 * a2 + s2), 3 * (a2 - t2), l3);
      }
    };
    __name(Util, "Util");
    _e3 = new WeakSet();
    e_fn2 = /* @__PURE__ */ __name(function(e2, t2, i2, a2, n2, s2, r2, o2, l3, c2) {
      if (l3 <= 0 || l3 >= 1)
        return;
      const h2 = 1 - l3, d2 = l3 * l3, u2 = d2 * l3, g2 = h2 * (h2 * (h2 * e2 + 3 * l3 * t2) + 3 * d2 * i2) + u2 * a2, p2 = h2 * (h2 * (h2 * n2 + 3 * l3 * s2) + 3 * d2 * r2) + u2 * o2;
      c2[0] = Math.min(c2[0], g2), c2[1] = Math.min(c2[1], p2), c2[2] = Math.max(c2[2], g2), c2[3] = Math.max(c2[3], p2);
    }, "#e");
    _t3 = new WeakSet();
    t_fn2 = /* @__PURE__ */ __name(function(e2, t2, i2, a2, n2, s2, r2, o2, l3, c2, h2, d2) {
      if (Math.abs(l3) < 1e-12)
        return void (Math.abs(c2) >= 1e-12 && __privateMethod(this, _e3, e_fn2).call(this, e2, t2, i2, a2, n2, s2, r2, o2, -h2 / c2, d2));
      const u2 = c2 ** 2 - 4 * h2 * l3;
      if (u2 < 0)
        return;
      const g2 = Math.sqrt(u2), p2 = 2 * l3;
      __privateMethod(this, _e3, e_fn2).call(this, e2, t2, i2, a2, n2, s2, r2, o2, (-c2 + g2) / p2, d2), __privateMethod(this, _e3, e_fn2).call(this, e2, t2, i2, a2, n2, s2, r2, o2, (-c2 - g2) / p2, d2);
    }, "#t");
    __privateAdd(Util, _e3);
    __privateAdd(Util, _t3);
    dc = null;
    uc = null;
    __name(normalizeUnicode, "normalizeUnicode");
    __name(getUuid, "getUuid");
    gc = "pdfjs_internal_id_";
    __name(MathClamp, "MathClamp");
    __name(toBase64Util, "toBase64Util");
    "function" != typeof Promise.try && (Promise.try = function(e2, ...t2) {
      return new Promise((i2) => {
        i2(e2(...t2));
      });
    }), "function" != typeof Math.sumPrecise && (Math.sumPrecise = function(e2) {
      return e2.reduce((e3, t2) => e3 + t2, 0);
    });
    pc = "http://www.w3.org/2000/svg";
    _PixelsPerInch = class {
    };
    PixelsPerInch = _PixelsPerInch;
    __name(PixelsPerInch, "PixelsPerInch");
    __publicField(PixelsPerInch, "CSS", 96);
    __publicField(PixelsPerInch, "PDF", 72);
    __publicField(PixelsPerInch, "PDF_TO_CSS_UNITS", _PixelsPerInch.CSS / _PixelsPerInch.PDF);
    __name(fetchData, "fetchData");
    PageViewport = class {
      constructor({ viewBox: e2, userUnit: t2, scale: i2, rotation: a2, offsetX: n2 = 0, offsetY: s2 = 0, dontFlip: r2 = false }) {
        this.viewBox = e2, this.userUnit = t2, this.scale = i2, this.rotation = a2, this.offsetX = n2, this.offsetY = s2, i2 *= t2;
        const o2 = (e2[2] + e2[0]) / 2, l3 = (e2[3] + e2[1]) / 2;
        let c2, h2, d2, u2, g2, p2, f2, m2;
        switch ((a2 %= 360) < 0 && (a2 += 360), a2) {
          case 180:
            c2 = -1, h2 = 0, d2 = 0, u2 = 1;
            break;
          case 90:
            c2 = 0, h2 = 1, d2 = 1, u2 = 0;
            break;
          case 270:
            c2 = 0, h2 = -1, d2 = -1, u2 = 0;
            break;
          case 0:
            c2 = 1, h2 = 0, d2 = 0, u2 = -1;
            break;
          default:
            throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
        }
        r2 && (d2 = -d2, u2 = -u2), 0 === c2 ? (g2 = Math.abs(l3 - e2[1]) * i2 + n2, p2 = Math.abs(o2 - e2[0]) * i2 + s2, f2 = (e2[3] - e2[1]) * i2, m2 = (e2[2] - e2[0]) * i2) : (g2 = Math.abs(o2 - e2[0]) * i2 + n2, p2 = Math.abs(l3 - e2[1]) * i2 + s2, f2 = (e2[2] - e2[0]) * i2, m2 = (e2[3] - e2[1]) * i2), this.transform = [c2 * i2, h2 * i2, d2 * i2, u2 * i2, g2 - c2 * i2 * o2 - d2 * i2 * l3, p2 - h2 * i2 * o2 - u2 * i2 * l3], this.width = f2, this.height = m2;
      }
      get rawDims() {
        const e2 = this.viewBox;
        return shadow(this, "rawDims", { pageWidth: e2[2] - e2[0], pageHeight: e2[3] - e2[1], pageX: e2[0], pageY: e2[1] });
      }
      clone({ scale: e2 = this.scale, rotation: t2 = this.rotation, offsetX: i2 = this.offsetX, offsetY: a2 = this.offsetY, dontFlip: n2 = false } = {}) {
        return new PageViewport({ viewBox: this.viewBox.slice(), userUnit: this.userUnit, scale: e2, rotation: t2, offsetX: i2, offsetY: a2, dontFlip: n2 });
      }
      convertToViewportPoint(e2, t2) {
        const i2 = [e2, t2];
        return Util.applyTransform(i2, this.transform), i2;
      }
      convertToViewportRectangle(e2) {
        const t2 = [e2[0], e2[1]];
        Util.applyTransform(t2, this.transform);
        const i2 = [e2[2], e2[3]];
        return Util.applyTransform(i2, this.transform), [t2[0], t2[1], i2[0], i2[1]];
      }
      convertToPdfPoint(e2, t2) {
        const i2 = [e2, t2];
        return Util.applyInverseTransform(i2, this.transform), i2;
      }
    };
    __name(PageViewport, "PageViewport");
    RenderingCancelledException = class extends cc {
      constructor(e2, t2 = 0) {
        super(e2, "RenderingCancelledException"), this.extraDelay = t2;
      }
    };
    __name(RenderingCancelledException, "RenderingCancelledException");
    __name(isDataScheme, "isDataScheme");
    __name(isPdfFile, "isPdfFile");
    __name(getFilenameFromUrl, "getFilenameFromUrl");
    __name(getPdfFilenameFromUrl, "getPdfFilenameFromUrl");
    StatTimer = class {
      started = /* @__PURE__ */ Object.create(null);
      times = [];
      time(e2) {
        e2 in this.started && warn3(`Timer is already running for ${e2}`), this.started[e2] = Date.now();
      }
      timeEnd(e2) {
        e2 in this.started || warn3(`Timer has not been started for ${e2}`), this.times.push({ name: e2, start: this.started[e2], end: Date.now() }), delete this.started[e2];
      }
      toString() {
        const e2 = [];
        let t2 = 0;
        for (const { name: e3 } of this.times)
          t2 = Math.max(e3.length, t2);
        for (const { name: i2, start: a2, end: n2 } of this.times)
          e2.push(`${i2.padEnd(t2)} ${n2 - a2}ms
`);
        return e2.join("");
      }
    };
    __name(StatTimer, "StatTimer");
    __name(isValidFetchUrl, "isValidFetchUrl");
    __name(noContextMenu, "noContextMenu");
    __name(stopEvent, "stopEvent");
    PDFDateString = class {
      static toDateObject(e2) {
        if (e2 instanceof Date)
          return e2;
        if (!e2 || "string" != typeof e2)
          return null;
        __privateGet(this, _it) || __privateSet(this, _it, new RegExp("^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?"));
        const t2 = __privateGet(this, _it).exec(e2);
        if (!t2)
          return null;
        const i2 = parseInt(t2[1], 10);
        let a2 = parseInt(t2[2], 10);
        a2 = a2 >= 1 && a2 <= 12 ? a2 - 1 : 0;
        let n2 = parseInt(t2[3], 10);
        n2 = n2 >= 1 && n2 <= 31 ? n2 : 1;
        let s2 = parseInt(t2[4], 10);
        s2 = s2 >= 0 && s2 <= 23 ? s2 : 0;
        let r2 = parseInt(t2[5], 10);
        r2 = r2 >= 0 && r2 <= 59 ? r2 : 0;
        let o2 = parseInt(t2[6], 10);
        o2 = o2 >= 0 && o2 <= 59 ? o2 : 0;
        const l3 = t2[7] || "Z";
        let c2 = parseInt(t2[8], 10);
        c2 = c2 >= 0 && c2 <= 23 ? c2 : 0;
        let h2 = parseInt(t2[9], 10) || 0;
        return h2 = h2 >= 0 && h2 <= 59 ? h2 : 0, "-" === l3 ? (s2 += c2, r2 += h2) : "+" === l3 && (s2 -= c2, r2 -= h2), new Date(Date.UTC(i2, a2, n2, s2, r2, o2));
      }
    };
    __name(PDFDateString, "PDFDateString");
    _it = new WeakMap();
    __privateAdd(PDFDateString, _it, void 0);
    __name(getXfaPageViewport, "getXfaPageViewport");
    __name(getRGB, "getRGB");
    __name(getCurrentTransform, "getCurrentTransform");
    __name(getCurrentTransformInverse, "getCurrentTransformInverse");
    __name(setLayerDimensions, "setLayerDimensions");
    OutputScale = class {
      constructor() {
        const { pixelRatio: e2 } = OutputScale;
        this.sx = e2, this.sy = e2;
      }
      get scaled() {
        return 1 !== this.sx || 1 !== this.sy;
      }
      get symmetric() {
        return this.sx === this.sy;
      }
      limitCanvas(e2, t2, i2, a2, n2 = -1) {
        let s2 = 1 / 0, r2 = 1 / 0, o2 = 1 / 0;
        (i2 = OutputScale.capPixels(i2, n2)) > 0 && (s2 = Math.sqrt(i2 / (e2 * t2))), -1 !== a2 && (r2 = a2 / e2, o2 = a2 / t2);
        const l3 = Math.min(s2, r2, o2);
        return (this.sx > l3 || this.sy > l3) && (this.sx = l3, this.sy = l3, true);
      }
      static get pixelRatio() {
        return globalThis.devicePixelRatio || 1;
      }
      static capPixels(e2, t2) {
        if (t2 >= 0) {
          const i2 = Math.ceil(window.screen.availWidth * window.screen.availHeight * this.pixelRatio ** 2 * (1 + t2 / 100));
          return e2 > 0 ? Math.min(e2, i2) : i2;
        }
        return e2;
      }
    };
    __name(OutputScale, "OutputScale");
    fc = ["image/apng", "image/avif", "image/bmp", "image/gif", "image/jpeg", "image/png", "image/svg+xml", "image/webp", "image/x-icon"];
    _EditorToolbar = class {
      constructor(e2) {
        __privateAdd(this, _ut);
        __privateAdd(this, _gt);
        __privateAdd(this, _pt);
        __privateAdd(this, _ft);
        __privateAdd(this, _at, null);
        __privateAdd(this, _nt, null);
        __privateAdd(this, _st, void 0);
        __privateAdd(this, _rt, null);
        __privateAdd(this, _ot, null);
        __privateAdd(this, _lt, null);
        __privateAdd(this, _ct, null);
        __privateSet(this, _st, e2), __privateGet(_EditorToolbar, _ht) || __privateSet(_EditorToolbar, _ht, Object.freeze({ freetext: "pdfjs-editor-remove-freetext-button", highlight: "pdfjs-editor-remove-highlight-button", ink: "pdfjs-editor-remove-ink-button", stamp: "pdfjs-editor-remove-stamp-button", signature: "pdfjs-editor-remove-signature-button" }));
      }
      render() {
        const e2 = __privateSet(this, _at, document.createElement("div"));
        e2.classList.add("editToolbar", "hidden"), e2.setAttribute("role", "toolbar");
        const t2 = __privateGet(this, _st)._uiManager._signal;
        t2 instanceof AbortSignal && !t2.aborted && (e2.addEventListener("contextmenu", noContextMenu, { signal: t2 }), e2.addEventListener("pointerdown", __privateMethod(_EditorToolbar, _dt, dt_fn), { signal: t2 }));
        const i2 = __privateSet(this, _rt, document.createElement("div"));
        i2.className = "buttons", e2.append(i2);
        const a2 = __privateGet(this, _st).toolbarPosition;
        if (a2) {
          const { style: t3 } = e2, i3 = "ltr" === __privateGet(this, _st)._uiManager.direction ? 1 - a2[0] : a2[0];
          t3.insetInlineEnd = 100 * i3 + "%", t3.top = `calc(${100 * a2[1]}% + var(--editor-toolbar-vert-offset))`;
        }
        return e2;
      }
      get div() {
        return __privateGet(this, _at);
      }
      hide() {
        __privateGet(this, _at).classList.add("hidden"), __privateGet(this, _nt)?.hideDropdown();
      }
      show() {
        __privateGet(this, _at).classList.remove("hidden"), __privateGet(this, _ot)?.shown(), __privateGet(this, _lt)?.shown();
      }
      addDeleteButton() {
        const { editorType: e2, _uiManager: t2 } = __privateGet(this, _st), i2 = document.createElement("button");
        i2.classList.add("basic", "deleteButton"), i2.tabIndex = 0, i2.setAttribute("data-l10n-id", __privateGet(_EditorToolbar, _ht)[e2]), __privateMethod(this, _pt, pt_fn).call(this, i2) && i2.addEventListener("click", (e3) => {
          t2.delete();
        }, { signal: t2._signal }), __privateGet(this, _rt).append(i2);
      }
      async addAltText(e2) {
        const t2 = await e2.render();
        __privateMethod(this, _pt, pt_fn).call(this, t2), __privateGet(this, _rt).append(t2, __privateGet(this, _ft, ft_get)), __privateSet(this, _ot, e2);
      }
      addComment(e2) {
        if (__privateGet(this, _lt))
          return;
        const t2 = e2.render();
        t2 && (__privateMethod(this, _pt, pt_fn).call(this, t2), __privateGet(this, _rt).append(t2, __privateGet(this, _ft, ft_get)), __privateSet(this, _lt, e2), e2.toolbar = this);
      }
      addColorPicker(e2) {
        if (__privateGet(this, _nt))
          return;
        __privateSet(this, _nt, e2);
        const t2 = e2.renderButton();
        __privateMethod(this, _pt, pt_fn).call(this, t2), __privateGet(this, _rt).append(t2, __privateGet(this, _ft, ft_get));
      }
      async addEditSignatureButton(e2) {
        const t2 = __privateSet(this, _ct, await e2.renderEditButton(__privateGet(this, _st)));
        __privateMethod(this, _pt, pt_fn).call(this, t2), __privateGet(this, _rt).append(t2, __privateGet(this, _ft, ft_get));
      }
      async addButton(e2, t2) {
        switch (e2) {
          case "colorPicker":
            this.addColorPicker(t2);
            break;
          case "altText":
            await this.addAltText(t2);
            break;
          case "editSignature":
            await this.addEditSignatureButton(t2);
            break;
          case "delete":
            this.addDeleteButton();
            break;
          case "comment":
            this.addComment(t2);
        }
      }
      updateEditSignatureButton(e2) {
        __privateGet(this, _ct) && (__privateGet(this, _ct).title = e2);
      }
      remove() {
        __privateGet(this, _at).remove(), __privateGet(this, _nt)?.destroy(), __privateSet(this, _nt, null);
      }
    };
    EditorToolbar = _EditorToolbar;
    __name(EditorToolbar, "EditorToolbar");
    _at = new WeakMap();
    _nt = new WeakMap();
    _st = new WeakMap();
    _rt = new WeakMap();
    _ot = new WeakMap();
    _lt = new WeakMap();
    _ct = new WeakMap();
    _ht = new WeakMap();
    _dt = new WeakSet();
    dt_fn = /* @__PURE__ */ __name(function(e2) {
      e2.stopPropagation();
    }, "#dt");
    _ut = new WeakSet();
    ut_fn = /* @__PURE__ */ __name(function(e2) {
      __privateGet(this, _st)._focusEventsAllowed = false, stopEvent(e2);
    }, "#ut");
    _gt = new WeakSet();
    gt_fn = /* @__PURE__ */ __name(function(e2) {
      __privateGet(this, _st)._focusEventsAllowed = true, stopEvent(e2);
    }, "#gt");
    _pt = new WeakSet();
    pt_fn = /* @__PURE__ */ __name(function(e2) {
      const t2 = __privateGet(this, _st)._uiManager._signal;
      return t2 instanceof AbortSignal && !t2.aborted && (e2.addEventListener("focusin", __privateMethod(this, _ut, ut_fn).bind(this), { capture: true, signal: t2 }), e2.addEventListener("focusout", __privateMethod(this, _gt, gt_fn).bind(this), { capture: true, signal: t2 }), e2.addEventListener("contextmenu", noContextMenu, { signal: t2 }), true);
    }, "#pt");
    _ft = new WeakSet();
    ft_get = /* @__PURE__ */ __name(function() {
      const e2 = document.createElement("div");
      return e2.className = "divider", e2;
    }, "#ft");
    __privateAdd(EditorToolbar, _dt);
    __privateAdd(EditorToolbar, _ht, null);
    FloatingToolbar = class {
      #rt = null;
      #at = null;
      #mt;
      constructor(e2) {
        this.#mt = e2;
      }
      #bt() {
        const e2 = this.#at = document.createElement("div");
        e2.className = "editToolbar", e2.setAttribute("role", "toolbar");
        const t2 = this.#mt._signal;
        t2 instanceof AbortSignal && !t2.aborted && e2.addEventListener("contextmenu", noContextMenu, { signal: t2 });
        const i2 = this.#rt = document.createElement("div");
        return i2.className = "buttons", e2.append(i2), this.#mt.hasCommentManager() && this.#yt("commentButton", "pdfjs-comment-floating-button", "pdfjs-comment-floating-button-label", () => {
          this.#mt.commentSelection("floating_button");
        }), this.#yt("highlightButton", "pdfjs-highlight-floating-button1", "pdfjs-highlight-floating-button-label", () => {
          this.#mt.highlightSelection("floating_button");
        }), e2;
      }
      #wt(e2, t2) {
        let i2 = 0, a2 = 0;
        for (const n2 of e2) {
          const e3 = n2.y + n2.height;
          if (e3 < i2)
            continue;
          const s2 = n2.x + (t2 ? n2.width : 0);
          e3 > i2 ? (a2 = s2, i2 = e3) : t2 ? s2 > a2 && (a2 = s2) : s2 < a2 && (a2 = s2);
        }
        return [t2 ? 1 - a2 : a2, i2];
      }
      show(e2, t2, i2) {
        const [a2, n2] = this.#wt(t2, i2), { style: s2 } = this.#at ||= this.#bt();
        e2.append(this.#at), s2.insetInlineEnd = 100 * a2 + "%", s2.top = `calc(${100 * n2}% + var(--editor-toolbar-vert-offset))`;
      }
      hide() {
        this.#at.remove();
      }
      #yt(e2, t2, i2, a2) {
        const n2 = document.createElement("button");
        n2.classList.add("basic", e2), n2.tabIndex = 0, n2.setAttribute("data-l10n-id", t2);
        const s2 = document.createElement("span");
        n2.append(s2), s2.className = "visuallyHidden", s2.setAttribute("data-l10n-id", i2);
        const r2 = this.#mt._signal;
        r2 instanceof AbortSignal && !r2.aborted && (n2.addEventListener("contextmenu", noContextMenu, { signal: r2 }), n2.addEventListener("click", a2, { signal: r2 })), this.#rt.append(n2);
      }
    };
    __name(FloatingToolbar, "FloatingToolbar");
    __name(bindEvents, "bindEvents");
    IdManager = class {
      #At = 0;
      get id() {
        return `${Nl}${this.#At++}`;
      }
    };
    __name(IdManager, "IdManager");
    ImageManager = class {
      #xt = getUuid();
      #At = 0;
      #St = null;
      static get _isSVGFittingCanvas() {
        const e2 = new OffscreenCanvas(1, 3).getContext("2d", { willReadFrequently: true }), t2 = new Image();
        t2.src = 'data:image/svg+xml;charset=UTF-8,<svg viewBox="0 0 1 1" width="1" height="1" xmlns="http://www.w3.org/2000/svg"><rect width="1" height="1" style="fill:red;"/></svg>';
        return shadow(this, "_isSVGFittingCanvas", t2.decode().then(() => (e2.drawImage(t2, 0, 0, 1, 1, 0, 0, 1, 3), 0 === new Uint32Array(e2.getImageData(0, 0, 1, 1).data.buffer)[0])));
      }
      async #vt(e2, t2) {
        this.#St ||= /* @__PURE__ */ new Map();
        let i2 = this.#St.get(e2);
        if (null === i2)
          return null;
        if (i2?.bitmap)
          return i2.refCounter += 1, i2;
        try {
          let e3;
          if (i2 ||= { bitmap: null, id: `image_${this.#xt}_${this.#At++}`, refCounter: 0, isSvg: false }, "string" == typeof t2 ? (i2.url = t2, e3 = await fetchData(t2, "blob")) : t2 instanceof File ? e3 = i2.file = t2 : t2 instanceof Blob && (e3 = t2), "image/svg+xml" === e3.type) {
            const t3 = ImageManager._isSVGFittingCanvas, a2 = new FileReader(), n2 = new Image(), s2 = new Promise((e4, s3) => {
              n2.onload = () => {
                i2.bitmap = n2, i2.isSvg = true, e4();
              }, a2.onload = async () => {
                const e5 = i2.svgUrl = a2.result;
                n2.src = await t3 ? `${e5}#svgView(preserveAspectRatio(none))` : e5;
              }, n2.onerror = a2.onerror = s3;
            });
            a2.readAsDataURL(e3), await s2;
          } else
            i2.bitmap = await createImageBitmap(e3);
          i2.refCounter = 1;
        } catch (e3) {
          warn3(e3), i2 = null;
        }
        return this.#St.set(e2, i2), i2 && this.#St.set(i2.id, i2), i2;
      }
      async getFromFile(e2) {
        const { lastModified: t2, name: i2, size: a2, type: n2 } = e2;
        return this.#vt(`${t2}_${i2}_${a2}_${n2}`, e2);
      }
      async getFromUrl(e2) {
        return this.#vt(e2, e2);
      }
      async getFromBlob(e2, t2) {
        const i2 = await t2;
        return this.#vt(e2, i2);
      }
      async getFromId(e2) {
        this.#St ||= /* @__PURE__ */ new Map();
        const t2 = this.#St.get(e2);
        if (!t2)
          return null;
        if (t2.bitmap)
          return t2.refCounter += 1, t2;
        if (t2.file)
          return this.getFromFile(t2.file);
        if (t2.blobPromise) {
          const { blobPromise: e3 } = t2;
          return delete t2.blobPromise, this.getFromBlob(t2.id, e3);
        }
        return this.getFromUrl(t2.url);
      }
      getFromCanvas(e2, t2) {
        this.#St ||= /* @__PURE__ */ new Map();
        let i2 = this.#St.get(e2);
        if (i2?.bitmap)
          return i2.refCounter += 1, i2;
        const a2 = new OffscreenCanvas(t2.width, t2.height);
        return a2.getContext("2d").drawImage(t2, 0, 0), i2 = { bitmap: a2.transferToImageBitmap(), id: `image_${this.#xt}_${this.#At++}`, refCounter: 1, isSvg: false }, this.#St.set(e2, i2), this.#St.set(i2.id, i2), i2;
      }
      getSvgUrl(e2) {
        const t2 = this.#St.get(e2);
        return t2?.isSvg ? t2.svgUrl : null;
      }
      deleteId(e2) {
        this.#St ||= /* @__PURE__ */ new Map();
        const t2 = this.#St.get(e2);
        if (!t2)
          return;
        if (t2.refCounter -= 1, 0 !== t2.refCounter)
          return;
        const { bitmap: i2 } = t2;
        if (!t2.url && !t2.file) {
          const e3 = new OffscreenCanvas(i2.width, i2.height);
          e3.getContext("bitmaprenderer").transferFromImageBitmap(i2), t2.blobPromise = e3.convertToBlob();
        }
        i2.close?.(), t2.bitmap = null;
      }
      isValidId(e2) {
        return e2.startsWith(`image_${this.#xt}_`);
      }
    };
    __name(ImageManager, "ImageManager");
    CommandManager = class {
      #Ct = [];
      #kt = false;
      #Tt;
      #It = -1;
      constructor(e2 = 128) {
        this.#Tt = e2;
      }
      add({ cmd: e2, undo: t2, post: i2, mustExec: a2, type: n2 = NaN, overwriteIfSameType: s2 = false, keepUndo: r2 = false }) {
        if (a2 && e2(), this.#kt)
          return;
        const o2 = { cmd: e2, undo: t2, post: i2, type: n2 };
        if (-1 === this.#It)
          return this.#Ct.length > 0 && (this.#Ct.length = 0), this.#It = 0, void this.#Ct.push(o2);
        if (s2 && this.#Ct[this.#It].type === n2)
          return r2 && (o2.undo = this.#Ct[this.#It].undo), void (this.#Ct[this.#It] = o2);
        const l3 = this.#It + 1;
        l3 === this.#Tt ? this.#Ct.splice(0, 1) : (this.#It = l3, l3 < this.#Ct.length && this.#Ct.splice(l3)), this.#Ct.push(o2);
      }
      undo() {
        if (-1 === this.#It)
          return;
        this.#kt = true;
        const { undo: e2, post: t2 } = this.#Ct[this.#It];
        e2(), t2?.(), this.#kt = false, this.#It -= 1;
      }
      redo() {
        if (this.#It < this.#Ct.length - 1) {
          this.#It += 1, this.#kt = true;
          const { cmd: e2, post: t2 } = this.#Ct[this.#It];
          e2(), t2?.(), this.#kt = false;
        }
      }
      hasSomethingToUndo() {
        return -1 !== this.#It;
      }
      hasSomethingToRedo() {
        return this.#It < this.#Ct.length - 1;
      }
      cleanType(e2) {
        if (-1 !== this.#It) {
          for (let t2 = this.#It; t2 >= 0; t2--)
            if (this.#Ct[t2].type !== e2)
              return this.#Ct.splice(t2 + 1, this.#It - t2), void (this.#It = t2);
          this.#Ct.length = 0, this.#It = -1;
        }
      }
      destroy() {
        this.#Ct = null;
      }
    };
    __name(CommandManager, "CommandManager");
    KeyboardManager = class {
      constructor(e2) {
        this.buffer = [], this.callbacks = /* @__PURE__ */ new Map(), this.allKeys = /* @__PURE__ */ new Set();
        const { isMac: t2 } = util_FeatureTest.platform;
        for (const [i2, a2, n2 = {}] of e2)
          for (const e3 of i2) {
            const i3 = e3.startsWith("mac+");
            t2 && i3 ? (this.callbacks.set(e3.slice(4), { callback: a2, options: n2 }), this.allKeys.add(e3.split("+").at(-1))) : t2 || i3 || (this.callbacks.set(e3, { callback: a2, options: n2 }), this.allKeys.add(e3.split("+").at(-1)));
          }
      }
      #Ft(e2) {
        e2.altKey && this.buffer.push("alt"), e2.ctrlKey && this.buffer.push("ctrl"), e2.metaKey && this.buffer.push("meta"), e2.shiftKey && this.buffer.push("shift"), this.buffer.push(e2.key);
        const t2 = this.buffer.join("+");
        return this.buffer.length = 0, t2;
      }
      exec(e2, t2) {
        if (!this.allKeys.has(t2.key))
          return;
        const i2 = this.callbacks.get(this.#Ft(t2));
        if (!i2)
          return;
        const { callback: a2, options: { bubbles: n2 = false, args: s2 = [], checker: r2 = null } } = i2;
        r2 && !r2(e2, t2) || (a2.bind(e2, ...s2, t2)(), n2 || stopEvent(t2));
      }
    };
    __name(KeyboardManager, "KeyboardManager");
    _ColorManager = class {
      get _colors() {
        const e2 = /* @__PURE__ */ new Map([["CanvasText", null], ["Canvas", null]]);
        return function(e3) {
          const t2 = document.createElement("span");
          t2.style.visibility = "hidden", t2.style.colorScheme = "only light", document.body.append(t2);
          for (const i2 of e3.keys()) {
            t2.style.color = i2;
            const a2 = window.getComputedStyle(t2).color;
            e3.set(i2, getRGB(a2));
          }
          t2.remove();
        }(e2), shadow(this, "_colors", e2);
      }
      convert(e2) {
        const t2 = getRGB(e2);
        if (!window.matchMedia("(forced-colors: active)").matches)
          return t2;
        for (const [e3, i2] of this._colors)
          if (i2.every((e4, i3) => e4 === t2[i3]))
            return _ColorManager._colorsMapping.get(e3);
        return t2;
      }
      getHexCode(e2) {
        const t2 = this._colors.get(e2);
        return t2 ? Util.makeHexColor(...t2) : e2;
      }
    };
    ColorManager = _ColorManager;
    __name(ColorManager, "ColorManager");
    __publicField(ColorManager, "_colorsMapping", /* @__PURE__ */ new Map([["CanvasText", [0, 0, 0]], ["Canvas", [255, 255, 255]]]));
    _AnnotationEditorUIManager = class {
      constructor(e2, t2, i2, a2, n2, s2, r2, o2, l3, c2, h2, d2, u2, g2, p2, f2) {
        __privateAdd(this, _Ii);
        __privateAdd(this, _Fi);
        __privateAdd(this, _Mi);
        __privateAdd(this, _Di);
        __privateAdd(this, _Oi);
        __privateAdd(this, _Ci);
        __privateAdd(this, __i);
        __privateAdd(this, _Pi);
        __privateAdd(this, _Ti);
        __privateAdd(this, _Ri);
        __privateAdd(this, _Bi);
        __privateAdd(this, _Ni);
        __privateAdd(this, _ki);
        __privateAdd(this, _Ei);
        __privateAdd(this, _ji);
        __privateAdd(this, _qi);
        __privateAdd(this, _Hi);
        __privateAdd(this, _Li);
        __privateAdd(this, _Xi);
        __privateAdd(this, _$i);
        __privateAdd(this, _Ui);
        __privateAdd(this, _Mt, new AbortController());
        __privateAdd(this, _Dt, null);
        __privateAdd(this, _Et, null);
        __privateAdd(this, _Ot, /* @__PURE__ */ new Map());
        __privateAdd(this, __t, /* @__PURE__ */ new Map());
        __privateAdd(this, _Pt, null);
        __privateAdd(this, _Rt, null);
        __privateAdd(this, _Bt, null);
        __privateAdd(this, _Nt, new CommandManager());
        __privateAdd(this, _Lt, null);
        __privateAdd(this, _Ut, null);
        __privateAdd(this, _jt, null);
        __privateAdd(this, _$t, 0);
        __privateAdd(this, _Ht, /* @__PURE__ */ new Set());
        __privateAdd(this, _qt, null);
        __privateAdd(this, _Xt, null);
        __privateAdd(this, _zt, /* @__PURE__ */ new Set());
        __publicField(this, "_editorUndoBar", null);
        __privateAdd(this, _Wt, false);
        __privateAdd(this, _Gt, false);
        __privateAdd(this, _Vt, false);
        __privateAdd(this, _Kt, null);
        __privateAdd(this, _Yt, null);
        __privateAdd(this, _Jt, null);
        __privateAdd(this, _Zt, null);
        __privateAdd(this, _Qt, false);
        __privateAdd(this, _ei, null);
        __privateAdd(this, _ti, new IdManager());
        __privateAdd(this, _ii, false);
        __privateAdd(this, _ai, false);
        __privateAdd(this, _ni, false);
        __privateAdd(this, _si, null);
        __privateAdd(this, _ri, null);
        __privateAdd(this, _oi, null);
        __privateAdd(this, _li, null);
        __privateAdd(this, _ci, null);
        __privateAdd(this, _hi, Ll.NONE);
        __privateAdd(this, _di, /* @__PURE__ */ new Set());
        __privateAdd(this, _ui, null);
        __privateAdd(this, _gi, null);
        __privateAdd(this, _pi, null);
        __privateAdd(this, _fi, null);
        __privateAdd(this, _mi, null);
        __privateAdd(this, _bi, { isEditing: false, isEmpty: true, hasSomethingToUndo: false, hasSomethingToRedo: false, hasSelectedEditor: false, hasSelectedText: false });
        __privateAdd(this, _yi, [0, 0]);
        __privateAdd(this, _wi, null);
        __privateAdd(this, _Ai, null);
        __privateAdd(this, _xi, null);
        __privateAdd(this, _Si, null);
        __privateAdd(this, _vi, null);
        const m2 = this._signal = __privateGet(this, _Mt).signal;
        __privateSet(this, _Ai, e2), __privateSet(this, _xi, t2), __privateSet(this, _Si, i2), __privateSet(this, _Pt, a2), __privateSet(this, _Lt, n2), __privateSet(this, _gi, s2), __privateSet(this, _mi, o2), this._eventBus = r2, r2._on("editingaction", this.onEditingAction.bind(this), { signal: m2 }), r2._on("pagechanging", this.onPageChanging.bind(this), { signal: m2 }), r2._on("scalechanging", this.onScaleChanging.bind(this), { signal: m2 }), r2._on("rotationchanging", this.onRotationChanging.bind(this), { signal: m2 }), r2._on("setpreference", this.onSetPreference.bind(this), { signal: m2 }), r2._on("switchannotationeditorparams", (e3) => this.updateParams(e3.type, e3.value), { signal: m2 }), window.addEventListener("pointerdown", () => {
          __privateSet(this, _ai, true);
        }, { capture: true, signal: m2 }), window.addEventListener("pointerup", () => {
          __privateSet(this, _ai, false);
        }, { capture: true, signal: m2 }), __privateMethod(this, _Ci, Ci_fn).call(this), __privateMethod(this, _ki, ki_fn).call(this), __privateMethod(this, _Ti, Ti_fn).call(this), __privateSet(this, _Rt, o2.annotationStorage), __privateSet(this, _Kt, o2.filterFactory), __privateSet(this, _pi, l3), __privateSet(this, _Zt, c2 || null), __privateSet(this, _Wt, h2), __privateSet(this, _Gt, d2), __privateSet(this, _Vt, u2), __privateSet(this, _ci, g2 || null), this.viewParameters = { realScale: PixelsPerInch.PDF_TO_CSS_UNITS, rotation: 0 }, this.isShiftKeyDown = false, this._editorUndoBar = p2 || null, this._supportsPinchToZoom = false !== f2;
      }
      static get _keyboardManager() {
        const e2 = _AnnotationEditorUIManager.prototype, arrowChecker = /* @__PURE__ */ __name((e3) => __privateGet(e3, _Ai).contains(document.activeElement) && "BUTTON" !== document.activeElement.tagName && e3.hasSomethingToControl(), "arrowChecker"), textInputChecker = /* @__PURE__ */ __name((e3, { target: t3 }) => {
          if (t3 instanceof HTMLInputElement) {
            const { type: e4 } = t3;
            return "text" !== e4 && "number" !== e4;
          }
          return true;
        }, "textInputChecker"), t2 = this.TRANSLATE_SMALL, i2 = this.TRANSLATE_BIG;
        return shadow(this, "_keyboardManager", new KeyboardManager([[["ctrl+a", "mac+meta+a"], e2.selectAll, { checker: textInputChecker }], [["ctrl+z", "mac+meta+z"], e2.undo, { checker: textInputChecker }], [["ctrl+y", "ctrl+shift+z", "mac+meta+shift+z", "ctrl+shift+Z", "mac+meta+shift+Z"], e2.redo, { checker: textInputChecker }], [["Backspace", "alt+Backspace", "ctrl+Backspace", "shift+Backspace", "mac+Backspace", "mac+alt+Backspace", "mac+ctrl+Backspace", "Delete", "ctrl+Delete", "shift+Delete", "mac+Delete"], e2.delete, { checker: textInputChecker }], [["Enter", "mac+Enter"], e2.addNewEditorFromKeyboard, { checker: (e3, { target: t3 }) => !(t3 instanceof HTMLButtonElement) && __privateGet(e3, _Ai).contains(t3) && !e3.isEnterHandled }], [[" ", "mac+ "], e2.addNewEditorFromKeyboard, { checker: (e3, { target: t3 }) => !(t3 instanceof HTMLButtonElement) && __privateGet(e3, _Ai).contains(document.activeElement) }], [["Escape", "mac+Escape"], e2.unselectAll], [["ArrowLeft", "mac+ArrowLeft"], e2.translateSelectedEditors, { args: [-t2, 0], checker: arrowChecker }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], e2.translateSelectedEditors, { args: [-i2, 0], checker: arrowChecker }], [["ArrowRight", "mac+ArrowRight"], e2.translateSelectedEditors, { args: [t2, 0], checker: arrowChecker }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], e2.translateSelectedEditors, { args: [i2, 0], checker: arrowChecker }], [["ArrowUp", "mac+ArrowUp"], e2.translateSelectedEditors, { args: [0, -t2], checker: arrowChecker }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], e2.translateSelectedEditors, { args: [0, -i2], checker: arrowChecker }], [["ArrowDown", "mac+ArrowDown"], e2.translateSelectedEditors, { args: [0, t2], checker: arrowChecker }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], e2.translateSelectedEditors, { args: [0, i2], checker: arrowChecker }]]));
      }
      destroy() {
        __privateGet(this, _vi)?.resolve(), __privateSet(this, _vi, null), __privateGet(this, _Mt)?.abort(), __privateSet(this, _Mt, null), this._signal = null;
        for (const e2 of __privateGet(this, __t).values())
          e2.destroy();
        __privateGet(this, __t).clear(), __privateGet(this, _Ot).clear(), __privateGet(this, _zt).clear(), __privateGet(this, _li)?.clear(), __privateSet(this, _Dt, null), __privateGet(this, _di).clear(), __privateGet(this, _Nt).destroy(), __privateGet(this, _Pt)?.destroy(), __privateGet(this, _Lt)?.destroy(), __privateGet(this, _gi)?.destroy(), __privateGet(this, _ei)?.hide(), __privateSet(this, _ei, null), __privateGet(this, _oi)?.destroy(), __privateSet(this, _oi, null), __privateSet(this, _Et, null), __privateGet(this, _Yt) && (clearTimeout(__privateGet(this, _Yt)), __privateSet(this, _Yt, null)), __privateGet(this, _wi) && (clearTimeout(__privateGet(this, _wi)), __privateSet(this, _wi, null)), this._editorUndoBar?.destroy(), __privateSet(this, _mi, null);
      }
      combinedSignal(e2) {
        return AbortSignal.any([this._signal, e2.signal]);
      }
      get mlManager() {
        return __privateGet(this, _ci);
      }
      get useNewAltTextFlow() {
        return __privateGet(this, _Gt);
      }
      get useNewAltTextWhenAddingImage() {
        return __privateGet(this, _Vt);
      }
      get hcmFilter() {
        return shadow(this, "hcmFilter", __privateGet(this, _pi) ? __privateGet(this, _Kt).addHCMFilter(__privateGet(this, _pi).foreground, __privateGet(this, _pi).background) : "none");
      }
      get direction() {
        return shadow(this, "direction", getComputedStyle(__privateGet(this, _Ai)).direction);
      }
      get _highlightColors() {
        return shadow(this, "_highlightColors", __privateGet(this, _Zt) ? new Map(__privateGet(this, _Zt).split(",").map((e2) => ((e2 = e2.split("=").map((e3) => e3.trim()))[1] = e2[1].toUpperCase(), e2))) : null);
      }
      get highlightColors() {
        const { _highlightColors: e2 } = this;
        if (!e2)
          return shadow(this, "highlightColors", null);
        const t2 = /* @__PURE__ */ new Map(), i2 = !!__privateGet(this, _pi);
        for (const [a2, n2] of e2) {
          const e3 = a2.endsWith("_HCM");
          i2 && e3 ? t2.set(a2.replace("_HCM", ""), n2) : i2 || e3 || t2.set(a2, n2);
        }
        return shadow(this, "highlightColors", t2);
      }
      get highlightColorNames() {
        return shadow(this, "highlightColorNames", this.highlightColors ? new Map(Array.from(this.highlightColors, (e2) => e2.reverse())) : null);
      }
      getNonHCMColor(e2) {
        if (!this._highlightColors)
          return e2;
        const t2 = this.highlightColorNames.get(e2);
        return this._highlightColors.get(t2) || e2;
      }
      getNonHCMColorName(e2) {
        return this.highlightColorNames.get(e2) || e2;
      }
      setCurrentDrawingSession(e2) {
        e2 ? (this.unselectAll(), this.disableUserSelect(true)) : this.disableUserSelect(false), __privateSet(this, _jt, e2);
      }
      setMainHighlightColorPicker(e2) {
        __privateSet(this, _oi, e2);
      }
      editAltText(e2, t2 = false) {
        __privateGet(this, _Pt)?.editAltText(this, e2, t2);
      }
      hasCommentManager() {
        return !!__privateGet(this, _Lt);
      }
      editComment(e2, t2) {
        __privateGet(this, _Lt)?.open(this, e2, t2);
      }
      getSignature(e2) {
        __privateGet(this, _gi)?.getSignature({ uiManager: this, editor: e2 });
      }
      get signatureManager() {
        return __privateGet(this, _gi);
      }
      switchToMode(e2, t2) {
        this._eventBus.on("annotationeditormodechanged", t2, { once: true, signal: this._signal }), this._eventBus.dispatch("showannotationeditorui", { source: this, mode: e2 });
      }
      setPreference(e2, t2) {
        this._eventBus.dispatch("setpreference", { source: this, name: e2, value: t2 });
      }
      onSetPreference({ name: e2, value: t2 }) {
        if ("enableNewAltTextWhenAddingImage" === e2)
          __privateSet(this, _Vt, t2);
      }
      onPageChanging({ pageNumber: e2 }) {
        __privateSet(this, _$t, e2 - 1);
      }
      focusMainContainer() {
        __privateGet(this, _Ai).focus();
      }
      findParent(e2, t2) {
        for (const i2 of __privateGet(this, __t).values()) {
          const { x: a2, y: n2, width: s2, height: r2 } = i2.div.getBoundingClientRect();
          if (e2 >= a2 && e2 <= a2 + s2 && t2 >= n2 && t2 <= n2 + r2)
            return i2;
        }
        return null;
      }
      disableUserSelect(e2 = false) {
        __privateGet(this, _xi).classList.toggle("noUserSelect", e2);
      }
      addShouldRescale(e2) {
        __privateGet(this, _zt).add(e2);
      }
      removeShouldRescale(e2) {
        __privateGet(this, _zt).delete(e2);
      }
      onScaleChanging({ scale: e2 }) {
        this.commitOrRemove(), this.viewParameters.realScale = e2 * PixelsPerInch.PDF_TO_CSS_UNITS;
        for (const e3 of __privateGet(this, _zt))
          e3.onScaleChanging();
        __privateGet(this, _jt)?.onScaleChanging();
      }
      onRotationChanging({ pagesRotation: e2 }) {
        this.commitOrRemove(), this.viewParameters.rotation = e2;
      }
      highlightSelection(e2 = "", t2 = false) {
        const i2 = document.getSelection();
        if (!i2 || i2.isCollapsed)
          return;
        const { anchorNode: a2, anchorOffset: n2, focusNode: s2, focusOffset: r2 } = i2, o2 = i2.toString(), l3 = __privateMethod(this, _Ii, Ii_fn).call(this, i2).closest(".textLayer"), c2 = this.getSelectionBoxes(l3);
        if (!c2)
          return;
        i2.empty();
        const h2 = __privateMethod(this, _Fi, Fi_fn).call(this, l3), d2 = __privateGet(this, _hi) === Ll.NONE, callback = /* @__PURE__ */ __name(() => {
          const i3 = h2?.createAndAddNewEditor({ x: 0, y: 0 }, false, { methodOfCreation: e2, boxes: c2, anchorNode: a2, anchorOffset: n2, focusNode: s2, focusOffset: r2, text: o2 });
          d2 && this.showAllEditors("highlight", true, true), t2 && i3?.editComment();
        }, "callback");
        d2 ? this.switchToMode(Ll.HIGHLIGHT, callback) : callback();
      }
      commentSelection(e2 = "") {
        this.highlightSelection(e2, true);
      }
      addToAnnotationStorage(e2) {
        e2.isEmpty() || !__privateGet(this, _Rt) || __privateGet(this, _Rt).has(e2.id) || __privateGet(this, _Rt).setValue(e2.id, e2);
      }
      a11yAlert(e2, t2 = null) {
        const i2 = __privateGet(this, _Si);
        i2 && (i2.setAttribute("data-l10n-id", e2), t2 ? i2.setAttribute("data-l10n-args", JSON.stringify(t2)) : i2.removeAttribute("data-l10n-args"));
      }
      blur() {
        if (this.isShiftKeyDown = false, __privateGet(this, _Qt) && (__privateSet(this, _Qt, false), __privateMethod(this, _Oi, Oi_fn).call(this, "main_toolbar")), !this.hasSelection)
          return;
        const { activeElement: e2 } = document;
        for (const t2 of __privateGet(this, _di))
          if (t2.div.contains(e2)) {
            __privateSet(this, _ri, [t2, e2]), t2._focusEventsAllowed = false;
            break;
          }
      }
      focus() {
        if (!__privateGet(this, _ri))
          return;
        const [e2, t2] = __privateGet(this, _ri);
        __privateSet(this, _ri, null), t2.addEventListener("focusin", () => {
          e2._focusEventsAllowed = true;
        }, { once: true, signal: this._signal }), t2.focus();
      }
      addEditListeners() {
        __privateMethod(this, _Ti, Ti_fn).call(this), __privateMethod(this, _Bi, Bi_fn).call(this);
      }
      removeEditListeners() {
        __privateMethod(this, _Ri, Ri_fn).call(this), __privateMethod(this, _Ni, Ni_fn).call(this);
      }
      dragOver(e2) {
        for (const { type: t2 } of e2.dataTransfer.items)
          for (const i2 of __privateGet(this, _Xt))
            if (i2.isHandlingMimeForPasting(t2))
              return e2.dataTransfer.dropEffect = "copy", void e2.preventDefault();
      }
      drop(e2) {
        for (const t2 of e2.dataTransfer.items)
          for (const i2 of __privateGet(this, _Xt))
            if (i2.isHandlingMimeForPasting(t2.type))
              return i2.paste(t2, this.currentLayer), void e2.preventDefault();
      }
      copy(e2) {
        if (e2.preventDefault(), __privateGet(this, _Dt)?.commitOrRemove(), !this.hasSelection)
          return;
        const t2 = [];
        for (const e3 of __privateGet(this, _di)) {
          const i2 = e3.serialize(true);
          i2 && t2.push(i2);
        }
        0 !== t2.length && e2.clipboardData.setData("application/pdfjs", JSON.stringify(t2));
      }
      cut(e2) {
        this.copy(e2), this.delete();
      }
      async paste(e2) {
        e2.preventDefault();
        const { clipboardData: t2 } = e2;
        for (const e3 of t2.items)
          for (const t3 of __privateGet(this, _Xt))
            if (t3.isHandlingMimeForPasting(e3.type))
              return void t3.paste(e3, this.currentLayer);
        let i2 = t2.getData("application/pdfjs");
        if (!i2)
          return;
        try {
          i2 = JSON.parse(i2);
        } catch (e3) {
          return void warn3(`paste: "${e3.message}".`);
        }
        if (!Array.isArray(i2))
          return;
        this.unselectAll();
        const a2 = this.currentLayer;
        try {
          const e3 = [];
          for (const t3 of i2) {
            const i3 = await a2.deserialize(t3);
            if (!i3)
              return;
            e3.push(i3);
          }
          const cmd = /* @__PURE__ */ __name(() => {
            for (const t3 of e3)
              __privateMethod(this, _Li, Li_fn).call(this, t3);
            __privateMethod(this, _Ui, Ui_fn).call(this, e3);
          }, "cmd"), undo = /* @__PURE__ */ __name(() => {
            for (const t3 of e3)
              t3.remove();
          }, "undo");
          this.addCommands({ cmd, undo, mustExec: true });
        } catch (e3) {
          warn3(`paste: "${e3.message}".`);
        }
      }
      keydown(e2) {
        this.isShiftKeyDown || "Shift" !== e2.key || (this.isShiftKeyDown = true), __privateGet(this, _hi) === Ll.NONE || this.isEditorHandlingKeyboard || _AnnotationEditorUIManager._keyboardManager.exec(this, e2);
      }
      keyup(e2) {
        this.isShiftKeyDown && "Shift" === e2.key && (this.isShiftKeyDown = false, __privateGet(this, _Qt) && (__privateSet(this, _Qt, false), __privateMethod(this, _Oi, Oi_fn).call(this, "main_toolbar")));
      }
      onEditingAction({ name: e2 }) {
        switch (e2) {
          case "undo":
          case "redo":
          case "delete":
          case "selectAll":
            this[e2]();
            break;
          case "highlightSelection":
            this.highlightSelection("context_menu");
            break;
          case "commentSelection":
            this.commentSelection("context_menu");
        }
      }
      setEditingState(e2) {
        e2 ? (__privateMethod(this, __i, _i_fn).call(this), __privateMethod(this, _Bi, Bi_fn).call(this), __privateMethod(this, _Ei, Ei_fn).call(this, { isEditing: __privateGet(this, _hi) !== Ll.NONE, isEmpty: __privateMethod(this, _$i, $i_fn).call(this), hasSomethingToUndo: __privateGet(this, _Nt).hasSomethingToUndo(), hasSomethingToRedo: __privateGet(this, _Nt).hasSomethingToRedo(), hasSelectedEditor: false })) : (__privateMethod(this, _Pi, Pi_fn).call(this), __privateMethod(this, _Ni, Ni_fn).call(this), __privateMethod(this, _Ei, Ei_fn).call(this, { isEditing: false }), this.disableUserSelect(false));
      }
      registerEditorTypes(e2) {
        if (!__privateGet(this, _Xt)) {
          __privateSet(this, _Xt, e2);
          for (const e3 of __privateGet(this, _Xt))
            __privateMethod(this, _ji, ji_fn).call(this, e3.defaultPropertiesToUpdate);
        }
      }
      getId() {
        return __privateGet(this, _ti).id;
      }
      get currentLayer() {
        return __privateGet(this, __t).get(__privateGet(this, _$t));
      }
      getLayer(e2) {
        return __privateGet(this, __t).get(e2);
      }
      get currentPageIndex() {
        return __privateGet(this, _$t);
      }
      addLayer(e2) {
        __privateGet(this, __t).set(e2.pageIndex, e2), __privateGet(this, _ii) ? e2.enable() : e2.disable();
      }
      removeLayer(e2) {
        __privateGet(this, __t).delete(e2.pageIndex);
      }
      async updateMode(e2, t2 = null, i2 = false, a2 = false, n2 = false) {
        if (__privateGet(this, _hi) !== e2 && (!__privateGet(this, _vi) || (await __privateGet(this, _vi).promise, __privateGet(this, _vi)))) {
          if (__privateSet(this, _vi, Promise.withResolvers()), __privateGet(this, _jt)?.commitOrRemove(), __privateGet(this, _hi) === Ll.POPUP && __privateGet(this, _Lt)?.hideSidebar(), __privateSet(this, _hi, e2), e2 === Ll.NONE)
            return this.setEditingState(false), __privateMethod(this, _Hi, Hi_fn).call(this), this._editorUndoBar?.hide(), void __privateGet(this, _vi).resolve();
          e2 === Ll.SIGNATURE && await __privateGet(this, _gi)?.loadSignatures(), e2 === Ll.POPUP && (__privateGet(this, _Et) || __privateSet(this, _Et, await __privateGet(this, _mi).getAnnotationsByType(new Set(__privateGet(this, _Xt).map((e3) => e3._editorType)))), __privateGet(this, _Lt)?.showSidebar(__privateGet(this, _Et))), this.setEditingState(true), await __privateMethod(this, _qi, qi_fn).call(this), this.unselectAll();
          for (const t3 of __privateGet(this, __t).values())
            t3.updateMode(e2);
          if (!t2)
            return i2 && this.addNewEditorFromKeyboard(), void __privateGet(this, _vi).resolve();
          for (const e3 of __privateGet(this, _Ot).values())
            e3.annotationElementId === t2 || e3.id === t2 ? (this.setSelected(e3), n2 ? e3.editComment() : a2 && e3.enterInEditMode()) : e3.unselect();
          __privateGet(this, _vi).resolve();
        }
      }
      addNewEditorFromKeyboard() {
        this.currentLayer.canCreateNewEmptyEditor() && this.currentLayer.addNewEditor();
      }
      updateToolbar(e2) {
        e2.mode !== __privateGet(this, _hi) && this._eventBus.dispatch("switchannotationeditormode", { source: this, ...e2 });
      }
      updateParams(e2, t2) {
        if (__privateGet(this, _Xt)) {
          switch (e2) {
            case jl.CREATE:
              return void this.currentLayer.addNewEditor(t2);
            case jl.HIGHLIGHT_SHOW_ALL:
              this._eventBus.dispatch("reporttelemetry", { source: this, details: { type: "editing", data: { type: "highlight", action: "toggle_visibility" } } }), (__privateGet(this, _fi) || __privateSet(this, _fi, /* @__PURE__ */ new Map())).set(e2, t2), this.showAllEditors("highlight", t2);
          }
          if (this.hasSelection)
            for (const i2 of __privateGet(this, _di))
              i2.updateParams(e2, t2);
          else
            for (const i2 of __privateGet(this, _Xt))
              i2.updateDefaultParams(e2, t2);
        }
      }
      showAllEditors(e2, t2, i2 = false) {
        for (const i3 of __privateGet(this, _Ot).values())
          i3.editorType === e2 && i3.show(t2);
        (__privateGet(this, _fi)?.get(jl.HIGHLIGHT_SHOW_ALL) ?? true) !== t2 && __privateMethod(this, _ji, ji_fn).call(this, [[jl.HIGHLIGHT_SHOW_ALL, t2]]);
      }
      enableWaiting(e2 = false) {
        if (__privateGet(this, _ni) !== e2) {
          __privateSet(this, _ni, e2);
          for (const t2 of __privateGet(this, __t).values())
            e2 ? t2.disableClick() : t2.enableClick(), t2.div.classList.toggle("waiting", e2);
        }
      }
      getEditors(e2) {
        const t2 = [];
        for (const i2 of __privateGet(this, _Ot).values())
          i2.pageIndex === e2 && t2.push(i2);
        return t2;
      }
      getEditor(e2) {
        return __privateGet(this, _Ot).get(e2);
      }
      addEditor(e2) {
        __privateGet(this, _Ot).set(e2.id, e2);
      }
      removeEditor(e2) {
        e2.div.contains(document.activeElement) && (__privateGet(this, _Yt) && clearTimeout(__privateGet(this, _Yt)), __privateSet(this, _Yt, setTimeout(() => {
          this.focusMainContainer(), __privateSet(this, _Yt, null);
        }, 0))), __privateGet(this, _Ot).delete(e2.id), e2.annotationElementId && __privateGet(this, _li)?.delete(e2.annotationElementId), this.unselect(e2), e2.annotationElementId && __privateGet(this, _Ht).has(e2.annotationElementId) || __privateGet(this, _Rt)?.remove(e2.id);
      }
      addDeletedAnnotationElement(e2) {
        __privateGet(this, _Ht).add(e2.annotationElementId), this.addChangedExistingAnnotation(e2), e2.deleted = true;
      }
      isDeletedAnnotationElement(e2) {
        return __privateGet(this, _Ht).has(e2);
      }
      removeDeletedAnnotationElement(e2) {
        __privateGet(this, _Ht).delete(e2.annotationElementId), this.removeChangedExistingAnnotation(e2), e2.deleted = false;
      }
      setActiveEditor(e2) {
        __privateGet(this, _Dt) !== e2 && (__privateSet(this, _Dt, e2), e2 && __privateMethod(this, _ji, ji_fn).call(this, e2.propertiesToUpdate));
      }
      updateUI(e2) {
        __privateGet(this, _Xi, Xi_get) === e2 && __privateMethod(this, _ji, ji_fn).call(this, e2.propertiesToUpdate);
      }
      updateUIForDefaultProperties(e2) {
        __privateMethod(this, _ji, ji_fn).call(this, e2.defaultPropertiesToUpdate);
      }
      toggleSelected(e2) {
        if (__privateGet(this, _di).has(e2))
          return __privateGet(this, _di).delete(e2), e2.unselect(), void __privateMethod(this, _Ei, Ei_fn).call(this, { hasSelectedEditor: this.hasSelection });
        __privateGet(this, _di).add(e2), e2.select(), __privateMethod(this, _ji, ji_fn).call(this, e2.propertiesToUpdate), __privateMethod(this, _Ei, Ei_fn).call(this, { hasSelectedEditor: true });
      }
      setSelected(e2) {
        this.updateToolbar({ mode: e2.mode, editId: e2.id }), __privateGet(this, _jt)?.commitOrRemove();
        for (const t2 of __privateGet(this, _di))
          t2 !== e2 && t2.unselect();
        __privateGet(this, _di).clear(), __privateGet(this, _di).add(e2), e2.select(), __privateMethod(this, _ji, ji_fn).call(this, e2.propertiesToUpdate), __privateMethod(this, _Ei, Ei_fn).call(this, { hasSelectedEditor: true });
      }
      isSelected(e2) {
        return __privateGet(this, _di).has(e2);
      }
      get firstSelectedEditor() {
        return __privateGet(this, _di).values().next().value;
      }
      unselect(e2) {
        e2.unselect(), __privateGet(this, _di).delete(e2), __privateMethod(this, _Ei, Ei_fn).call(this, { hasSelectedEditor: this.hasSelection });
      }
      get hasSelection() {
        return 0 !== __privateGet(this, _di).size;
      }
      get isEnterHandled() {
        return 1 === __privateGet(this, _di).size && this.firstSelectedEditor.isEnterHandled;
      }
      undo() {
        __privateGet(this, _Nt).undo(), __privateMethod(this, _Ei, Ei_fn).call(this, { hasSomethingToUndo: __privateGet(this, _Nt).hasSomethingToUndo(), hasSomethingToRedo: true, isEmpty: __privateMethod(this, _$i, $i_fn).call(this) }), this._editorUndoBar?.hide();
      }
      redo() {
        __privateGet(this, _Nt).redo(), __privateMethod(this, _Ei, Ei_fn).call(this, { hasSomethingToUndo: true, hasSomethingToRedo: __privateGet(this, _Nt).hasSomethingToRedo(), isEmpty: __privateMethod(this, _$i, $i_fn).call(this) });
      }
      addCommands(e2) {
        __privateGet(this, _Nt).add(e2), __privateMethod(this, _Ei, Ei_fn).call(this, { hasSomethingToUndo: true, hasSomethingToRedo: false, isEmpty: __privateMethod(this, _$i, $i_fn).call(this) });
      }
      cleanUndoStack(e2) {
        __privateGet(this, _Nt).cleanType(e2);
      }
      delete() {
        this.commitOrRemove();
        const e2 = this.currentLayer?.endDrawingSession(true);
        if (!this.hasSelection && !e2)
          return;
        const t2 = e2 ? [e2] : [...__privateGet(this, _di)], undo = /* @__PURE__ */ __name(() => {
          for (const e3 of t2)
            __privateMethod(this, _Li, Li_fn).call(this, e3);
        }, "undo");
        this.addCommands({ cmd: () => {
          this._editorUndoBar?.show(undo, 1 === t2.length ? t2[0].editorType : t2.length);
          for (const e3 of t2)
            e3.remove();
        }, undo, mustExec: true });
      }
      commitOrRemove() {
        __privateGet(this, _Dt)?.commitOrRemove();
      }
      hasSomethingToControl() {
        return __privateGet(this, _Dt) || this.hasSelection;
      }
      selectAll() {
        for (const e2 of __privateGet(this, _di))
          e2.commit();
        __privateMethod(this, _Ui, Ui_fn).call(this, __privateGet(this, _Ot).values());
      }
      unselectAll() {
        if ((!__privateGet(this, _Dt) || (__privateGet(this, _Dt).commitOrRemove(), __privateGet(this, _hi) === Ll.NONE)) && !__privateGet(this, _jt)?.commitOrRemove() && this.hasSelection) {
          for (const e2 of __privateGet(this, _di))
            e2.unselect();
          __privateGet(this, _di).clear(), __privateMethod(this, _Ei, Ei_fn).call(this, { hasSelectedEditor: false });
        }
      }
      translateSelectedEditors(e2, t2, i2 = false) {
        if (i2 || this.commitOrRemove(), !this.hasSelection)
          return;
        __privateGet(this, _yi)[0] += e2, __privateGet(this, _yi)[1] += t2;
        const [a2, n2] = __privateGet(this, _yi), s2 = [...__privateGet(this, _di)];
        __privateGet(this, _wi) && clearTimeout(__privateGet(this, _wi)), __privateSet(this, _wi, setTimeout(() => {
          __privateSet(this, _wi, null), __privateGet(this, _yi)[0] = __privateGet(this, _yi)[1] = 0, this.addCommands({ cmd: () => {
            for (const e3 of s2)
              __privateGet(this, _Ot).has(e3.id) && (e3.translateInPage(a2, n2), e3.translationDone());
          }, undo: () => {
            for (const e3 of s2)
              __privateGet(this, _Ot).has(e3.id) && (e3.translateInPage(-a2, -n2), e3.translationDone());
          }, mustExec: false });
        }, 1e3));
        for (const i3 of s2)
          i3.translateInPage(e2, t2), i3.translationDone();
      }
      setUpDragSession() {
        if (this.hasSelection) {
          this.disableUserSelect(true), __privateSet(this, _qt, /* @__PURE__ */ new Map());
          for (const e2 of __privateGet(this, _di))
            __privateGet(this, _qt).set(e2, { savedX: e2.x, savedY: e2.y, savedPageIndex: e2.pageIndex, newX: 0, newY: 0, newPageIndex: -1 });
        }
      }
      endDragSession() {
        if (!__privateGet(this, _qt))
          return false;
        this.disableUserSelect(false);
        const e2 = __privateGet(this, _qt);
        __privateSet(this, _qt, null);
        let t2 = false;
        for (const [{ x: i2, y: a2, pageIndex: n2 }, s2] of e2)
          s2.newX = i2, s2.newY = a2, s2.newPageIndex = n2, t2 ||= i2 !== s2.savedX || a2 !== s2.savedY || n2 !== s2.savedPageIndex;
        if (!t2)
          return false;
        const move = /* @__PURE__ */ __name((e3, t3, i2, a2) => {
          if (__privateGet(this, _Ot).has(e3.id)) {
            const n2 = __privateGet(this, __t).get(a2);
            n2 ? e3._setParentAndPosition(n2, t3, i2) : (e3.pageIndex = a2, e3.x = t3, e3.y = i2);
          }
        }, "move");
        return this.addCommands({ cmd: () => {
          for (const [t3, { newX: i2, newY: a2, newPageIndex: n2 }] of e2)
            move(t3, i2, a2, n2);
        }, undo: () => {
          for (const [t3, { savedX: i2, savedY: a2, savedPageIndex: n2 }] of e2)
            move(t3, i2, a2, n2);
        }, mustExec: true }), true;
      }
      dragSelectedEditors(e2, t2) {
        if (__privateGet(this, _qt))
          for (const i2 of __privateGet(this, _qt).keys())
            i2.drag(e2, t2);
      }
      rebuild(e2) {
        if (null === e2.parent) {
          const t2 = this.getLayer(e2.pageIndex);
          t2 ? (t2.changeParent(e2), t2.addOrRebuild(e2)) : (this.addEditor(e2), this.addToAnnotationStorage(e2), e2.rebuild());
        } else
          e2.parent.addOrRebuild(e2);
      }
      get isEditorHandlingKeyboard() {
        return this.getActive()?.shouldGetKeyboardEvents() || 1 === __privateGet(this, _di).size && this.firstSelectedEditor.shouldGetKeyboardEvents();
      }
      isActive(e2) {
        return __privateGet(this, _Dt) === e2;
      }
      getActive() {
        return __privateGet(this, _Dt);
      }
      getMode() {
        return __privateGet(this, _hi);
      }
      get imageManager() {
        return shadow(this, "imageManager", new ImageManager());
      }
      getSelectionBoxes(e2) {
        if (!e2)
          return null;
        const t2 = document.getSelection();
        for (let i3 = 0, a3 = t2.rangeCount; i3 < a3; i3++)
          if (!e2.contains(t2.getRangeAt(i3).commonAncestorContainer))
            return null;
        const { x: i2, y: a2, width: n2, height: s2 } = e2.getBoundingClientRect();
        let r2;
        switch (e2.getAttribute("data-main-rotation")) {
          case "90":
            r2 = /* @__PURE__ */ __name((e3, t3, r3, o3) => ({ x: (t3 - a2) / s2, y: 1 - (e3 + r3 - i2) / n2, width: o3 / s2, height: r3 / n2 }), "r");
            break;
          case "180":
            r2 = /* @__PURE__ */ __name((e3, t3, r3, o3) => ({ x: 1 - (e3 + r3 - i2) / n2, y: 1 - (t3 + o3 - a2) / s2, width: r3 / n2, height: o3 / s2 }), "r");
            break;
          case "270":
            r2 = /* @__PURE__ */ __name((e3, t3, r3, o3) => ({ x: 1 - (t3 + o3 - a2) / s2, y: (e3 - i2) / n2, width: o3 / s2, height: r3 / n2 }), "r");
            break;
          default:
            r2 = /* @__PURE__ */ __name((e3, t3, r3, o3) => ({ x: (e3 - i2) / n2, y: (t3 - a2) / s2, width: r3 / n2, height: o3 / s2 }), "r");
        }
        const o2 = [];
        for (let e3 = 0, i3 = t2.rangeCount; e3 < i3; e3++) {
          const i4 = t2.getRangeAt(e3);
          if (!i4.collapsed)
            for (const { x: e4, y: t3, width: a3, height: n3 } of i4.getClientRects())
              0 !== a3 && 0 !== n3 && o2.push(r2(e4, t3, a3, n3));
        }
        return 0 === o2.length ? null : o2;
      }
      addChangedExistingAnnotation({ annotationElementId: e2, id: t2 }) {
        (__privateGet(this, _Bt) || __privateSet(this, _Bt, /* @__PURE__ */ new Map())).set(e2, t2);
      }
      removeChangedExistingAnnotation({ annotationElementId: e2 }) {
        __privateGet(this, _Bt)?.delete(e2);
      }
      renderAnnotationElement(e2) {
        const t2 = __privateGet(this, _Bt)?.get(e2.data.id);
        if (!t2)
          return;
        const i2 = __privateGet(this, _Rt).getRawValue(t2);
        i2 && (__privateGet(this, _hi) !== Ll.NONE || i2.hasBeenModified) && i2.renderAnnotationElement(e2);
      }
      setMissingCanvas(e2, t2, i2) {
        const a2 = __privateGet(this, _li)?.get(e2);
        a2 && (a2.setCanvas(t2, i2), __privateGet(this, _li).delete(e2));
      }
      addMissingCanvas(e2, t2) {
        (__privateGet(this, _li) || __privateSet(this, _li, /* @__PURE__ */ new Map())).set(e2, t2);
      }
    };
    AnnotationEditorUIManager = _AnnotationEditorUIManager;
    __name(AnnotationEditorUIManager, "AnnotationEditorUIManager");
    _Mt = new WeakMap();
    _Dt = new WeakMap();
    _Et = new WeakMap();
    _Ot = new WeakMap();
    __t = new WeakMap();
    _Pt = new WeakMap();
    _Rt = new WeakMap();
    _Bt = new WeakMap();
    _Nt = new WeakMap();
    _Lt = new WeakMap();
    _Ut = new WeakMap();
    _jt = new WeakMap();
    _$t = new WeakMap();
    _Ht = new WeakMap();
    _qt = new WeakMap();
    _Xt = new WeakMap();
    _zt = new WeakMap();
    _Wt = new WeakMap();
    _Gt = new WeakMap();
    _Vt = new WeakMap();
    _Kt = new WeakMap();
    _Yt = new WeakMap();
    _Jt = new WeakMap();
    _Zt = new WeakMap();
    _Qt = new WeakMap();
    _ei = new WeakMap();
    _ti = new WeakMap();
    _ii = new WeakMap();
    _ai = new WeakMap();
    _ni = new WeakMap();
    _si = new WeakMap();
    _ri = new WeakMap();
    _oi = new WeakMap();
    _li = new WeakMap();
    _ci = new WeakMap();
    _hi = new WeakMap();
    _di = new WeakMap();
    _ui = new WeakMap();
    _gi = new WeakMap();
    _pi = new WeakMap();
    _fi = new WeakMap();
    _mi = new WeakMap();
    _bi = new WeakMap();
    _yi = new WeakMap();
    _wi = new WeakMap();
    _Ai = new WeakMap();
    _xi = new WeakMap();
    _Si = new WeakMap();
    _vi = new WeakMap();
    _Ii = new WeakSet();
    Ii_fn = /* @__PURE__ */ __name(function({ anchorNode: e2 }) {
      return e2.nodeType === Node.TEXT_NODE ? e2.parentElement : e2;
    }, "#Ii");
    _Fi = new WeakSet();
    Fi_fn = /* @__PURE__ */ __name(function(e2) {
      const { currentLayer: t2 } = this;
      if (t2.hasTextLayer(e2))
        return t2;
      for (const t3 of __privateGet(this, __t).values())
        if (t3.hasTextLayer(e2))
          return t3;
      return null;
    }, "#Fi");
    _Mi = new WeakSet();
    Mi_fn = /* @__PURE__ */ __name(function() {
      const e2 = document.getSelection();
      if (!e2 || e2.isCollapsed)
        return;
      const t2 = __privateMethod(this, _Ii, Ii_fn).call(this, e2).closest(".textLayer"), i2 = this.getSelectionBoxes(t2);
      i2 && (__privateGet(this, _ei) || __privateSet(this, _ei, new FloatingToolbar(this)), __privateGet(this, _ei).show(t2, i2, "ltr" === this.direction));
    }, "#Mi");
    _Di = new WeakSet();
    Di_fn = /* @__PURE__ */ __name(function() {
      const e2 = document.getSelection();
      if (!e2 || e2.isCollapsed)
        return void (__privateGet(this, _ui) && (__privateGet(this, _ei)?.hide(), __privateSet(this, _ui, null), __privateMethod(this, _Ei, Ei_fn).call(this, { hasSelectedText: false })));
      const { anchorNode: t2 } = e2;
      if (t2 === __privateGet(this, _ui))
        return;
      const i2 = __privateMethod(this, _Ii, Ii_fn).call(this, e2).closest(".textLayer");
      if (i2) {
        if (__privateGet(this, _ei)?.hide(), __privateSet(this, _ui, t2), __privateMethod(this, _Ei, Ei_fn).call(this, { hasSelectedText: true }), (__privateGet(this, _hi) === Ll.HIGHLIGHT || __privateGet(this, _hi) === Ll.NONE) && (__privateGet(this, _hi) === Ll.HIGHLIGHT && this.showAllEditors("highlight", true, true), __privateSet(this, _Qt, this.isShiftKeyDown), !this.isShiftKeyDown)) {
          const e3 = __privateGet(this, _hi) === Ll.HIGHLIGHT ? __privateMethod(this, _Fi, Fi_fn).call(this, i2) : null;
          if (e3?.toggleDrawing(), __privateGet(this, _ai)) {
            const t3 = new AbortController(), i3 = this.combinedSignal(t3), pointerup = /* @__PURE__ */ __name((i4) => {
              "pointerup" === i4.type && 0 !== i4.button || (t3.abort(), e3?.toggleDrawing(true), "pointerup" === i4.type && __privateMethod(this, _Oi, Oi_fn).call(this, "main_toolbar"));
            }, "pointerup");
            window.addEventListener("pointerup", pointerup, { signal: i3 }), window.addEventListener("blur", pointerup, { signal: i3 });
          } else
            e3?.toggleDrawing(true), __privateMethod(this, _Oi, Oi_fn).call(this, "main_toolbar");
        }
      } else
        __privateGet(this, _ui) && (__privateGet(this, _ei)?.hide(), __privateSet(this, _ui, null), __privateMethod(this, _Ei, Ei_fn).call(this, { hasSelectedText: false }));
    }, "#Di");
    _Oi = new WeakSet();
    Oi_fn = /* @__PURE__ */ __name(function(e2 = "") {
      __privateGet(this, _hi) === Ll.HIGHLIGHT ? this.highlightSelection(e2) : __privateGet(this, _Wt) && __privateMethod(this, _Mi, Mi_fn).call(this);
    }, "#Oi");
    _Ci = new WeakSet();
    Ci_fn = /* @__PURE__ */ __name(function() {
      document.addEventListener("selectionchange", __privateMethod(this, _Di, Di_fn).bind(this), { signal: this._signal });
    }, "#Ci");
    __i = new WeakSet();
    _i_fn = /* @__PURE__ */ __name(function() {
      if (__privateGet(this, _Jt))
        return;
      __privateSet(this, _Jt, new AbortController());
      const e2 = this.combinedSignal(__privateGet(this, _Jt));
      window.addEventListener("focus", this.focus.bind(this), { signal: e2 }), window.addEventListener("blur", this.blur.bind(this), { signal: e2 });
    }, "#_i");
    _Pi = new WeakSet();
    Pi_fn = /* @__PURE__ */ __name(function() {
      __privateGet(this, _Jt)?.abort(), __privateSet(this, _Jt, null);
    }, "#Pi");
    _Ti = new WeakSet();
    Ti_fn = /* @__PURE__ */ __name(function() {
      if (__privateGet(this, _si))
        return;
      __privateSet(this, _si, new AbortController());
      const e2 = this.combinedSignal(__privateGet(this, _si));
      window.addEventListener("keydown", this.keydown.bind(this), { signal: e2 }), window.addEventListener("keyup", this.keyup.bind(this), { signal: e2 });
    }, "#Ti");
    _Ri = new WeakSet();
    Ri_fn = /* @__PURE__ */ __name(function() {
      __privateGet(this, _si)?.abort(), __privateSet(this, _si, null);
    }, "#Ri");
    _Bi = new WeakSet();
    Bi_fn = /* @__PURE__ */ __name(function() {
      if (__privateGet(this, _Ut))
        return;
      __privateSet(this, _Ut, new AbortController());
      const e2 = this.combinedSignal(__privateGet(this, _Ut));
      document.addEventListener("copy", this.copy.bind(this), { signal: e2 }), document.addEventListener("cut", this.cut.bind(this), { signal: e2 }), document.addEventListener("paste", this.paste.bind(this), { signal: e2 });
    }, "#Bi");
    _Ni = new WeakSet();
    Ni_fn = /* @__PURE__ */ __name(function() {
      __privateGet(this, _Ut)?.abort(), __privateSet(this, _Ut, null);
    }, "#Ni");
    _ki = new WeakSet();
    ki_fn = /* @__PURE__ */ __name(function() {
      const e2 = this._signal;
      document.addEventListener("dragover", this.dragOver.bind(this), { signal: e2 }), document.addEventListener("drop", this.drop.bind(this), { signal: e2 });
    }, "#ki");
    _Ei = new WeakSet();
    Ei_fn = /* @__PURE__ */ __name(function(e2) {
      Object.entries(e2).some(([e3, t2]) => __privateGet(this, _bi)[e3] !== t2) && (this._eventBus.dispatch("annotationeditorstateschanged", { source: this, details: Object.assign(__privateGet(this, _bi), e2) }), __privateGet(this, _hi) === Ll.HIGHLIGHT && false === e2.hasSelectedEditor && __privateMethod(this, _ji, ji_fn).call(this, [[jl.HIGHLIGHT_FREE, true]]));
    }, "#Ei");
    _ji = new WeakSet();
    ji_fn = /* @__PURE__ */ __name(function(e2) {
      this._eventBus.dispatch("annotationeditorparamschanged", { source: this, details: e2 });
    }, "#ji");
    _qi = new WeakSet();
    qi_fn = /* @__PURE__ */ __name(async function() {
      if (!__privateGet(this, _ii)) {
        __privateSet(this, _ii, true);
        const e2 = [];
        for (const t2 of __privateGet(this, __t).values())
          e2.push(t2.enable());
        await Promise.all(e2);
        for (const e3 of __privateGet(this, _Ot).values())
          e3.enable();
      }
    }, "#qi");
    _Hi = new WeakSet();
    Hi_fn = /* @__PURE__ */ __name(function() {
      if (this.unselectAll(), __privateGet(this, _ii)) {
        __privateSet(this, _ii, false);
        for (const e2 of __privateGet(this, __t).values())
          e2.disable();
        for (const e2 of __privateGet(this, _Ot).values())
          e2.disable();
      }
    }, "#Hi");
    _Li = new WeakSet();
    Li_fn = /* @__PURE__ */ __name(function(e2) {
      const t2 = __privateGet(this, __t).get(e2.pageIndex);
      t2 ? t2.addOrRebuild(e2) : (this.addEditor(e2), this.addToAnnotationStorage(e2));
    }, "#Li");
    _Xi = new WeakSet();
    Xi_get = /* @__PURE__ */ __name(function() {
      let e2 = null;
      for (e2 of __privateGet(this, _di))
        ;
      return e2;
    }, "#Xi");
    _$i = new WeakSet();
    $i_fn = /* @__PURE__ */ __name(function() {
      if (0 === __privateGet(this, _Ot).size)
        return true;
      if (1 === __privateGet(this, _Ot).size)
        for (const e2 of __privateGet(this, _Ot).values())
          return e2.isEmpty();
      return false;
    }, "#$i");
    _Ui = new WeakSet();
    Ui_fn = /* @__PURE__ */ __name(function(e2) {
      for (const e3 of __privateGet(this, _di))
        e3.unselect();
      __privateGet(this, _di).clear();
      for (const t2 of e2)
        t2.isEmpty() || (__privateGet(this, _di).add(t2), t2.select());
      __privateMethod(this, _Ei, Ei_fn).call(this, { hasSelectedEditor: this.hasSelection });
    }, "#Ui");
    __publicField(AnnotationEditorUIManager, "TRANSLATE_SMALL", 1);
    __publicField(AnnotationEditorUIManager, "TRANSLATE_BIG", 10);
    _AltText = class {
      constructor(e2) {
        __privateAdd(this, _ia);
        __privateAdd(this, _aa);
        __privateAdd(this, _ot2, null);
        __privateAdd(this, _zi, false);
        __privateAdd(this, _Wi, null);
        __privateAdd(this, _Gi, null);
        __privateAdd(this, _Vi, null);
        __privateAdd(this, _Ki, null);
        __privateAdd(this, _Yi, false);
        __privateAdd(this, _Ji, null);
        __privateAdd(this, _st2, null);
        __privateAdd(this, _Zi, null);
        __privateAdd(this, _Qi, null);
        __privateAdd(this, _ea, false);
        __privateSet(this, _st2, e2), __privateSet(this, _ea, e2._uiManager.useNewAltTextFlow), __privateGet(_AltText, _ta) || __privateSet(_AltText, _ta, Object.freeze({ added: "pdfjs-editor-new-alt-text-added-button", "added-label": "pdfjs-editor-new-alt-text-added-button-label", missing: "pdfjs-editor-new-alt-text-missing-button", "missing-label": "pdfjs-editor-new-alt-text-missing-button-label", review: "pdfjs-editor-new-alt-text-to-review-button", "review-label": "pdfjs-editor-new-alt-text-to-review-button-label" }));
      }
      static initialize(e2) {
        _AltText._l10n ??= e2;
      }
      async render() {
        const e2 = __privateSet(this, _Wi, document.createElement("button"));
        e2.className = "altText", e2.tabIndex = "0";
        const t2 = __privateSet(this, _Gi, document.createElement("span"));
        e2.append(t2), __privateGet(this, _ea) ? (e2.classList.add("new"), e2.setAttribute("data-l10n-id", __privateGet(_AltText, _ta).missing), t2.setAttribute("data-l10n-id", __privateGet(_AltText, _ta)["missing-label"])) : (e2.setAttribute("data-l10n-id", "pdfjs-editor-alt-text-button"), t2.setAttribute("data-l10n-id", "pdfjs-editor-alt-text-button-label"));
        const i2 = __privateGet(this, _st2)._uiManager._signal;
        e2.addEventListener("contextmenu", noContextMenu, { signal: i2 }), e2.addEventListener("pointerdown", (e3) => e3.stopPropagation(), { signal: i2 });
        const onClick = /* @__PURE__ */ __name((e3) => {
          e3.preventDefault(), __privateGet(this, _st2)._uiManager.editAltText(__privateGet(this, _st2)), __privateGet(this, _ea) && __privateGet(this, _st2)._reportTelemetry({ action: "pdfjs.image.alt_text.image_status_label_clicked", data: { label: __privateGet(this, _ia, ia_get) } });
        }, "onClick");
        return e2.addEventListener("click", onClick, { capture: true, signal: i2 }), e2.addEventListener("keydown", (t3) => {
          t3.target === e2 && "Enter" === t3.key && (__privateSet(this, _Yi, true), onClick(t3));
        }, { signal: i2 }), await __privateMethod(this, _aa, aa_fn).call(this), e2;
      }
      finish() {
        __privateGet(this, _Wi) && (__privateGet(this, _Wi).focus({ focusVisible: __privateGet(this, _Yi) }), __privateSet(this, _Yi, false));
      }
      isEmpty() {
        return __privateGet(this, _ea) ? null === __privateGet(this, _ot2) : !__privateGet(this, _ot2) && !__privateGet(this, _zi);
      }
      hasData() {
        return __privateGet(this, _ea) ? null !== __privateGet(this, _ot2) || !!__privateGet(this, _Zi) : this.isEmpty();
      }
      get guessedText() {
        return __privateGet(this, _Zi);
      }
      async setGuessedText(e2) {
        null === __privateGet(this, _ot2) && (__privateSet(this, _Zi, e2), __privateSet(this, _Qi, await _AltText._l10n.get("pdfjs-editor-new-alt-text-generated-alt-text-with-disclaimer", { generatedAltText: e2 })), __privateMethod(this, _aa, aa_fn).call(this));
      }
      toggleAltTextBadge(e2 = false) {
        if (!__privateGet(this, _ea) || __privateGet(this, _ot2))
          return __privateGet(this, _Ji)?.remove(), void __privateSet(this, _Ji, null);
        if (!__privateGet(this, _Ji)) {
          const e3 = __privateSet(this, _Ji, document.createElement("div"));
          e3.className = "noAltTextBadge", __privateGet(this, _st2).div.append(e3);
        }
        __privateGet(this, _Ji).classList.toggle("hidden", !e2);
      }
      serialize(e2) {
        let t2 = __privateGet(this, _ot2);
        return e2 || __privateGet(this, _Zi) !== t2 || (t2 = __privateGet(this, _Qi)), { altText: t2, decorative: __privateGet(this, _zi), guessedText: __privateGet(this, _Zi), textWithDisclaimer: __privateGet(this, _Qi) };
      }
      get data() {
        return { altText: __privateGet(this, _ot2), decorative: __privateGet(this, _zi) };
      }
      set data({ altText: e2, decorative: t2, guessedText: i2, textWithDisclaimer: a2, cancel: n2 = false }) {
        i2 && (__privateSet(this, _Zi, i2), __privateSet(this, _Qi, a2)), __privateGet(this, _ot2) === e2 && __privateGet(this, _zi) === t2 || (n2 || (__privateSet(this, _ot2, e2), __privateSet(this, _zi, t2)), __privateMethod(this, _aa, aa_fn).call(this));
      }
      toggle(e2 = false) {
        __privateGet(this, _Wi) && (!e2 && __privateGet(this, _Ki) && (clearTimeout(__privateGet(this, _Ki)), __privateSet(this, _Ki, null)), __privateGet(this, _Wi).disabled = !e2);
      }
      shown() {
        __privateGet(this, _st2)._reportTelemetry({ action: "pdfjs.image.alt_text.image_status_label_displayed", data: { label: __privateGet(this, _ia, ia_get) } });
      }
      destroy() {
        __privateGet(this, _Wi)?.remove(), __privateSet(this, _Wi, null), __privateSet(this, _Gi, null), __privateSet(this, _Vi, null), __privateGet(this, _Ji)?.remove(), __privateSet(this, _Ji, null);
      }
    };
    AltText = _AltText;
    __name(AltText, "AltText");
    _ot2 = new WeakMap();
    _zi = new WeakMap();
    _Wi = new WeakMap();
    _Gi = new WeakMap();
    _Vi = new WeakMap();
    _Ki = new WeakMap();
    _Yi = new WeakMap();
    _Ji = new WeakMap();
    _st2 = new WeakMap();
    _Zi = new WeakMap();
    _Qi = new WeakMap();
    _ea = new WeakMap();
    _ta = new WeakMap();
    _ia = new WeakSet();
    ia_get = /* @__PURE__ */ __name(function() {
      return (__privateGet(this, _ot2) ? "added" : null === __privateGet(this, _ot2) && this.guessedText && "review") || "missing";
    }, "#ia");
    _aa = new WeakSet();
    aa_fn = /* @__PURE__ */ __name(async function() {
      const e2 = __privateGet(this, _Wi);
      if (!e2)
        return;
      if (__privateGet(this, _ea)) {
        if (e2.classList.toggle("done", !!__privateGet(this, _ot2)), e2.setAttribute("data-l10n-id", __privateGet(_AltText, _ta)[__privateGet(this, _ia, ia_get)]), __privateGet(this, _Gi)?.setAttribute("data-l10n-id", __privateGet(_AltText, _ta)[`${__privateGet(this, _ia, ia_get)}-label`]), !__privateGet(this, _ot2))
          return void __privateGet(this, _Vi)?.remove();
      } else {
        if (!__privateGet(this, _ot2) && !__privateGet(this, _zi))
          return e2.classList.remove("done"), void __privateGet(this, _Vi)?.remove();
        e2.classList.add("done"), e2.setAttribute("data-l10n-id", "pdfjs-editor-alt-text-edit-button");
      }
      let t2 = __privateGet(this, _Vi);
      if (!t2) {
        __privateSet(this, _Vi, t2 = document.createElement("span")), t2.className = "tooltip", t2.setAttribute("role", "tooltip"), t2.id = `alt-text-tooltip-${__privateGet(this, _st2).id}`;
        const i3 = 100, a2 = __privateGet(this, _st2)._uiManager._signal;
        a2.addEventListener("abort", () => {
          clearTimeout(__privateGet(this, _Ki)), __privateSet(this, _Ki, null);
        }, { once: true }), e2.addEventListener("mouseenter", () => {
          __privateSet(this, _Ki, setTimeout(() => {
            __privateSet(this, _Ki, null), __privateGet(this, _Vi).classList.add("show"), __privateGet(this, _st2)._reportTelemetry({ action: "alt_text_tooltip" });
          }, i3));
        }, { signal: a2 }), e2.addEventListener("mouseleave", () => {
          __privateGet(this, _Ki) && (clearTimeout(__privateGet(this, _Ki)), __privateSet(this, _Ki, null)), __privateGet(this, _Vi)?.classList.remove("show");
        }, { signal: a2 });
      }
      __privateGet(this, _zi) ? t2.setAttribute("data-l10n-id", "pdfjs-editor-alt-text-decorative-tooltip") : (t2.removeAttribute("data-l10n-id"), t2.textContent = __privateGet(this, _ot2)), t2.parentNode || e2.append(t2);
      const i2 = __privateGet(this, _st2).getElementForAltText();
      i2?.setAttribute("aria-describedby", t2.id);
    }, "#aa");
    __privateAdd(AltText, _ta, null);
    __publicField(AltText, "_l10n", null);
    Comment = class {
      #na = null;
      #sa = false;
      #st = null;
      #ra = null;
      #ve = null;
      #oa = null;
      #la = false;
      constructor(e2) {
        this.#st = e2, this.toolbar = null;
      }
      render() {
        if (!this.#st._uiManager.hasCommentManager())
          return null;
        const e2 = this.#na = document.createElement("button");
        e2.className = "comment", e2.tabIndex = "0", e2.setAttribute("data-l10n-id", "pdfjs-editor-edit-comment-button");
        const t2 = this.#st._uiManager._signal;
        if (!(t2 instanceof AbortSignal) || t2.aborted)
          return e2;
        e2.addEventListener("contextmenu", noContextMenu, { signal: t2 }), e2.addEventListener("pointerdown", (e3) => e3.stopPropagation(), { signal: t2 });
        const onClick = /* @__PURE__ */ __name((e3) => {
          e3.preventDefault(), this.edit();
        }, "onClick");
        return e2.addEventListener("click", onClick, { capture: true, signal: t2 }), e2.addEventListener("keydown", (t3) => {
          t3.target === e2 && "Enter" === t3.key && (this.#sa = true, onClick(t3));
        }, { signal: t2 }), e2;
      }
      edit() {
        const { bottom: e2, left: t2, right: i2 } = this.#st.getClientDimensions(), a2 = { top: e2 };
        "ltr" === this.#st._uiManager.direction ? a2.right = i2 : a2.left = t2, this.#st._uiManager.editComment(this.#st, a2);
      }
      finish() {
        this.#na && (this.#na.focus({ focusVisible: this.#sa }), this.#sa = false);
      }
      isDeleted() {
        return this.#la || "" === this.#ve;
      }
      hasBeenEdited() {
        return this.isDeleted() || this.#ve !== this.#ra;
      }
      serialize() {
        return this.data;
      }
      get data() {
        return { text: this.#ve, date: this.#oa, deleted: this.#la };
      }
      set data(e2) {
        if (null === e2)
          return this.#ve = "", void (this.#la = true);
        this.#ve = e2, this.#oa = /* @__PURE__ */ new Date(), this.#la = false;
      }
      setInitialText(e2) {
        this.#ra = e2, this.data = e2;
      }
      toggle(e2 = false) {
        this.#na && (this.#na.disabled = !e2);
      }
      shown() {
      }
      destroy() {
        this.#na?.remove(), this.#na = null, this.#ve = "", this.#oa = null, this.#st = null, this.#sa = false, this.#la = false;
      }
    };
    __name(Comment, "Comment");
    TouchManager = class {
      #Ai;
      #ca = false;
      #ha = null;
      #da;
      #ua;
      #ga;
      #pa;
      #fa = null;
      #ma;
      #ba = null;
      #ya;
      #wa = null;
      constructor({ container: e2, isPinchingDisabled: t2 = null, isPinchingStopped: i2 = null, onPinchStart: a2 = null, onPinching: n2 = null, onPinchEnd: s2 = null, signal: r2 }) {
        this.#Ai = e2, this.#ha = i2, this.#da = t2, this.#ua = a2, this.#ga = n2, this.#pa = s2, this.#ya = new AbortController(), this.#ma = AbortSignal.any([r2, this.#ya.signal]), e2.addEventListener("touchstart", this.#Aa.bind(this), { passive: false, signal: this.#ma });
      }
      get MIN_TOUCH_DISTANCE_TO_PINCH() {
        return 35 / OutputScale.pixelRatio;
      }
      #Aa(e2) {
        if (this.#da?.())
          return;
        if (1 === e2.touches.length) {
          if (this.#fa)
            return;
          const e3 = this.#fa = new AbortController(), t3 = AbortSignal.any([this.#ma, e3.signal]), i3 = this.#Ai, a2 = { capture: true, signal: t3, passive: false }, cancelPointerDown = /* @__PURE__ */ __name((e4) => {
            "touch" === e4.pointerType && (this.#fa?.abort(), this.#fa = null);
          }, "cancelPointerDown");
          return i3.addEventListener("pointerdown", (e4) => {
            "touch" === e4.pointerType && (stopEvent(e4), cancelPointerDown(e4));
          }, a2), i3.addEventListener("pointerup", cancelPointerDown, a2), void i3.addEventListener("pointercancel", cancelPointerDown, a2);
        }
        if (!this.#wa) {
          this.#wa = new AbortController();
          const e3 = AbortSignal.any([this.#ma, this.#wa.signal]), t3 = this.#Ai, i3 = { signal: e3, capture: false, passive: false };
          t3.addEventListener("touchmove", this.#xa.bind(this), i3);
          const a2 = this.#Sa.bind(this);
          t3.addEventListener("touchend", a2, i3), t3.addEventListener("touchcancel", a2, i3), i3.capture = true, t3.addEventListener("pointerdown", stopEvent, i3), t3.addEventListener("pointermove", stopEvent, i3), t3.addEventListener("pointercancel", stopEvent, i3), t3.addEventListener("pointerup", stopEvent, i3), this.#ua?.();
        }
        if (stopEvent(e2), 2 !== e2.touches.length || this.#ha?.())
          return void (this.#ba = null);
        let [t2, i2] = e2.touches;
        t2.identifier > i2.identifier && ([t2, i2] = [i2, t2]), this.#ba = { touch0X: t2.screenX, touch0Y: t2.screenY, touch1X: i2.screenX, touch1Y: i2.screenY };
      }
      #xa(e2) {
        if (!this.#ba || 2 !== e2.touches.length)
          return;
        stopEvent(e2);
        let [t2, i2] = e2.touches;
        t2.identifier > i2.identifier && ([t2, i2] = [i2, t2]);
        const { screenX: a2, screenY: n2 } = t2, { screenX: s2, screenY: r2 } = i2, o2 = this.#ba, { touch0X: l3, touch0Y: c2, touch1X: h2, touch1Y: d2 } = o2, u2 = h2 - l3, g2 = d2 - c2, p2 = s2 - a2, f2 = r2 - n2, m2 = Math.hypot(p2, f2) || 1, b2 = Math.hypot(u2, g2) || 1;
        if (!this.#ca && Math.abs(b2 - m2) <= TouchManager.MIN_TOUCH_DISTANCE_TO_PINCH)
          return;
        if (o2.touch0X = a2, o2.touch0Y = n2, o2.touch1X = s2, o2.touch1Y = r2, !this.#ca)
          return void (this.#ca = true);
        const y2 = [(a2 + s2) / 2, (n2 + r2) / 2];
        this.#ga?.(y2, b2, m2);
      }
      #Sa(e2) {
        e2.touches.length >= 2 || (this.#wa && (this.#wa.abort(), this.#wa = null, this.#pa?.()), this.#ba && (stopEvent(e2), this.#ba = null, this.#ca = false));
      }
      destroy() {
        this.#ya?.abort(), this.#ya = null, this.#fa?.abort(), this.#fa = null;
      }
    };
    __name(TouchManager, "TouchManager");
    _AnnotationEditor = class {
      constructor(e2) {
        __privateAdd(this, _Ga);
        __privateAdd(this, _Ka);
        __privateAdd(this, _Ya);
        __privateAdd(this, _Ja);
        __privateAdd(this, _en);
        __privateAdd(this, _Qa);
        __privateAdd(this, _Za);
        __privateAdd(this, _in);
        __privateAdd(this, _an);
        __privateAdd(this, _nn);
        __privateAdd(this, _rn);
        __privateAdd(this, _sn);
        __privateAdd(this, _tn);
        __privateAdd(this, _on);
        __privateAdd(this, _ln);
        __privateAdd(this, _cn);
        __privateAdd(this, _hn);
        __privateAdd(this, _Wa);
        __privateAdd(this, _va, null);
        __privateAdd(this, _Ca, null);
        __privateAdd(this, _ot3, null);
        __privateAdd(this, _lt2, null);
        __privateAdd(this, _ka, false);
        __privateAdd(this, _Ta, null);
        __privateAdd(this, _Ia, "");
        __privateAdd(this, _Fa, false);
        __privateAdd(this, _Ma, null);
        __privateAdd(this, _Da, null);
        __privateAdd(this, _Ea, null);
        __privateAdd(this, _Oa, null);
        __privateAdd(this, __a, "");
        __privateAdd(this, _Pa, false);
        __privateAdd(this, _Ra, null);
        __privateAdd(this, _Ba, false);
        __privateAdd(this, _Na, false);
        __privateAdd(this, _La, false);
        __privateAdd(this, _Ua, null);
        __privateAdd(this, _ja, 0);
        __privateAdd(this, _$a, 0);
        __privateAdd(this, _Ha, null);
        __privateAdd(this, _qa, null);
        __publicField(this, "isSelected", false);
        __publicField(this, "_isCopy", false);
        __publicField(this, "_editToolbar", null);
        __publicField(this, "_initialOptions", /* @__PURE__ */ Object.create(null));
        __publicField(this, "_initialData", null);
        __publicField(this, "_isVisible", true);
        __publicField(this, "_uiManager", null);
        __publicField(this, "_focusEventsAllowed", true);
        __privateAdd(this, _Xa, false);
        __privateAdd(this, _za, _AnnotationEditor._zIndex++);
        this.parent = e2.parent, this.id = e2.id, this.width = this.height = null, this.pageIndex = e2.parent.pageIndex, this.name = e2.name, this.div = null, this._uiManager = e2.uiManager, this.annotationElementId = null, this._willKeepAspectRatio = false, this._initialOptions.isCentered = e2.isCentered, this._structTreeParentId = null, this.annotationElementId = e2.annotationElementId || null;
        const { rotation: t2, rawDims: { pageWidth: i2, pageHeight: a2, pageX: n2, pageY: s2 } } = this.parent.viewport;
        this.rotation = t2, this.pageRotation = (360 + t2 - this._uiManager.viewParameters.rotation) % 360, this.pageDimensions = [i2, a2], this.pageTranslation = [n2, s2];
        const [r2, o2] = this.parentDimensions;
        this.x = e2.x / r2, this.y = e2.y / o2, this.isAttachedToDOM = false, this.deleted = false;
      }
      static get _resizerKeyboardManager() {
        const e2 = _AnnotationEditor.prototype._resizeWithKeyboard, t2 = AnnotationEditorUIManager.TRANSLATE_SMALL, i2 = AnnotationEditorUIManager.TRANSLATE_BIG;
        return shadow(this, "_resizerKeyboardManager", new KeyboardManager([[["ArrowLeft", "mac+ArrowLeft"], e2, { args: [-t2, 0] }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], e2, { args: [-i2, 0] }], [["ArrowRight", "mac+ArrowRight"], e2, { args: [t2, 0] }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], e2, { args: [i2, 0] }], [["ArrowUp", "mac+ArrowUp"], e2, { args: [0, -t2] }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], e2, { args: [0, -i2] }], [["ArrowDown", "mac+ArrowDown"], e2, { args: [0, t2] }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], e2, { args: [0, i2] }], [["Escape", "mac+Escape"], _AnnotationEditor.prototype._stopResizingWithKeyboard]]));
      }
      get editorType() {
        return Object.getPrototypeOf(this).constructor._type;
      }
      get mode() {
        return Object.getPrototypeOf(this).constructor._editorType;
      }
      static get isDrawer() {
        return false;
      }
      static get _defaultLineColor() {
        return shadow(this, "_defaultLineColor", this._colorManager.getHexCode("CanvasText"));
      }
      static deleteAnnotationElement(e2) {
        const t2 = new FakeEditor({ id: e2.parent.getNextId(), parent: e2.parent, uiManager: e2._uiManager });
        t2.annotationElementId = e2.annotationElementId, t2.deleted = true, t2._uiManager.addToAnnotationStorage(t2);
      }
      static initialize(e2, t2) {
        if (_AnnotationEditor._l10n ??= e2, _AnnotationEditor._l10nResizer ||= Object.freeze({ topLeft: "pdfjs-editor-resizer-top-left", topMiddle: "pdfjs-editor-resizer-top-middle", topRight: "pdfjs-editor-resizer-top-right", middleRight: "pdfjs-editor-resizer-middle-right", bottomRight: "pdfjs-editor-resizer-bottom-right", bottomMiddle: "pdfjs-editor-resizer-bottom-middle", bottomLeft: "pdfjs-editor-resizer-bottom-left", middleLeft: "pdfjs-editor-resizer-middle-left" }), -1 !== _AnnotationEditor._borderLineWidth)
          return;
        const i2 = getComputedStyle(document.documentElement);
        _AnnotationEditor._borderLineWidth = parseFloat(i2.getPropertyValue("--outline-width")) || 0;
      }
      static updateDefaultParams(e2, t2) {
      }
      static get defaultPropertiesToUpdate() {
        return [];
      }
      static isHandlingMimeForPasting(e2) {
        return false;
      }
      static paste(e2, t2) {
        unreachable("Not implemented");
      }
      get propertiesToUpdate() {
        return [];
      }
      get _isDraggable() {
        return __privateGet(this, _Xa);
      }
      set _isDraggable(e2) {
        __privateSet(this, _Xa, e2), this.div?.classList.toggle("draggable", e2);
      }
      get isEnterHandled() {
        return true;
      }
      center() {
        const [e2, t2] = this.pageDimensions;
        switch (this.parentRotation) {
          case 90:
            this.x -= this.height * t2 / (2 * e2), this.y += this.width * e2 / (2 * t2);
            break;
          case 180:
            this.x += this.width / 2, this.y += this.height / 2;
            break;
          case 270:
            this.x += this.height * t2 / (2 * e2), this.y -= this.width * e2 / (2 * t2);
            break;
          default:
            this.x -= this.width / 2, this.y -= this.height / 2;
        }
        this.fixAndSetPosition();
      }
      addCommands(e2) {
        this._uiManager.addCommands(e2);
      }
      get currentLayer() {
        return this._uiManager.currentLayer;
      }
      setInBackground() {
        this.div.style.zIndex = 0;
      }
      setInForeground() {
        this.div.style.zIndex = __privateGet(this, _za);
      }
      setParent(e2) {
        null !== e2 ? (this.pageIndex = e2.pageIndex, this.pageDimensions = e2.pageDimensions) : __privateMethod(this, _Wa, Wa_fn).call(this), this.parent = e2;
      }
      focusin(e2) {
        this._focusEventsAllowed && (__privateGet(this, _Pa) ? __privateSet(this, _Pa, false) : this.parent.setSelected(this));
      }
      focusout(e2) {
        if (!this._focusEventsAllowed)
          return;
        if (!this.isAttachedToDOM)
          return;
        const t2 = e2.relatedTarget;
        t2?.closest(`#${this.id}`) || (e2.preventDefault(), this.parent?.isMultipleSelection || this.commitOrRemove());
      }
      commitOrRemove() {
        this.isEmpty() ? this.remove() : this.commit();
      }
      commit() {
        this.isInEditMode() && this.addToAnnotationStorage();
      }
      addToAnnotationStorage() {
        this._uiManager.addToAnnotationStorage(this);
      }
      setAt(e2, t2, i2, a2) {
        const [n2, s2] = this.parentDimensions;
        [i2, a2] = this.screenToPageTranslation(i2, a2), this.x = (e2 + i2) / n2, this.y = (t2 + a2) / s2, this.fixAndSetPosition();
      }
      _moveAfterPaste(e2, t2) {
        const [i2, a2] = this.parentDimensions;
        this.setAt(e2 * i2, t2 * a2, this.width * i2, this.height * a2), this._onTranslated();
      }
      translate(e2, t2) {
        __privateMethod(this, _Ga, Ga_fn).call(this, this.parentDimensions, e2, t2);
      }
      translateInPage(e2, t2) {
        __privateGet(this, _Ra) || __privateSet(this, _Ra, [this.x, this.y, this.width, this.height]), __privateMethod(this, _Ga, Ga_fn).call(this, this.pageDimensions, e2, t2), this.div.scrollIntoView({ block: "nearest" });
      }
      translationDone() {
        this._onTranslated(this.x, this.y);
      }
      drag(e2, t2) {
        __privateGet(this, _Ra) || __privateSet(this, _Ra, [this.x, this.y, this.width, this.height]);
        const { div: i2, parentDimensions: [a2, n2] } = this;
        if (this.x += e2 / a2, this.y += t2 / n2, this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) {
          const { x: e3, y: t3 } = this.div.getBoundingClientRect();
          this.parent.findNewParent(this, e3, t3) && (this.x -= Math.floor(this.x), this.y -= Math.floor(this.y));
        }
        let { x: s2, y: r2 } = this;
        const [o2, l3] = this.getBaseTranslation();
        s2 += o2, r2 += l3;
        const { style: c2 } = i2;
        c2.left = `${(100 * s2).toFixed(2)}%`, c2.top = `${(100 * r2).toFixed(2)}%`, this._onTranslating(s2, r2), i2.scrollIntoView({ block: "nearest" });
      }
      _onTranslating(e2, t2) {
      }
      _onTranslated(e2, t2) {
      }
      get _hasBeenMoved() {
        return !!__privateGet(this, _Ra) && (__privateGet(this, _Ra)[0] !== this.x || __privateGet(this, _Ra)[1] !== this.y);
      }
      get _hasBeenResized() {
        return !!__privateGet(this, _Ra) && (__privateGet(this, _Ra)[2] !== this.width || __privateGet(this, _Ra)[3] !== this.height);
      }
      getBaseTranslation() {
        const [e2, t2] = this.parentDimensions, { _borderLineWidth: i2 } = _AnnotationEditor, a2 = i2 / e2, n2 = i2 / t2;
        switch (this.rotation) {
          case 90:
            return [-a2, n2];
          case 180:
            return [a2, n2];
          case 270:
            return [a2, -n2];
          default:
            return [-a2, -n2];
        }
      }
      get _mustFixPosition() {
        return true;
      }
      fixAndSetPosition(e2 = this.rotation) {
        const { div: { style: t2 }, pageDimensions: [i2, a2] } = this;
        let { x: n2, y: s2, width: r2, height: o2 } = this;
        if (r2 *= i2, o2 *= a2, n2 *= i2, s2 *= a2, this._mustFixPosition)
          switch (e2) {
            case 0:
              n2 = MathClamp(n2, 0, i2 - r2), s2 = MathClamp(s2, 0, a2 - o2);
              break;
            case 90:
              n2 = MathClamp(n2, 0, i2 - o2), s2 = MathClamp(s2, r2, a2);
              break;
            case 180:
              n2 = MathClamp(n2, r2, i2), s2 = MathClamp(s2, o2, a2);
              break;
            case 270:
              n2 = MathClamp(n2, o2, i2), s2 = MathClamp(s2, 0, a2 - r2);
          }
        this.x = n2 /= i2, this.y = s2 /= a2;
        const [l3, c2] = this.getBaseTranslation();
        n2 += l3, s2 += c2, t2.left = `${(100 * n2).toFixed(2)}%`, t2.top = `${(100 * s2).toFixed(2)}%`, this.moveInDOM();
      }
      screenToPageTranslation(e2, t2) {
        var _a4;
        return __privateMethod(_a4 = _AnnotationEditor, _Va, Va_fn).call(_a4, e2, t2, this.parentRotation);
      }
      pageTranslationToScreen(e2, t2) {
        var _a4;
        return __privateMethod(_a4 = _AnnotationEditor, _Va, Va_fn).call(_a4, e2, t2, 360 - this.parentRotation);
      }
      get parentScale() {
        return this._uiManager.viewParameters.realScale;
      }
      get parentRotation() {
        return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360;
      }
      get parentDimensions() {
        const { parentScale: e2, pageDimensions: [t2, i2] } = this;
        return [t2 * e2, i2 * e2];
      }
      setDims(e2, t2) {
        const [i2, a2] = this.parentDimensions, { style: n2 } = this.div;
        n2.width = `${(100 * e2 / i2).toFixed(2)}%`, __privateGet(this, _Fa) || (n2.height = `${(100 * t2 / a2).toFixed(2)}%`);
      }
      fixDims() {
        const { style: e2 } = this.div, { height: t2, width: i2 } = e2, a2 = i2.endsWith("%"), n2 = !__privateGet(this, _Fa) && t2.endsWith("%");
        if (a2 && n2)
          return;
        const [s2, r2] = this.parentDimensions;
        a2 || (e2.width = `${(100 * parseFloat(i2) / s2).toFixed(2)}%`), __privateGet(this, _Fa) || n2 || (e2.height = `${(100 * parseFloat(t2) / r2).toFixed(2)}%`);
      }
      getInitialTranslation() {
        return [0, 0];
      }
      _onResized() {
      }
      static _round(e2) {
        return Math.round(1e4 * e2) / 1e4;
      }
      _onResizing() {
      }
      altTextFinish() {
        __privateGet(this, _ot3)?.finish();
      }
      get toolbarButtons() {
        return null;
      }
      async addEditToolbar() {
        if (this._editToolbar || __privateGet(this, _Na))
          return this._editToolbar;
        this._editToolbar = new EditorToolbar(this), this.div.append(this._editToolbar.render());
        const { toolbarButtons: e2 } = this;
        if (e2)
          for (const [t2, i2] of e2)
            await this._editToolbar.addButton(t2, i2);
        return this._editToolbar.addButton("comment", this.addCommentButton()), this._editToolbar.addButton("delete"), this._editToolbar;
      }
      removeEditToolbar() {
        this._editToolbar && (this._editToolbar.remove(), this._editToolbar = null, __privateGet(this, _ot3)?.destroy());
      }
      addContainer(e2) {
        const t2 = this._editToolbar?.div;
        t2 ? t2.before(e2) : this.div.append(e2);
      }
      getClientDimensions() {
        return this.div.getBoundingClientRect();
      }
      createAltText() {
        return __privateGet(this, _ot3) || (AltText.initialize(_AnnotationEditor._l10n), __privateSet(this, _ot3, new AltText(this)), __privateGet(this, _va) && (__privateGet(this, _ot3).data = __privateGet(this, _va), __privateSet(this, _va, null))), __privateGet(this, _ot3);
      }
      get altTextData() {
        return __privateGet(this, _ot3)?.data;
      }
      set altTextData(e2) {
        __privateGet(this, _ot3) && (__privateGet(this, _ot3).data = e2);
      }
      get guessedAltText() {
        return __privateGet(this, _ot3)?.guessedText;
      }
      async setGuessedAltText(e2) {
        await __privateGet(this, _ot3)?.setGuessedText(e2);
      }
      serializeAltText(e2) {
        return __privateGet(this, _ot3)?.serialize(e2);
      }
      hasAltText() {
        return !!__privateGet(this, _ot3) && !__privateGet(this, _ot3).isEmpty();
      }
      hasAltTextData() {
        return __privateGet(this, _ot3)?.hasData() ?? false;
      }
      addCommentButton() {
        return __privateGet(this, _lt2) ? __privateGet(this, _lt2) : __privateSet(this, _lt2, new Comment(this));
      }
      get commentColor() {
        return null;
      }
      get comment() {
        const e2 = __privateGet(this, _lt2);
        return { text: e2.data.text, date: e2.data.date, deleted: e2.isDeleted(), color: this.commentColor };
      }
      set comment(e2) {
        __privateGet(this, _lt2) || __privateSet(this, _lt2, new Comment(this)), __privateGet(this, _lt2).data = e2;
      }
      setCommentData(e2) {
        __privateGet(this, _lt2) || __privateSet(this, _lt2, new Comment(this)), __privateGet(this, _lt2).setInitialText(e2);
      }
      get hasEditedComment() {
        return __privateGet(this, _lt2)?.hasBeenEdited();
      }
      async editComment() {
        __privateGet(this, _lt2) || __privateSet(this, _lt2, new Comment(this)), __privateGet(this, _lt2).edit();
      }
      addComment(e2) {
        if (this.hasEditedComment) {
          const t2 = 180, i2 = 100, [, , , a2] = e2.rect, [n2] = this.pageDimensions, [s2] = this.pageTranslation, r2 = s2 + n2 + 1, o2 = a2 - i2, l3 = r2 + t2;
          e2.popup = { contents: this.comment.text, deleted: this.comment.deleted, rect: [r2, o2, l3, a2] };
        }
      }
      render() {
        const e2 = this.div = document.createElement("div");
        e2.setAttribute("data-editor-rotation", (360 - this.rotation) % 360), e2.className = this.name, e2.setAttribute("id", this.id), e2.tabIndex = __privateGet(this, _ka) ? -1 : 0, e2.setAttribute("role", "application"), this.defaultL10nId && e2.setAttribute("data-l10n-id", this.defaultL10nId), this._isVisible || e2.classList.add("hidden"), this.setInForeground(), __privateMethod(this, _tn, tn_fn).call(this);
        const [t2, i2] = this.parentDimensions;
        this.parentRotation % 180 != 0 && (e2.style.maxWidth = `${(100 * i2 / t2).toFixed(2)}%`, e2.style.maxHeight = `${(100 * t2 / i2).toFixed(2)}%`);
        const [a2, n2] = this.getInitialTranslation();
        return this.translate(a2, n2), bindEvents(this, e2, ["keydown", "pointerdown", "dblclick"]), this.isResizable && this._uiManager._supportsPinchToZoom && (__privateGet(this, _qa) || __privateSet(this, _qa, new TouchManager({ container: e2, isPinchingDisabled: () => !this.isSelected, onPinchStart: __privateMethod(this, _in, in_fn).bind(this), onPinching: __privateMethod(this, _an, an_fn).bind(this), onPinchEnd: __privateMethod(this, _nn, nn_fn).bind(this), signal: this._uiManager._signal }))), this._uiManager._editorUndoBar?.hide(), e2;
      }
      pointerdown(e2) {
        const { isMac: t2 } = util_FeatureTest.platform;
        0 !== e2.button || e2.ctrlKey && t2 ? e2.preventDefault() : (__privateSet(this, _Pa, true), this._isDraggable ? __privateMethod(this, _sn, sn_fn).call(this, e2) : __privateMethod(this, _rn, rn_fn).call(this, e2));
      }
      _onStartDragging() {
      }
      _onStopDragging() {
      }
      moveInDOM() {
        __privateGet(this, _Ua) && clearTimeout(__privateGet(this, _Ua)), __privateSet(this, _Ua, setTimeout(() => {
          __privateSet(this, _Ua, null), this.parent?.moveEditorInDOM(this);
        }, 0));
      }
      _setParentAndPosition(e2, t2, i2) {
        e2.changeParent(this), this.x = t2, this.y = i2, this.fixAndSetPosition(), this._onTranslated();
      }
      getRect(e2, t2, i2 = this.rotation) {
        const a2 = this.parentScale, [n2, s2] = this.pageDimensions, [r2, o2] = this.pageTranslation, l3 = e2 / a2, c2 = t2 / a2, h2 = this.x * n2, d2 = this.y * s2, u2 = this.width * n2, g2 = this.height * s2;
        switch (i2) {
          case 0:
            return [h2 + l3 + r2, s2 - d2 - c2 - g2 + o2, h2 + l3 + u2 + r2, s2 - d2 - c2 + o2];
          case 90:
            return [h2 + c2 + r2, s2 - d2 + l3 + o2, h2 + c2 + g2 + r2, s2 - d2 + l3 + u2 + o2];
          case 180:
            return [h2 - l3 - u2 + r2, s2 - d2 + c2 + o2, h2 - l3 + r2, s2 - d2 + c2 + g2 + o2];
          case 270:
            return [h2 - c2 - g2 + r2, s2 - d2 - l3 - u2 + o2, h2 - c2 + r2, s2 - d2 - l3 + o2];
          default:
            throw new Error("Invalid rotation");
        }
      }
      getRectInCurrentCoords(e2, t2) {
        const [i2, a2, n2, s2] = e2, r2 = n2 - i2, o2 = s2 - a2;
        switch (this.rotation) {
          case 0:
            return [i2, t2 - s2, r2, o2];
          case 90:
            return [i2, t2 - a2, o2, r2];
          case 180:
            return [n2, t2 - a2, r2, o2];
          case 270:
            return [n2, t2 - s2, o2, r2];
          default:
            throw new Error("Invalid rotation");
        }
      }
      getPDFRect() {
        return this.getRect(0, 0);
      }
      onceAdded(e2) {
      }
      isEmpty() {
        return false;
      }
      enableEditMode() {
        return !this.isInEditMode() && (this.parent.setEditingState(false), __privateSet(this, _Na, true), true);
      }
      disableEditMode() {
        return !!this.isInEditMode() && (this.parent.setEditingState(true), __privateSet(this, _Na, false), true);
      }
      isInEditMode() {
        return __privateGet(this, _Na);
      }
      shouldGetKeyboardEvents() {
        return __privateGet(this, _La);
      }
      needsToBeRebuilt() {
        return this.div && !this.isAttachedToDOM;
      }
      get isOnScreen() {
        const { top: e2, left: t2, bottom: i2, right: a2 } = this.getClientDimensions(), { innerHeight: n2, innerWidth: s2 } = window;
        return t2 < s2 && a2 > 0 && e2 < n2 && i2 > 0;
      }
      rebuild() {
        __privateMethod(this, _tn, tn_fn).call(this);
      }
      rotate(e2) {
      }
      resize() {
      }
      serializeDeleted() {
        return { id: this.annotationElementId, deleted: true, pageIndex: this.pageIndex, popupRef: this._initialData?.popupRef || "" };
      }
      serialize(e2 = false, t2 = null) {
        unreachable("An editor must be serializable");
      }
      static async deserialize(e2, t2, i2) {
        const a2 = new this.prototype.constructor({ parent: t2, id: t2.getNextId(), uiManager: i2, annotationElementId: e2.annotationElementId });
        a2.rotation = e2.rotation, __privateSet(a2, _va, e2.accessibilityData), a2._isCopy = e2.isCopy || false;
        const [n2, s2] = a2.pageDimensions, [r2, o2, l3, c2] = a2.getRectInCurrentCoords(e2.rect, s2);
        return a2.x = r2 / n2, a2.y = o2 / s2, a2.width = l3 / n2, a2.height = c2 / s2, a2;
      }
      get hasBeenModified() {
        return !!this.annotationElementId && (this.deleted || null !== this.serialize());
      }
      remove() {
        if (__privateGet(this, _Oa)?.abort(), __privateSet(this, _Oa, null), this.isEmpty() || this.commit(), this.parent ? this.parent.remove(this) : this._uiManager.removeEditor(this), __privateGet(this, _Ua) && (clearTimeout(__privateGet(this, _Ua)), __privateSet(this, _Ua, null)), __privateMethod(this, _Wa, Wa_fn).call(this), this.removeEditToolbar(), __privateGet(this, _Ha)) {
          for (const e2 of __privateGet(this, _Ha).values())
            clearTimeout(e2);
          __privateSet(this, _Ha, null);
        }
        this.parent = null, __privateGet(this, _qa)?.destroy(), __privateSet(this, _qa, null);
      }
      get isResizable() {
        return false;
      }
      makeResizable() {
        this.isResizable && (__privateMethod(this, _Ya, Ya_fn).call(this), __privateGet(this, _Ma).classList.remove("hidden"));
      }
      get toolbarPosition() {
        return null;
      }
      keydown(e2) {
        if (!this.isResizable || e2.target !== this.div || "Enter" !== e2.key)
          return;
        this._uiManager.setSelected(this), __privateSet(this, _Ea, { savedX: this.x, savedY: this.y, savedWidth: this.width, savedHeight: this.height });
        const t2 = __privateGet(this, _Ma).children;
        if (!__privateGet(this, _Ca)) {
          __privateSet(this, _Ca, Array.from(t2));
          const e3 = __privateMethod(this, _on, on_fn).bind(this), i3 = __privateMethod(this, _ln, ln_fn).bind(this), a3 = this._uiManager._signal;
          for (const t3 of __privateGet(this, _Ca)) {
            const n3 = t3.getAttribute("data-resizer-name");
            t3.setAttribute("role", "spinbutton"), t3.addEventListener("keydown", e3, { signal: a3 }), t3.addEventListener("blur", i3, { signal: a3 }), t3.addEventListener("focus", __privateMethod(this, _cn, cn_fn).bind(this, n3), { signal: a3 }), t3.setAttribute("data-l10n-id", _AnnotationEditor._l10nResizer[n3]);
          }
        }
        const i2 = __privateGet(this, _Ca)[0];
        let a2 = 0;
        for (const e3 of t2) {
          if (e3 === i2)
            break;
          a2++;
        }
        const n2 = (360 - this.rotation + this.parentRotation) % 360 / 90 * (__privateGet(this, _Ca).length / 4);
        if (n2 !== a2) {
          if (n2 < a2)
            for (let e4 = 0; e4 < a2 - n2; e4++)
              __privateGet(this, _Ma).append(__privateGet(this, _Ma).firstChild);
          else if (n2 > a2)
            for (let e4 = 0; e4 < n2 - a2; e4++)
              __privateGet(this, _Ma).firstChild.before(__privateGet(this, _Ma).lastChild);
          let e3 = 0;
          for (const i3 of t2) {
            const t3 = __privateGet(this, _Ca)[e3++].getAttribute("data-resizer-name");
            i3.setAttribute("data-l10n-id", _AnnotationEditor._l10nResizer[t3]);
          }
        }
        __privateMethod(this, _hn, hn_fn).call(this, 0), __privateSet(this, _La, true), __privateGet(this, _Ma).firstChild.focus({ focusVisible: true }), e2.preventDefault(), e2.stopImmediatePropagation();
      }
      _resizeWithKeyboard(e2, t2) {
        __privateGet(this, _La) && __privateMethod(this, _Za, Za_fn).call(this, __privateGet(this, __a), { deltaX: e2, deltaY: t2, fromKeyboard: true });
      }
      _stopResizingWithKeyboard() {
        __privateMethod(this, _Wa, Wa_fn).call(this), this.div.focus();
      }
      select() {
        this.isSelected && this._editToolbar || (this.isSelected = true, this.makeResizable(), this.div?.classList.add("selectedEditor"), this._editToolbar ? (this._editToolbar?.show(), __privateGet(this, _ot3)?.toggleAltTextBadge(false)) : this.addEditToolbar().then(() => {
          this.div?.classList.contains("selectedEditor") && this._editToolbar?.show();
        }));
      }
      unselect() {
        this.isSelected && (this.isSelected = false, __privateGet(this, _Ma)?.classList.add("hidden"), this.div?.classList.remove("selectedEditor"), this.div?.contains(document.activeElement) && this._uiManager.currentLayer.div.focus({ preventScroll: true }), this._editToolbar?.hide(), __privateGet(this, _ot3)?.toggleAltTextBadge(true));
      }
      updateParams(e2, t2) {
      }
      disableEditing() {
      }
      enableEditing() {
      }
      get canChangeContent() {
        return false;
      }
      enterInEditMode() {
        this.canChangeContent && (this.enableEditMode(), this.div.focus());
      }
      dblclick(e2) {
        this.enterInEditMode(), this.parent.updateToolbar({ mode: this.constructor._editorType, editId: this.id });
      }
      getElementForAltText() {
        return this.div;
      }
      get contentDiv() {
        return this.div;
      }
      get isEditing() {
        return __privateGet(this, _Ba);
      }
      set isEditing(e2) {
        __privateSet(this, _Ba, e2), this.parent && (e2 ? (this.parent.setSelected(this), this.parent.setActiveEditor(this)) : this.parent.setActiveEditor(null));
      }
      setAspectRatio(e2, t2) {
        __privateSet(this, _Fa, true);
        const i2 = e2 / t2, { style: a2 } = this.div;
        a2.aspectRatio = i2, a2.height = "auto";
      }
      static get MIN_SIZE() {
        return 16;
      }
      static canCreateNewEmptyEditor() {
        return true;
      }
      get telemetryInitialData() {
        return { action: "added" };
      }
      get telemetryFinalData() {
        return null;
      }
      _reportTelemetry(e2, t2 = false) {
        if (t2) {
          __privateGet(this, _Ha) || __privateSet(this, _Ha, /* @__PURE__ */ new Map());
          const { action: t3 } = e2;
          let i2 = __privateGet(this, _Ha).get(t3);
          return i2 && clearTimeout(i2), i2 = setTimeout(() => {
            this._reportTelemetry(e2), __privateGet(this, _Ha).delete(t3), 0 === __privateGet(this, _Ha).size && __privateSet(this, _Ha, null);
          }, _AnnotationEditor._telemetryTimeout), void __privateGet(this, _Ha).set(t3, i2);
        }
        e2.type ||= this.editorType, this._uiManager._eventBus.dispatch("reporttelemetry", { source: this, details: { type: "editing", data: e2 } });
      }
      show(e2 = this._isVisible) {
        this.div.classList.toggle("hidden", !e2), this._isVisible = e2;
      }
      enable() {
        this.div && (this.div.tabIndex = 0), __privateSet(this, _ka, false);
      }
      disable() {
        this.div && (this.div.tabIndex = -1), __privateSet(this, _ka, true);
      }
      renderAnnotationElement(e2) {
        if (this.deleted)
          return e2.hide(), null;
        let t2 = e2.container.querySelector(".annotationContent");
        if (t2) {
          if ("CANVAS" === t2.nodeName) {
            const e3 = t2;
            t2 = document.createElement("div"), t2.classList.add("annotationContent", this.editorType), e3.before(t2);
          }
        } else
          t2 = document.createElement("div"), t2.classList.add("annotationContent", this.editorType), e2.container.prepend(t2);
        return t2;
      }
      resetAnnotationElement(e2) {
        const { firstChild: t2 } = e2.container;
        "DIV" === t2?.nodeName && t2.classList.contains("annotationContent") && t2.remove();
      }
    };
    AnnotationEditor = _AnnotationEditor;
    __name(AnnotationEditor, "AnnotationEditor");
    _va = new WeakMap();
    _Ca = new WeakMap();
    _ot3 = new WeakMap();
    _lt2 = new WeakMap();
    _ka = new WeakMap();
    _Ta = new WeakMap();
    _Ia = new WeakMap();
    _Fa = new WeakMap();
    _Ma = new WeakMap();
    _Da = new WeakMap();
    _Ea = new WeakMap();
    _Oa = new WeakMap();
    __a = new WeakMap();
    _Pa = new WeakMap();
    _Ra = new WeakMap();
    _Ba = new WeakMap();
    _Na = new WeakMap();
    _La = new WeakMap();
    _Ua = new WeakMap();
    _ja = new WeakMap();
    _$a = new WeakMap();
    _Ha = new WeakMap();
    _qa = new WeakMap();
    _Xa = new WeakMap();
    _za = new WeakMap();
    _Ga = new WeakSet();
    Ga_fn = /* @__PURE__ */ __name(function([e2, t2], i2, a2) {
      [i2, a2] = this.screenToPageTranslation(i2, a2), this.x += i2 / e2, this.y += a2 / t2, this._onTranslating(this.x, this.y), this.fixAndSetPosition();
    }, "#Ga");
    _Va = new WeakSet();
    Va_fn = /* @__PURE__ */ __name(function(e2, t2, i2) {
      switch (i2) {
        case 90:
          return [t2, -e2];
        case 180:
          return [-e2, -t2];
        case 270:
          return [-t2, e2];
        default:
          return [e2, t2];
      }
    }, "#Va");
    _Ka = new WeakSet();
    Ka_fn = /* @__PURE__ */ __name(function(e2) {
      switch (e2) {
        case 90: {
          const [e3, t2] = this.pageDimensions;
          return [0, -e3 / t2, t2 / e3, 0];
        }
        case 180:
          return [-1, 0, 0, -1];
        case 270: {
          const [e3, t2] = this.pageDimensions;
          return [0, e3 / t2, -t2 / e3, 0];
        }
        default:
          return [1, 0, 0, 1];
      }
    }, "#Ka");
    _Ya = new WeakSet();
    Ya_fn = /* @__PURE__ */ __name(function() {
      if (__privateGet(this, _Ma))
        return;
      __privateSet(this, _Ma, document.createElement("div")), __privateGet(this, _Ma).classList.add("resizers");
      const e2 = this._willKeepAspectRatio ? ["topLeft", "topRight", "bottomRight", "bottomLeft"] : ["topLeft", "topMiddle", "topRight", "middleRight", "bottomRight", "bottomMiddle", "bottomLeft", "middleLeft"], t2 = this._uiManager._signal;
      for (const i2 of e2) {
        const e3 = document.createElement("div");
        __privateGet(this, _Ma).append(e3), e3.classList.add("resizer", i2), e3.setAttribute("data-resizer-name", i2), e3.addEventListener("pointerdown", __privateMethod(this, _Ja, Ja_fn).bind(this, i2), { signal: t2 }), e3.addEventListener("contextmenu", noContextMenu, { signal: t2 }), e3.tabIndex = -1;
      }
      this.div.prepend(__privateGet(this, _Ma));
    }, "#Ya");
    _Ja = new WeakSet();
    Ja_fn = /* @__PURE__ */ __name(function(e2, t2) {
      t2.preventDefault();
      const { isMac: i2 } = util_FeatureTest.platform;
      if (0 !== t2.button || t2.ctrlKey && i2)
        return;
      __privateGet(this, _ot3)?.toggle(false);
      const a2 = this._isDraggable;
      this._isDraggable = false, __privateSet(this, _Da, [t2.screenX, t2.screenY]);
      const n2 = new AbortController(), s2 = this._uiManager.combinedSignal(n2);
      this.parent.togglePointerEvents(false), window.addEventListener("pointermove", __privateMethod(this, _Za, Za_fn).bind(this, e2), { passive: true, capture: true, signal: s2 }), window.addEventListener("touchmove", stopEvent, { passive: false, signal: s2 }), window.addEventListener("contextmenu", noContextMenu, { signal: s2 }), __privateSet(this, _Ea, { savedX: this.x, savedY: this.y, savedWidth: this.width, savedHeight: this.height });
      const r2 = this.parent.div.style.cursor, o2 = this.div.style.cursor;
      this.div.style.cursor = this.parent.div.style.cursor = window.getComputedStyle(t2.target).cursor;
      const pointerUpCallback = /* @__PURE__ */ __name(() => {
        n2.abort(), this.parent.togglePointerEvents(true), __privateGet(this, _ot3)?.toggle(true), this._isDraggable = a2, this.parent.div.style.cursor = r2, this.div.style.cursor = o2, __privateMethod(this, _Qa, Qa_fn).call(this);
      }, "pointerUpCallback");
      window.addEventListener("pointerup", pointerUpCallback, { signal: s2 }), window.addEventListener("blur", pointerUpCallback, { signal: s2 });
    }, "#Ja");
    _en = new WeakSet();
    en_fn = /* @__PURE__ */ __name(function(e2, t2, i2, a2) {
      this.width = i2, this.height = a2, this.x = e2, this.y = t2;
      const [n2, s2] = this.parentDimensions;
      this.setDims(n2 * i2, s2 * a2), this.fixAndSetPosition(), this._onResized();
    }, "#en");
    _Qa = new WeakSet();
    Qa_fn = /* @__PURE__ */ __name(function() {
      if (!__privateGet(this, _Ea))
        return;
      const { savedX: e2, savedY: t2, savedWidth: i2, savedHeight: a2 } = __privateGet(this, _Ea);
      __privateSet(this, _Ea, null);
      const n2 = this.x, s2 = this.y, r2 = this.width, o2 = this.height;
      n2 === e2 && s2 === t2 && r2 === i2 && o2 === a2 || this.addCommands({ cmd: __privateMethod(this, _en, en_fn).bind(this, n2, s2, r2, o2), undo: __privateMethod(this, _en, en_fn).bind(this, e2, t2, i2, a2), mustExec: true });
    }, "#Qa");
    _Za = new WeakSet();
    Za_fn = /* @__PURE__ */ __name(function(e2, t2) {
      const [i2, a2] = this.parentDimensions, n2 = this.x, s2 = this.y, r2 = this.width, o2 = this.height, l3 = _AnnotationEditor.MIN_SIZE / i2, c2 = _AnnotationEditor.MIN_SIZE / a2, h2 = __privateMethod(this, _Ka, Ka_fn).call(this, this.rotation), transf = /* @__PURE__ */ __name((e3, t3) => [h2[0] * e3 + h2[2] * t3, h2[1] * e3 + h2[3] * t3], "transf"), d2 = __privateMethod(this, _Ka, Ka_fn).call(this, 360 - this.rotation);
      let u2, g2, p2 = false, f2 = false;
      switch (e2) {
        case "topLeft":
          p2 = true, u2 = /* @__PURE__ */ __name((e3, t3) => [0, 0], "u"), g2 = /* @__PURE__ */ __name((e3, t3) => [e3, t3], "g");
          break;
        case "topMiddle":
          u2 = /* @__PURE__ */ __name((e3, t3) => [e3 / 2, 0], "u"), g2 = /* @__PURE__ */ __name((e3, t3) => [e3 / 2, t3], "g");
          break;
        case "topRight":
          p2 = true, u2 = /* @__PURE__ */ __name((e3, t3) => [e3, 0], "u"), g2 = /* @__PURE__ */ __name((e3, t3) => [0, t3], "g");
          break;
        case "middleRight":
          f2 = true, u2 = /* @__PURE__ */ __name((e3, t3) => [e3, t3 / 2], "u"), g2 = /* @__PURE__ */ __name((e3, t3) => [0, t3 / 2], "g");
          break;
        case "bottomRight":
          p2 = true, u2 = /* @__PURE__ */ __name((e3, t3) => [e3, t3], "u"), g2 = /* @__PURE__ */ __name((e3, t3) => [0, 0], "g");
          break;
        case "bottomMiddle":
          u2 = /* @__PURE__ */ __name((e3, t3) => [e3 / 2, t3], "u"), g2 = /* @__PURE__ */ __name((e3, t3) => [e3 / 2, 0], "g");
          break;
        case "bottomLeft":
          p2 = true, u2 = /* @__PURE__ */ __name((e3, t3) => [0, t3], "u"), g2 = /* @__PURE__ */ __name((e3, t3) => [e3, 0], "g");
          break;
        case "middleLeft":
          f2 = true, u2 = /* @__PURE__ */ __name((e3, t3) => [0, t3 / 2], "u"), g2 = /* @__PURE__ */ __name((e3, t3) => [e3, t3 / 2], "g");
      }
      const m2 = u2(r2, o2), b2 = g2(r2, o2);
      let y2 = transf(...b2);
      const w2 = _AnnotationEditor._round(n2 + y2[0]), x2 = _AnnotationEditor._round(s2 + y2[1]);
      let S2, v2, C2 = 1, k2 = 1;
      if (t2.fromKeyboard)
        ({ deltaX: S2, deltaY: v2 } = t2);
      else {
        const { screenX: e3, screenY: i3 } = t2, [a3, n3] = __privateGet(this, _Da);
        [S2, v2] = this.screenToPageTranslation(e3 - a3, i3 - n3), __privateGet(this, _Da)[0] = e3, __privateGet(this, _Da)[1] = i3;
      }
      var T2, F2;
      if ([S2, v2] = (T2 = S2 / i2, F2 = v2 / a2, [d2[0] * T2 + d2[2] * F2, d2[1] * T2 + d2[3] * F2]), p2) {
        const e3 = Math.hypot(r2, o2);
        C2 = k2 = Math.max(Math.min(Math.hypot(b2[0] - m2[0] - S2, b2[1] - m2[1] - v2) / e3, 1 / r2, 1 / o2), l3 / r2, c2 / o2);
      } else
        f2 ? C2 = MathClamp(Math.abs(b2[0] - m2[0] - S2), l3, 1) / r2 : k2 = MathClamp(Math.abs(b2[1] - m2[1] - v2), c2, 1) / o2;
      const M2 = _AnnotationEditor._round(r2 * C2), D2 = _AnnotationEditor._round(o2 * k2);
      y2 = transf(...g2(M2, D2));
      const E2 = w2 - y2[0], O2 = x2 - y2[1];
      __privateGet(this, _Ra) || __privateSet(this, _Ra, [this.x, this.y, this.width, this.height]), this.width = M2, this.height = D2, this.x = E2, this.y = O2, this.setDims(i2 * M2, a2 * D2), this.fixAndSetPosition(), this._onResizing();
    }, "#Za");
    _in = new WeakSet();
    in_fn = /* @__PURE__ */ __name(function() {
      __privateSet(this, _Ea, { savedX: this.x, savedY: this.y, savedWidth: this.width, savedHeight: this.height }), __privateGet(this, _ot3)?.toggle(false), this.parent.togglePointerEvents(false);
    }, "#in");
    _an = new WeakSet();
    an_fn = /* @__PURE__ */ __name(function(e2, t2, i2) {
      let a2 = i2 / t2 * 0.7 + 1 - 0.7;
      if (1 === a2)
        return;
      const n2 = __privateMethod(this, _Ka, Ka_fn).call(this, this.rotation), transf = /* @__PURE__ */ __name((e3, t3) => [n2[0] * e3 + n2[2] * t3, n2[1] * e3 + n2[3] * t3], "transf"), [s2, r2] = this.parentDimensions, o2 = this.x, l3 = this.y, c2 = this.width, h2 = this.height, d2 = _AnnotationEditor.MIN_SIZE / s2, u2 = _AnnotationEditor.MIN_SIZE / r2;
      a2 = Math.max(Math.min(a2, 1 / c2, 1 / h2), d2 / c2, u2 / h2);
      const g2 = _AnnotationEditor._round(c2 * a2), p2 = _AnnotationEditor._round(h2 * a2);
      if (g2 === c2 && p2 === h2)
        return;
      __privateGet(this, _Ra) || __privateSet(this, _Ra, [o2, l3, c2, h2]);
      const f2 = transf(c2 / 2, h2 / 2), m2 = _AnnotationEditor._round(o2 + f2[0]), b2 = _AnnotationEditor._round(l3 + f2[1]), y2 = transf(g2 / 2, p2 / 2);
      this.x = m2 - y2[0], this.y = b2 - y2[1], this.width = g2, this.height = p2, this.setDims(s2 * g2, r2 * p2), this.fixAndSetPosition(), this._onResizing();
    }, "#an");
    _nn = new WeakSet();
    nn_fn = /* @__PURE__ */ __name(function() {
      __privateGet(this, _ot3)?.toggle(true), this.parent.togglePointerEvents(true), __privateMethod(this, _Qa, Qa_fn).call(this);
    }, "#nn");
    _rn = new WeakSet();
    rn_fn = /* @__PURE__ */ __name(function(e2) {
      const { isMac: t2 } = util_FeatureTest.platform;
      e2.ctrlKey && !t2 || e2.shiftKey || e2.metaKey && t2 ? this.parent.toggleSelected(this) : this.parent.setSelected(this);
    }, "#rn");
    _sn = new WeakSet();
    sn_fn = /* @__PURE__ */ __name(function(e2) {
      const { isSelected: t2 } = this;
      this._uiManager.setUpDragSession();
      let i2 = false;
      const a2 = new AbortController(), n2 = this._uiManager.combinedSignal(a2), s2 = { capture: true, passive: false, signal: n2 }, cancelDrag = /* @__PURE__ */ __name((e3) => {
        a2.abort(), __privateSet(this, _Ta, null), __privateSet(this, _Pa, false), this._uiManager.endDragSession() || __privateMethod(this, _rn, rn_fn).call(this, e3), i2 && this._onStopDragging();
      }, "cancelDrag");
      t2 && (__privateSet(this, _ja, e2.clientX), __privateSet(this, _$a, e2.clientY), __privateSet(this, _Ta, e2.pointerId), __privateSet(this, _Ia, e2.pointerType), window.addEventListener("pointermove", (e3) => {
        i2 || (i2 = true, this._onStartDragging());
        const { clientX: t3, clientY: a3, pointerId: n3 } = e3;
        if (n3 !== __privateGet(this, _Ta))
          return void stopEvent(e3);
        const [s3, r2] = this.screenToPageTranslation(t3 - __privateGet(this, _ja), a3 - __privateGet(this, _$a));
        __privateSet(this, _ja, t3), __privateSet(this, _$a, a3), this._uiManager.dragSelectedEditors(s3, r2);
      }, s2), window.addEventListener("touchmove", stopEvent, s2), window.addEventListener("pointerdown", (e3) => {
        e3.pointerType === __privateGet(this, _Ia) && (__privateGet(this, _qa) || e3.isPrimary) && cancelDrag(e3), stopEvent(e3);
      }, s2));
      const pointerUpCallback = /* @__PURE__ */ __name((e3) => {
        __privateGet(this, _Ta) && __privateGet(this, _Ta) !== e3.pointerId ? stopEvent(e3) : cancelDrag(e3);
      }, "pointerUpCallback");
      window.addEventListener("pointerup", pointerUpCallback, { signal: n2 }), window.addEventListener("blur", pointerUpCallback, { signal: n2 });
    }, "#sn");
    _tn = new WeakSet();
    tn_fn = /* @__PURE__ */ __name(function() {
      if (__privateGet(this, _Oa) || !this.div)
        return;
      __privateSet(this, _Oa, new AbortController());
      const e2 = this._uiManager.combinedSignal(__privateGet(this, _Oa));
      this.div.addEventListener("focusin", this.focusin.bind(this), { signal: e2 }), this.div.addEventListener("focusout", this.focusout.bind(this), { signal: e2 });
    }, "#tn");
    _on = new WeakSet();
    on_fn = /* @__PURE__ */ __name(function(e2) {
      _AnnotationEditor._resizerKeyboardManager.exec(this, e2);
    }, "#on");
    _ln = new WeakSet();
    ln_fn = /* @__PURE__ */ __name(function(e2) {
      __privateGet(this, _La) && e2.relatedTarget?.parentNode !== __privateGet(this, _Ma) && __privateMethod(this, _Wa, Wa_fn).call(this);
    }, "#ln");
    _cn = new WeakSet();
    cn_fn = /* @__PURE__ */ __name(function(e2) {
      __privateSet(this, __a, __privateGet(this, _La) ? e2 : "");
    }, "#cn");
    _hn = new WeakSet();
    hn_fn = /* @__PURE__ */ __name(function(e2) {
      if (__privateGet(this, _Ca))
        for (const t2 of __privateGet(this, _Ca))
          t2.tabIndex = e2;
    }, "#hn");
    _Wa = new WeakSet();
    Wa_fn = /* @__PURE__ */ __name(function() {
      __privateSet(this, _La, false), __privateMethod(this, _hn, hn_fn).call(this, -1), __privateMethod(this, _Qa, Qa_fn).call(this);
    }, "#Wa");
    __privateAdd(AnnotationEditor, _Va);
    __publicField(AnnotationEditor, "_l10n", null);
    __publicField(AnnotationEditor, "_l10nResizer", null);
    __publicField(AnnotationEditor, "_borderLineWidth", -1);
    __publicField(AnnotationEditor, "_colorManager", new ColorManager());
    __publicField(AnnotationEditor, "_zIndex", 1);
    __publicField(AnnotationEditor, "_telemetryTimeout", 1e3);
    FakeEditor = class extends AnnotationEditor {
      constructor(e2) {
        super(e2), this.annotationElementId = e2.annotationElementId, this.deleted = true;
      }
      serialize() {
        return this.serializeDeleted();
      }
    };
    __name(FakeEditor, "FakeEditor");
    mc = 3285377520;
    bc = 4294901760;
    yc = 65535;
    MurmurHash3_64 = class {
      constructor(e2) {
        this.h1 = e2 ? 4294967295 & e2 : mc, this.h2 = e2 ? 4294967295 & e2 : mc;
      }
      update(e2) {
        let t2, i2;
        if ("string" == typeof e2) {
          t2 = new Uint8Array(2 * e2.length), i2 = 0;
          for (let a3 = 0, n3 = e2.length; a3 < n3; a3++) {
            const n4 = e2.charCodeAt(a3);
            n4 <= 255 ? t2[i2++] = n4 : (t2[i2++] = n4 >>> 8, t2[i2++] = 255 & n4);
          }
        } else {
          if (!ArrayBuffer.isView(e2))
            throw new Error("Invalid data format, must be a string or TypedArray.");
          t2 = e2.slice(), i2 = t2.byteLength;
        }
        const a2 = i2 >> 2, n2 = i2 - 4 * a2, s2 = new Uint32Array(t2.buffer, 0, a2);
        let r2 = 0, o2 = 0, l3 = this.h1, c2 = this.h2;
        const h2 = 3432918353, d2 = 461845907, u2 = 11601, g2 = 13715;
        for (let e3 = 0; e3 < a2; e3++)
          1 & e3 ? (r2 = s2[e3], r2 = r2 * h2 & bc | r2 * u2 & yc, r2 = r2 << 15 | r2 >>> 17, r2 = r2 * d2 & bc | r2 * g2 & yc, l3 ^= r2, l3 = l3 << 13 | l3 >>> 19, l3 = 5 * l3 + 3864292196) : (o2 = s2[e3], o2 = o2 * h2 & bc | o2 * u2 & yc, o2 = o2 << 15 | o2 >>> 17, o2 = o2 * d2 & bc | o2 * g2 & yc, c2 ^= o2, c2 = c2 << 13 | c2 >>> 19, c2 = 5 * c2 + 3864292196);
        switch (r2 = 0, n2) {
          case 3:
            r2 ^= t2[4 * a2 + 2] << 16;
          case 2:
            r2 ^= t2[4 * a2 + 1] << 8;
          case 1:
            r2 ^= t2[4 * a2], r2 = r2 * h2 & bc | r2 * u2 & yc, r2 = r2 << 15 | r2 >>> 17, r2 = r2 * d2 & bc | r2 * g2 & yc, 1 & a2 ? l3 ^= r2 : c2 ^= r2;
        }
        this.h1 = l3, this.h2 = c2;
      }
      hexdigest() {
        let e2 = this.h1, t2 = this.h2;
        return e2 ^= t2 >>> 1, e2 = 3981806797 * e2 & bc | 36045 * e2 & yc, t2 = 4283543511 * t2 & bc | (2950163797 * (t2 << 16 | e2 >>> 16) & bc) >>> 16, e2 ^= t2 >>> 1, e2 = 444984403 * e2 & bc | 60499 * e2 & yc, t2 = 3301882366 * t2 & bc | (3120437893 * (t2 << 16 | e2 >>> 16) & bc) >>> 16, e2 ^= t2 >>> 1, (e2 >>> 0).toString(16).padStart(8, "0") + (t2 >>> 0).toString(16).padStart(8, "0");
      }
    };
    __name(MurmurHash3_64, "MurmurHash3_64");
    wc = Object.freeze({ map: null, hash: "", transfer: void 0 });
    AnnotationStorage = class {
      #dn = false;
      #un = null;
      #gn = /* @__PURE__ */ new Map();
      constructor() {
        this.onSetModified = null, this.onResetModified = null, this.onAnnotationEditor = null;
      }
      getValue(e2, t2) {
        const i2 = this.#gn.get(e2);
        return void 0 === i2 ? t2 : Object.assign(t2, i2);
      }
      getRawValue(e2) {
        return this.#gn.get(e2);
      }
      remove(e2) {
        if (this.#gn.delete(e2), 0 === this.#gn.size && this.resetModified(), "function" == typeof this.onAnnotationEditor) {
          for (const e3 of this.#gn.values())
            if (e3 instanceof AnnotationEditor)
              return;
          this.onAnnotationEditor(null);
        }
      }
      setValue(e2, t2) {
        const i2 = this.#gn.get(e2);
        let a2 = false;
        if (void 0 !== i2)
          for (const [e3, n2] of Object.entries(t2))
            i2[e3] !== n2 && (a2 = true, i2[e3] = n2);
        else
          a2 = true, this.#gn.set(e2, t2);
        a2 && this.#pn(), t2 instanceof AnnotationEditor && "function" == typeof this.onAnnotationEditor && this.onAnnotationEditor(t2.constructor._type);
      }
      has(e2) {
        return this.#gn.has(e2);
      }
      get size() {
        return this.#gn.size;
      }
      #pn() {
        this.#dn || (this.#dn = true, "function" == typeof this.onSetModified && this.onSetModified());
      }
      resetModified() {
        this.#dn && (this.#dn = false, "function" == typeof this.onResetModified && this.onResetModified());
      }
      get print() {
        return new PrintAnnotationStorage(this);
      }
      get serializable() {
        if (0 === this.#gn.size)
          return wc;
        const e2 = /* @__PURE__ */ new Map(), t2 = new MurmurHash3_64(), i2 = [], a2 = /* @__PURE__ */ Object.create(null);
        let n2 = false;
        for (const [i3, s2] of this.#gn) {
          const r2 = s2 instanceof AnnotationEditor ? s2.serialize(false, a2) : s2;
          r2 && (e2.set(i3, r2), t2.update(`${i3}:${JSON.stringify(r2)}`), n2 ||= !!r2.bitmap);
        }
        if (n2)
          for (const t3 of e2.values())
            t3.bitmap && i2.push(t3.bitmap);
        return e2.size > 0 ? { map: e2, hash: t2.hexdigest(), transfer: i2 } : wc;
      }
      get editorStats() {
        let e2 = null;
        const t2 = /* @__PURE__ */ new Map();
        for (const i2 of this.#gn.values()) {
          if (!(i2 instanceof AnnotationEditor))
            continue;
          const a2 = i2.telemetryFinalData;
          if (!a2)
            continue;
          const { type: n2 } = a2;
          t2.has(n2) || t2.set(n2, Object.getPrototypeOf(i2).constructor), e2 ||= /* @__PURE__ */ Object.create(null);
          const s2 = e2[n2] ||= /* @__PURE__ */ new Map();
          for (const [e3, t3] of Object.entries(a2)) {
            if ("type" === e3)
              continue;
            let i3 = s2.get(e3);
            i3 || (i3 = /* @__PURE__ */ new Map(), s2.set(e3, i3));
            const a3 = i3.get(t3) ?? 0;
            i3.set(t3, a3 + 1);
          }
        }
        for (const [i2, a2] of t2)
          e2[i2] = a2.computeTelemetryFinalData(e2[i2]);
        return e2;
      }
      resetModifiedIds() {
        this.#un = null;
      }
      get modifiedIds() {
        if (this.#un)
          return this.#un;
        const e2 = [];
        for (const t2 of this.#gn.values())
          t2 instanceof AnnotationEditor && t2.annotationElementId && t2.serialize() && e2.push(t2.annotationElementId);
        return this.#un = { ids: new Set(e2), hash: e2.join(",") };
      }
      [Symbol.iterator]() {
        return this.#gn.entries();
      }
    };
    __name(AnnotationStorage, "AnnotationStorage");
    PrintAnnotationStorage = class extends AnnotationStorage {
      #fn;
      constructor(e2) {
        super();
        const { map: t2, hash: i2, transfer: a2 } = e2.serializable, n2 = structuredClone(t2, a2 ? { transfer: a2 } : null);
        this.#fn = { map: n2, hash: i2, transfer: a2 };
      }
      get print() {
        unreachable("Should not call PrintAnnotationStorage.print");
      }
      get serializable() {
        return this.#fn;
      }
      get modifiedIds() {
        return shadow(this, "modifiedIds", { ids: /* @__PURE__ */ new Set(), hash: "" });
      }
    };
    __name(PrintAnnotationStorage, "PrintAnnotationStorage");
    FontLoader = class {
      #mn = /* @__PURE__ */ new Set();
      constructor({ ownerDocument: e2 = globalThis.document, styleElement: t2 = null }) {
        this._document = e2, this.nativeFontFaces = /* @__PURE__ */ new Set(), this.styleElement = null, this.loadingRequests = [], this.loadTestFontId = 0;
      }
      addNativeFontFace(e2) {
        this.nativeFontFaces.add(e2), this._document.fonts.add(e2);
      }
      removeNativeFontFace(e2) {
        this.nativeFontFaces.delete(e2), this._document.fonts.delete(e2);
      }
      insertRule(e2) {
        this.styleElement || (this.styleElement = this._document.createElement("style"), this._document.documentElement.getElementsByTagName("head")[0].append(this.styleElement));
        const t2 = this.styleElement.sheet;
        t2.insertRule(e2, t2.cssRules.length);
      }
      clear() {
        for (const e2 of this.nativeFontFaces)
          this._document.fonts.delete(e2);
        this.nativeFontFaces.clear(), this.#mn.clear(), this.styleElement && (this.styleElement.remove(), this.styleElement = null);
      }
      async loadSystemFont({ systemFontInfo: e2, disableFontFace: t2, _inspectFont: i2 }) {
        if (e2 && !this.#mn.has(e2.loadedName)) {
          if (assert3(!t2, "loadSystemFont shouldn't be called when `disableFontFace` is set."), this.isFontLoadingAPISupported) {
            const { loadedName: t3, src: a2, style: n2 } = e2, s2 = new FontFace(t3, a2, n2);
            this.addNativeFontFace(s2);
            try {
              await s2.load(), this.#mn.add(t3), i2?.(e2);
            } catch {
              warn3(`Cannot load system font: ${e2.baseFontName}, installing it could help to improve PDF rendering.`), this.removeNativeFontFace(s2);
            }
            return;
          }
          unreachable("Not implemented: loadSystemFont without the Font Loading API.");
        }
      }
      async bind(e2) {
        if (e2.attached || e2.missingFile && !e2.systemFontInfo)
          return;
        if (e2.attached = true, e2.systemFontInfo)
          return void await this.loadSystemFont(e2);
        if (this.isFontLoadingAPISupported) {
          const t3 = e2.createNativeFontFace();
          if (t3) {
            this.addNativeFontFace(t3);
            try {
              await t3.loaded;
            } catch (i2) {
              throw warn3(`Failed to load font '${t3.family}': '${i2}'.`), e2.disableFontFace = true, i2;
            }
          }
          return;
        }
        const t2 = e2.createFontFaceRule();
        if (t2) {
          if (this.insertRule(t2), this.isSyncFontLoadingSupported)
            return;
          await new Promise((t3) => {
            const i2 = this._queueLoadingCallback(t3);
            this._prepareFontLoadEvent(e2, i2);
          });
        }
      }
      get isFontLoadingAPISupported() {
        return shadow(this, "isFontLoadingAPISupported", !!this._document?.fonts);
      }
      get isSyncFontLoadingSupported() {
        return shadow(this, "isSyncFontLoadingSupported", Cl || util_FeatureTest.platform.isFirefox);
      }
      _queueLoadingCallback(e2) {
        const { loadingRequests: t2 } = this, i2 = { done: false, complete: function() {
          for (assert3(!i2.done, "completeRequest() cannot be called twice."), i2.done = true; t2.length > 0 && t2[0].done; ) {
            const e3 = t2.shift();
            setTimeout(e3.callback, 0);
          }
        }, callback: e2 };
        return t2.push(i2), i2;
      }
      get _loadTestFont() {
        return shadow(this, "_loadTestFont", atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA=="));
      }
      _prepareFontLoadEvent(e2, t2) {
        function int32(e3, t3) {
          return e3.charCodeAt(t3) << 24 | e3.charCodeAt(t3 + 1) << 16 | e3.charCodeAt(t3 + 2) << 8 | 255 & e3.charCodeAt(t3 + 3);
        }
        __name(int32, "int32");
        function spliceString(e3, t3, i3, a3) {
          return e3.substring(0, t3) + a3 + e3.substring(t3 + i3);
        }
        __name(spliceString, "spliceString");
        let i2, a2;
        const n2 = this._document.createElement("canvas");
        n2.width = 1, n2.height = 1;
        const s2 = n2.getContext("2d");
        let r2 = 0;
        const o2 = `lt${Date.now()}${this.loadTestFontId++}`;
        let l3 = this._loadTestFont;
        l3 = spliceString(l3, 976, o2.length, o2);
        const c2 = 1482184792;
        let h2 = int32(l3, 16);
        for (i2 = 0, a2 = o2.length - 3; i2 < a2; i2 += 4)
          h2 = h2 - c2 + int32(o2, i2) | 0;
        var d2;
        i2 < o2.length && (h2 = h2 - c2 + int32(o2 + "XXX", i2) | 0), l3 = spliceString(l3, 16, 4, (d2 = h2, String.fromCharCode(d2 >> 24 & 255, d2 >> 16 & 255, d2 >> 8 & 255, 255 & d2)));
        const u2 = `@font-face {font-family:"${o2}";src:${`url(data:font/opentype;base64,${btoa(l3)});`}}`;
        this.insertRule(u2);
        const g2 = this._document.createElement("div");
        g2.style.visibility = "hidden", g2.style.width = g2.style.height = "10px", g2.style.position = "absolute", g2.style.top = g2.style.left = "0px";
        for (const t3 of [e2.loadedName, o2]) {
          const e3 = this._document.createElement("span");
          e3.textContent = "Hi", e3.style.fontFamily = t3, g2.append(e3);
        }
        this._document.body.append(g2), (/* @__PURE__ */ __name(function isFontReady(e3, t3) {
          if (++r2 > 30)
            return warn3("Load test font never loaded."), void t3();
          s2.font = "30px " + e3, s2.fillText(".", 0, 20), s2.getImageData(0, 0, 1, 1).data[3] > 0 ? t3() : setTimeout(isFontReady.bind(null, e3, t3));
        }, "isFontReady"))(o2, () => {
          g2.remove(), t2.complete();
        });
      }
    };
    __name(FontLoader, "FontLoader");
    FontFaceObject = class {
      constructor(e2, t2 = null) {
        this.compiledGlyphs = /* @__PURE__ */ Object.create(null);
        for (const t3 in e2)
          this[t3] = e2[t3];
        this._inspectFont = t2;
      }
      createNativeFontFace() {
        if (!this.data || this.disableFontFace)
          return null;
        let e2;
        if (this.cssFontInfo) {
          const t2 = { weight: this.cssFontInfo.fontWeight };
          this.cssFontInfo.italicAngle && (t2.style = `oblique ${this.cssFontInfo.italicAngle}deg`), e2 = new FontFace(this.cssFontInfo.fontFamily, this.data, t2);
        } else
          e2 = new FontFace(this.loadedName, this.data, {});
        return this._inspectFont?.(this), e2;
      }
      createFontFaceRule() {
        if (!this.data || this.disableFontFace)
          return null;
        const e2 = `url(data:${this.mimetype};base64,${toBase64Util(this.data)});`;
        let t2;
        if (this.cssFontInfo) {
          let i2 = `font-weight: ${this.cssFontInfo.fontWeight};`;
          this.cssFontInfo.italicAngle && (i2 += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`), t2 = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${i2}src:${e2}}`;
        } else
          t2 = `@font-face {font-family:"${this.loadedName}";src:${e2}}`;
        return this._inspectFont?.(this, e2), t2;
      }
      getPathGenerator(e2, t2) {
        if (void 0 !== this.compiledGlyphs[t2])
          return this.compiledGlyphs[t2];
        const i2 = this.loadedName + "_path_" + t2;
        let a2;
        try {
          a2 = e2.get(i2);
        } catch (e3) {
          warn3(`getPathGenerator - ignoring character: "${e3}".`);
        }
        const n2 = new Path2D(a2 || "");
        return this.fontExtraProperties || e2.delete(i2), this.compiledGlyphs[t2] = n2;
      }
    };
    __name(FontFaceObject, "FontFaceObject");
    __name(getFactoryUrlProp, "getFactoryUrlProp");
    isRefProxy = /* @__PURE__ */ __name((e2) => "object" == typeof e2 && Number.isInteger(e2?.num) && e2.num >= 0 && Number.isInteger(e2?.gen) && e2.gen >= 0, "isRefProxy");
    Ac = function(e2, t2, i2) {
      if (!Array.isArray(i2) || i2.length < 2)
        return false;
      const [a2, n2, ...s2] = i2;
      if (!e2(a2) && !Number.isInteger(a2))
        return false;
      if (!t2(n2))
        return false;
      const r2 = s2.length;
      let o2 = true;
      switch (n2.name) {
        case "XYZ":
          if (r2 < 2 || r2 > 3)
            return false;
          break;
        case "Fit":
        case "FitB":
          return 0 === r2;
        case "FitH":
        case "FitBH":
        case "FitV":
        case "FitBV":
          if (r2 > 1)
            return false;
          break;
        case "FitR":
          if (4 !== r2)
            return false;
          o2 = false;
          break;
        default:
          return false;
      }
      for (const e3 of s2)
        if (!("number" == typeof e3 || o2 && null === e3))
          return false;
      return true;
    }.bind(null, isRefProxy, (e2) => "object" == typeof e2 && "string" == typeof e2?.name);
    LoopbackPort = class {
      #bn = /* @__PURE__ */ new Map();
      #yn = Promise.resolve();
      postMessage(e2, t2) {
        const i2 = { data: structuredClone(e2, t2 ? { transfer: t2 } : null) };
        this.#yn.then(() => {
          for (const [e3] of this.#bn)
            e3.call(this, i2);
        });
      }
      addEventListener(e2, t2, i2 = null) {
        let a2 = null;
        if (i2?.signal instanceof AbortSignal) {
          const { signal: n2 } = i2;
          if (n2.aborted)
            return void warn3("LoopbackPort - cannot use an `aborted` signal.");
          const onAbort = /* @__PURE__ */ __name(() => this.removeEventListener(e2, t2), "onAbort");
          a2 = /* @__PURE__ */ __name(() => n2.removeEventListener("abort", onAbort), "a"), n2.addEventListener("abort", onAbort);
        }
        this.#bn.set(t2, a2);
      }
      removeEventListener(e2, t2) {
        const i2 = this.#bn.get(t2);
        i2?.(), this.#bn.delete(t2);
      }
      terminate() {
        for (const [, e2] of this.#bn)
          e2?.();
        this.#bn.clear();
      }
    };
    __name(LoopbackPort, "LoopbackPort");
    xc = 1;
    Sc = 2;
    vc = 1;
    Cc = 2;
    kc = 3;
    Tc = 4;
    Ic = 5;
    Fc = 6;
    Mc = 7;
    Dc = 8;
    __name(onFn, "onFn");
    __name(wrapReason, "wrapReason");
    MessageHandler = class {
      #Je = new AbortController();
      constructor(e2, t2, i2) {
        this.sourceName = e2, this.targetName = t2, this.comObj = i2, this.callbackId = 1, this.streamId = 1, this.streamSinks = /* @__PURE__ */ Object.create(null), this.streamControllers = /* @__PURE__ */ Object.create(null), this.callbackCapabilities = /* @__PURE__ */ Object.create(null), this.actionHandler = /* @__PURE__ */ Object.create(null), i2.addEventListener("message", this.#Ze.bind(this), { signal: this.#Je.signal });
      }
      #Ze({ data: e2 }) {
        if (e2.targetName !== this.sourceName)
          return;
        if (e2.stream)
          return void this.#Qe(e2);
        if (e2.callback) {
          const t3 = e2.callbackId, i2 = this.callbackCapabilities[t3];
          if (!i2)
            throw new Error(`Cannot resolve callback ${t3}`);
          if (delete this.callbackCapabilities[t3], e2.callback === xc)
            i2.resolve(e2.data);
          else {
            if (e2.callback !== Sc)
              throw new Error("Unexpected callback case");
            i2.reject(wrapReason(e2.reason));
          }
          return;
        }
        const t2 = this.actionHandler[e2.action];
        if (!t2)
          throw new Error(`Unknown action from worker: ${e2.action}`);
        if (e2.callbackId) {
          const i2 = this.sourceName, a2 = e2.sourceName, n2 = this.comObj;
          return void Promise.try(t2, e2.data).then(function(t3) {
            n2.postMessage({ sourceName: i2, targetName: a2, callback: xc, callbackId: e2.callbackId, data: t3 });
          }, function(t3) {
            n2.postMessage({ sourceName: i2, targetName: a2, callback: Sc, callbackId: e2.callbackId, reason: wrapReason(t3) });
          });
        }
        e2.streamId ? this.#et(e2) : t2(e2.data);
      }
      on(e2, t2) {
        const i2 = this.actionHandler;
        if (i2[e2])
          throw new Error(`There is already an actionName called "${e2}"`);
        i2[e2] = t2;
      }
      send(e2, t2, i2) {
        this.comObj.postMessage({ sourceName: this.sourceName, targetName: this.targetName, action: e2, data: t2 }, i2);
      }
      sendWithPromise(e2, t2, i2) {
        const a2 = this.callbackId++, n2 = Promise.withResolvers();
        this.callbackCapabilities[a2] = n2;
        try {
          this.comObj.postMessage({ sourceName: this.sourceName, targetName: this.targetName, action: e2, callbackId: a2, data: t2 }, i2);
        } catch (e3) {
          n2.reject(e3);
        }
        return n2.promise;
      }
      sendWithStream(e2, t2, i2, a2) {
        const n2 = this.streamId++, s2 = this.sourceName, r2 = this.targetName, o2 = this.comObj;
        return new ReadableStream({ start: (i3) => {
          const l3 = Promise.withResolvers();
          return this.streamControllers[n2] = { controller: i3, startCall: l3, pullCall: null, cancelCall: null, isClosed: false }, o2.postMessage({ sourceName: s2, targetName: r2, action: e2, streamId: n2, data: t2, desiredSize: i3.desiredSize }, a2), l3.promise;
        }, pull: (e3) => {
          const t3 = Promise.withResolvers();
          return this.streamControllers[n2].pullCall = t3, o2.postMessage({ sourceName: s2, targetName: r2, stream: Fc, streamId: n2, desiredSize: e3.desiredSize }), t3.promise;
        }, cancel: (e3) => {
          assert3(e3 instanceof Error, "cancel must have a valid reason");
          const t3 = Promise.withResolvers();
          return this.streamControllers[n2].cancelCall = t3, this.streamControllers[n2].isClosed = true, o2.postMessage({ sourceName: s2, targetName: r2, stream: vc, streamId: n2, reason: wrapReason(e3) }), t3.promise;
        } }, i2);
      }
      #et(e2) {
        const t2 = e2.streamId, i2 = this.sourceName, a2 = e2.sourceName, n2 = this.comObj, s2 = this, r2 = this.actionHandler[e2.action], o2 = { enqueue(e3, s3 = 1, r3) {
          if (this.isCancelled)
            return;
          const o3 = this.desiredSize;
          this.desiredSize -= s3, o3 > 0 && this.desiredSize <= 0 && (this.sinkCapability = Promise.withResolvers(), this.ready = this.sinkCapability.promise), n2.postMessage({ sourceName: i2, targetName: a2, stream: Tc, streamId: t2, chunk: e3 }, r3);
        }, close() {
          this.isCancelled || (this.isCancelled = true, n2.postMessage({ sourceName: i2, targetName: a2, stream: kc, streamId: t2 }), delete s2.streamSinks[t2]);
        }, error(e3) {
          assert3(e3 instanceof Error, "error must have a valid reason"), this.isCancelled || (this.isCancelled = true, n2.postMessage({ sourceName: i2, targetName: a2, stream: Ic, streamId: t2, reason: wrapReason(e3) }));
        }, sinkCapability: Promise.withResolvers(), onPull: null, onCancel: null, isCancelled: false, desiredSize: e2.desiredSize, ready: null };
        o2.sinkCapability.resolve(), o2.ready = o2.sinkCapability.promise, this.streamSinks[t2] = o2, Promise.try(r2, e2.data, o2).then(function() {
          n2.postMessage({ sourceName: i2, targetName: a2, stream: Dc, streamId: t2, success: true });
        }, function(e3) {
          n2.postMessage({ sourceName: i2, targetName: a2, stream: Dc, streamId: t2, reason: wrapReason(e3) });
        });
      }
      #Qe(e2) {
        const t2 = e2.streamId, i2 = this.sourceName, a2 = e2.sourceName, n2 = this.comObj, s2 = this.streamControllers[t2], r2 = this.streamSinks[t2];
        switch (e2.stream) {
          case Dc:
            e2.success ? s2.startCall.resolve() : s2.startCall.reject(wrapReason(e2.reason));
            break;
          case Mc:
            e2.success ? s2.pullCall.resolve() : s2.pullCall.reject(wrapReason(e2.reason));
            break;
          case Fc:
            if (!r2) {
              n2.postMessage({ sourceName: i2, targetName: a2, stream: Mc, streamId: t2, success: true });
              break;
            }
            r2.desiredSize <= 0 && e2.desiredSize > 0 && r2.sinkCapability.resolve(), r2.desiredSize = e2.desiredSize, Promise.try(r2.onPull || onFn).then(function() {
              n2.postMessage({ sourceName: i2, targetName: a2, stream: Mc, streamId: t2, success: true });
            }, function(e3) {
              n2.postMessage({ sourceName: i2, targetName: a2, stream: Mc, streamId: t2, reason: wrapReason(e3) });
            });
            break;
          case Tc:
            if (assert3(s2, "enqueue should have stream controller"), s2.isClosed)
              break;
            s2.controller.enqueue(e2.chunk);
            break;
          case kc:
            if (assert3(s2, "close should have stream controller"), s2.isClosed)
              break;
            s2.isClosed = true, s2.controller.close(), this.#tt(s2, t2);
            break;
          case Ic:
            assert3(s2, "error should have stream controller"), s2.controller.error(wrapReason(e2.reason)), this.#tt(s2, t2);
            break;
          case Cc:
            e2.success ? s2.cancelCall.resolve() : s2.cancelCall.reject(wrapReason(e2.reason)), this.#tt(s2, t2);
            break;
          case vc:
            if (!r2)
              break;
            const o2 = wrapReason(e2.reason);
            Promise.try(r2.onCancel || onFn, o2).then(function() {
              n2.postMessage({ sourceName: i2, targetName: a2, stream: Cc, streamId: t2, success: true });
            }, function(e3) {
              n2.postMessage({ sourceName: i2, targetName: a2, stream: Cc, streamId: t2, reason: wrapReason(e3) });
            }), r2.sinkCapability.reject(o2), r2.isCancelled = true, delete this.streamSinks[t2];
            break;
          default:
            throw new Error("Unexpected stream case");
        }
      }
      async #tt(e2, t2) {
        await Promise.allSettled([e2.startCall?.promise, e2.pullCall?.promise, e2.cancelCall?.promise]), delete this.streamControllers[t2];
      }
      destroy() {
        this.#Je?.abort(), this.#Je = null;
      }
    };
    __name(MessageHandler, "MessageHandler");
    BaseCanvasFactory = class {
      #wn = false;
      constructor({ enableHWA: e2 = false }) {
        this.#wn = e2;
      }
      create(e2, t2) {
        if (e2 <= 0 || t2 <= 0)
          throw new Error("Invalid canvas size");
        const i2 = this._createCanvas(e2, t2);
        return { canvas: i2, context: i2.getContext("2d", { willReadFrequently: !this.#wn }) };
      }
      reset(e2, t2, i2) {
        if (!e2.canvas)
          throw new Error("Canvas is not specified");
        if (t2 <= 0 || i2 <= 0)
          throw new Error("Invalid canvas size");
        e2.canvas.width = t2, e2.canvas.height = i2;
      }
      destroy(e2) {
        if (!e2.canvas)
          throw new Error("Canvas is not specified");
        e2.canvas.width = 0, e2.canvas.height = 0, e2.canvas = null, e2.context = null;
      }
      _createCanvas(e2, t2) {
        unreachable("Abstract method `_createCanvas` called.");
      }
    };
    __name(BaseCanvasFactory, "BaseCanvasFactory");
    DOMCanvasFactory = class extends BaseCanvasFactory {
      constructor({ ownerDocument: e2 = globalThis.document, enableHWA: t2 = false }) {
        super({ enableHWA: t2 }), this._document = e2;
      }
      _createCanvas(e2, t2) {
        const i2 = this._document.createElement("canvas");
        return i2.width = e2, i2.height = t2, i2;
      }
    };
    __name(DOMCanvasFactory, "DOMCanvasFactory");
    BaseCMapReaderFactory = class {
      constructor({ baseUrl: e2 = null, isCompressed: t2 = true }) {
        this.baseUrl = e2, this.isCompressed = t2;
      }
      async fetch({ name: e2 }) {
        if (!this.baseUrl)
          throw new Error("Ensure that the `cMapUrl` and `cMapPacked` API parameters are provided.");
        if (!e2)
          throw new Error("CMap name must be specified.");
        const t2 = this.baseUrl + e2 + (this.isCompressed ? ".bcmap" : "");
        return this._fetch(t2).then((e3) => ({ cMapData: e3, isCompressed: this.isCompressed })).catch((e3) => {
          throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${t2}`);
        });
      }
      async _fetch(e2) {
        unreachable("Abstract method `_fetch` called.");
      }
    };
    __name(BaseCMapReaderFactory, "BaseCMapReaderFactory");
    DOMCMapReaderFactory = class extends BaseCMapReaderFactory {
      async _fetch(e2) {
        const t2 = await fetchData(e2, this.isCompressed ? "arraybuffer" : "text");
        return t2 instanceof ArrayBuffer ? new Uint8Array(t2) : stringToBytes(t2);
      }
    };
    __name(DOMCMapReaderFactory, "DOMCMapReaderFactory");
    BaseFilterFactory = class {
      addFilter(e2) {
        return "none";
      }
      addHCMFilter(e2, t2) {
        return "none";
      }
      addAlphaFilter(e2) {
        return "none";
      }
      addLuminosityFilter(e2) {
        return "none";
      }
      addHighlightHCMFilter(e2, t2, i2, a2, n2) {
        return "none";
      }
      destroy(e2 = false) {
      }
    };
    __name(BaseFilterFactory, "BaseFilterFactory");
    DOMFilterFactory = class extends BaseFilterFactory {
      #An;
      #xn;
      #Sn;
      #vn;
      #Cn;
      #kn;
      #At = 0;
      constructor({ docId: e2, ownerDocument: t2 = globalThis.document }) {
        super(), this.#vn = e2, this.#Cn = t2;
      }
      get #St() {
        return this.#xn ||= /* @__PURE__ */ new Map();
      }
      get #Tn() {
        return this.#kn ||= /* @__PURE__ */ new Map();
      }
      get #In() {
        if (!this.#Sn) {
          const e2 = this.#Cn.createElement("div"), { style: t2 } = e2;
          t2.visibility = "hidden", t2.contain = "strict", t2.width = t2.height = 0, t2.position = "absolute", t2.top = t2.left = 0, t2.zIndex = -1;
          const i2 = this.#Cn.createElementNS(pc, "svg");
          i2.setAttribute("width", 0), i2.setAttribute("height", 0), this.#Sn = this.#Cn.createElementNS(pc, "defs"), e2.append(i2), i2.append(this.#Sn), this.#Cn.body.append(e2);
        }
        return this.#Sn;
      }
      #Fn(e2) {
        if (1 === e2.length) {
          const t3 = e2[0], i3 = new Array(256);
          for (let e3 = 0; e3 < 256; e3++)
            i3[e3] = t3[e3] / 255;
          const a3 = i3.join(",");
          return [a3, a3, a3];
        }
        const [t2, i2, a2] = e2, n2 = new Array(256), s2 = new Array(256), r2 = new Array(256);
        for (let e3 = 0; e3 < 256; e3++)
          n2[e3] = t2[e3] / 255, s2[e3] = i2[e3] / 255, r2[e3] = a2[e3] / 255;
        return [n2.join(","), s2.join(","), r2.join(",")];
      }
      #Mn(e2) {
        if (void 0 === this.#An) {
          this.#An = "";
          const e3 = this.#Cn.URL;
          e3 !== this.#Cn.baseURI && (isDataScheme(e3) ? warn3('#createUrl: ignore "data:"-URL for performance reasons.') : this.#An = updateUrlHash(e3, ""));
        }
        return `url(${this.#An}#${e2})`;
      }
      addFilter(e2) {
        if (!e2)
          return "none";
        let t2 = this.#St.get(e2);
        if (t2)
          return t2;
        const [i2, a2, n2] = this.#Fn(e2), s2 = 1 === e2.length ? i2 : `${i2}${a2}${n2}`;
        if (t2 = this.#St.get(s2), t2)
          return this.#St.set(e2, t2), t2;
        const r2 = `g_${this.#vn}_transfer_map_${this.#At++}`, o2 = this.#Mn(r2);
        this.#St.set(e2, o2), this.#St.set(s2, o2);
        const l3 = this.#Dn(r2);
        return this.#En(i2, a2, n2, l3), o2;
      }
      addHCMFilter(e2, t2) {
        const i2 = `${e2}-${t2}`, a2 = "base";
        let n2 = this.#Tn.get(a2);
        if (n2?.key === i2)
          return n2.url;
        if (n2 ? (n2.filter?.remove(), n2.key = i2, n2.url = "none", n2.filter = null) : (n2 = { key: i2, url: "none", filter: null }, this.#Tn.set(a2, n2)), !e2 || !t2)
          return n2.url;
        const s2 = this.#On(e2);
        e2 = Util.makeHexColor(...s2);
        const r2 = this.#On(t2);
        if (t2 = Util.makeHexColor(...r2), this.#In.style.color = "", "#000000" === e2 && "#ffffff" === t2 || e2 === t2)
          return n2.url;
        const o2 = new Array(256);
        for (let e3 = 0; e3 <= 255; e3++) {
          const t3 = e3 / 255;
          o2[e3] = t3 <= 0.03928 ? t3 / 12.92 : ((t3 + 0.055) / 1.055) ** 2.4;
        }
        const l3 = o2.join(","), c2 = `g_${this.#vn}_hcm_filter`, h2 = n2.filter = this.#Dn(c2);
        this.#En(l3, l3, l3, h2), this.#_n(h2);
        const getSteps = /* @__PURE__ */ __name((e3, t3) => {
          const i3 = s2[e3] / 255, a3 = r2[e3] / 255, n3 = new Array(t3 + 1);
          for (let e4 = 0; e4 <= t3; e4++)
            n3[e4] = i3 + e4 / t3 * (a3 - i3);
          return n3.join(",");
        }, "getSteps");
        return this.#En(getSteps(0, 5), getSteps(1, 5), getSteps(2, 5), h2), n2.url = this.#Mn(c2), n2.url;
      }
      addAlphaFilter(e2) {
        let t2 = this.#St.get(e2);
        if (t2)
          return t2;
        const [i2] = this.#Fn([e2]), a2 = `alpha_${i2}`;
        if (t2 = this.#St.get(a2), t2)
          return this.#St.set(e2, t2), t2;
        const n2 = `g_${this.#vn}_alpha_map_${this.#At++}`, s2 = this.#Mn(n2);
        this.#St.set(e2, s2), this.#St.set(a2, s2);
        const r2 = this.#Dn(n2);
        return this.#Pn(i2, r2), s2;
      }
      addLuminosityFilter(e2) {
        let t2, i2, a2 = this.#St.get(e2 || "luminosity");
        if (a2)
          return a2;
        if (e2 ? ([t2] = this.#Fn([e2]), i2 = `luminosity_${t2}`) : i2 = "luminosity", a2 = this.#St.get(i2), a2)
          return this.#St.set(e2, a2), a2;
        const n2 = `g_${this.#vn}_luminosity_map_${this.#At++}`, s2 = this.#Mn(n2);
        this.#St.set(e2, s2), this.#St.set(i2, s2);
        const r2 = this.#Dn(n2);
        return this.#Rn(r2), e2 && this.#Pn(t2, r2), s2;
      }
      addHighlightHCMFilter(e2, t2, i2, a2, n2) {
        const s2 = `${t2}-${i2}-${a2}-${n2}`;
        let r2 = this.#Tn.get(e2);
        if (r2?.key === s2)
          return r2.url;
        if (r2 ? (r2.filter?.remove(), r2.key = s2, r2.url = "none", r2.filter = null) : (r2 = { key: s2, url: "none", filter: null }, this.#Tn.set(e2, r2)), !t2 || !i2)
          return r2.url;
        const [o2, l3] = [t2, i2].map(this.#On.bind(this));
        let c2 = Math.round(0.2126 * o2[0] + 0.7152 * o2[1] + 0.0722 * o2[2]), h2 = Math.round(0.2126 * l3[0] + 0.7152 * l3[1] + 0.0722 * l3[2]), [d2, u2] = [a2, n2].map(this.#On.bind(this));
        h2 < c2 && ([c2, h2, d2, u2] = [h2, c2, u2, d2]), this.#In.style.color = "";
        const getSteps = /* @__PURE__ */ __name((e3, t3, i3) => {
          const a3 = new Array(256), n3 = (h2 - c2) / i3, s3 = e3 / 255, r3 = (t3 - e3) / (255 * i3);
          let o3 = 0;
          for (let e4 = 0; e4 <= i3; e4++) {
            const t4 = Math.round(c2 + e4 * n3), i4 = s3 + e4 * r3;
            for (let e5 = o3; e5 <= t4; e5++)
              a3[e5] = i4;
            o3 = t4 + 1;
          }
          for (let e4 = o3; e4 < 256; e4++)
            a3[e4] = a3[o3 - 1];
          return a3.join(",");
        }, "getSteps"), g2 = `g_${this.#vn}_hcm_${e2}_filter`, p2 = r2.filter = this.#Dn(g2);
        return this.#_n(p2), this.#En(getSteps(d2[0], u2[0], 5), getSteps(d2[1], u2[1], 5), getSteps(d2[2], u2[2], 5), p2), r2.url = this.#Mn(g2), r2.url;
      }
      destroy(e2 = false) {
        e2 && this.#kn?.size || (this.#Sn?.parentNode.parentNode.remove(), this.#Sn = null, this.#xn?.clear(), this.#xn = null, this.#kn?.clear(), this.#kn = null, this.#At = 0);
      }
      #Rn(e2) {
        const t2 = this.#Cn.createElementNS(pc, "feColorMatrix");
        t2.setAttribute("type", "matrix"), t2.setAttribute("values", "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.3 0.59 0.11 0 0"), e2.append(t2);
      }
      #_n(e2) {
        const t2 = this.#Cn.createElementNS(pc, "feColorMatrix");
        t2.setAttribute("type", "matrix"), t2.setAttribute("values", "0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0"), e2.append(t2);
      }
      #Dn(e2) {
        const t2 = this.#Cn.createElementNS(pc, "filter");
        return t2.setAttribute("color-interpolation-filters", "sRGB"), t2.setAttribute("id", e2), this.#In.append(t2), t2;
      }
      #Bn(e2, t2, i2) {
        const a2 = this.#Cn.createElementNS(pc, t2);
        a2.setAttribute("type", "discrete"), a2.setAttribute("tableValues", i2), e2.append(a2);
      }
      #En(e2, t2, i2, a2) {
        const n2 = this.#Cn.createElementNS(pc, "feComponentTransfer");
        a2.append(n2), this.#Bn(n2, "feFuncR", e2), this.#Bn(n2, "feFuncG", t2), this.#Bn(n2, "feFuncB", i2);
      }
      #Pn(e2, t2) {
        const i2 = this.#Cn.createElementNS(pc, "feComponentTransfer");
        t2.append(i2), this.#Bn(i2, "feFuncA", e2);
      }
      #On(e2) {
        return this.#In.style.color = e2, getRGB(getComputedStyle(this.#In).getPropertyValue("color"));
      }
    };
    __name(DOMFilterFactory, "DOMFilterFactory");
    BaseStandardFontDataFactory = class {
      constructor({ baseUrl: e2 = null }) {
        this.baseUrl = e2;
      }
      async fetch({ filename: e2 }) {
        if (!this.baseUrl)
          throw new Error("Ensure that the `standardFontDataUrl` API parameter is provided.");
        if (!e2)
          throw new Error("Font filename must be specified.");
        const t2 = `${this.baseUrl}${e2}`;
        return this._fetch(t2).catch((e3) => {
          throw new Error(`Unable to load font data at: ${t2}`);
        });
      }
      async _fetch(e2) {
        unreachable("Abstract method `_fetch` called.");
      }
    };
    __name(BaseStandardFontDataFactory, "BaseStandardFontDataFactory");
    DOMStandardFontDataFactory = class extends BaseStandardFontDataFactory {
      async _fetch(e2) {
        const t2 = await fetchData(e2, "arraybuffer");
        return new Uint8Array(t2);
      }
    };
    __name(DOMStandardFontDataFactory, "DOMStandardFontDataFactory");
    BaseWasmFactory = class {
      constructor({ baseUrl: e2 = null }) {
        this.baseUrl = e2;
      }
      async fetch({ filename: e2 }) {
        if (!this.baseUrl)
          throw new Error("Ensure that the `wasmUrl` API parameter is provided.");
        if (!e2)
          throw new Error("Wasm filename must be specified.");
        const t2 = `${this.baseUrl}${e2}`;
        return this._fetch(t2).catch((e3) => {
          throw new Error(`Unable to load wasm data at: ${t2}`);
        });
      }
      async _fetch(e2) {
        unreachable("Abstract method `_fetch` called.");
      }
    };
    __name(BaseWasmFactory, "BaseWasmFactory");
    DOMWasmFactory = class extends BaseWasmFactory {
      async _fetch(e2) {
        const t2 = await fetchData(e2, "arraybuffer");
        return new Uint8Array(t2);
      }
    };
    __name(DOMWasmFactory, "DOMWasmFactory");
    __name(node_utils_fetchData, "node_utils_fetchData");
    NodeFilterFactory = class extends BaseFilterFactory {
    };
    __name(NodeFilterFactory, "NodeFilterFactory");
    NodeCanvasFactory = class extends BaseCanvasFactory {
      _createCanvas(e2, t2) {
        process.getBuiltinModule("module").createRequire(import.meta.url);
        return new Proxy({}, { get: (e3, t3) => () => {
          throw new Error("@napi-rs/canvas is not available in this environment");
        } }).createCanvas(e2, t2);
      }
    };
    __name(NodeCanvasFactory, "NodeCanvasFactory");
    NodeCMapReaderFactory = class extends BaseCMapReaderFactory {
      async _fetch(e2) {
        return node_utils_fetchData(e2);
      }
    };
    __name(NodeCMapReaderFactory, "NodeCMapReaderFactory");
    NodeStandardFontDataFactory = class extends BaseStandardFontDataFactory {
      async _fetch(e2) {
        return node_utils_fetchData(e2);
      }
    };
    __name(NodeStandardFontDataFactory, "NodeStandardFontDataFactory");
    NodeWasmFactory = class extends BaseWasmFactory {
      async _fetch(e2) {
        return node_utils_fetchData(e2);
      }
    };
    __name(NodeWasmFactory, "NodeWasmFactory");
    Ec = "__forcedDependency";
    CanvasDependencyTracker = class {
      #Nn = { __proto__: null };
      #Ln = { __proto__: null, transform: [], moveText: [], sameLineText: [], [Ec]: [] };
      #Un = /* @__PURE__ */ new Map();
      #jn = [];
      #$n = [];
      #Hn = [[1, 0, 0, 1, 0, 0]];
      #qn = [-1 / 0, -1 / 0, 1 / 0, 1 / 0];
      #Xn = new Float64Array([1 / 0, 1 / 0, -1 / 0, -1 / 0]);
      #zn = -1;
      #Wn = /* @__PURE__ */ new Set();
      #Gn = /* @__PURE__ */ new Map();
      #Vn = /* @__PURE__ */ new Map();
      #Kn;
      #Yn;
      constructor(e2) {
        this.#Kn = e2.width, this.#Yn = e2.height;
      }
      save(e2) {
        return this.#Nn = { __proto__: this.#Nn }, this.#Ln = { __proto__: this.#Ln, transform: { __proto__: this.#Ln.transform }, moveText: { __proto__: this.#Ln.moveText }, sameLineText: { __proto__: this.#Ln.sameLineText }, [Ec]: { __proto__: this.#Ln[Ec] } }, this.#qn = { __proto__: this.#qn }, this.#jn.push([e2, null]), this;
      }
      restore(e2) {
        const t2 = Object.getPrototypeOf(this.#Nn);
        if (null === t2)
          return this;
        this.#Nn = t2, this.#Ln = Object.getPrototypeOf(this.#Ln), this.#qn = Object.getPrototypeOf(this.#qn);
        const i2 = this.#jn.pop();
        return void 0 !== i2 && (i2[1] = e2), this;
      }
      recordOpenMarker(e2) {
        return this.#jn.push([e2, null]), this;
      }
      getOpenMarker() {
        return 0 === this.#jn.length ? null : this.#jn.at(-1)[0];
      }
      recordCloseMarker(e2) {
        const t2 = this.#jn.pop();
        return void 0 !== t2 && (t2[1] = e2), this;
      }
      beginMarkedContent(e2) {
        return this.#$n.push([e2, null]), this;
      }
      endMarkedContent(e2) {
        const t2 = this.#$n.pop();
        return void 0 !== t2 && (t2[1] = e2), this;
      }
      pushBaseTransform(e2) {
        return this.#Hn.push(Util.multiplyByDOMMatrix(this.#Hn.at(-1), e2.getTransform())), this;
      }
      popBaseTransform() {
        return this.#Hn.length > 1 && this.#Hn.pop(), this;
      }
      recordSimpleData(e2, t2) {
        return this.#Nn[e2] = t2, this;
      }
      recordIncrementalData(e2, t2) {
        return this.#Ln[e2].push(t2), this;
      }
      resetIncrementalData(e2, t2) {
        return this.#Ln[e2].length = 0, this;
      }
      recordNamedData(e2, t2) {
        return this.#Un.set(e2, t2), this;
      }
      recordFutureForcedDependency(e2, t2) {
        return this.recordIncrementalData(Ec, t2), this;
      }
      inheritSimpleDataAsFutureForcedDependencies(e2) {
        for (const t2 of e2)
          t2 in this.#Nn && this.recordFutureForcedDependency(t2, this.#Nn[t2]);
        return this;
      }
      inheritPendingDependenciesAsFutureForcedDependencies() {
        for (const e2 of this.#Wn)
          this.recordFutureForcedDependency(Ec, e2);
        return this;
      }
      resetBBox(e2) {
        return this.#zn = e2, this.#Xn[0] = 1 / 0, this.#Xn[1] = 1 / 0, this.#Xn[2] = -1 / 0, this.#Xn[3] = -1 / 0, this;
      }
      get hasPendingBBox() {
        return -1 !== this.#zn;
      }
      recordClipBox(e2, t2, i2, a2, n2, s2) {
        const r2 = Util.multiplyByDOMMatrix(this.#Hn.at(-1), t2.getTransform()), o2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        Util.axialAlignedBoundingBox([i2, n2, a2, s2], r2, o2);
        const l3 = Util.intersect(this.#qn, o2);
        return l3 ? (this.#qn[0] = l3[0], this.#qn[1] = l3[1], this.#qn[2] = l3[2], this.#qn[3] = l3[3]) : (this.#qn[0] = this.#qn[1] = 1 / 0, this.#qn[2] = this.#qn[3] = -1 / 0), this;
      }
      recordBBox(e2, t2, i2, a2, n2, s2) {
        const r2 = this.#qn;
        if (r2[0] === 1 / 0)
          return this;
        const o2 = Util.multiplyByDOMMatrix(this.#Hn.at(-1), t2.getTransform());
        if (r2[0] === -1 / 0)
          return Util.axialAlignedBoundingBox([i2, n2, a2, s2], o2, this.#Xn), this;
        const l3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        return Util.axialAlignedBoundingBox([i2, n2, a2, s2], o2, l3), this.#Xn[0] = Math.min(this.#Xn[0], Math.max(l3[0], r2[0])), this.#Xn[1] = Math.min(this.#Xn[1], Math.max(l3[1], r2[1])), this.#Xn[2] = Math.max(this.#Xn[2], Math.min(l3[2], r2[2])), this.#Xn[3] = Math.max(this.#Xn[3], Math.min(l3[3], r2[3])), this;
      }
      recordCharacterBBox(e2, t2, i2, a2 = 1, n2 = 0, s2 = 0, r2) {
        const o2 = i2.bbox;
        let l3, c2;
        if (o2 && (l3 = o2[2] !== o2[0] && o2[3] !== o2[1] && this.#Vn.get(i2), false !== l3 && (c2 = [0, 0, 0, 0], Util.axialAlignedBoundingBox(o2, i2.fontMatrix, c2), 1 === a2 && 0 === n2 && 0 === s2 || Util.scaleMinMax([a2, 0, 0, -a2, n2, s2], c2), l3)))
          return this.recordBBox(e2, t2, c2[0], c2[2], c2[1], c2[3]);
        if (!r2)
          return this.recordFullPageBBox(e2);
        const h2 = r2();
        return o2 && c2 && void 0 === l3 && (l3 = c2[0] <= n2 - h2.actualBoundingBoxLeft && c2[2] >= n2 + h2.actualBoundingBoxRight && c2[1] <= s2 - h2.actualBoundingBoxAscent && c2[3] >= s2 + h2.actualBoundingBoxDescent, this.#Vn.set(i2, l3), l3) ? this.recordBBox(e2, t2, c2[0], c2[2], c2[1], c2[3]) : this.recordBBox(e2, t2, n2 - h2.actualBoundingBoxLeft, n2 + h2.actualBoundingBoxRight, s2 - h2.actualBoundingBoxAscent, s2 + h2.actualBoundingBoxDescent);
      }
      recordFullPageBBox(e2) {
        return this.#Xn[0] = Math.max(0, this.#qn[0]), this.#Xn[1] = Math.max(0, this.#qn[1]), this.#Xn[2] = Math.min(this.#Kn, this.#qn[2]), this.#Xn[3] = Math.min(this.#Yn, this.#qn[3]), this;
      }
      getSimpleIndex(e2) {
        return this.#Nn[e2];
      }
      recordDependencies(e2, t2) {
        const i2 = this.#Wn, a2 = this.#Nn, n2 = this.#Ln;
        for (const e3 of t2)
          e3 in this.#Nn ? i2.add(a2[e3]) : e3 in n2 && n2[e3].forEach(i2.add, i2);
        return this;
      }
      copyDependenciesFromIncrementalOperation(e2, t2) {
        const i2 = this.#Gn, a2 = this.#Wn;
        for (const e3 of this.#Ln[t2])
          i2.get(e3).dependencies.forEach(a2.add, a2.add(e3));
        return this;
      }
      recordNamedDependency(e2, t2) {
        return this.#Un.has(t2) && this.#Wn.add(this.#Un.get(t2)), this;
      }
      recordOperation(e2, t2 = false) {
        this.recordDependencies(e2, [Ec]);
        const i2 = new Set(this.#Wn), a2 = this.#jn.concat(this.#$n), n2 = this.#zn === e2 ? { minX: this.#Xn[0], minY: this.#Xn[1], maxX: this.#Xn[2], maxY: this.#Xn[3] } : null;
        return this.#Gn.set(e2, { bbox: n2, pairs: a2, dependencies: i2 }), t2 || (this.#zn = -1), this.#Wn.clear(), this;
      }
      bboxToClipBoxDropOperation(e2) {
        return -1 !== this.#zn && (this.#zn = -1, this.#qn[0] = Math.max(this.#qn[0], this.#Xn[0]), this.#qn[1] = Math.max(this.#qn[1], this.#Xn[1]), this.#qn[2] = Math.min(this.#qn[2], this.#Xn[2]), this.#qn[3] = Math.min(this.#qn[3], this.#Xn[3])), this.#Wn.clear(), this;
      }
      _takePendingDependencies() {
        const e2 = this.#Wn;
        return this.#Wn = /* @__PURE__ */ new Set(), e2;
      }
      _extractOperation(e2) {
        const t2 = this.#Gn.get(e2);
        return this.#Gn.delete(e2), t2;
      }
      _pushPendingDependencies(e2) {
        for (const t2 of e2)
          this.#Wn.add(t2);
      }
      take() {
        return this.#Vn.clear(), Array.from(this.#Gn, ([e2, { bbox: t2, pairs: i2, dependencies: a2 }]) => (i2.forEach((e3) => e3.forEach(a2.add, a2)), a2.delete(e2), { minX: (t2?.minX ?? 0) / this.#Kn, maxX: (t2?.maxX ?? this.#Kn) / this.#Kn, minY: (t2?.minY ?? 0) / this.#Yn, maxY: (t2?.maxY ?? this.#Yn) / this.#Yn, dependencies: Array.from(a2).sort((e3, t3) => e3 - t3), idx: e2 }));
      }
    };
    __name(CanvasDependencyTracker, "CanvasDependencyTracker");
    CanvasNestedDependencyTracker = class {
      #Jn;
      #Zn;
      #Qn = 0;
      #es;
      #ts = 0;
      constructor(e2, t2) {
        if (e2 instanceof CanvasNestedDependencyTracker)
          return e2;
        this.#Jn = e2, this.#es = e2._takePendingDependencies(), this.#Zn = t2;
      }
      save(e2) {
        return this.#ts++, this.#Jn.save(this.#Zn), this;
      }
      restore(e2) {
        return this.#ts > 0 && (this.#Jn.restore(this.#Zn), this.#ts--), this;
      }
      recordOpenMarker(e2) {
        return this.#Qn++, this;
      }
      getOpenMarker() {
        return this.#Qn > 0 ? this.#Zn : this.#Jn.getOpenMarker();
      }
      recordCloseMarker(e2) {
        return this.#Qn--, this;
      }
      beginMarkedContent(e2) {
        return this;
      }
      endMarkedContent(e2) {
        return this;
      }
      pushBaseTransform(e2) {
        return this.#Jn.pushBaseTransform(e2), this;
      }
      popBaseTransform() {
        return this.#Jn.popBaseTransform(), this;
      }
      recordSimpleData(e2, t2) {
        return this.#Jn.recordSimpleData(e2, this.#Zn), this;
      }
      recordIncrementalData(e2, t2) {
        return this.#Jn.recordIncrementalData(e2, this.#Zn), this;
      }
      resetIncrementalData(e2, t2) {
        return this.#Jn.resetIncrementalData(e2, this.#Zn), this;
      }
      recordNamedData(e2, t2) {
        return this;
      }
      recordFutureForcedDependency(e2, t2) {
        return this.#Jn.recordFutureForcedDependency(e2, this.#Zn), this;
      }
      inheritSimpleDataAsFutureForcedDependencies(e2) {
        return this.#Jn.inheritSimpleDataAsFutureForcedDependencies(e2), this;
      }
      inheritPendingDependenciesAsFutureForcedDependencies() {
        return this.#Jn.inheritPendingDependenciesAsFutureForcedDependencies(), this;
      }
      resetBBox(e2) {
        return this.#Jn.hasPendingBBox || this.#Jn.resetBBox(this.#Zn), this;
      }
      get hasPendingBBox() {
        return this.#Jn.hasPendingBBox;
      }
      recordClipBox(e2, t2, i2, a2, n2, s2) {
        return this.#Jn.recordClipBox(this.#Zn, t2, i2, a2, n2, s2), this;
      }
      recordBBox(e2, t2, i2, a2, n2, s2) {
        return this.#Jn.recordBBox(this.#Zn, t2, i2, a2, n2, s2), this;
      }
      recordCharacterBBox(e2, t2, i2, a2, n2, s2, r2) {
        return this.#Jn.recordCharacterBBox(this.#Zn, t2, i2, a2, n2, s2, r2), this;
      }
      recordFullPageBBox(e2) {
        return this.#Jn.recordFullPageBBox(this.#Zn), this;
      }
      getSimpleIndex(e2) {
        return this.#Jn.getSimpleIndex(e2);
      }
      recordDependencies(e2, t2) {
        return this.#Jn.recordDependencies(this.#Zn, t2), this;
      }
      copyDependenciesFromIncrementalOperation(e2, t2) {
        return this.#Jn.copyDependenciesFromIncrementalOperation(this.#Zn, t2), this;
      }
      recordNamedDependency(e2, t2) {
        return this.#Jn.recordNamedDependency(this.#Zn, t2), this;
      }
      recordOperation(e2) {
        this.#Jn.recordOperation(this.#Zn, true);
        const t2 = this.#Jn._extractOperation(this.#Zn);
        for (const e3 of t2.dependencies)
          this.#es.add(e3);
        return this.#es.delete(this.#Zn), this.#es.delete(null), this;
      }
      bboxToClipBoxDropOperation(e2) {
        return this.#Jn.bboxToClipBoxDropOperation(this.#Zn), this;
      }
      recordNestedDependencies() {
        this.#Jn._pushPendingDependencies(this.#es);
      }
      take() {
        throw new Error("Unreachable");
      }
    };
    __name(CanvasNestedDependencyTracker, "CanvasNestedDependencyTracker");
    Oc = ["path", "transform", "filter", "strokeColor", "strokeAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "dash"];
    _c2 = ["path", "transform", "filter", "fillColor", "fillAlpha", "globalCompositeOperation", "SMask"];
    Pc = ["transform", "SMask", "filter", "fillAlpha", "strokeAlpha", "globalCompositeOperation"];
    Rc = ["filter", "fillColor", "fillAlpha"];
    Bc = ["transform", "leading", "charSpacing", "wordSpacing", "hScale", "textRise", "moveText", "textMatrix", "font", "filter", "fillColor", "textRenderingMode", "SMask", "fillAlpha", "strokeAlpha", "globalCompositeOperation"];
    Nc = ["transform"];
    Lc = ["transform", "fillColor"];
    Uc = "Fill";
    jc = "Stroke";
    $c = "Shading";
    __name(applyBoundingBox, "applyBoundingBox");
    BaseShadingPattern = class {
      isModifyingCurrentTransform() {
        return false;
      }
      getPattern() {
        unreachable("Abstract method `getPattern` called.");
      }
    };
    __name(BaseShadingPattern, "BaseShadingPattern");
    RadialAxialShadingPattern = class extends BaseShadingPattern {
      constructor(e2) {
        super(), this._type = e2[1], this._bbox = e2[2], this._colorStops = e2[3], this._p0 = e2[4], this._p1 = e2[5], this._r0 = e2[6], this._r1 = e2[7], this.matrix = null;
      }
      _createGradient(e2) {
        let t2;
        "axial" === this._type ? t2 = e2.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]) : "radial" === this._type && (t2 = e2.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1));
        for (const e3 of this._colorStops)
          t2.addColorStop(e3[0], e3[1]);
        return t2;
      }
      getPattern(e2, t2, i2, a2) {
        let n2;
        if (a2 === jc || a2 === Uc) {
          const s2 = t2.current.getClippedPathBoundingBox(a2, getCurrentTransform(e2)) || [0, 0, 0, 0], r2 = Math.ceil(s2[2] - s2[0]) || 1, o2 = Math.ceil(s2[3] - s2[1]) || 1, l3 = t2.cachedCanvases.getCanvas("pattern", r2, o2), c2 = l3.context;
          c2.clearRect(0, 0, c2.canvas.width, c2.canvas.height), c2.beginPath(), c2.rect(0, 0, c2.canvas.width, c2.canvas.height), c2.translate(-s2[0], -s2[1]), i2 = Util.transform(i2, [1, 0, 0, 1, s2[0], s2[1]]), c2.transform(...t2.baseTransform), this.matrix && c2.transform(...this.matrix), applyBoundingBox(c2, this._bbox), c2.fillStyle = this._createGradient(c2), c2.fill(), n2 = e2.createPattern(l3.canvas, "no-repeat");
          const h2 = new DOMMatrix(i2);
          n2.setTransform(h2);
        } else
          applyBoundingBox(e2, this._bbox), n2 = this._createGradient(e2);
        return n2;
      }
    };
    __name(RadialAxialShadingPattern, "RadialAxialShadingPattern");
    __name(drawTriangle, "drawTriangle");
    __name(drawFigure, "drawFigure");
    MeshShadingPattern = class extends BaseShadingPattern {
      constructor(e2) {
        super(), this._coords = e2[2], this._colors = e2[3], this._figures = e2[4], this._bounds = e2[5], this._bbox = e2[6], this._background = e2[7], this.matrix = null;
      }
      _createMeshCanvas(e2, t2, i2) {
        const a2 = Math.floor(this._bounds[0]), n2 = Math.floor(this._bounds[1]), s2 = Math.ceil(this._bounds[2]) - a2, r2 = Math.ceil(this._bounds[3]) - n2, o2 = Math.min(Math.ceil(Math.abs(s2 * e2[0] * 1.1)), 3e3), l3 = Math.min(Math.ceil(Math.abs(r2 * e2[1] * 1.1)), 3e3), c2 = s2 / o2, h2 = r2 / l3, d2 = { coords: this._coords, colors: this._colors, offsetX: -a2, offsetY: -n2, scaleX: 1 / c2, scaleY: 1 / h2 }, u2 = o2 + 4, g2 = l3 + 4, p2 = i2.getCanvas("mesh", u2, g2), f2 = p2.context, m2 = f2.createImageData(o2, l3);
        if (t2) {
          const e3 = m2.data;
          for (let i3 = 0, a3 = e3.length; i3 < a3; i3 += 4)
            e3[i3] = t2[0], e3[i3 + 1] = t2[1], e3[i3 + 2] = t2[2], e3[i3 + 3] = 255;
        }
        for (const e3 of this._figures)
          drawFigure(m2, e3, d2);
        f2.putImageData(m2, 2, 2);
        return { canvas: p2.canvas, offsetX: a2 - 2 * c2, offsetY: n2 - 2 * h2, scaleX: c2, scaleY: h2 };
      }
      isModifyingCurrentTransform() {
        return true;
      }
      getPattern(e2, t2, i2, a2) {
        applyBoundingBox(e2, this._bbox);
        const n2 = new Float32Array(2);
        if (a2 === $c)
          Util.singularValueDecompose2dScale(getCurrentTransform(e2), n2);
        else if (this.matrix) {
          Util.singularValueDecompose2dScale(this.matrix, n2);
          const [e3, i3] = n2;
          Util.singularValueDecompose2dScale(t2.baseTransform, n2), n2[0] *= e3, n2[1] *= i3;
        } else
          Util.singularValueDecompose2dScale(t2.baseTransform, n2);
        const s2 = this._createMeshCanvas(n2, a2 === $c ? null : this._background, t2.cachedCanvases);
        return a2 !== $c && (e2.setTransform(...t2.baseTransform), this.matrix && e2.transform(...this.matrix)), e2.translate(s2.offsetX, s2.offsetY), e2.scale(s2.scaleX, s2.scaleY), e2.createPattern(s2.canvas, "no-repeat");
      }
    };
    __name(MeshShadingPattern, "MeshShadingPattern");
    DummyShadingPattern = class extends BaseShadingPattern {
      getPattern() {
        return "hotpink";
      }
    };
    __name(DummyShadingPattern, "DummyShadingPattern");
    Hc = 1;
    qc = 2;
    _TilingPattern = class {
      constructor(e2, t2, i2, a2) {
        this.color = e2[1], this.operatorList = e2[2], this.matrix = e2[3], this.bbox = e2[4], this.xstep = e2[5], this.ystep = e2[6], this.paintType = e2[7], this.tilingType = e2[8], this.ctx = t2, this.canvasGraphicsFactory = i2, this.baseTransform = a2;
      }
      createPatternCanvas(e2) {
        const { bbox: t2, operatorList: i2, paintType: a2, tilingType: n2, color: s2, canvasGraphicsFactory: r2 } = this;
        let { xstep: o2, ystep: l3 } = this;
        o2 = Math.abs(o2), l3 = Math.abs(l3), info3("TilingType: " + n2);
        const c2 = t2[0], h2 = t2[1], d2 = t2[2], u2 = t2[3], g2 = d2 - c2, p2 = u2 - h2, f2 = new Float32Array(2);
        Util.singularValueDecompose2dScale(this.matrix, f2);
        const [m2, b2] = f2;
        Util.singularValueDecompose2dScale(this.baseTransform, f2);
        const y2 = m2 * f2[0], w2 = b2 * f2[1];
        let x2 = g2, S2 = p2, v2 = false, C2 = false;
        const k2 = Math.ceil(o2 * y2), T2 = Math.ceil(l3 * w2);
        k2 >= Math.ceil(g2 * y2) ? x2 = o2 : v2 = true, T2 >= Math.ceil(p2 * w2) ? S2 = l3 : C2 = true;
        const F2 = this.getSizeAndScale(x2, this.ctx.canvas.width, y2), M2 = this.getSizeAndScale(S2, this.ctx.canvas.height, w2), D2 = e2.cachedCanvases.getCanvas("pattern", F2.size, M2.size), E2 = D2.context, O2 = r2.createCanvasGraphics(E2);
        if (O2.groupLevel = e2.groupLevel, this.setFillAndStrokeStyleToContext(O2, a2, s2), E2.translate(-F2.scale * c2, -M2.scale * h2), O2.transform(0, F2.scale, 0, 0, M2.scale, 0, 0), E2.save(), O2.dependencyTracker?.save(), this.clipBbox(O2, c2, h2, d2, u2), O2.baseTransform = getCurrentTransform(O2.ctx), O2.executeOperatorList(i2), O2.endDrawing(), O2.dependencyTracker?.restore().recordNestedDependencies?.(), E2.restore(), v2 || C2) {
          const t3 = D2.canvas;
          v2 && (x2 = o2), C2 && (S2 = l3);
          const i3 = this.getSizeAndScale(x2, this.ctx.canvas.width, y2), a3 = this.getSizeAndScale(S2, this.ctx.canvas.height, w2), n3 = i3.size, s3 = a3.size, r3 = e2.cachedCanvases.getCanvas("pattern-workaround", n3, s3), d3 = r3.context, u3 = v2 ? Math.floor(g2 / o2) : 0, f3 = C2 ? Math.floor(p2 / l3) : 0;
          for (let e3 = 0; e3 <= u3; e3++)
            for (let i4 = 0; i4 <= f3; i4++)
              d3.drawImage(t3, n3 * e3, s3 * i4, n3, s3, 0, 0, n3, s3);
          return { canvas: r3.canvas, scaleX: i3.scale, scaleY: a3.scale, offsetX: c2, offsetY: h2 };
        }
        return { canvas: D2.canvas, scaleX: F2.scale, scaleY: M2.scale, offsetX: c2, offsetY: h2 };
      }
      getSizeAndScale(e2, t2, i2) {
        const a2 = Math.max(_TilingPattern.MAX_PATTERN_SIZE, t2);
        let n2 = Math.ceil(e2 * i2);
        return n2 >= a2 ? n2 = a2 : i2 = n2 / e2, { scale: i2, size: n2 };
      }
      clipBbox(e2, t2, i2, a2, n2) {
        const s2 = a2 - t2, r2 = n2 - i2;
        e2.ctx.rect(t2, i2, s2, r2), Util.axialAlignedBoundingBox([t2, i2, a2, n2], getCurrentTransform(e2.ctx), e2.current.minMax), e2.clip(), e2.endPath();
      }
      setFillAndStrokeStyleToContext(e2, t2, i2) {
        const a2 = e2.ctx, n2 = e2.current;
        switch (t2) {
          case Hc:
            const { fillStyle: e3, strokeStyle: s2 } = this.ctx;
            a2.fillStyle = n2.fillColor = e3, a2.strokeStyle = n2.strokeColor = s2;
            break;
          case qc:
            a2.fillStyle = a2.strokeStyle = i2, n2.fillColor = n2.strokeColor = i2;
            break;
          default:
            throw new FormatError(`Unsupported paint type: ${t2}`);
        }
      }
      isModifyingCurrentTransform() {
        return false;
      }
      getPattern(e2, t2, i2, a2) {
        let n2 = i2;
        a2 !== $c && (n2 = Util.transform(n2, t2.baseTransform), this.matrix && (n2 = Util.transform(n2, this.matrix)));
        const s2 = this.createPatternCanvas(t2);
        let r2 = new DOMMatrix(n2);
        r2 = r2.translate(s2.offsetX, s2.offsetY), r2 = r2.scale(1 / s2.scaleX, 1 / s2.scaleY);
        const o2 = e2.createPattern(s2.canvas, "repeat");
        return o2.setTransform(r2), o2;
      }
    };
    TilingPattern = _TilingPattern;
    __name(TilingPattern, "TilingPattern");
    __publicField(TilingPattern, "MAX_PATTERN_SIZE", 3e3);
    __name(convertBlackAndWhiteToRGBA, "convertBlackAndWhiteToRGBA");
    Xc = 16;
    zc = new DOMMatrix();
    Wc = new Float32Array(2);
    Gc = new Float32Array([1 / 0, 1 / 0, -1 / 0, -1 / 0]);
    CachedCanvases = class {
      constructor(e2) {
        this.canvasFactory = e2, this.cache = /* @__PURE__ */ Object.create(null);
      }
      getCanvas(e2, t2, i2) {
        let a2;
        return void 0 !== this.cache[e2] ? (a2 = this.cache[e2], this.canvasFactory.reset(a2, t2, i2)) : (a2 = this.canvasFactory.create(t2, i2), this.cache[e2] = a2), a2;
      }
      delete(e2) {
        delete this.cache[e2];
      }
      clear() {
        for (const e2 in this.cache) {
          const t2 = this.cache[e2];
          this.canvasFactory.destroy(t2), delete this.cache[e2];
        }
      }
    };
    __name(CachedCanvases, "CachedCanvases");
    __name(drawImageAtIntegerCoords, "drawImageAtIntegerCoords");
    CanvasExtraState = class {
      alphaIsShape = false;
      fontSize = 0;
      fontSizeScale = 1;
      textMatrix = null;
      textMatrixScale = 1;
      fontMatrix = kl;
      leading = 0;
      x = 0;
      y = 0;
      lineX = 0;
      lineY = 0;
      charSpacing = 0;
      wordSpacing = 0;
      textHScale = 1;
      textRenderingMode = Hl;
      textRise = 0;
      fillColor = "#000000";
      strokeColor = "#000000";
      patternFill = false;
      patternStroke = false;
      fillAlpha = 1;
      strokeAlpha = 1;
      lineWidth = 1;
      activeSMask = null;
      transferMaps = "none";
      constructor(e2, t2, i2) {
        i2?.(this), this.clipBox = new Float32Array([0, 0, e2, t2]), this.minMax = Gc.slice();
      }
      clone() {
        const e2 = Object.create(this);
        return e2.clipBox = this.clipBox.slice(), e2.minMax = this.minMax.slice(), e2;
      }
      getPathBoundingBox(e2 = Uc, t2 = null) {
        const i2 = this.minMax.slice();
        if (e2 === jc) {
          t2 || unreachable("Stroke bounding box must include transform."), Util.singularValueDecompose2dScale(t2, Wc);
          const e3 = Wc[0] * this.lineWidth / 2, a2 = Wc[1] * this.lineWidth / 2;
          i2[0] -= e3, i2[1] -= a2, i2[2] += e3, i2[3] += a2;
        }
        return i2;
      }
      updateClipFromPath() {
        const e2 = Util.intersect(this.clipBox, this.getPathBoundingBox());
        this.startNewPathAndClipBox(e2 || [0, 0, 0, 0]);
      }
      isEmptyClip() {
        return this.minMax[0] === 1 / 0;
      }
      startNewPathAndClipBox(e2) {
        this.clipBox.set(e2, 0), this.minMax.set(Gc, 0);
      }
      getClippedPathBoundingBox(e2 = Uc, t2 = null) {
        return Util.intersect(this.clipBox, this.getPathBoundingBox(e2, t2));
      }
    };
    __name(CanvasExtraState, "CanvasExtraState");
    __name(putBinaryImageData, "putBinaryImageData");
    __name(putBinaryImageMask, "putBinaryImageMask");
    __name(copyCtxState, "copyCtxState");
    __name(resetCtxToDefault, "resetCtxToDefault");
    __name(getImageSmoothingEnabled, "getImageSmoothingEnabled");
    Vc = ["butt", "round", "square"];
    Kc = ["miter", "round", "bevel"];
    Yc = {};
    Jc = {};
    CanvasGraphics = class {
      constructor(e2, t2, i2, a2, n2, { optionalContentConfig: s2, markedContentStack: r2 = null }, o2, l3, c2) {
        this.ctx = e2, this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height), this.stateStack = [], this.pendingClip = null, this.pendingEOFill = false, this.res = null, this.xobjs = null, this.commonObjs = t2, this.objs = i2, this.canvasFactory = a2, this.filterFactory = n2, this.groupStack = [], this.baseTransform = null, this.baseTransformStack = [], this.groupLevel = 0, this.smaskStack = [], this.smaskCounter = 0, this.tempSMask = null, this.suspendedCtx = null, this.contentVisible = true, this.markedContentStack = r2 || [], this.optionalContentConfig = s2, this.cachedCanvases = new CachedCanvases(this.canvasFactory), this.cachedPatterns = /* @__PURE__ */ new Map(), this.annotationCanvasMap = o2, this.viewportScale = 1, this.outputScaleX = 1, this.outputScaleY = 1, this.pageColors = l3, this._cachedScaleForStroking = [-1, 0], this._cachedGetSinglePixelWidth = null, this._cachedBitmapsMap = /* @__PURE__ */ new Map(), this.dependencyTracker = c2 ?? null;
      }
      getObject(e2, t2, i2 = null) {
        return "string" == typeof t2 ? (this.dependencyTracker?.recordNamedDependency(e2, t2), t2.startsWith("g_") ? this.commonObjs.get(t2) : this.objs.get(t2)) : i2;
      }
      beginDrawing({ transform: e2, viewport: t2, transparency: i2 = false, background: a2 = null }) {
        const n2 = this.ctx.canvas.width, s2 = this.ctx.canvas.height, r2 = this.ctx.fillStyle;
        if (this.ctx.fillStyle = a2 || "#ffffff", this.ctx.fillRect(0, 0, n2, s2), this.ctx.fillStyle = r2, i2) {
          const e3 = this.cachedCanvases.getCanvas("transparent", n2, s2);
          this.compositeCtx = this.ctx, this.transparentCanvas = e3.canvas, this.ctx = e3.context, this.ctx.save(), this.ctx.transform(...getCurrentTransform(this.compositeCtx));
        }
        this.ctx.save(), resetCtxToDefault(this.ctx), e2 && (this.ctx.transform(...e2), this.outputScaleX = e2[0], this.outputScaleY = e2[0]), this.ctx.transform(...t2.transform), this.viewportScale = t2.scale, this.baseTransform = getCurrentTransform(this.ctx);
      }
      executeOperatorList(e2, t2, i2, a2, n2) {
        const s2 = e2.argsArray, r2 = e2.fnArray;
        let o2 = t2 || 0;
        const l3 = s2.length;
        if (l3 === o2)
          return o2;
        const c2 = l3 - o2 > 10 && "function" == typeof i2, h2 = c2 ? Date.now() + 15 : 0;
        let d2 = 0;
        const u2 = this.commonObjs, g2 = this.objs;
        let p2, f2;
        for (; ; ) {
          if (void 0 !== a2 && o2 === a2.nextBreakPoint)
            return a2.breakIt(o2, i2), o2;
          if (!n2 || n2.has(o2))
            if (p2 = r2[o2], f2 = s2[o2] ?? null, p2 !== ic.dependency)
              null === f2 ? this[p2](o2) : this[p2](o2, ...f2);
            else
              for (const e3 of f2) {
                this.dependencyTracker?.recordNamedData(e3, o2);
                const t3 = e3.startsWith("g_") ? u2 : g2;
                if (!t3.has(e3))
                  return t3.get(e3, i2), o2;
              }
          if (o2++, o2 === l3)
            return o2;
          if (c2 && ++d2 > 10) {
            if (Date.now() > h2)
              return i2(), o2;
            d2 = 0;
          }
        }
      }
      #is() {
        for (; this.stateStack.length || this.inSMaskMode; )
          this.restore();
        this.current.activeSMask = null, this.ctx.restore(), this.transparentCanvas && (this.ctx = this.compositeCtx, this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.drawImage(this.transparentCanvas, 0, 0), this.ctx.restore(), this.transparentCanvas = null);
      }
      endDrawing() {
        this.#is(), this.cachedCanvases.clear(), this.cachedPatterns.clear();
        for (const e2 of this._cachedBitmapsMap.values()) {
          for (const t2 of e2.values())
            "undefined" != typeof HTMLCanvasElement && t2 instanceof HTMLCanvasElement && (t2.width = t2.height = 0);
          e2.clear();
        }
        this._cachedBitmapsMap.clear(), this.#as();
      }
      #as() {
        if (this.pageColors) {
          const e2 = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background);
          if ("none" !== e2) {
            const t2 = this.ctx.filter;
            this.ctx.filter = e2, this.ctx.drawImage(this.ctx.canvas, 0, 0), this.ctx.filter = t2;
          }
        }
      }
      _scaleImage(e2, t2) {
        const i2 = e2.width ?? e2.displayWidth, a2 = e2.height ?? e2.displayHeight;
        let n2, s2, r2 = Math.max(Math.hypot(t2[0], t2[1]), 1), o2 = Math.max(Math.hypot(t2[2], t2[3]), 1), l3 = i2, c2 = a2, h2 = "prescale1";
        for (; r2 > 2 && l3 > 1 || o2 > 2 && c2 > 1; ) {
          let t3 = l3, i3 = c2;
          r2 > 2 && l3 > 1 && (t3 = l3 >= 16384 ? Math.floor(l3 / 2) - 1 || 1 : Math.ceil(l3 / 2), r2 /= l3 / t3), o2 > 2 && c2 > 1 && (i3 = c2 >= 16384 ? Math.floor(c2 / 2) - 1 || 1 : Math.ceil(c2) / 2, o2 /= c2 / i3), n2 = this.cachedCanvases.getCanvas(h2, t3, i3), s2 = n2.context, s2.clearRect(0, 0, t3, i3), s2.drawImage(e2, 0, 0, l3, c2, 0, 0, t3, i3), e2 = n2.canvas, l3 = t3, c2 = i3, h2 = "prescale1" === h2 ? "prescale2" : "prescale1";
        }
        return { img: e2, paintWidth: l3, paintHeight: c2 };
      }
      _createMaskCanvas(e2, t2) {
        const i2 = this.ctx, { width: a2, height: n2 } = t2, s2 = this.current.fillColor, r2 = this.current.patternFill, o2 = getCurrentTransform(i2);
        let l3, c2, h2, d2;
        if ((t2.bitmap || t2.data) && t2.count > 1) {
          const i3 = t2.bitmap || t2.data.buffer;
          c2 = JSON.stringify(r2 ? o2 : [o2.slice(0, 4), s2]), l3 = this._cachedBitmapsMap.get(i3), l3 || (l3 = /* @__PURE__ */ new Map(), this._cachedBitmapsMap.set(i3, l3));
          const a3 = l3.get(c2);
          if (a3 && !r2) {
            const t3 = Math.round(Math.min(o2[0], o2[2]) + o2[4]), i4 = Math.round(Math.min(o2[1], o2[3]) + o2[5]);
            return this.dependencyTracker?.recordDependencies(e2, Lc), { canvas: a3, offsetX: t3, offsetY: i4 };
          }
          h2 = a3;
        }
        h2 || (d2 = this.cachedCanvases.getCanvas("maskCanvas", a2, n2), putBinaryImageMask(d2.context, t2));
        let u2 = Util.transform(o2, [1 / a2, 0, 0, -1 / n2, 0, 0]);
        u2 = Util.transform(u2, [1, 0, 0, 1, 0, -n2]);
        const g2 = Gc.slice();
        Util.axialAlignedBoundingBox([0, 0, a2, n2], u2, g2);
        const [p2, f2, m2, b2] = g2, y2 = Math.round(m2 - p2) || 1, w2 = Math.round(b2 - f2) || 1, x2 = this.cachedCanvases.getCanvas("fillCanvas", y2, w2), S2 = x2.context, v2 = p2, C2 = f2;
        S2.translate(-v2, -C2), S2.transform(...u2), h2 || (h2 = this._scaleImage(d2.canvas, getCurrentTransformInverse(S2)), h2 = h2.img, l3 && r2 && l3.set(c2, h2)), S2.imageSmoothingEnabled = getImageSmoothingEnabled(getCurrentTransform(S2), t2.interpolate), drawImageAtIntegerCoords(S2, h2, 0, 0, h2.width, h2.height, 0, 0, a2, n2), S2.globalCompositeOperation = "source-in";
        const k2 = Util.transform(getCurrentTransformInverse(S2), [1, 0, 0, 1, -v2, -C2]);
        return S2.fillStyle = r2 ? s2.getPattern(i2, this, k2, Uc) : s2, S2.fillRect(0, 0, a2, n2), l3 && !r2 && (this.cachedCanvases.delete("fillCanvas"), l3.set(c2, x2.canvas)), this.dependencyTracker?.recordDependencies(e2, Lc), { canvas: x2.canvas, offsetX: Math.round(v2), offsetY: Math.round(C2) };
      }
      setLineWidth(e2, t2) {
        this.dependencyTracker?.recordSimpleData("lineWidth", e2), t2 !== this.current.lineWidth && (this._cachedScaleForStroking[0] = -1), this.current.lineWidth = t2, this.ctx.lineWidth = t2;
      }
      setLineCap(e2, t2) {
        this.dependencyTracker?.recordSimpleData("lineCap", e2), this.ctx.lineCap = Vc[t2];
      }
      setLineJoin(e2, t2) {
        this.dependencyTracker?.recordSimpleData("lineJoin", e2), this.ctx.lineJoin = Kc[t2];
      }
      setMiterLimit(e2, t2) {
        this.dependencyTracker?.recordSimpleData("miterLimit", e2), this.ctx.miterLimit = t2;
      }
      setDash(e2, t2, i2) {
        this.dependencyTracker?.recordSimpleData("dash", e2);
        const a2 = this.ctx;
        void 0 !== a2.setLineDash && (a2.setLineDash(t2), a2.lineDashOffset = i2);
      }
      setRenderingIntent(e2, t2) {
      }
      setFlatness(e2, t2) {
      }
      setGState(e2, t2) {
        for (const [i2, a2] of t2)
          switch (i2) {
            case "LW":
              this.setLineWidth(e2, a2);
              break;
            case "LC":
              this.setLineCap(e2, a2);
              break;
            case "LJ":
              this.setLineJoin(e2, a2);
              break;
            case "ML":
              this.setMiterLimit(e2, a2);
              break;
            case "D":
              this.setDash(e2, a2[0], a2[1]);
              break;
            case "RI":
              this.setRenderingIntent(e2, a2);
              break;
            case "FL":
              this.setFlatness(e2, a2);
              break;
            case "Font":
              this.setFont(e2, a2[0], a2[1]);
              break;
            case "CA":
              this.dependencyTracker?.recordSimpleData("strokeAlpha", e2), this.current.strokeAlpha = a2;
              break;
            case "ca":
              this.dependencyTracker?.recordSimpleData("fillAlpha", e2), this.ctx.globalAlpha = this.current.fillAlpha = a2;
              break;
            case "BM":
              this.dependencyTracker?.recordSimpleData("globalCompositeOperation", e2), this.ctx.globalCompositeOperation = a2;
              break;
            case "SMask":
              this.dependencyTracker?.recordSimpleData("SMask", e2), this.current.activeSMask = a2 ? this.tempSMask : null, this.tempSMask = null, this.checkSMaskState();
              break;
            case "TR":
              this.dependencyTracker?.recordSimpleData("filter", e2), this.ctx.filter = this.current.transferMaps = this.filterFactory.addFilter(a2);
          }
      }
      get inSMaskMode() {
        return !!this.suspendedCtx;
      }
      checkSMaskState() {
        const e2 = this.inSMaskMode;
        this.current.activeSMask && !e2 ? this.beginSMaskMode() : !this.current.activeSMask && e2 && this.endSMaskMode();
      }
      beginSMaskMode(e2) {
        if (this.inSMaskMode)
          throw new Error("beginSMaskMode called while already in smask mode");
        const t2 = this.ctx.canvas.width, i2 = this.ctx.canvas.height, a2 = "smaskGroupAt" + this.groupLevel, n2 = this.cachedCanvases.getCanvas(a2, t2, i2);
        this.suspendedCtx = this.ctx;
        const s2 = this.ctx = n2.context;
        s2.setTransform(this.suspendedCtx.getTransform()), copyCtxState(this.suspendedCtx, s2), function(e3, t3) {
          if (e3._removeMirroring)
            throw new Error("Context is already forwarding operations.");
          e3.__originalSave = e3.save, e3.__originalRestore = e3.restore, e3.__originalRotate = e3.rotate, e3.__originalScale = e3.scale, e3.__originalTranslate = e3.translate, e3.__originalTransform = e3.transform, e3.__originalSetTransform = e3.setTransform, e3.__originalResetTransform = e3.resetTransform, e3.__originalClip = e3.clip, e3.__originalMoveTo = e3.moveTo, e3.__originalLineTo = e3.lineTo, e3.__originalBezierCurveTo = e3.bezierCurveTo, e3.__originalRect = e3.rect, e3.__originalClosePath = e3.closePath, e3.__originalBeginPath = e3.beginPath, e3._removeMirroring = () => {
            e3.save = e3.__originalSave, e3.restore = e3.__originalRestore, e3.rotate = e3.__originalRotate, e3.scale = e3.__originalScale, e3.translate = e3.__originalTranslate, e3.transform = e3.__originalTransform, e3.setTransform = e3.__originalSetTransform, e3.resetTransform = e3.__originalResetTransform, e3.clip = e3.__originalClip, e3.moveTo = e3.__originalMoveTo, e3.lineTo = e3.__originalLineTo, e3.bezierCurveTo = e3.__originalBezierCurveTo, e3.rect = e3.__originalRect, e3.closePath = e3.__originalClosePath, e3.beginPath = e3.__originalBeginPath, delete e3._removeMirroring;
          }, e3.save = function() {
            t3.save(), this.__originalSave();
          }, e3.restore = function() {
            t3.restore(), this.__originalRestore();
          }, e3.translate = function(e4, i3) {
            t3.translate(e4, i3), this.__originalTranslate(e4, i3);
          }, e3.scale = function(e4, i3) {
            t3.scale(e4, i3), this.__originalScale(e4, i3);
          }, e3.transform = function(e4, i3, a3, n3, s3, r2) {
            t3.transform(e4, i3, a3, n3, s3, r2), this.__originalTransform(e4, i3, a3, n3, s3, r2);
          }, e3.setTransform = function(e4, i3, a3, n3, s3, r2) {
            t3.setTransform(e4, i3, a3, n3, s3, r2), this.__originalSetTransform(e4, i3, a3, n3, s3, r2);
          }, e3.resetTransform = function() {
            t3.resetTransform(), this.__originalResetTransform();
          }, e3.rotate = function(e4) {
            t3.rotate(e4), this.__originalRotate(e4);
          }, e3.clip = function(e4) {
            t3.clip(e4), this.__originalClip(e4);
          }, e3.moveTo = function(e4, i3) {
            t3.moveTo(e4, i3), this.__originalMoveTo(e4, i3);
          }, e3.lineTo = function(e4, i3) {
            t3.lineTo(e4, i3), this.__originalLineTo(e4, i3);
          }, e3.bezierCurveTo = function(e4, i3, a3, n3, s3, r2) {
            t3.bezierCurveTo(e4, i3, a3, n3, s3, r2), this.__originalBezierCurveTo(e4, i3, a3, n3, s3, r2);
          }, e3.rect = function(e4, i3, a3, n3) {
            t3.rect(e4, i3, a3, n3), this.__originalRect(e4, i3, a3, n3);
          }, e3.closePath = function() {
            t3.closePath(), this.__originalClosePath();
          }, e3.beginPath = function() {
            t3.beginPath(), this.__originalBeginPath();
          };
        }(s2, this.suspendedCtx), this.setGState(e2, [["BM", "source-over"]]);
      }
      endSMaskMode() {
        if (!this.inSMaskMode)
          throw new Error("endSMaskMode called while not in smask mode");
        this.ctx._removeMirroring(), copyCtxState(this.ctx, this.suspendedCtx), this.ctx = this.suspendedCtx, this.suspendedCtx = null;
      }
      compose(e2) {
        if (!this.current.activeSMask)
          return;
        e2 ? (e2[0] = Math.floor(e2[0]), e2[1] = Math.floor(e2[1]), e2[2] = Math.ceil(e2[2]), e2[3] = Math.ceil(e2[3])) : e2 = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];
        const t2 = this.current.activeSMask, i2 = this.suspendedCtx;
        this.composeSMask(i2, t2, this.ctx, e2), this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height), this.ctx.restore();
      }
      composeSMask(e2, t2, i2, a2) {
        const n2 = a2[0], s2 = a2[1], r2 = a2[2] - n2, o2 = a2[3] - s2;
        0 !== r2 && 0 !== o2 && (this.genericComposeSMask(t2.context, i2, r2, o2, t2.subtype, t2.backdrop, t2.transferMap, n2, s2, t2.offsetX, t2.offsetY), e2.save(), e2.globalAlpha = 1, e2.globalCompositeOperation = "source-over", e2.setTransform(1, 0, 0, 1, 0, 0), e2.drawImage(i2.canvas, 0, 0), e2.restore());
      }
      genericComposeSMask(e2, t2, i2, a2, n2, s2, r2, o2, l3, c2, h2) {
        let d2 = e2.canvas, u2 = o2 - c2, g2 = l3 - h2;
        if (s2)
          if (u2 < 0 || g2 < 0 || u2 + i2 > d2.width || g2 + a2 > d2.height) {
            const e3 = this.cachedCanvases.getCanvas("maskExtension", i2, a2), t3 = e3.context;
            t3.drawImage(d2, -u2, -g2), t3.globalCompositeOperation = "destination-atop", t3.fillStyle = s2, t3.fillRect(0, 0, i2, a2), t3.globalCompositeOperation = "source-over", d2 = e3.canvas, u2 = g2 = 0;
          } else {
            e2.save(), e2.globalAlpha = 1, e2.setTransform(1, 0, 0, 1, 0, 0);
            const t3 = new Path2D();
            t3.rect(u2, g2, i2, a2), e2.clip(t3), e2.globalCompositeOperation = "destination-atop", e2.fillStyle = s2, e2.fillRect(u2, g2, i2, a2), e2.restore();
          }
        t2.save(), t2.globalAlpha = 1, t2.setTransform(1, 0, 0, 1, 0, 0), "Alpha" === n2 && r2 ? t2.filter = this.filterFactory.addAlphaFilter(r2) : "Luminosity" === n2 && (t2.filter = this.filterFactory.addLuminosityFilter(r2));
        const p2 = new Path2D();
        p2.rect(o2, l3, i2, a2), t2.clip(p2), t2.globalCompositeOperation = "destination-in", t2.drawImage(d2, u2, g2, i2, a2, o2, l3, i2, a2), t2.restore();
      }
      save(e2) {
        this.inSMaskMode && copyCtxState(this.ctx, this.suspendedCtx), this.ctx.save();
        const t2 = this.current;
        this.stateStack.push(t2), this.current = t2.clone(), this.dependencyTracker?.save(e2);
      }
      restore(e2) {
        this.dependencyTracker?.restore(e2), 0 !== this.stateStack.length ? (this.current = this.stateStack.pop(), this.ctx.restore(), this.inSMaskMode && copyCtxState(this.suspendedCtx, this.ctx), this.checkSMaskState(), this.pendingClip = null, this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null) : this.inSMaskMode && this.endSMaskMode();
      }
      transform(e2, t2, i2, a2, n2, s2, r2) {
        this.dependencyTracker?.recordIncrementalData("transform", e2), this.ctx.transform(t2, i2, a2, n2, s2, r2), this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null;
      }
      constructPath(e2, t2, i2, a2) {
        let [n2] = i2;
        if (!a2)
          return n2 ||= i2[0] = new Path2D(), void this[t2](e2, n2);
        if (null !== this.dependencyTracker) {
          const i3 = t2 === ic.stroke ? this.current.lineWidth / 2 : 0;
          this.dependencyTracker.resetBBox(e2).recordBBox(e2, this.ctx, a2[0] - i3, a2[2] + i3, a2[1] - i3, a2[3] + i3).recordDependencies(e2, ["transform"]);
        }
        if (!(n2 instanceof Path2D)) {
          const e3 = i2[0] = new Path2D();
          for (let t3 = 0, i3 = n2.length; t3 < i3; )
            switch (n2[t3++]) {
              case ac:
                e3.moveTo(n2[t3++], n2[t3++]);
                break;
              case nc:
                e3.lineTo(n2[t3++], n2[t3++]);
                break;
              case sc:
                e3.bezierCurveTo(n2[t3++], n2[t3++], n2[t3++], n2[t3++], n2[t3++], n2[t3++]);
                break;
              case rc:
                e3.closePath();
                break;
              default:
                warn3(`Unrecognized drawing path operator: ${n2[t3 - 1]}`);
            }
          n2 = e3;
        }
        Util.axialAlignedBoundingBox(a2, getCurrentTransform(this.ctx), this.current.minMax), this[t2](e2, n2), this._pathStartIdx = e2;
      }
      closePath(e2) {
        this.ctx.closePath();
      }
      stroke(e2, t2, i2 = true) {
        const a2 = this.ctx, n2 = this.current.strokeColor;
        if (a2.globalAlpha = this.current.strokeAlpha, this.contentVisible)
          if ("object" == typeof n2 && n2?.getPattern) {
            const e3 = n2.isModifyingCurrentTransform() ? a2.getTransform() : null;
            if (a2.save(), a2.strokeStyle = n2.getPattern(a2, this, getCurrentTransformInverse(a2), jc), e3) {
              const i3 = new Path2D();
              i3.addPath(t2, a2.getTransform().invertSelf().multiplySelf(e3)), t2 = i3;
            }
            this.rescaleAndStroke(t2, false), a2.restore();
          } else
            this.rescaleAndStroke(t2, true);
        this.dependencyTracker?.recordDependencies(e2, Oc), i2 && this.consumePath(e2, t2, this.current.getClippedPathBoundingBox(jc, getCurrentTransform(this.ctx))), a2.globalAlpha = this.current.fillAlpha;
      }
      closeStroke(e2, t2) {
        this.stroke(e2, t2);
      }
      fill(e2, t2, i2 = true) {
        const a2 = this.ctx, n2 = this.current.fillColor;
        let s2 = false;
        if (this.current.patternFill) {
          const i3 = n2.isModifyingCurrentTransform() ? a2.getTransform() : null;
          if (this.dependencyTracker?.save(e2), a2.save(), a2.fillStyle = n2.getPattern(a2, this, getCurrentTransformInverse(a2), Uc), i3) {
            const e3 = new Path2D();
            e3.addPath(t2, a2.getTransform().invertSelf().multiplySelf(i3)), t2 = e3;
          }
          s2 = true;
        }
        const r2 = this.current.getClippedPathBoundingBox();
        this.contentVisible && null !== r2 && (this.pendingEOFill ? (a2.fill(t2, "evenodd"), this.pendingEOFill = false) : a2.fill(t2)), this.dependencyTracker?.recordDependencies(e2, _c2), s2 && (a2.restore(), this.dependencyTracker?.restore(e2)), i2 && this.consumePath(e2, t2, r2);
      }
      eoFill(e2, t2) {
        this.pendingEOFill = true, this.fill(e2, t2);
      }
      fillStroke(e2, t2) {
        this.fill(e2, t2, false), this.stroke(e2, t2, false), this.consumePath(e2, t2);
      }
      eoFillStroke(e2, t2) {
        this.pendingEOFill = true, this.fillStroke(e2, t2);
      }
      closeFillStroke(e2, t2) {
        this.fillStroke(e2, t2);
      }
      closeEOFillStroke(e2, t2) {
        this.pendingEOFill = true, this.fillStroke(e2, t2);
      }
      endPath(e2, t2) {
        this.consumePath(e2, t2);
      }
      rawFillPath(e2, t2) {
        this.ctx.fill(t2), this.dependencyTracker?.recordDependencies(e2, Rc).recordOperation(e2);
      }
      clip(e2) {
        this.dependencyTracker?.recordFutureForcedDependency("clipMode", e2), this.pendingClip = Yc;
      }
      eoClip(e2) {
        this.dependencyTracker?.recordFutureForcedDependency("clipMode", e2), this.pendingClip = Jc;
      }
      beginText(e2) {
        this.current.textMatrix = null, this.current.textMatrixScale = 1, this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0, this.dependencyTracker?.recordOpenMarker(e2).resetIncrementalData("sameLineText").resetIncrementalData("moveText", e2);
      }
      endText(e2) {
        const t2 = this.pendingTextPaths, i2 = this.ctx;
        if (this.dependencyTracker) {
          const { dependencyTracker: i3 } = this;
          void 0 !== t2 && i3.recordFutureForcedDependency("textClip", i3.getOpenMarker()).recordFutureForcedDependency("textClip", e2), i3.recordCloseMarker(e2);
        }
        if (void 0 !== t2) {
          const e3 = new Path2D(), a2 = i2.getTransform().invertSelf();
          for (const { transform: i3, x: n2, y: s2, fontSize: r2, path: o2 } of t2)
            o2 && e3.addPath(o2, new DOMMatrix(i3).preMultiplySelf(a2).translate(n2, s2).scale(r2, -r2));
          i2.clip(e3);
        }
        delete this.pendingTextPaths;
      }
      setCharSpacing(e2, t2) {
        this.dependencyTracker?.recordSimpleData("charSpacing", e2), this.current.charSpacing = t2;
      }
      setWordSpacing(e2, t2) {
        this.dependencyTracker?.recordSimpleData("wordSpacing", e2), this.current.wordSpacing = t2;
      }
      setHScale(e2, t2) {
        this.dependencyTracker?.recordSimpleData("hScale", e2), this.current.textHScale = t2 / 100;
      }
      setLeading(e2, t2) {
        this.dependencyTracker?.recordSimpleData("leading", e2), this.current.leading = -t2;
      }
      setFont(e2, t2, i2) {
        this.dependencyTracker?.recordSimpleData("font", e2).recordNamedDependency(e2, t2);
        const a2 = this.commonObjs.get(t2), n2 = this.current;
        if (!a2)
          throw new Error(`Can't find font for ${t2}`);
        if (n2.fontMatrix = a2.fontMatrix || kl, 0 !== n2.fontMatrix[0] && 0 !== n2.fontMatrix[3] || warn3("Invalid font matrix for font " + t2), i2 < 0 ? (i2 = -i2, n2.fontDirection = -1) : n2.fontDirection = 1, this.current.font = a2, this.current.fontSize = i2, a2.isType3Font)
          return;
        const s2 = a2.loadedName || "sans-serif", r2 = a2.systemFontInfo?.css || `"${s2}", ${a2.fallbackName}`;
        let o2 = "normal";
        a2.black ? o2 = "900" : a2.bold && (o2 = "bold");
        const l3 = a2.italic ? "italic" : "normal";
        let c2 = i2;
        i2 < 16 ? c2 = 16 : i2 > 100 && (c2 = 100), this.current.fontSizeScale = i2 / c2, this.ctx.font = `${l3} ${o2} ${c2}px ${r2}`;
      }
      setTextRenderingMode(e2, t2) {
        this.dependencyTracker?.recordSimpleData("textRenderingMode", e2), this.current.textRenderingMode = t2;
      }
      setTextRise(e2, t2) {
        this.dependencyTracker?.recordSimpleData("textRise", e2), this.current.textRise = t2;
      }
      moveText(e2, t2, i2) {
        this.dependencyTracker?.resetIncrementalData("sameLineText").recordIncrementalData("moveText", e2), this.current.x = this.current.lineX += t2, this.current.y = this.current.lineY += i2;
      }
      setLeadingMoveText(e2, t2, i2) {
        this.setLeading(e2, -i2), this.moveText(e2, t2, i2);
      }
      setTextMatrix(e2, t2) {
        this.dependencyTracker?.recordSimpleData("textMatrix", e2);
        const { current: i2 } = this;
        i2.textMatrix = t2, i2.textMatrixScale = Math.hypot(t2[0], t2[1]), i2.x = i2.lineX = 0, i2.y = i2.lineY = 0;
      }
      nextLine(e2) {
        this.moveText(e2, 0, this.current.leading), this.dependencyTracker?.recordIncrementalData("moveText", this.dependencyTracker.getSimpleIndex("leading") ?? e2);
      }
      #ns(e2, t2, i2) {
        const a2 = new Path2D();
        return a2.addPath(e2, new DOMMatrix(i2).invertSelf().multiplySelf(t2)), a2;
      }
      paintChar(e2, t2, i2, a2, n2, s2) {
        const r2 = this.ctx, o2 = this.current, l3 = o2.font, c2 = o2.textRenderingMode, h2 = o2.fontSize / o2.fontSizeScale, d2 = c2 & Wl, u2 = !!(c2 & Gl), g2 = o2.patternFill && !l3.missingFile, p2 = o2.patternStroke && !l3.missingFile;
        let f2;
        if ((l3.disableFontFace || u2 || g2 || p2) && !l3.missingFile && (f2 = l3.getPathGenerator(this.commonObjs, t2)), f2 && (l3.disableFontFace || g2 || p2)) {
          let t3;
          if (r2.save(), r2.translate(i2, a2), r2.scale(h2, -h2), this.dependencyTracker?.recordCharacterBBox(e2, r2, l3), d2 === Hl || d2 === Xl)
            if (n2) {
              t3 = r2.getTransform(), r2.setTransform(...n2);
              const e3 = this.#ns(f2, t3, n2);
              r2.fill(e3);
            } else
              r2.fill(f2);
          if (d2 === ql || d2 === Xl)
            if (s2) {
              t3 ||= r2.getTransform(), r2.setTransform(...s2);
              const { a: e3, b: i3, c: a3, d: n3 } = t3, o3 = Util.inverseTransform(s2), l4 = Util.transform([e3, i3, a3, n3, 0, 0], o3);
              Util.singularValueDecompose2dScale(l4, Wc), r2.lineWidth *= Math.max(Wc[0], Wc[1]) / h2, r2.stroke(this.#ns(f2, t3, s2));
            } else
              r2.lineWidth /= h2, r2.stroke(f2);
          r2.restore();
        } else
          d2 !== Hl && d2 !== Xl || (r2.fillText(t2, i2, a2), this.dependencyTracker?.recordCharacterBBox(e2, r2, l3, h2, i2, a2, () => r2.measureText(t2))), d2 !== ql && d2 !== Xl || (this.dependencyTracker && this.dependencyTracker?.recordCharacterBBox(e2, r2, l3, h2, i2, a2, () => r2.measureText(t2)).recordDependencies(e2, Oc), r2.strokeText(t2, i2, a2));
        if (u2) {
          (this.pendingTextPaths ||= []).push({ transform: getCurrentTransform(r2), x: i2, y: a2, fontSize: h2, path: f2 }), this.dependencyTracker?.recordCharacterBBox(e2, r2, l3, h2, i2, a2);
        }
      }
      get isFontSubpixelAAEnabled() {
        const { context: e2 } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10);
        e2.scale(1.5, 1), e2.fillText("I", 0, 10);
        const t2 = e2.getImageData(0, 0, 10, 10).data;
        let i2 = false;
        for (let e3 = 3; e3 < t2.length; e3 += 4)
          if (t2[e3] > 0 && t2[e3] < 255) {
            i2 = true;
            break;
          }
        return shadow(this, "isFontSubpixelAAEnabled", i2);
      }
      showText(e2, t2) {
        this.dependencyTracker && (this.dependencyTracker.recordDependencies(e2, Bc).copyDependenciesFromIncrementalOperation(e2, "sameLineText").resetBBox(e2), this.current.textRenderingMode & Gl && this.dependencyTracker.recordFutureForcedDependency("textClip", e2).inheritPendingDependenciesAsFutureForcedDependencies());
        const i2 = this.current, a2 = i2.font;
        if (a2.isType3Font)
          return this.showType3Text(e2, t2), void this.dependencyTracker?.recordOperation(e2).recordIncrementalData("sameLineText", e2);
        const n2 = i2.fontSize;
        if (0 === n2)
          return void this.dependencyTracker?.recordOperation(e2);
        const s2 = this.ctx, r2 = i2.fontSizeScale, o2 = i2.charSpacing, l3 = i2.wordSpacing, c2 = i2.fontDirection, h2 = i2.textHScale * c2, d2 = t2.length, u2 = a2.vertical, g2 = u2 ? 1 : -1, p2 = a2.defaultVMetrics, f2 = n2 * i2.fontMatrix[0], m2 = i2.textRenderingMode === Hl && !a2.disableFontFace && !i2.patternFill;
        let b2, y2;
        if (s2.save(), i2.textMatrix && s2.transform(...i2.textMatrix), s2.translate(i2.x, i2.y + i2.textRise), c2 > 0 ? s2.scale(h2, -1) : s2.scale(h2, 1), i2.patternFill) {
          s2.save();
          const e3 = i2.fillColor.getPattern(s2, this, getCurrentTransformInverse(s2), Uc);
          b2 = getCurrentTransform(s2), s2.restore(), s2.fillStyle = e3;
        }
        if (i2.patternStroke) {
          s2.save();
          const e3 = i2.strokeColor.getPattern(s2, this, getCurrentTransformInverse(s2), jc);
          y2 = getCurrentTransform(s2), s2.restore(), s2.strokeStyle = e3;
        }
        let w2 = i2.lineWidth;
        const x2 = i2.textMatrixScale;
        if (0 === x2 || 0 === w2) {
          const e3 = i2.textRenderingMode & Wl;
          e3 !== ql && e3 !== Xl || (w2 = this.getSinglePixelWidth());
        } else
          w2 /= x2;
        if (1 !== r2 && (s2.scale(r2, r2), w2 /= r2), s2.lineWidth = w2, a2.isInvalidPDFjsFont) {
          const a3 = [];
          let n3 = 0;
          for (const e3 of t2)
            a3.push(e3.unicode), n3 += e3.width;
          const r3 = a3.join("");
          if (s2.fillText(r3, 0, 0), null !== this.dependencyTracker) {
            const t3 = s2.measureText(r3);
            this.dependencyTracker.recordBBox(e2, this.ctx, -t3.actualBoundingBoxLeft, t3.actualBoundingBoxRight, -t3.actualBoundingBoxAscent, t3.actualBoundingBoxDescent).recordOperation(e2).recordIncrementalData("sameLineText", e2);
          }
          return i2.x += n3 * f2 * h2, s2.restore(), void this.compose();
        }
        let S2, v2 = 0;
        for (S2 = 0; S2 < d2; ++S2) {
          const i3 = t2[S2];
          if ("number" == typeof i3) {
            v2 += g2 * i3 * n2 / 1e3;
            continue;
          }
          let h3 = false;
          const d3 = (i3.isSpace ? l3 : 0) + o2, w3 = i3.fontChar, x3 = i3.accent;
          let C2, k2, T2, F2 = i3.width;
          if (u2) {
            const e3 = i3.vmetric || p2, t3 = -(i3.vmetric ? e3[1] : 0.5 * F2) * f2, a3 = e3[2] * f2;
            F2 = e3 ? -e3[0] : F2, C2 = t3 / r2, k2 = (v2 + a3) / r2;
          } else
            C2 = v2 / r2, k2 = 0;
          if (a2.remeasure && F2 > 0) {
            T2 = s2.measureText(w3);
            const e3 = 1e3 * T2.width / n2 * r2;
            if (F2 < e3 && this.isFontSubpixelAAEnabled) {
              const t3 = F2 / e3;
              h3 = true, s2.save(), s2.scale(t3, 1), C2 /= t3;
            } else
              F2 !== e3 && (C2 += (F2 - e3) / 2e3 * n2 / r2);
          }
          if (this.contentVisible && (i3.isInFont || a2.missingFile)) {
            if (m2 && !x3)
              s2.fillText(w3, C2, k2), this.dependencyTracker?.recordCharacterBBox(e2, s2, T2 ? { bbox: null } : a2, n2 / r2, C2, k2, () => T2 ?? s2.measureText(w3));
            else if (this.paintChar(e2, w3, C2, k2, b2, y2), x3) {
              const t3 = C2 + n2 * x3.offset.x / r2, i4 = k2 - n2 * x3.offset.y / r2;
              this.paintChar(e2, x3.fontChar, t3, i4, b2, y2);
            }
          }
          v2 += u2 ? F2 * f2 - d3 * c2 : F2 * f2 + d3 * c2, h3 && s2.restore();
        }
        u2 ? i2.y -= v2 : i2.x += v2 * h2, s2.restore(), this.compose(), this.dependencyTracker?.recordOperation(e2).recordIncrementalData("sameLineText", e2);
      }
      showType3Text(e2, t2) {
        const i2 = this.ctx, a2 = this.current, n2 = a2.font, s2 = a2.fontSize, r2 = a2.fontDirection, o2 = n2.vertical ? 1 : -1, l3 = a2.charSpacing, c2 = a2.wordSpacing, h2 = a2.textHScale * r2, d2 = a2.fontMatrix || kl, u2 = t2.length;
        let g2, p2, f2, m2;
        if (a2.textRenderingMode === zl || 0 === s2)
          return;
        this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null, i2.save(), a2.textMatrix && i2.transform(...a2.textMatrix), i2.translate(a2.x, a2.y + a2.textRise), i2.scale(h2, r2);
        const b2 = this.dependencyTracker;
        for (this.dependencyTracker = b2 ? new CanvasNestedDependencyTracker(b2, e2) : null, g2 = 0; g2 < u2; ++g2) {
          if (p2 = t2[g2], "number" == typeof p2) {
            m2 = o2 * p2 * s2 / 1e3, this.ctx.translate(m2, 0), a2.x += m2 * h2;
            continue;
          }
          const e3 = (p2.isSpace ? c2 : 0) + l3, r3 = n2.charProcOperatorList[p2.operatorListId];
          r3 ? this.contentVisible && (this.save(), i2.scale(s2, s2), i2.transform(...d2), this.executeOperatorList(r3), this.restore()) : warn3(`Type3 character "${p2.operatorListId}" is not available.`);
          const u3 = [p2.width, 0];
          Util.applyTransform(u3, d2), f2 = u3[0] * s2 + e3, i2.translate(f2, 0), a2.x += f2 * h2;
        }
        i2.restore(), b2 && (this.dependencyTracker.recordNestedDependencies(), this.dependencyTracker = b2);
      }
      setCharWidth(e2, t2, i2) {
      }
      setCharWidthAndBounds(e2, t2, i2, a2, n2, s2, r2) {
        const o2 = new Path2D();
        o2.rect(a2, n2, s2 - a2, r2 - n2), this.ctx.clip(o2), this.dependencyTracker?.recordBBox(e2, this.ctx, a2, s2, n2, r2).recordClipBox(e2, this.ctx, a2, s2, n2, r2), this.endPath(e2);
      }
      getColorN_Pattern(e2, t2) {
        let i2;
        if ("TilingPattern" === t2[0]) {
          const a2 = this.baseTransform || getCurrentTransform(this.ctx), n2 = { createCanvasGraphics: (t3) => new CanvasGraphics(t3, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, { optionalContentConfig: this.optionalContentConfig, markedContentStack: this.markedContentStack }, void 0, void 0, this.dependencyTracker ? new CanvasNestedDependencyTracker(this.dependencyTracker, e2) : null) };
          i2 = new TilingPattern(t2, this.ctx, n2, a2);
        } else
          i2 = this._getPattern(e2, t2[1], t2[2]);
        return i2;
      }
      setStrokeColorN(e2, ...t2) {
        this.dependencyTracker?.recordSimpleData("strokeColor", e2), this.current.strokeColor = this.getColorN_Pattern(e2, t2), this.current.patternStroke = true;
      }
      setFillColorN(e2, ...t2) {
        this.dependencyTracker?.recordSimpleData("fillColor", e2), this.current.fillColor = this.getColorN_Pattern(e2, t2), this.current.patternFill = true;
      }
      setStrokeRGBColor(e2, t2) {
        this.dependencyTracker?.recordSimpleData("strokeColor", e2), this.ctx.strokeStyle = this.current.strokeColor = t2, this.current.patternStroke = false;
      }
      setStrokeTransparent(e2) {
        this.dependencyTracker?.recordSimpleData("strokeColor", e2), this.ctx.strokeStyle = this.current.strokeColor = "transparent", this.current.patternStroke = false;
      }
      setFillRGBColor(e2, t2) {
        this.dependencyTracker?.recordSimpleData("fillColor", e2), this.ctx.fillStyle = this.current.fillColor = t2, this.current.patternFill = false;
      }
      setFillTransparent(e2) {
        this.dependencyTracker?.recordSimpleData("fillColor", e2), this.ctx.fillStyle = this.current.fillColor = "transparent", this.current.patternFill = false;
      }
      _getPattern(e2, t2, i2 = null) {
        let a2;
        return this.cachedPatterns.has(t2) ? a2 = this.cachedPatterns.get(t2) : (a2 = function(e3) {
          switch (e3[0]) {
            case "RadialAxial":
              return new RadialAxialShadingPattern(e3);
            case "Mesh":
              return new MeshShadingPattern(e3);
            case "Dummy":
              return new DummyShadingPattern();
          }
          throw new Error(`Unknown IR type: ${e3[0]}`);
        }(this.getObject(e2, t2)), this.cachedPatterns.set(t2, a2)), i2 && (a2.matrix = i2), a2;
      }
      shadingFill(e2, t2) {
        if (!this.contentVisible)
          return;
        const i2 = this.ctx;
        this.save(e2);
        const a2 = this._getPattern(e2, t2);
        i2.fillStyle = a2.getPattern(i2, this, getCurrentTransformInverse(i2), $c);
        const n2 = getCurrentTransformInverse(i2);
        if (n2) {
          const { width: e3, height: t3 } = i2.canvas, a3 = Gc.slice();
          Util.axialAlignedBoundingBox([0, 0, e3, t3], n2, a3);
          const [s2, r2, o2, l3] = a3;
          this.ctx.fillRect(s2, r2, o2 - s2, l3 - r2);
        } else
          this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
        this.dependencyTracker?.resetBBox(e2).recordFullPageBBox(e2).recordDependencies(e2, Nc).recordDependencies(e2, _c2).recordOperation(e2), this.compose(this.current.getClippedPathBoundingBox()), this.restore(e2);
      }
      beginInlineImage() {
        unreachable("Should not call beginInlineImage");
      }
      beginImageData() {
        unreachable("Should not call beginImageData");
      }
      paintFormXObjectBegin(e2, t2, i2) {
        if (this.contentVisible && (this.save(e2), this.baseTransformStack.push(this.baseTransform), t2 && this.transform(e2, ...t2), this.baseTransform = getCurrentTransform(this.ctx), i2)) {
          Util.axialAlignedBoundingBox(i2, this.baseTransform, this.current.minMax);
          const [t3, a2, n2, s2] = i2, r2 = new Path2D();
          r2.rect(t3, a2, n2 - t3, s2 - a2), this.ctx.clip(r2), this.dependencyTracker?.recordClipBox(e2, this.ctx, t3, n2, a2, s2), this.endPath(e2);
        }
      }
      paintFormXObjectEnd(e2) {
        this.contentVisible && (this.restore(e2), this.baseTransform = this.baseTransformStack.pop());
      }
      beginGroup(e2, t2) {
        if (!this.contentVisible)
          return;
        this.save(e2), this.inSMaskMode && (this.endSMaskMode(), this.current.activeSMask = null);
        const i2 = this.ctx;
        t2.isolated || info3("TODO: Support non-isolated groups."), t2.knockout && warn3("Knockout groups not supported.");
        const a2 = getCurrentTransform(i2);
        if (t2.matrix && i2.transform(...t2.matrix), !t2.bbox)
          throw new Error("Bounding box is required.");
        let n2 = Gc.slice();
        Util.axialAlignedBoundingBox(t2.bbox, getCurrentTransform(i2), n2);
        const s2 = [0, 0, i2.canvas.width, i2.canvas.height];
        n2 = Util.intersect(n2, s2) || [0, 0, 0, 0];
        const r2 = Math.floor(n2[0]), o2 = Math.floor(n2[1]), l3 = Math.max(Math.ceil(n2[2]) - r2, 1), c2 = Math.max(Math.ceil(n2[3]) - o2, 1);
        this.current.startNewPathAndClipBox([0, 0, l3, c2]);
        let h2 = "groupAt" + this.groupLevel;
        t2.smask && (h2 += "_smask_" + this.smaskCounter++ % 2);
        const d2 = this.cachedCanvases.getCanvas(h2, l3, c2), u2 = d2.context;
        u2.translate(-r2, -o2), u2.transform(...a2);
        let g2 = new Path2D();
        const [p2, f2, m2, b2] = t2.bbox;
        if (g2.rect(p2, f2, m2 - p2, b2 - f2), t2.matrix) {
          const e3 = new Path2D();
          e3.addPath(g2, new DOMMatrix(t2.matrix)), g2 = e3;
        }
        u2.clip(g2), t2.smask && this.smaskStack.push({ canvas: d2.canvas, context: u2, offsetX: r2, offsetY: o2, subtype: t2.smask.subtype, backdrop: t2.smask.backdrop, transferMap: t2.smask.transferMap || null, startTransformInverse: null }), t2.smask && !this.dependencyTracker || (i2.setTransform(1, 0, 0, 1, 0, 0), i2.translate(r2, o2), i2.save()), copyCtxState(i2, u2), this.ctx = u2, this.dependencyTracker?.inheritSimpleDataAsFutureForcedDependencies(["fillAlpha", "strokeAlpha", "globalCompositeOperation"]).pushBaseTransform(i2), this.setGState(e2, [["BM", "source-over"], ["ca", 1], ["CA", 1]]), this.groupStack.push(i2), this.groupLevel++;
      }
      endGroup(e2, t2) {
        if (!this.contentVisible)
          return;
        this.groupLevel--;
        const i2 = this.ctx, a2 = this.groupStack.pop();
        if (this.ctx = a2, this.ctx.imageSmoothingEnabled = false, this.dependencyTracker?.popBaseTransform(), t2.smask)
          this.tempSMask = this.smaskStack.pop(), this.restore(e2), this.dependencyTracker && this.ctx.restore();
        else {
          this.ctx.restore();
          const t3 = getCurrentTransform(this.ctx);
          this.restore(e2), this.ctx.save(), this.ctx.setTransform(...t3);
          const a3 = Gc.slice();
          Util.axialAlignedBoundingBox([0, 0, i2.canvas.width, i2.canvas.height], t3, a3), this.ctx.drawImage(i2.canvas, 0, 0), this.ctx.restore(), this.compose(a3);
        }
      }
      beginAnnotation(e2, t2, i2, a2, n2, s2) {
        if (this.#is(), resetCtxToDefault(this.ctx), this.ctx.save(), this.save(e2), this.baseTransform && this.ctx.setTransform(...this.baseTransform), i2) {
          const n3 = i2[2] - i2[0], r2 = i2[3] - i2[1];
          if (s2 && this.annotationCanvasMap) {
            (a2 = a2.slice())[4] -= i2[0], a2[5] -= i2[1], (i2 = i2.slice())[0] = i2[1] = 0, i2[2] = n3, i2[3] = r2, Util.singularValueDecompose2dScale(getCurrentTransform(this.ctx), Wc);
            const { viewportScale: e3 } = this, s3 = Math.ceil(n3 * this.outputScaleX * e3), o2 = Math.ceil(r2 * this.outputScaleY * e3);
            this.annotationCanvas = this.canvasFactory.create(s3, o2);
            const { canvas: l3, context: c2 } = this.annotationCanvas;
            this.annotationCanvasMap.set(t2, l3), this.annotationCanvas.savedCtx = this.ctx, this.ctx = c2, this.ctx.save(), this.ctx.setTransform(Wc[0], 0, 0, -Wc[1], 0, r2 * Wc[1]), resetCtxToDefault(this.ctx);
          } else {
            resetCtxToDefault(this.ctx), this.endPath(e2);
            const t3 = new Path2D();
            t3.rect(i2[0], i2[1], n3, r2), this.ctx.clip(t3);
          }
        }
        this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height), this.transform(e2, ...a2), this.transform(e2, ...n2);
      }
      endAnnotation(e2) {
        this.annotationCanvas && (this.ctx.restore(), this.#as(), this.ctx = this.annotationCanvas.savedCtx, delete this.annotationCanvas.savedCtx, delete this.annotationCanvas);
      }
      paintImageMaskXObject(e2, t2) {
        if (!this.contentVisible)
          return;
        const i2 = t2.count;
        (t2 = this.getObject(e2, t2.data, t2)).count = i2;
        const a2 = this.ctx, n2 = this._createMaskCanvas(e2, t2), s2 = n2.canvas;
        a2.save(), a2.setTransform(1, 0, 0, 1, 0, 0), a2.drawImage(s2, n2.offsetX, n2.offsetY), this.dependencyTracker?.resetBBox(e2).recordBBox(e2, this.ctx, n2.offsetX, n2.offsetX + s2.width, n2.offsetY, n2.offsetY + s2.height).recordOperation(e2), a2.restore(), this.compose();
      }
      paintImageMaskXObjectRepeat(e2, t2, i2, a2 = 0, n2 = 0, s2, r2) {
        if (!this.contentVisible)
          return;
        t2 = this.getObject(e2, t2.data, t2);
        const o2 = this.ctx;
        o2.save();
        const l3 = getCurrentTransform(o2);
        o2.transform(i2, a2, n2, s2, 0, 0);
        const c2 = this._createMaskCanvas(e2, t2);
        o2.setTransform(1, 0, 0, 1, c2.offsetX - l3[4], c2.offsetY - l3[5]), this.dependencyTracker?.resetBBox(e2);
        for (let t3 = 0, h2 = r2.length; t3 < h2; t3 += 2) {
          const h3 = Util.transform(l3, [i2, a2, n2, s2, r2[t3], r2[t3 + 1]]);
          o2.drawImage(c2.canvas, h3[4], h3[5]), this.dependencyTracker?.recordBBox(e2, this.ctx, h3[4], h3[4] + c2.canvas.width, h3[5], h3[5] + c2.canvas.height);
        }
        o2.restore(), this.compose(), this.dependencyTracker?.recordOperation(e2);
      }
      paintImageMaskXObjectGroup(e2, t2) {
        if (!this.contentVisible)
          return;
        const i2 = this.ctx, a2 = this.current.fillColor, n2 = this.current.patternFill;
        this.dependencyTracker?.resetBBox(e2).recordDependencies(e2, Lc);
        for (const s2 of t2) {
          const { data: t3, width: r2, height: o2, transform: l3 } = s2, c2 = this.cachedCanvases.getCanvas("maskCanvas", r2, o2), h2 = c2.context;
          h2.save();
          putBinaryImageMask(h2, this.getObject(e2, t3, s2)), h2.globalCompositeOperation = "source-in", h2.fillStyle = n2 ? a2.getPattern(h2, this, getCurrentTransformInverse(i2), Uc) : a2, h2.fillRect(0, 0, r2, o2), h2.restore(), i2.save(), i2.transform(...l3), i2.scale(1, -1), drawImageAtIntegerCoords(i2, c2.canvas, 0, 0, r2, o2, 0, -1, 1, 1), this.dependencyTracker?.recordBBox(e2, i2, 0, r2, 0, o2), i2.restore();
        }
        this.compose(), this.dependencyTracker?.recordOperation(e2);
      }
      paintImageXObject(e2, t2) {
        if (!this.contentVisible)
          return;
        const i2 = this.getObject(e2, t2);
        i2 ? this.paintInlineImageXObject(e2, i2) : warn3("Dependent image isn't ready yet");
      }
      paintImageXObjectRepeat(e2, t2, i2, a2, n2) {
        if (!this.contentVisible)
          return;
        const s2 = this.getObject(e2, t2);
        if (!s2)
          return void warn3("Dependent image isn't ready yet");
        const r2 = s2.width, o2 = s2.height, l3 = [];
        for (let e3 = 0, t3 = n2.length; e3 < t3; e3 += 2)
          l3.push({ transform: [i2, 0, 0, a2, n2[e3], n2[e3 + 1]], x: 0, y: 0, w: r2, h: o2 });
        this.paintInlineImageXObjectGroup(e2, s2, l3);
      }
      applyTransferMapsToCanvas(e2) {
        return "none" !== this.current.transferMaps && (e2.filter = this.current.transferMaps, e2.drawImage(e2.canvas, 0, 0), e2.filter = "none"), e2.canvas;
      }
      applyTransferMapsToBitmap(e2) {
        if ("none" === this.current.transferMaps)
          return e2.bitmap;
        const { bitmap: t2, width: i2, height: a2 } = e2, n2 = this.cachedCanvases.getCanvas("inlineImage", i2, a2), s2 = n2.context;
        return s2.filter = this.current.transferMaps, s2.drawImage(t2, 0, 0), s2.filter = "none", n2.canvas;
      }
      paintInlineImageXObject(e2, t2) {
        if (!this.contentVisible)
          return;
        const i2 = t2.width, a2 = t2.height, n2 = this.ctx;
        this.save(e2);
        const { filter: s2 } = n2;
        let r2;
        if ("none" !== s2 && "" !== s2 && (n2.filter = "none"), n2.scale(1 / i2, -1 / a2), t2.bitmap)
          r2 = this.applyTransferMapsToBitmap(t2);
        else if ("function" == typeof HTMLElement && t2 instanceof HTMLElement || !t2.data)
          r2 = t2;
        else {
          const e3 = this.cachedCanvases.getCanvas("inlineImage", i2, a2).context;
          putBinaryImageData(e3, t2), r2 = this.applyTransferMapsToCanvas(e3);
        }
        const o2 = this._scaleImage(r2, getCurrentTransformInverse(n2));
        n2.imageSmoothingEnabled = getImageSmoothingEnabled(getCurrentTransform(n2), t2.interpolate), this.dependencyTracker?.resetBBox(e2).recordBBox(e2, n2, 0, i2, -a2, 0).recordDependencies(e2, Pc).recordOperation(e2), drawImageAtIntegerCoords(n2, o2.img, 0, 0, o2.paintWidth, o2.paintHeight, 0, -a2, i2, a2), this.compose(), this.restore(e2);
      }
      paintInlineImageXObjectGroup(e2, t2, i2) {
        if (!this.contentVisible)
          return;
        const a2 = this.ctx;
        let n2;
        if (t2.bitmap)
          n2 = t2.bitmap;
        else {
          const e3 = t2.width, i3 = t2.height, a3 = this.cachedCanvases.getCanvas("inlineImage", e3, i3).context;
          putBinaryImageData(a3, t2), n2 = this.applyTransferMapsToCanvas(a3);
        }
        this.dependencyTracker?.resetBBox(e2);
        for (const t3 of i2)
          a2.save(), a2.transform(...t3.transform), a2.scale(1, -1), drawImageAtIntegerCoords(a2, n2, t3.x, t3.y, t3.w, t3.h, 0, -1, 1, 1), this.dependencyTracker?.recordBBox(e2, a2, 0, 1, -1, 0), a2.restore();
        this.dependencyTracker?.recordOperation(e2), this.compose();
      }
      paintSolidColorImageMask(e2) {
        this.contentVisible && (this.dependencyTracker?.resetBBox(e2).recordBBox(e2, this.ctx, 0, 1, 0, 1).recordDependencies(e2, _c2).recordOperation(e2), this.ctx.fillRect(0, 0, 1, 1), this.compose());
      }
      markPoint(e2, t2) {
      }
      markPointProps(e2, t2, i2) {
      }
      beginMarkedContent(e2, t2) {
        this.dependencyTracker?.beginMarkedContent(e2), this.markedContentStack.push({ visible: true });
      }
      beginMarkedContentProps(e2, t2, i2) {
        this.dependencyTracker?.beginMarkedContent(e2), "OC" === t2 ? this.markedContentStack.push({ visible: this.optionalContentConfig.isVisible(i2) }) : this.markedContentStack.push({ visible: true }), this.contentVisible = this.isContentVisible();
      }
      endMarkedContent(e2) {
        this.dependencyTracker?.endMarkedContent(e2), this.markedContentStack.pop(), this.contentVisible = this.isContentVisible();
      }
      beginCompat(e2) {
      }
      endCompat(e2) {
      }
      consumePath(e2, t2, i2) {
        const a2 = this.current.isEmptyClip();
        this.pendingClip && this.current.updateClipFromPath(), this.pendingClip || this.compose(i2);
        const n2 = this.ctx;
        this.pendingClip ? (a2 || (this.pendingClip === Jc ? n2.clip(t2, "evenodd") : n2.clip(t2)), this.pendingClip = null, this.dependencyTracker?.bboxToClipBoxDropOperation(e2).recordFutureForcedDependency("clipPath", e2)) : this.dependencyTracker?.recordOperation(e2), this.current.startNewPathAndClipBox(this.current.clipBox);
      }
      getSinglePixelWidth() {
        if (!this._cachedGetSinglePixelWidth) {
          const e2 = getCurrentTransform(this.ctx);
          if (0 === e2[1] && 0 === e2[2])
            this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(e2[0]), Math.abs(e2[3]));
          else {
            const t2 = Math.abs(e2[0] * e2[3] - e2[2] * e2[1]), i2 = Math.hypot(e2[0], e2[2]), a2 = Math.hypot(e2[1], e2[3]);
            this._cachedGetSinglePixelWidth = Math.max(i2, a2) / t2;
          }
        }
        return this._cachedGetSinglePixelWidth;
      }
      getScaleForStroking() {
        if (-1 === this._cachedScaleForStroking[0]) {
          const { lineWidth: e2 } = this.current, { a: t2, b: i2, c: a2, d: n2 } = this.ctx.getTransform();
          let s2, r2;
          if (0 === i2 && 0 === a2) {
            const i3 = Math.abs(t2), a3 = Math.abs(n2);
            if (i3 === a3)
              if (0 === e2)
                s2 = r2 = 1 / i3;
              else {
                const t3 = i3 * e2;
                s2 = r2 = t3 < 1 ? 1 / t3 : 1;
              }
            else if (0 === e2)
              s2 = 1 / i3, r2 = 1 / a3;
            else {
              const t3 = i3 * e2, n3 = a3 * e2;
              s2 = t3 < 1 ? 1 / t3 : 1, r2 = n3 < 1 ? 1 / n3 : 1;
            }
          } else {
            const o2 = Math.abs(t2 * n2 - i2 * a2), l3 = Math.hypot(t2, i2), c2 = Math.hypot(a2, n2);
            if (0 === e2)
              s2 = c2 / o2, r2 = l3 / o2;
            else {
              const t3 = e2 * o2;
              s2 = c2 > t3 ? c2 / t3 : 1, r2 = l3 > t3 ? l3 / t3 : 1;
            }
          }
          this._cachedScaleForStroking[0] = s2, this._cachedScaleForStroking[1] = r2;
        }
        return this._cachedScaleForStroking;
      }
      rescaleAndStroke(e2, t2) {
        const { ctx: i2, current: { lineWidth: a2 } } = this, [n2, s2] = this.getScaleForStroking();
        if (n2 === s2)
          return i2.lineWidth = (a2 || 1) * n2, void i2.stroke(e2);
        const r2 = i2.getLineDash();
        t2 && i2.save(), i2.scale(n2, s2), zc.a = 1 / n2, zc.d = 1 / s2;
        const o2 = new Path2D();
        if (o2.addPath(e2, zc), r2.length > 0) {
          const e3 = Math.max(n2, s2);
          i2.setLineDash(r2.map((t3) => t3 / e3)), i2.lineDashOffset /= e3;
        }
        i2.lineWidth = a2 || 1, i2.stroke(o2), t2 && i2.restore();
      }
      isContentVisible() {
        for (let e2 = this.markedContentStack.length - 1; e2 >= 0; e2--)
          if (!this.markedContentStack[e2].visible)
            return false;
        return true;
      }
    };
    __name(CanvasGraphics, "CanvasGraphics");
    for (const e2 in ic)
      void 0 !== CanvasGraphics.prototype[e2] && (CanvasGraphics.prototype[ic[e2]] = CanvasGraphics.prototype[e2]);
    GlobalWorkerOptions = class {
      static get workerPort() {
        return __privateGet(this, _ss);
      }
      static set workerPort(e2) {
        if (!("undefined" != typeof Worker && e2 instanceof Worker) && null !== e2)
          throw new Error("Invalid `workerPort` type.");
        __privateSet(this, _ss, e2);
      }
      static get workerSrc() {
        return __privateGet(this, _rs);
      }
      static set workerSrc(e2) {
        if ("string" != typeof e2)
          throw new Error("Invalid `workerSrc` type.");
        __privateSet(this, _rs, e2);
      }
    };
    __name(GlobalWorkerOptions, "GlobalWorkerOptions");
    _ss = new WeakMap();
    _rs = new WeakMap();
    __privateAdd(GlobalWorkerOptions, _ss, null);
    __privateAdd(GlobalWorkerOptions, _rs, "");
    Metadata = class {
      #os;
      #ls;
      constructor({ parsedData: e2, rawData: t2 }) {
        this.#os = e2, this.#ls = t2;
      }
      getRaw() {
        return this.#ls;
      }
      get(e2) {
        return this.#os.get(e2) ?? null;
      }
      [Symbol.iterator]() {
        return this.#os.entries();
      }
    };
    __name(Metadata, "Metadata");
    Zc = Symbol("INTERNAL");
    OptionalContentGroup = class {
      #cs = false;
      #hs = false;
      #ds = false;
      #us = true;
      constructor(e2, { name: t2, intent: i2, usage: a2, rbGroups: n2 }) {
        this.#cs = !!(e2 & Fl), this.#hs = !!(e2 & Ml), this.name = t2, this.intent = i2, this.usage = a2, this.rbGroups = n2;
      }
      get visible() {
        if (this.#ds)
          return this.#us;
        if (!this.#us)
          return false;
        const { print: e2, view: t2 } = this.usage;
        return this.#cs ? "OFF" !== t2?.viewState : !this.#hs || "OFF" !== e2?.printState;
      }
      _setVisible(e2, t2, i2 = false) {
        e2 !== Zc && unreachable("Internal method `_setVisible` called."), this.#ds = i2, this.#us = t2;
      }
    };
    __name(OptionalContentGroup, "OptionalContentGroup");
    OptionalContentConfig = class {
      #gs = null;
      #ps = /* @__PURE__ */ new Map();
      #fs = null;
      #ms = null;
      constructor(e2, t2 = Fl) {
        if (this.renderingIntent = t2, this.name = null, this.creator = null, null !== e2) {
          this.name = e2.name, this.creator = e2.creator, this.#ms = e2.order;
          for (const i2 of e2.groups)
            this.#ps.set(i2.id, new OptionalContentGroup(t2, i2));
          if ("OFF" === e2.baseState)
            for (const e3 of this.#ps.values())
              e3._setVisible(Zc, false);
          for (const t3 of e2.on)
            this.#ps.get(t3)._setVisible(Zc, true);
          for (const t3 of e2.off)
            this.#ps.get(t3)._setVisible(Zc, false);
          this.#fs = this.getHash();
        }
      }
      #bs(e2) {
        const t2 = e2.length;
        if (t2 < 2)
          return true;
        const i2 = e2[0];
        for (let a2 = 1; a2 < t2; a2++) {
          const t3 = e2[a2];
          let n2;
          if (Array.isArray(t3))
            n2 = this.#bs(t3);
          else {
            if (!this.#ps.has(t3))
              return warn3(`Optional content group not found: ${t3}`), true;
            n2 = this.#ps.get(t3).visible;
          }
          switch (i2) {
            case "And":
              if (!n2)
                return false;
              break;
            case "Or":
              if (n2)
                return true;
              break;
            case "Not":
              return !n2;
            default:
              return true;
          }
        }
        return "And" === i2;
      }
      isVisible(e2) {
        if (0 === this.#ps.size)
          return true;
        if (!e2)
          return info3("Optional content group not defined."), true;
        if ("OCG" === e2.type)
          return this.#ps.has(e2.id) ? this.#ps.get(e2.id).visible : (warn3(`Optional content group not found: ${e2.id}`), true);
        if ("OCMD" === e2.type) {
          if (e2.expression)
            return this.#bs(e2.expression);
          if (!e2.policy || "AnyOn" === e2.policy) {
            for (const t2 of e2.ids) {
              if (!this.#ps.has(t2))
                return warn3(`Optional content group not found: ${t2}`), true;
              if (this.#ps.get(t2).visible)
                return true;
            }
            return false;
          }
          if ("AllOn" === e2.policy) {
            for (const t2 of e2.ids) {
              if (!this.#ps.has(t2))
                return warn3(`Optional content group not found: ${t2}`), true;
              if (!this.#ps.get(t2).visible)
                return false;
            }
            return true;
          }
          if ("AnyOff" === e2.policy) {
            for (const t2 of e2.ids) {
              if (!this.#ps.has(t2))
                return warn3(`Optional content group not found: ${t2}`), true;
              if (!this.#ps.get(t2).visible)
                return true;
            }
            return false;
          }
          if ("AllOff" === e2.policy) {
            for (const t2 of e2.ids) {
              if (!this.#ps.has(t2))
                return warn3(`Optional content group not found: ${t2}`), true;
              if (this.#ps.get(t2).visible)
                return false;
            }
            return true;
          }
          return warn3(`Unknown optional content policy ${e2.policy}.`), true;
        }
        return warn3(`Unknown group type ${e2.type}.`), true;
      }
      setVisibility(e2, t2 = true, i2 = true) {
        const a2 = this.#ps.get(e2);
        if (a2) {
          if (i2 && t2 && a2.rbGroups.length)
            for (const t3 of a2.rbGroups)
              for (const i3 of t3)
                i3 !== e2 && this.#ps.get(i3)?._setVisible(Zc, false, true);
          a2._setVisible(Zc, !!t2, true), this.#gs = null;
        } else
          warn3(`Optional content group not found: ${e2}`);
      }
      setOCGState({ state: e2, preserveRB: t2 }) {
        let i2;
        for (const a2 of e2) {
          switch (a2) {
            case "ON":
            case "OFF":
            case "Toggle":
              i2 = a2;
              continue;
          }
          const e3 = this.#ps.get(a2);
          if (e3)
            switch (i2) {
              case "ON":
                this.setVisibility(a2, true, t2);
                break;
              case "OFF":
                this.setVisibility(a2, false, t2);
                break;
              case "Toggle":
                this.setVisibility(a2, !e3.visible, t2);
            }
        }
        this.#gs = null;
      }
      get hasInitialVisibility() {
        return null === this.#fs || this.getHash() === this.#fs;
      }
      getOrder() {
        return this.#ps.size ? this.#ms ? this.#ms.slice() : [...this.#ps.keys()] : null;
      }
      getGroup(e2) {
        return this.#ps.get(e2) || null;
      }
      getHash() {
        if (null !== this.#gs)
          return this.#gs;
        const e2 = new MurmurHash3_64();
        for (const [t2, i2] of this.#ps)
          e2.update(`${t2}:${i2.visible}`);
        return this.#gs = e2.hexdigest();
      }
      [Symbol.iterator]() {
        return this.#ps.entries();
      }
    };
    __name(OptionalContentConfig, "OptionalContentConfig");
    PDFDataTransportStream = class {
      constructor(e2, { disableRange: t2 = false, disableStream: i2 = false }) {
        assert3(e2, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.');
        const { length: a2, initialData: n2, progressiveDone: s2, contentDispositionFilename: r2 } = e2;
        if (this._queuedChunks = [], this._progressiveDone = s2, this._contentDispositionFilename = r2, n2?.length > 0) {
          const e3 = n2 instanceof Uint8Array && n2.byteLength === n2.buffer.byteLength ? n2.buffer : new Uint8Array(n2).buffer;
          this._queuedChunks.push(e3);
        }
        this._pdfDataRangeTransport = e2, this._isStreamingSupported = !i2, this._isRangeSupported = !t2, this._contentLength = a2, this._fullRequestReader = null, this._rangeReaders = [], e2.addRangeListener((e3, t3) => {
          this._onReceiveData({ begin: e3, chunk: t3 });
        }), e2.addProgressListener((e3, t3) => {
          this._onProgress({ loaded: e3, total: t3 });
        }), e2.addProgressiveReadListener((e3) => {
          this._onReceiveData({ chunk: e3 });
        }), e2.addProgressiveDoneListener(() => {
          this._onProgressiveDone();
        }), e2.transportReady();
      }
      _onReceiveData({ begin: e2, chunk: t2 }) {
        const i2 = t2 instanceof Uint8Array && t2.byteLength === t2.buffer.byteLength ? t2.buffer : new Uint8Array(t2).buffer;
        if (void 0 === e2)
          this._fullRequestReader ? this._fullRequestReader._enqueue(i2) : this._queuedChunks.push(i2);
        else {
          assert3(this._rangeReaders.some(function(t3) {
            return t3._begin === e2 && (t3._enqueue(i2), true);
          }), "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
        }
      }
      get _progressiveDataLength() {
        return this._fullRequestReader?._loaded ?? 0;
      }
      _onProgress(e2) {
        void 0 === e2.total ? this._rangeReaders[0]?.onProgress?.({ loaded: e2.loaded }) : this._fullRequestReader?.onProgress?.({ loaded: e2.loaded, total: e2.total });
      }
      _onProgressiveDone() {
        this._fullRequestReader?.progressiveDone(), this._progressiveDone = true;
      }
      _removeRangeReader(e2) {
        const t2 = this._rangeReaders.indexOf(e2);
        t2 >= 0 && this._rangeReaders.splice(t2, 1);
      }
      getFullReader() {
        assert3(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
        const e2 = this._queuedChunks;
        return this._queuedChunks = null, new PDFDataTransportStreamReader(this, e2, this._progressiveDone, this._contentDispositionFilename);
      }
      getRangeReader(e2, t2) {
        if (t2 <= this._progressiveDataLength)
          return null;
        const i2 = new PDFDataTransportStreamRangeReader(this, e2, t2);
        return this._pdfDataRangeTransport.requestDataRange(e2, t2), this._rangeReaders.push(i2), i2;
      }
      cancelAllRequests(e2) {
        this._fullRequestReader?.cancel(e2);
        for (const t2 of this._rangeReaders.slice(0))
          t2.cancel(e2);
        this._pdfDataRangeTransport.abort();
      }
    };
    __name(PDFDataTransportStream, "PDFDataTransportStream");
    PDFDataTransportStreamReader = class {
      constructor(e2, t2, i2 = false, a2 = null) {
        this._stream = e2, this._done = i2 || false, this._filename = isPdfFile(a2) ? a2 : null, this._queuedChunks = t2 || [], this._loaded = 0;
        for (const e3 of this._queuedChunks)
          this._loaded += e3.byteLength;
        this._requests = [], this._headersReady = Promise.resolve(), e2._fullRequestReader = this, this.onProgress = null;
      }
      _enqueue(e2) {
        if (!this._done) {
          if (this._requests.length > 0) {
            this._requests.shift().resolve({ value: e2, done: false });
          } else
            this._queuedChunks.push(e2);
          this._loaded += e2.byteLength;
        }
      }
      get headersReady() {
        return this._headersReady;
      }
      get filename() {
        return this._filename;
      }
      get isRangeSupported() {
        return this._stream._isRangeSupported;
      }
      get isStreamingSupported() {
        return this._stream._isStreamingSupported;
      }
      get contentLength() {
        return this._stream._contentLength;
      }
      async read() {
        if (this._queuedChunks.length > 0) {
          return { value: this._queuedChunks.shift(), done: false };
        }
        if (this._done)
          return { value: void 0, done: true };
        const e2 = Promise.withResolvers();
        return this._requests.push(e2), e2.promise;
      }
      cancel(e2) {
        this._done = true;
        for (const e3 of this._requests)
          e3.resolve({ value: void 0, done: true });
        this._requests.length = 0;
      }
      progressiveDone() {
        this._done || (this._done = true);
      }
    };
    __name(PDFDataTransportStreamReader, "PDFDataTransportStreamReader");
    PDFDataTransportStreamRangeReader = class {
      constructor(e2, t2, i2) {
        this._stream = e2, this._begin = t2, this._end = i2, this._queuedChunk = null, this._requests = [], this._done = false, this.onProgress = null;
      }
      _enqueue(e2) {
        if (!this._done) {
          if (0 === this._requests.length)
            this._queuedChunk = e2;
          else {
            this._requests.shift().resolve({ value: e2, done: false });
            for (const e3 of this._requests)
              e3.resolve({ value: void 0, done: true });
            this._requests.length = 0;
          }
          this._done = true, this._stream._removeRangeReader(this);
        }
      }
      get isStreamingSupported() {
        return false;
      }
      async read() {
        if (this._queuedChunk) {
          const e3 = this._queuedChunk;
          return this._queuedChunk = null, { value: e3, done: false };
        }
        if (this._done)
          return { value: void 0, done: true };
        const e2 = Promise.withResolvers();
        return this._requests.push(e2), e2.promise;
      }
      cancel(e2) {
        this._done = true;
        for (const e3 of this._requests)
          e3.resolve({ value: void 0, done: true });
        this._requests.length = 0, this._stream._removeRangeReader(this);
      }
    };
    __name(PDFDataTransportStreamRangeReader, "PDFDataTransportStreamRangeReader");
    __name(createHeaders, "createHeaders");
    __name(getResponseOrigin, "getResponseOrigin");
    __name(validateRangeRequestCapabilities, "validateRangeRequestCapabilities");
    __name(extractFilenameFromHeader, "extractFilenameFromHeader");
    __name(createResponseError, "createResponseError");
    __name(validateResponseStatus, "validateResponseStatus");
    __name(createFetchOptions, "createFetchOptions");
    __name(getArrayBuffer, "getArrayBuffer");
    PDFFetchStream = class {
      _responseOrigin = null;
      constructor(e2) {
        this.source = e2, this.isHttp = /^https?:/i.test(e2.url), this.headers = createHeaders(this.isHttp, e2.httpHeaders), this._fullRequestReader = null, this._rangeRequestReaders = [];
      }
      get _progressiveDataLength() {
        return this._fullRequestReader?._loaded ?? 0;
      }
      getFullReader() {
        return assert3(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once."), this._fullRequestReader = new PDFFetchStreamReader(this), this._fullRequestReader;
      }
      getRangeReader(e2, t2) {
        if (t2 <= this._progressiveDataLength)
          return null;
        const i2 = new PDFFetchStreamRangeReader(this, e2, t2);
        return this._rangeRequestReaders.push(i2), i2;
      }
      cancelAllRequests(e2) {
        this._fullRequestReader?.cancel(e2);
        for (const t2 of this._rangeRequestReaders.slice(0))
          t2.cancel(e2);
      }
    };
    __name(PDFFetchStream, "PDFFetchStream");
    PDFFetchStreamReader = class {
      constructor(e2) {
        this._stream = e2, this._reader = null, this._loaded = 0, this._filename = null;
        const t2 = e2.source;
        this._withCredentials = t2.withCredentials || false, this._contentLength = t2.length, this._headersCapability = Promise.withResolvers(), this._disableRange = t2.disableRange || false, this._rangeChunkSize = t2.rangeChunkSize, this._rangeChunkSize || this._disableRange || (this._disableRange = true), this._abortController = new AbortController(), this._isStreamingSupported = !t2.disableStream, this._isRangeSupported = !t2.disableRange;
        const i2 = new Headers(e2.headers), a2 = t2.url;
        fetch(a2, createFetchOptions(i2, this._withCredentials, this._abortController)).then((t3) => {
          if (e2._responseOrigin = getResponseOrigin(t3.url), !validateResponseStatus(t3.status))
            throw createResponseError(t3.status, a2);
          this._reader = t3.body.getReader(), this._headersCapability.resolve();
          const i3 = t3.headers, { allowRangeRequests: n2, suggestedLength: s2 } = validateRangeRequestCapabilities({ responseHeaders: i3, isHttp: e2.isHttp, rangeChunkSize: this._rangeChunkSize, disableRange: this._disableRange });
          this._isRangeSupported = n2, this._contentLength = s2 || this._contentLength, this._filename = extractFilenameFromHeader(i3), !this._isStreamingSupported && this._isRangeSupported && this.cancel(new AbortException("Streaming is disabled."));
        }).catch(this._headersCapability.reject), this.onProgress = null;
      }
      get headersReady() {
        return this._headersCapability.promise;
      }
      get filename() {
        return this._filename;
      }
      get contentLength() {
        return this._contentLength;
      }
      get isRangeSupported() {
        return this._isRangeSupported;
      }
      get isStreamingSupported() {
        return this._isStreamingSupported;
      }
      async read() {
        await this._headersCapability.promise;
        const { value: e2, done: t2 } = await this._reader.read();
        return t2 ? { value: e2, done: t2 } : (this._loaded += e2.byteLength, this.onProgress?.({ loaded: this._loaded, total: this._contentLength }), { value: getArrayBuffer(e2), done: false });
      }
      cancel(e2) {
        this._reader?.cancel(e2), this._abortController.abort();
      }
    };
    __name(PDFFetchStreamReader, "PDFFetchStreamReader");
    PDFFetchStreamRangeReader = class {
      constructor(e2, t2, i2) {
        this._stream = e2, this._reader = null, this._loaded = 0;
        const a2 = e2.source;
        this._withCredentials = a2.withCredentials || false, this._readCapability = Promise.withResolvers(), this._isStreamingSupported = !a2.disableStream, this._abortController = new AbortController();
        const n2 = new Headers(e2.headers);
        n2.append("Range", `bytes=${t2}-${i2 - 1}`);
        const s2 = a2.url;
        fetch(s2, createFetchOptions(n2, this._withCredentials, this._abortController)).then((t3) => {
          const i3 = getResponseOrigin(t3.url);
          if (i3 !== e2._responseOrigin)
            throw new Error(`Expected range response-origin "${i3}" to match "${e2._responseOrigin}".`);
          if (!validateResponseStatus(t3.status))
            throw createResponseError(t3.status, s2);
          this._readCapability.resolve(), this._reader = t3.body.getReader();
        }).catch(this._readCapability.reject), this.onProgress = null;
      }
      get isStreamingSupported() {
        return this._isStreamingSupported;
      }
      async read() {
        await this._readCapability.promise;
        const { value: e2, done: t2 } = await this._reader.read();
        return t2 ? { value: e2, done: t2 } : (this._loaded += e2.byteLength, this.onProgress?.({ loaded: this._loaded }), { value: getArrayBuffer(e2), done: false });
      }
      cancel(e2) {
        this._reader?.cancel(e2), this._abortController.abort();
      }
    };
    __name(PDFFetchStreamRangeReader, "PDFFetchStreamRangeReader");
    NetworkManager = class {
      _responseOrigin = null;
      constructor({ url: e2, httpHeaders: t2, withCredentials: i2 }) {
        this.url = e2, this.isHttp = /^https?:/i.test(e2), this.headers = createHeaders(this.isHttp, t2), this.withCredentials = i2 || false, this.currXhrId = 0, this.pendingRequests = /* @__PURE__ */ Object.create(null);
      }
      request(e2) {
        const t2 = new XMLHttpRequest(), i2 = this.currXhrId++, a2 = this.pendingRequests[i2] = { xhr: t2 };
        t2.open("GET", this.url), t2.withCredentials = this.withCredentials;
        for (const [e3, i3] of this.headers)
          t2.setRequestHeader(e3, i3);
        return this.isHttp && "begin" in e2 && "end" in e2 ? (t2.setRequestHeader("Range", `bytes=${e2.begin}-${e2.end - 1}`), a2.expectedStatus = 206) : a2.expectedStatus = 200, t2.responseType = "arraybuffer", assert3(e2.onError, "Expected `onError` callback to be provided."), t2.onerror = () => {
          e2.onError(t2.status);
        }, t2.onreadystatechange = this.onStateChange.bind(this, i2), t2.onprogress = this.onProgress.bind(this, i2), a2.onHeadersReceived = e2.onHeadersReceived, a2.onDone = e2.onDone, a2.onError = e2.onError, a2.onProgress = e2.onProgress, t2.send(null), i2;
      }
      onProgress(e2, t2) {
        const i2 = this.pendingRequests[e2];
        i2 && i2.onProgress?.(t2);
      }
      onStateChange(e2, t2) {
        const i2 = this.pendingRequests[e2];
        if (!i2)
          return;
        const a2 = i2.xhr;
        if (a2.readyState >= 2 && i2.onHeadersReceived && (i2.onHeadersReceived(), delete i2.onHeadersReceived), 4 !== a2.readyState)
          return;
        if (!(e2 in this.pendingRequests))
          return;
        if (delete this.pendingRequests[e2], 0 === a2.status && this.isHttp)
          return void i2.onError(a2.status);
        const n2 = a2.status || 200;
        if (!(200 === n2 && 206 === i2.expectedStatus) && n2 !== i2.expectedStatus)
          return void i2.onError(a2.status);
        const s2 = function(e3) {
          const t3 = e3.response;
          return "string" != typeof t3 ? t3 : stringToBytes(t3).buffer;
        }(a2);
        if (206 === n2) {
          const e3 = a2.getResponseHeader("Content-Range"), t3 = /bytes (\d+)-(\d+)\/(\d+)/.exec(e3);
          t3 ? i2.onDone({ begin: parseInt(t3[1], 10), chunk: s2 }) : (warn3('Missing or invalid "Content-Range" header.'), i2.onError(0));
        } else
          s2 ? i2.onDone({ begin: 0, chunk: s2 }) : i2.onError(a2.status);
      }
      getRequestXhr(e2) {
        return this.pendingRequests[e2].xhr;
      }
      isPendingRequest(e2) {
        return e2 in this.pendingRequests;
      }
      abortRequest(e2) {
        const t2 = this.pendingRequests[e2].xhr;
        delete this.pendingRequests[e2], t2.abort();
      }
    };
    __name(NetworkManager, "NetworkManager");
    PDFNetworkStream = class {
      constructor(e2) {
        this._source = e2, this._manager = new NetworkManager(e2), this._rangeChunkSize = e2.rangeChunkSize, this._fullRequestReader = null, this._rangeRequestReaders = [];
      }
      _onRangeRequestReaderClosed(e2) {
        const t2 = this._rangeRequestReaders.indexOf(e2);
        t2 >= 0 && this._rangeRequestReaders.splice(t2, 1);
      }
      getFullReader() {
        return assert3(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once."), this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source), this._fullRequestReader;
      }
      getRangeReader(e2, t2) {
        const i2 = new PDFNetworkStreamRangeRequestReader(this._manager, e2, t2);
        return i2.onClosed = this._onRangeRequestReaderClosed.bind(this), this._rangeRequestReaders.push(i2), i2;
      }
      cancelAllRequests(e2) {
        this._fullRequestReader?.cancel(e2);
        for (const t2 of this._rangeRequestReaders.slice(0))
          t2.cancel(e2);
      }
    };
    __name(PDFNetworkStream, "PDFNetworkStream");
    PDFNetworkStreamFullRequestReader = class {
      constructor(e2, t2) {
        this._manager = e2, this._url = t2.url, this._fullRequestId = e2.request({ onHeadersReceived: this._onHeadersReceived.bind(this), onDone: this._onDone.bind(this), onError: this._onError.bind(this), onProgress: this._onProgress.bind(this) }), this._headersCapability = Promise.withResolvers(), this._disableRange = t2.disableRange || false, this._contentLength = t2.length, this._rangeChunkSize = t2.rangeChunkSize, this._rangeChunkSize || this._disableRange || (this._disableRange = true), this._isStreamingSupported = false, this._isRangeSupported = false, this._cachedChunks = [], this._requests = [], this._done = false, this._storedError = void 0, this._filename = null, this.onProgress = null;
      }
      _onHeadersReceived() {
        const e2 = this._fullRequestId, t2 = this._manager.getRequestXhr(e2);
        this._manager._responseOrigin = getResponseOrigin(t2.responseURL);
        const i2 = t2.getAllResponseHeaders(), a2 = new Headers(i2 ? i2.trimStart().replace(/[^\S ]+$/, "").split(/[\r\n]+/).map((e3) => {
          const [t3, ...i3] = e3.split(": ");
          return [t3, i3.join(": ")];
        }) : []), { allowRangeRequests: n2, suggestedLength: s2 } = validateRangeRequestCapabilities({ responseHeaders: a2, isHttp: this._manager.isHttp, rangeChunkSize: this._rangeChunkSize, disableRange: this._disableRange });
        n2 && (this._isRangeSupported = true), this._contentLength = s2 || this._contentLength, this._filename = extractFilenameFromHeader(a2), this._isRangeSupported && this._manager.abortRequest(e2), this._headersCapability.resolve();
      }
      _onDone(e2) {
        if (e2)
          if (this._requests.length > 0) {
            this._requests.shift().resolve({ value: e2.chunk, done: false });
          } else
            this._cachedChunks.push(e2.chunk);
        if (this._done = true, !(this._cachedChunks.length > 0)) {
          for (const e3 of this._requests)
            e3.resolve({ value: void 0, done: true });
          this._requests.length = 0;
        }
      }
      _onError(e2) {
        this._storedError = createResponseError(e2, this._url), this._headersCapability.reject(this._storedError);
        for (const e3 of this._requests)
          e3.reject(this._storedError);
        this._requests.length = 0, this._cachedChunks.length = 0;
      }
      _onProgress(e2) {
        this.onProgress?.({ loaded: e2.loaded, total: e2.lengthComputable ? e2.total : this._contentLength });
      }
      get filename() {
        return this._filename;
      }
      get isRangeSupported() {
        return this._isRangeSupported;
      }
      get isStreamingSupported() {
        return this._isStreamingSupported;
      }
      get contentLength() {
        return this._contentLength;
      }
      get headersReady() {
        return this._headersCapability.promise;
      }
      async read() {
        if (await this._headersCapability.promise, this._storedError)
          throw this._storedError;
        if (this._cachedChunks.length > 0) {
          return { value: this._cachedChunks.shift(), done: false };
        }
        if (this._done)
          return { value: void 0, done: true };
        const e2 = Promise.withResolvers();
        return this._requests.push(e2), e2.promise;
      }
      cancel(e2) {
        this._done = true, this._headersCapability.reject(e2);
        for (const e3 of this._requests)
          e3.resolve({ value: void 0, done: true });
        this._requests.length = 0, this._manager.isPendingRequest(this._fullRequestId) && this._manager.abortRequest(this._fullRequestId), this._fullRequestReader = null;
      }
    };
    __name(PDFNetworkStreamFullRequestReader, "PDFNetworkStreamFullRequestReader");
    PDFNetworkStreamRangeRequestReader = class {
      constructor(e2, t2, i2) {
        this._manager = e2, this._url = e2.url, this._requestId = e2.request({ begin: t2, end: i2, onHeadersReceived: this._onHeadersReceived.bind(this), onDone: this._onDone.bind(this), onError: this._onError.bind(this), onProgress: this._onProgress.bind(this) }), this._requests = [], this._queuedChunk = null, this._done = false, this._storedError = void 0, this.onProgress = null, this.onClosed = null;
      }
      _onHeadersReceived() {
        const e2 = getResponseOrigin(this._manager.getRequestXhr(this._requestId)?.responseURL);
        e2 !== this._manager._responseOrigin && (this._storedError = new Error(`Expected range response-origin "${e2}" to match "${this._manager._responseOrigin}".`), this._onError(0));
      }
      _close() {
        this.onClosed?.(this);
      }
      _onDone(e2) {
        const t2 = e2.chunk;
        if (this._requests.length > 0) {
          this._requests.shift().resolve({ value: t2, done: false });
        } else
          this._queuedChunk = t2;
        this._done = true;
        for (const e3 of this._requests)
          e3.resolve({ value: void 0, done: true });
        this._requests.length = 0, this._close();
      }
      _onError(e2) {
        this._storedError ??= createResponseError(e2, this._url);
        for (const e3 of this._requests)
          e3.reject(this._storedError);
        this._requests.length = 0, this._queuedChunk = null;
      }
      _onProgress(e2) {
        this.isStreamingSupported || this.onProgress?.({ loaded: e2.loaded });
      }
      get isStreamingSupported() {
        return false;
      }
      async read() {
        if (this._storedError)
          throw this._storedError;
        if (null !== this._queuedChunk) {
          const e3 = this._queuedChunk;
          return this._queuedChunk = null, { value: e3, done: false };
        }
        if (this._done)
          return { value: void 0, done: true };
        const e2 = Promise.withResolvers();
        return this._requests.push(e2), e2.promise;
      }
      cancel(e2) {
        this._done = true;
        for (const e3 of this._requests)
          e3.resolve({ value: void 0, done: true });
        this._requests.length = 0, this._manager.isPendingRequest(this._requestId) && this._manager.abortRequest(this._requestId), this._close();
      }
    };
    __name(PDFNetworkStreamRangeRequestReader, "PDFNetworkStreamRangeRequestReader");
    Qc = /^[a-z][a-z0-9\-+.]+:/i;
    PDFNodeStream = class {
      constructor(e2) {
        this.source = e2, this.url = function(e3) {
          if (Qc.test(e3))
            return new URL(e3);
          const t2 = process.getBuiltinModule("url");
          return new URL(t2.pathToFileURL(e3));
        }(e2.url), assert3("file:" === this.url.protocol, "PDFNodeStream only supports file:// URLs."), this._fullRequestReader = null, this._rangeRequestReaders = [];
      }
      get _progressiveDataLength() {
        return this._fullRequestReader?._loaded ?? 0;
      }
      getFullReader() {
        return assert3(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once."), this._fullRequestReader = new PDFNodeStreamFsFullReader(this), this._fullRequestReader;
      }
      getRangeReader(e2, t2) {
        if (t2 <= this._progressiveDataLength)
          return null;
        const i2 = new PDFNodeStreamFsRangeReader(this, e2, t2);
        return this._rangeRequestReaders.push(i2), i2;
      }
      cancelAllRequests(e2) {
        this._fullRequestReader?.cancel(e2);
        for (const t2 of this._rangeRequestReaders.slice(0))
          t2.cancel(e2);
      }
    };
    __name(PDFNodeStream, "PDFNodeStream");
    PDFNodeStreamFsFullReader = class {
      constructor(e2) {
        this._url = e2.url, this._done = false, this._storedError = null, this.onProgress = null;
        const t2 = e2.source;
        this._contentLength = t2.length, this._loaded = 0, this._filename = null, this._disableRange = t2.disableRange || false, this._rangeChunkSize = t2.rangeChunkSize, this._rangeChunkSize || this._disableRange || (this._disableRange = true), this._isStreamingSupported = !t2.disableStream, this._isRangeSupported = !t2.disableRange, this._readableStream = null, this._readCapability = Promise.withResolvers(), this._headersCapability = Promise.withResolvers();
        const i2 = process.getBuiltinModule("fs");
        i2.promises.lstat(this._url).then((e3) => {
          this._contentLength = e3.size, this._setReadableStream(i2.createReadStream(this._url)), this._headersCapability.resolve();
        }, (e3) => {
          "ENOENT" === e3.code && (e3 = createResponseError(0, this._url.href)), this._storedError = e3, this._headersCapability.reject(e3);
        });
      }
      get headersReady() {
        return this._headersCapability.promise;
      }
      get filename() {
        return this._filename;
      }
      get contentLength() {
        return this._contentLength;
      }
      get isRangeSupported() {
        return this._isRangeSupported;
      }
      get isStreamingSupported() {
        return this._isStreamingSupported;
      }
      async read() {
        if (await this._readCapability.promise, this._done)
          return { value: void 0, done: true };
        if (this._storedError)
          throw this._storedError;
        const e2 = this._readableStream.read();
        if (null === e2)
          return this._readCapability = Promise.withResolvers(), this.read();
        this._loaded += e2.length, this.onProgress?.({ loaded: this._loaded, total: this._contentLength });
        return { value: new Uint8Array(e2).buffer, done: false };
      }
      cancel(e2) {
        this._readableStream ? this._readableStream.destroy(e2) : this._error(e2);
      }
      _error(e2) {
        this._storedError = e2, this._readCapability.resolve();
      }
      _setReadableStream(e2) {
        this._readableStream = e2, e2.on("readable", () => {
          this._readCapability.resolve();
        }), e2.on("end", () => {
          e2.destroy(), this._done = true, this._readCapability.resolve();
        }), e2.on("error", (e3) => {
          this._error(e3);
        }), !this._isStreamingSupported && this._isRangeSupported && this._error(new AbortException("streaming is disabled")), this._storedError && this._readableStream.destroy(this._storedError);
      }
    };
    __name(PDFNodeStreamFsFullReader, "PDFNodeStreamFsFullReader");
    PDFNodeStreamFsRangeReader = class {
      constructor(e2, t2, i2) {
        this._url = e2.url, this._done = false, this._storedError = null, this.onProgress = null, this._loaded = 0, this._readableStream = null, this._readCapability = Promise.withResolvers();
        const a2 = e2.source;
        this._isStreamingSupported = !a2.disableStream;
        const n2 = process.getBuiltinModule("fs");
        this._setReadableStream(n2.createReadStream(this._url, { start: t2, end: i2 - 1 }));
      }
      get isStreamingSupported() {
        return this._isStreamingSupported;
      }
      async read() {
        if (await this._readCapability.promise, this._done)
          return { value: void 0, done: true };
        if (this._storedError)
          throw this._storedError;
        const e2 = this._readableStream.read();
        if (null === e2)
          return this._readCapability = Promise.withResolvers(), this.read();
        this._loaded += e2.length, this.onProgress?.({ loaded: this._loaded });
        return { value: new Uint8Array(e2).buffer, done: false };
      }
      cancel(e2) {
        this._readableStream ? this._readableStream.destroy(e2) : this._error(e2);
      }
      _error(e2) {
        this._storedError = e2, this._readCapability.resolve();
      }
      _setReadableStream(e2) {
        this._readableStream = e2, e2.on("readable", () => {
          this._readCapability.resolve();
        }), e2.on("end", () => {
          e2.destroy(), this._done = true, this._readCapability.resolve();
        }), e2.on("error", (e3) => {
          this._error(e3);
        }), this._storedError && this._readableStream.destroy(this._storedError);
      }
    };
    __name(PDFNodeStreamFsRangeReader, "PDFNodeStreamFsRangeReader");
    eh = Symbol("INITIAL_DATA");
    PDFObjects = class {
      #ys = /* @__PURE__ */ Object.create(null);
      #ws(e2) {
        return this.#ys[e2] ||= { ...Promise.withResolvers(), data: eh };
      }
      get(e2, t2 = null) {
        if (t2) {
          const i3 = this.#ws(e2);
          return i3.promise.then(() => t2(i3.data)), null;
        }
        const i2 = this.#ys[e2];
        if (!i2 || i2.data === eh)
          throw new Error(`Requesting object that isn't resolved yet ${e2}.`);
        return i2.data;
      }
      has(e2) {
        const t2 = this.#ys[e2];
        return !!t2 && t2.data !== eh;
      }
      delete(e2) {
        const t2 = this.#ys[e2];
        return !(!t2 || t2.data === eh) && (delete this.#ys[e2], true);
      }
      resolve(e2, t2 = null) {
        const i2 = this.#ws(e2);
        i2.data = t2, i2.resolve();
      }
      clear() {
        for (const e2 in this.#ys) {
          const { data: t2 } = this.#ys[e2];
          t2?.bitmap?.close();
        }
        this.#ys = /* @__PURE__ */ Object.create(null);
      }
      *[Symbol.iterator]() {
        for (const e2 in this.#ys) {
          const { data: t2 } = this.#ys[e2];
          t2 !== eh && (yield [e2, t2]);
        }
      }
    };
    __name(PDFObjects, "PDFObjects");
    _TextLayer = class {
      constructor({ textContentSource: e2, container: t2, viewport: i2 }) {
        __privateAdd(this, _qs);
        __privateAdd(this, _Ws);
        __privateAdd(this, _zs);
        __privateAdd(this, _As, Promise.withResolvers());
        __privateAdd(this, _Ai2, null);
        __privateAdd(this, _xs, false);
        __privateAdd(this, _Ss, !!globalThis.FontInspector?.enabled);
        __privateAdd(this, _vs, null);
        __privateAdd(this, _Cs, null);
        __privateAdd(this, _ks, 0);
        __privateAdd(this, _Ts, 0);
        __privateAdd(this, _Is, null);
        __privateAdd(this, _Fs, null);
        __privateAdd(this, _Ms, 0);
        __privateAdd(this, _Ds, 0);
        __privateAdd(this, _Es, /* @__PURE__ */ Object.create(null));
        __privateAdd(this, _Os, []);
        __privateAdd(this, __s, null);
        __privateAdd(this, _Ps, []);
        __privateAdd(this, _Rs, /* @__PURE__ */ new WeakMap());
        __privateAdd(this, _Bs, null);
        var _a4;
        if (e2 instanceof ReadableStream)
          __privateSet(this, __s, e2);
        else {
          if ("object" != typeof e2)
            throw new Error('No "textContentSource" parameter specified.');
          __privateSet(this, __s, new ReadableStream({ start(t3) {
            t3.enqueue(e2), t3.close();
          } }));
        }
        __privateSet(this, _Ai2, __privateSet(this, _Fs, t2)), __privateSet(this, _Ds, i2.scale * OutputScale.pixelRatio), __privateSet(this, _Ms, i2.rotation), __privateSet(this, _Cs, { div: null, properties: null, ctx: null });
        const { pageWidth: a2, pageHeight: n2, pageX: s2, pageY: r2 } = i2.rawDims;
        __privateSet(this, _Bs, [1, 0, 0, -1, -s2, r2 + n2]), __privateSet(this, _Ts, a2), __privateSet(this, _ks, n2), __privateMethod(_a4 = _TextLayer, _Hs, Hs_fn).call(_a4), setLayerDimensions(t2, i2), __privateGet(this, _As).promise.finally(() => {
          __privateGet(_TextLayer, _$s).delete(this), __privateSet(this, _Cs, null), __privateSet(this, _Es, null);
        }).catch(() => {
        });
      }
      static get fontFamilyMap() {
        const { isWindows: e2, isFirefox: t2 } = util_FeatureTest.platform;
        return shadow(this, "fontFamilyMap", /* @__PURE__ */ new Map([["sans-serif", (e2 && t2 ? "Calibri, " : "") + "sans-serif"], ["monospace", (e2 && t2 ? "Lucida Console, " : "") + "monospace"]]));
      }
      render() {
        const pump = /* @__PURE__ */ __name(() => {
          __privateGet(this, _Is).read().then(({ value: e2, done: t2 }) => {
            t2 ? __privateGet(this, _As).resolve() : (__privateGet(this, _vs) ?? __privateSet(this, _vs, e2.lang), Object.assign(__privateGet(this, _Es), e2.styles), __privateMethod(this, _qs, qs_fn).call(this, e2.items), pump());
          }, __privateGet(this, _As).reject);
        }, "pump");
        return __privateSet(this, _Is, __privateGet(this, __s).getReader()), __privateGet(_TextLayer, _$s).add(this), pump(), __privateGet(this, _As).promise;
      }
      update({ viewport: e2, onBefore: t2 = null }) {
        var _a4;
        const i2 = e2.scale * OutputScale.pixelRatio, a2 = e2.rotation;
        if (a2 !== __privateGet(this, _Ms) && (t2?.(), __privateSet(this, _Ms, a2), setLayerDimensions(__privateGet(this, _Fs), { rotation: a2 })), i2 !== __privateGet(this, _Ds)) {
          t2?.(), __privateSet(this, _Ds, i2);
          const e3 = { div: null, properties: null, ctx: __privateMethod(_a4 = _TextLayer, _Xs, Xs_fn).call(_a4, __privateGet(this, _vs)) };
          for (const t3 of __privateGet(this, _Ps))
            e3.properties = __privateGet(this, _Rs).get(t3), e3.div = t3, __privateMethod(this, _zs, zs_fn).call(this, e3);
        }
      }
      cancel() {
        const e2 = new AbortException("TextLayer task cancelled.");
        __privateGet(this, _Is)?.cancel(e2).catch(() => {
        }), __privateSet(this, _Is, null), __privateGet(this, _As).reject(e2);
      }
      get textDivs() {
        return __privateGet(this, _Ps);
      }
      get textContentItemsStr() {
        return __privateGet(this, _Os);
      }
      static cleanup() {
        if (!(__privateGet(this, _$s).size > 0)) {
          __privateGet(this, _Ns).clear();
          for (const { canvas: e2 } of __privateGet(this, _Ls).values())
            e2.remove();
          __privateGet(this, _Ls).clear();
        }
      }
    };
    TextLayer = _TextLayer;
    __name(TextLayer, "TextLayer");
    _As = new WeakMap();
    _Ai2 = new WeakMap();
    _xs = new WeakMap();
    _Ss = new WeakMap();
    _vs = new WeakMap();
    _Cs = new WeakMap();
    _ks = new WeakMap();
    _Ts = new WeakMap();
    _Is = new WeakMap();
    _Fs = new WeakMap();
    _Ms = new WeakMap();
    _Ds = new WeakMap();
    _Es = new WeakMap();
    _Os = new WeakMap();
    __s = new WeakMap();
    _Ps = new WeakMap();
    _Rs = new WeakMap();
    _Bs = new WeakMap();
    _Ns = new WeakMap();
    _Ls = new WeakMap();
    _Us = new WeakMap();
    _js = new WeakMap();
    _$s = new WeakMap();
    _qs = new WeakSet();
    qs_fn = /* @__PURE__ */ __name(function(e2) {
      var _a4;
      if (__privateGet(this, _xs))
        return;
      __privateGet(this, _Cs).ctx ??= __privateMethod(_a4 = _TextLayer, _Xs, Xs_fn).call(_a4, __privateGet(this, _vs));
      const t2 = __privateGet(this, _Ps), i2 = __privateGet(this, _Os);
      for (const a2 of e2) {
        if (t2.length > 1e5)
          return warn3("Ignoring additional textDivs for performance reasons."), void __privateSet(this, _xs, true);
        if (void 0 !== a2.str)
          i2.push(a2.str), __privateMethod(this, _Ws, Ws_fn).call(this, a2);
        else if ("beginMarkedContentProps" === a2.type || "beginMarkedContent" === a2.type) {
          const e3 = __privateGet(this, _Ai2);
          __privateSet(this, _Ai2, document.createElement("span")), __privateGet(this, _Ai2).classList.add("markedContent"), a2.id && __privateGet(this, _Ai2).setAttribute("id", `${a2.id}`), e3.append(__privateGet(this, _Ai2));
        } else
          "endMarkedContent" === a2.type && __privateSet(this, _Ai2, __privateGet(this, _Ai2).parentNode);
      }
    }, "#qs");
    _Ws = new WeakSet();
    Ws_fn = /* @__PURE__ */ __name(function(e2) {
      var _a4;
      const t2 = document.createElement("span"), i2 = { angle: 0, canvasWidth: 0, hasText: "" !== e2.str, hasEOL: e2.hasEOL, fontSize: 0 };
      __privateGet(this, _Ps).push(t2);
      const a2 = Util.transform(__privateGet(this, _Bs), e2.transform);
      let n2 = Math.atan2(a2[1], a2[0]);
      const s2 = __privateGet(this, _Es)[e2.fontName];
      s2.vertical && (n2 += Math.PI / 2);
      let r2 = __privateGet(this, _Ss) && s2.fontSubstitution || s2.fontFamily;
      r2 = _TextLayer.fontFamilyMap.get(r2) || r2;
      const o2 = Math.hypot(a2[2], a2[3]), l3 = o2 * __privateMethod(_a4 = _TextLayer, _Gs, Gs_fn).call(_a4, r2, s2, __privateGet(this, _vs));
      let c2, h2;
      0 === n2 ? (c2 = a2[4], h2 = a2[5] - l3) : (c2 = a2[4] + l3 * Math.sin(n2), h2 = a2[5] - l3 * Math.cos(n2));
      const d2 = "calc(var(--total-scale-factor) *", u2 = t2.style;
      __privateGet(this, _Ai2) === __privateGet(this, _Fs) ? (u2.left = `${(100 * c2 / __privateGet(this, _Ts)).toFixed(2)}%`, u2.top = `${(100 * h2 / __privateGet(this, _ks)).toFixed(2)}%`) : (u2.left = `${d2}${c2.toFixed(2)}px)`, u2.top = `${d2}${h2.toFixed(2)}px)`), u2.fontSize = `${d2}${(__privateGet(_TextLayer, _js) * o2).toFixed(2)}px)`, u2.fontFamily = r2, i2.fontSize = o2, t2.setAttribute("role", "presentation"), t2.textContent = e2.str, t2.dir = e2.dir, __privateGet(this, _Ss) && (t2.dataset.fontName = s2.fontSubstitutionLoadedName || e2.fontName), 0 !== n2 && (i2.angle = n2 * (180 / Math.PI));
      let g2 = false;
      if (e2.str.length > 1)
        g2 = true;
      else if (" " !== e2.str && e2.transform[0] !== e2.transform[3]) {
        const t3 = Math.abs(e2.transform[0]), i3 = Math.abs(e2.transform[3]);
        t3 !== i3 && Math.max(t3, i3) / Math.min(t3, i3) > 1.5 && (g2 = true);
      }
      if (g2 && (i2.canvasWidth = s2.vertical ? e2.height : e2.width), __privateGet(this, _Rs).set(t2, i2), __privateGet(this, _Cs).div = t2, __privateGet(this, _Cs).properties = i2, __privateMethod(this, _zs, zs_fn).call(this, __privateGet(this, _Cs)), i2.hasText && __privateGet(this, _Ai2).append(t2), i2.hasEOL) {
        const e3 = document.createElement("br");
        e3.setAttribute("role", "presentation"), __privateGet(this, _Ai2).append(e3);
      }
    }, "#Ws");
    _zs = new WeakSet();
    zs_fn = /* @__PURE__ */ __name(function(e2) {
      var _a4;
      const { div: t2, properties: i2, ctx: a2 } = e2, { style: n2 } = t2;
      let s2 = "";
      if (__privateGet(_TextLayer, _js) > 1 && (s2 = `scale(${1 / __privateGet(_TextLayer, _js)})`), 0 !== i2.canvasWidth && i2.hasText) {
        const { fontFamily: e3 } = n2, { canvasWidth: r2, fontSize: o2 } = i2;
        __privateMethod(_a4 = _TextLayer, _Vs, Vs_fn).call(_a4, a2, o2 * __privateGet(this, _Ds), e3);
        const { width: l3 } = a2.measureText(t2.textContent);
        l3 > 0 && (s2 = `scaleX(${r2 * __privateGet(this, _Ds) / l3}) ${s2}`);
      }
      0 !== i2.angle && (s2 = `rotate(${i2.angle}deg) ${s2}`), s2.length > 0 && (n2.transform = s2);
    }, "#zs");
    _Xs = new WeakSet();
    Xs_fn = /* @__PURE__ */ __name(function(e2 = null) {
      let t2 = __privateGet(this, _Ls).get(e2 ||= "");
      if (!t2) {
        const i2 = document.createElement("canvas");
        i2.className = "hiddenCanvasElement", i2.lang = e2, document.body.append(i2), t2 = i2.getContext("2d", { alpha: false, willReadFrequently: true }), __privateGet(this, _Ls).set(e2, t2), __privateGet(this, _Us).set(t2, { size: 0, family: "" });
      }
      return t2;
    }, "#Xs");
    _Vs = new WeakSet();
    Vs_fn = /* @__PURE__ */ __name(function(e2, t2, i2) {
      const a2 = __privateGet(this, _Us).get(e2);
      t2 === a2.size && i2 === a2.family || (e2.font = `${t2}px ${i2}`, a2.size = t2, a2.family = i2);
    }, "#Vs");
    _Hs = new WeakSet();
    Hs_fn = /* @__PURE__ */ __name(function() {
      if (null !== __privateGet(this, _js))
        return;
      const e2 = document.createElement("div");
      e2.style.opacity = 0, e2.style.lineHeight = 1, e2.style.fontSize = "1px", e2.style.position = "absolute", e2.textContent = "X", document.body.append(e2), __privateSet(this, _js, e2.getBoundingClientRect().height), e2.remove();
    }, "#Hs");
    _Gs = new WeakSet();
    Gs_fn = /* @__PURE__ */ __name(function(e2, t2, i2) {
      const a2 = __privateGet(this, _Ns).get(e2);
      if (a2)
        return a2;
      const n2 = __privateMethod(this, _Xs, Xs_fn).call(this, i2);
      n2.canvas.width = n2.canvas.height = 30, __privateMethod(this, _Vs, Vs_fn).call(this, n2, 30, e2);
      const s2 = n2.measureText(""), r2 = s2.fontBoundingBoxAscent, o2 = Math.abs(s2.fontBoundingBoxDescent);
      n2.canvas.width = n2.canvas.height = 0;
      let l3 = 0.8;
      return r2 ? l3 = r2 / (r2 + o2) : (util_FeatureTest.platform.isFirefox && warn3("Enable the `dom.textMetrics.fontBoundingBox.enabled` preference in `about:config` to improve TextLayer rendering."), t2.ascent ? l3 = t2.ascent : t2.descent && (l3 = 1 + t2.descent)), __privateGet(this, _Ns).set(e2, l3), l3;
    }, "#Gs");
    __privateAdd(TextLayer, _Xs);
    __privateAdd(TextLayer, _Vs);
    __privateAdd(TextLayer, _Hs);
    __privateAdd(TextLayer, _Gs);
    __privateAdd(TextLayer, _Ns, /* @__PURE__ */ new Map());
    __privateAdd(TextLayer, _Ls, /* @__PURE__ */ new Map());
    __privateAdd(TextLayer, _Us, /* @__PURE__ */ new WeakMap());
    __privateAdd(TextLayer, _js, null);
    __privateAdd(TextLayer, _$s, /* @__PURE__ */ new Set());
    XfaText = class {
      static textContent(e2) {
        const t2 = [], i2 = { items: t2, styles: /* @__PURE__ */ Object.create(null) };
        return (/* @__PURE__ */ __name(function walk(e3) {
          if (!e3)
            return;
          let i3 = null;
          const a2 = e3.name;
          if ("#text" === a2)
            i3 = e3.value;
          else {
            if (!XfaText.shouldBuildText(a2))
              return;
            e3?.attributes?.textContent ? i3 = e3.attributes.textContent : e3.value && (i3 = e3.value);
          }
          if (null !== i3 && t2.push({ str: i3 }), e3.children)
            for (const t3 of e3.children)
              walk(t3);
        }, "walk"))(e2), i2;
      }
      static shouldBuildText(e2) {
        return !("textarea" === e2 || "input" === e2 || "option" === e2 || "select" === e2);
      }
    };
    __name(XfaText, "XfaText");
    __name(getDocument, "getDocument");
    _PDFDocumentLoadingTask = class {
      _capability = Promise.withResolvers();
      _transport = null;
      _worker = null;
      docId = "d" + __privateWrapper(_PDFDocumentLoadingTask, _vn)._++;
      destroyed = false;
      onPassword = null;
      onProgress = null;
      get promise() {
        return this._capability.promise;
      }
      async destroy() {
        this.destroyed = true;
        try {
          this._worker?.port && (this._worker._pendingDestroy = true), await this._transport?.destroy();
        } catch (e2) {
          throw this._worker?.port && delete this._worker._pendingDestroy, e2;
        }
        this._transport = null, this._worker?.destroy(), this._worker = null;
      }
      async getData() {
        return this._transport.getData();
      }
    };
    PDFDocumentLoadingTask = _PDFDocumentLoadingTask;
    __name(PDFDocumentLoadingTask, "PDFDocumentLoadingTask");
    _vn = new WeakMap();
    __privateAdd(PDFDocumentLoadingTask, _vn, 0);
    PDFDataRangeTransport = class {
      #As = Promise.withResolvers();
      #Ks = [];
      #Ys = [];
      #Js = [];
      #Zs = [];
      constructor(e2, t2, i2 = false, a2 = null) {
        this.length = e2, this.initialData = t2, this.progressiveDone = i2, this.contentDispositionFilename = a2;
      }
      addRangeListener(e2) {
        this.#Zs.push(e2);
      }
      addProgressListener(e2) {
        this.#Js.push(e2);
      }
      addProgressiveReadListener(e2) {
        this.#Ys.push(e2);
      }
      addProgressiveDoneListener(e2) {
        this.#Ks.push(e2);
      }
      onDataRange(e2, t2) {
        for (const i2 of this.#Zs)
          i2(e2, t2);
      }
      onDataProgress(e2, t2) {
        this.#As.promise.then(() => {
          for (const i2 of this.#Js)
            i2(e2, t2);
        });
      }
      onDataProgressiveRead(e2) {
        this.#As.promise.then(() => {
          for (const t2 of this.#Ys)
            t2(e2);
        });
      }
      onDataProgressiveDone() {
        this.#As.promise.then(() => {
          for (const e2 of this.#Ks)
            e2();
        });
      }
      transportReady() {
        this.#As.resolve();
      }
      requestDataRange(e2, t2) {
        unreachable("Abstract method PDFDataRangeTransport.requestDataRange");
      }
      abort() {
      }
    };
    __name(PDFDataRangeTransport, "PDFDataRangeTransport");
    PDFDocumentProxy = class {
      constructor(e2, t2) {
        this._pdfInfo = e2, this._transport = t2;
      }
      get annotationStorage() {
        return this._transport.annotationStorage;
      }
      get canvasFactory() {
        return this._transport.canvasFactory;
      }
      get filterFactory() {
        return this._transport.filterFactory;
      }
      get numPages() {
        return this._pdfInfo.numPages;
      }
      get fingerprints() {
        return this._pdfInfo.fingerprints;
      }
      get isPureXfa() {
        return shadow(this, "isPureXfa", !!this._transport._htmlForXfa);
      }
      get allXfaHtml() {
        return this._transport._htmlForXfa;
      }
      getPage(e2) {
        return this._transport.getPage(e2);
      }
      getPageIndex(e2) {
        return this._transport.getPageIndex(e2);
      }
      getDestinations() {
        return this._transport.getDestinations();
      }
      getDestination(e2) {
        return this._transport.getDestination(e2);
      }
      getPageLabels() {
        return this._transport.getPageLabels();
      }
      getPageLayout() {
        return this._transport.getPageLayout();
      }
      getPageMode() {
        return this._transport.getPageMode();
      }
      getViewerPreferences() {
        return this._transport.getViewerPreferences();
      }
      getOpenAction() {
        return this._transport.getOpenAction();
      }
      getAttachments() {
        return this._transport.getAttachments();
      }
      getAnnotationsByType(e2, t2) {
        return this._transport.getAnnotationsByType(e2, t2);
      }
      getJSActions() {
        return this._transport.getDocJSActions();
      }
      getOutline() {
        return this._transport.getOutline();
      }
      getOptionalContentConfig({ intent: e2 = "display" } = {}) {
        const { renderingIntent: t2 } = this._transport.getRenderingIntent(e2);
        return this._transport.getOptionalContentConfig(t2);
      }
      getPermissions() {
        return this._transport.getPermissions();
      }
      getMetadata() {
        return this._transport.getMetadata();
      }
      getMarkInfo() {
        return this._transport.getMarkInfo();
      }
      getData() {
        return this._transport.getData();
      }
      saveDocument() {
        return this._transport.saveDocument();
      }
      getDownloadInfo() {
        return this._transport.downloadInfoCapability.promise;
      }
      cleanup(e2 = false) {
        return this._transport.startCleanup(e2 || this.isPureXfa);
      }
      destroy() {
        return this.loadingTask.destroy();
      }
      cachedPageNumber(e2) {
        return this._transport.cachedPageNumber(e2);
      }
      get loadingParams() {
        return this._transport.loadingParams;
      }
      get loadingTask() {
        return this._transport.loadingTask;
      }
      getFieldObjects() {
        return this._transport.getFieldObjects();
      }
      hasJSActions() {
        return this._transport.hasJSActions();
      }
      getCalculationOrderIds() {
        return this._transport.getCalculationOrderIds();
      }
    };
    __name(PDFDocumentProxy, "PDFDocumentProxy");
    PDFPageProxy = class {
      #Qs = false;
      constructor(e2, t2, i2, a2 = false) {
        this._pageIndex = e2, this._pageInfo = t2, this._transport = i2, this._stats = a2 ? new StatTimer() : null, this._pdfBug = a2, this.commonObjs = i2.commonObjs, this.objs = new PDFObjects(), this._intentStates = /* @__PURE__ */ new Map(), this.destroyed = false, this.recordedGroups = null;
      }
      get pageNumber() {
        return this._pageIndex + 1;
      }
      get rotate() {
        return this._pageInfo.rotate;
      }
      get ref() {
        return this._pageInfo.ref;
      }
      get userUnit() {
        return this._pageInfo.userUnit;
      }
      get view() {
        return this._pageInfo.view;
      }
      getViewport({ scale: e2, rotation: t2 = this.rotate, offsetX: i2 = 0, offsetY: a2 = 0, dontFlip: n2 = false } = {}) {
        return new PageViewport({ viewBox: this.view, userUnit: this.userUnit, scale: e2, rotation: t2, offsetX: i2, offsetY: a2, dontFlip: n2 });
      }
      getAnnotations({ intent: e2 = "display" } = {}) {
        const { renderingIntent: t2 } = this._transport.getRenderingIntent(e2);
        return this._transport.getAnnotations(this._pageIndex, t2);
      }
      getJSActions() {
        return this._transport.getPageJSActions(this._pageIndex);
      }
      get filterFactory() {
        return this._transport.filterFactory;
      }
      get isPureXfa() {
        return shadow(this, "isPureXfa", !!this._transport._htmlForXfa);
      }
      async getXfa() {
        return this._transport._htmlForXfa?.children[this._pageIndex] || null;
      }
      render({ canvasContext: e2, canvas: t2 = e2.canvas, viewport: i2, intent: a2 = "display", annotationMode: n2 = Bl.ENABLE, transform: s2 = null, background: r2 = null, optionalContentConfigPromise: o2 = null, annotationCanvasMap: l3 = null, pageColors: c2 = null, printAnnotationStorage: h2 = null, isEditing: d2 = false, recordOperations: u2 = false, filteredOperationIndexes: g2 = null }) {
        this._stats?.time("Overall");
        const p2 = this._transport.getRenderingIntent(a2, n2, h2, d2), { renderingIntent: f2, cacheKey: m2 } = p2;
        this.#Qs = false, o2 ||= this._transport.getOptionalContentConfig(f2);
        let b2 = this._intentStates.get(m2);
        b2 || (b2 = /* @__PURE__ */ Object.create(null), this._intentStates.set(m2, b2)), b2.streamReaderCancelTimeout && (clearTimeout(b2.streamReaderCancelTimeout), b2.streamReaderCancelTimeout = null);
        const y2 = !!(f2 & Ml);
        b2.displayReadyCapability || (b2.displayReadyCapability = Promise.withResolvers(), b2.operatorList = { fnArray: [], argsArray: [], lastChunk: false, separateAnnots: null }, this._stats?.time("Page Request"), this._pumpOperatorList(p2));
        const w2 = !this.recordedGroups && (u2 || this._pdfBug && globalThis.StepperManager?.enabled), complete = /* @__PURE__ */ __name((e3) => {
          if (b2.renderTasks.delete(x2), w2) {
            const e4 = x2.gfx?.dependencyTracker.take();
            e4 ? (x2.stepper?.setOperatorGroups(e4), u2 && (this.recordedGroups = e4)) : u2 && (this.recordedGroups = []);
          }
          y2 && (this.#Qs = true), this.#er(), e3 ? (x2.capability.reject(e3), this._abortOperatorList({ intentState: b2, reason: e3 instanceof Error ? e3 : new Error(e3) })) : x2.capability.resolve(), this._stats && (this._stats.timeEnd("Rendering"), this._stats.timeEnd("Overall"), globalThis.Stats?.enabled && globalThis.Stats.add(this.pageNumber, this._stats));
        }, "complete"), x2 = new InternalRenderTask({ callback: complete, params: { canvas: t2, canvasContext: e2, dependencyTracker: w2 ? new CanvasDependencyTracker(t2) : null, viewport: i2, transform: s2, background: r2 }, objs: this.objs, commonObjs: this.commonObjs, annotationCanvasMap: l3, operatorList: b2.operatorList, pageIndex: this._pageIndex, canvasFactory: this._transport.canvasFactory, filterFactory: this._transport.filterFactory, useRequestAnimationFrame: !y2, pdfBug: this._pdfBug, pageColors: c2, enableHWA: this._transport.enableHWA, filteredOperationIndexes: g2 });
        (b2.renderTasks ||= /* @__PURE__ */ new Set()).add(x2);
        const S2 = x2.task;
        return Promise.all([b2.displayReadyCapability.promise, o2]).then(([e3, t3]) => {
          if (this.destroyed)
            complete();
          else {
            if (this._stats?.time("Rendering"), !(t3.renderingIntent & f2))
              throw new Error("Must use the same `intent`-argument when calling the `PDFPageProxy.render` and `PDFDocumentProxy.getOptionalContentConfig` methods.");
            x2.initializeGraphics({ transparency: e3, optionalContentConfig: t3 }), x2.operatorListChanged();
          }
        }).catch(complete), S2;
      }
      getOperatorList({ intent: e2 = "display", annotationMode: t2 = Bl.ENABLE, printAnnotationStorage: i2 = null, isEditing: a2 = false } = {}) {
        const n2 = this._transport.getRenderingIntent(e2, t2, i2, a2, true);
        let s2, r2 = this._intentStates.get(n2.cacheKey);
        return r2 || (r2 = /* @__PURE__ */ Object.create(null), this._intentStates.set(n2.cacheKey, r2)), r2.opListReadCapability || (s2 = /* @__PURE__ */ Object.create(null), s2.operatorListChanged = function() {
          r2.operatorList.lastChunk && (r2.opListReadCapability.resolve(r2.operatorList), r2.renderTasks.delete(s2));
        }, r2.opListReadCapability = Promise.withResolvers(), (r2.renderTasks ||= /* @__PURE__ */ new Set()).add(s2), r2.operatorList = { fnArray: [], argsArray: [], lastChunk: false, separateAnnots: null }, this._stats?.time("Page Request"), this._pumpOperatorList(n2)), r2.opListReadCapability.promise;
      }
      streamTextContent({ includeMarkedContent: e2 = false, disableNormalization: t2 = false } = {}) {
        return this._transport.messageHandler.sendWithStream("GetTextContent", { pageIndex: this._pageIndex, includeMarkedContent: true === e2, disableNormalization: true === t2 }, { highWaterMark: 100, size: (e3) => e3.items.length });
      }
      getTextContent(e2 = {}) {
        if (this._transport._htmlForXfa)
          return this.getXfa().then((e3) => XfaText.textContent(e3));
        const t2 = this.streamTextContent(e2);
        return new Promise(function(e3, i2) {
          const a2 = t2.getReader(), n2 = { items: [], styles: /* @__PURE__ */ Object.create(null), lang: null };
          !(/* @__PURE__ */ __name(function pump() {
            a2.read().then(function({ value: t3, done: i3 }) {
              i3 ? e3(n2) : (n2.lang ??= t3.lang, Object.assign(n2.styles, t3.styles), n2.items.push(...t3.items), pump());
            }, i2);
          }, "pump"))();
        });
      }
      getStructTree() {
        return this._transport.getStructTree(this._pageIndex);
      }
      _destroy() {
        this.destroyed = true;
        const e2 = [];
        for (const t2 of this._intentStates.values())
          if (this._abortOperatorList({ intentState: t2, reason: new Error("Page was destroyed."), force: true }), !t2.opListReadCapability)
            for (const i2 of t2.renderTasks)
              e2.push(i2.completed), i2.cancel();
        return this.objs.clear(), this.#Qs = false, Promise.all(e2);
      }
      cleanup(e2 = false) {
        this.#Qs = true;
        const t2 = this.#er();
        return e2 && t2 && (this._stats &&= new StatTimer()), t2;
      }
      #er() {
        if (!this.#Qs || this.destroyed)
          return false;
        for (const { renderTasks: e2, operatorList: t2 } of this._intentStates.values())
          if (e2.size > 0 || !t2.lastChunk)
            return false;
        return this._intentStates.clear(), this.objs.clear(), this.#Qs = false, true;
      }
      _startRenderPage(e2, t2) {
        const i2 = this._intentStates.get(t2);
        i2 && (this._stats?.timeEnd("Page Request"), i2.displayReadyCapability?.resolve(e2));
      }
      _renderPageChunk(e2, t2) {
        for (let i2 = 0, a2 = e2.length; i2 < a2; i2++)
          t2.operatorList.fnArray.push(e2.fnArray[i2]), t2.operatorList.argsArray.push(e2.argsArray[i2]);
        t2.operatorList.lastChunk = e2.lastChunk, t2.operatorList.separateAnnots = e2.separateAnnots;
        for (const e3 of t2.renderTasks)
          e3.operatorListChanged();
        e2.lastChunk && this.#er();
      }
      _pumpOperatorList({ renderingIntent: e2, cacheKey: t2, annotationStorageSerializable: i2, modifiedIds: a2 }) {
        const { map: n2, transfer: s2 } = i2, r2 = this._transport.messageHandler.sendWithStream("GetOperatorList", { pageIndex: this._pageIndex, intent: e2, cacheKey: t2, annotationStorage: n2, modifiedIds: a2 }, s2).getReader(), o2 = this._intentStates.get(t2);
        o2.streamReader = r2;
        const pump = /* @__PURE__ */ __name(() => {
          r2.read().then(({ value: e3, done: t3 }) => {
            t3 ? o2.streamReader = null : this._transport.destroyed || (this._renderPageChunk(e3, o2), pump());
          }, (e3) => {
            if (o2.streamReader = null, !this._transport.destroyed) {
              if (o2.operatorList) {
                o2.operatorList.lastChunk = true;
                for (const e4 of o2.renderTasks)
                  e4.operatorListChanged();
                this.#er();
              }
              if (o2.displayReadyCapability)
                o2.displayReadyCapability.reject(e3);
              else {
                if (!o2.opListReadCapability)
                  throw e3;
                o2.opListReadCapability.reject(e3);
              }
            }
          });
        }, "pump");
        pump();
      }
      _abortOperatorList({ intentState: e2, reason: t2, force: i2 = false }) {
        if (e2.streamReader) {
          if (e2.streamReaderCancelTimeout && (clearTimeout(e2.streamReaderCancelTimeout), e2.streamReaderCancelTimeout = null), !i2) {
            if (e2.renderTasks.size > 0)
              return;
            if (t2 instanceof RenderingCancelledException) {
              let i3 = 100;
              return t2.extraDelay > 0 && t2.extraDelay < 1e3 && (i3 += t2.extraDelay), void (e2.streamReaderCancelTimeout = setTimeout(() => {
                e2.streamReaderCancelTimeout = null, this._abortOperatorList({ intentState: e2, reason: t2, force: true });
              }, i3));
            }
          }
          if (e2.streamReader.cancel(new AbortException(t2.message)).catch(() => {
          }), e2.streamReader = null, !this._transport.destroyed) {
            for (const [t3, i3] of this._intentStates)
              if (i3 === e2) {
                this._intentStates.delete(t3);
                break;
              }
            this.cleanup();
          }
        }
      }
      get stats() {
        return this._stats;
      }
    };
    __name(PDFPageProxy, "PDFPageProxy");
    _PDFWorker = class {
      constructor({ name: e2 = null, port: t2 = null, verbosity: i2 = getVerbosityLevel() } = {}) {
        __privateAdd(this, _lr);
        __privateAdd(this, _rr);
        __privateAdd(this, _or);
        __privateAdd(this, _hr);
        __privateAdd(this, _As2, Promise.withResolvers());
        __privateAdd(this, _tr, null);
        __privateAdd(this, _ss2, null);
        __privateAdd(this, _ir, null);
        if (this.name = e2, this.destroyed = false, this.verbosity = i2, t2) {
          if (__privateGet(_PDFWorker, _sr).has(t2))
            throw new Error("Cannot use more than one PDFWorker per port.");
          __privateGet(_PDFWorker, _sr).set(t2, this), __privateMethod(this, _rr, rr_fn).call(this, t2);
        } else
          __privateMethod(this, _or, or_fn).call(this);
      }
      static {
        Cl && (__privateSet(_PDFWorker, _nr, true), GlobalWorkerOptions.workerSrc ||= "./pdf.worker.mjs"), _PDFWorker._isSameOrigin = (e2, t2) => {
          const i2 = URL.parse(e2);
          if (!i2?.origin || "null" === i2.origin)
            return false;
          const a2 = new URL(t2, i2);
          return i2.origin === a2.origin;
        }, _PDFWorker._createCDNWrapper = (e2) => {
          const t2 = `await import("${e2}");`;
          return URL.createObjectURL(new Blob([t2], { type: "text/javascript" }));
        }, _PDFWorker.fromPort = (e2) => {
          var t2;
          if (t2 = "`PDFWorker.fromPort` - please use `PDFWorker.create` instead.", console.log("Deprecated API usage: " + t2), !e2?.port)
            throw new Error("PDFWorker.fromPort - invalid method signature.");
          return _PDFWorker.create(e2);
        };
      }
      get promise() {
        return __privateGet(this, _As2).promise;
      }
      get port() {
        return __privateGet(this, _ss2);
      }
      get messageHandler() {
        return __privateGet(this, _tr);
      }
      destroy() {
        this.destroyed = true, __privateGet(this, _ir)?.terminate(), __privateSet(this, _ir, null), __privateGet(_PDFWorker, _sr).delete(__privateGet(this, _ss2)), __privateSet(this, _ss2, null), __privateGet(this, _tr)?.destroy(), __privateSet(this, _tr, null);
      }
      static create(e2) {
        const t2 = __privateGet(this, _sr).get(e2?.port);
        if (t2) {
          if (t2._pendingDestroy)
            throw new Error("PDFWorker.create - the worker is being destroyed.\nPlease remember to await `PDFDocumentLoadingTask.destroy()`-calls.");
          return t2;
        }
        return new _PDFWorker(e2);
      }
      static get workerSrc() {
        if (GlobalWorkerOptions.workerSrc)
          return GlobalWorkerOptions.workerSrc;
        throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
      }
      static get _setupFakeWorkerGlobal() {
        return shadow(this, "_setupFakeWorkerGlobal", (async () => {
          if (__privateGet(this, _cr, cr_get))
            return __privateGet(this, _cr, cr_get);
          return (await import(this.workerSrc)).WorkerMessageHandler;
        })());
      }
    };
    PDFWorker = _PDFWorker;
    __name(PDFWorker, "PDFWorker");
    _As2 = new WeakMap();
    _tr = new WeakMap();
    _ss2 = new WeakMap();
    _ir = new WeakMap();
    _ar = new WeakMap();
    _nr = new WeakMap();
    _sr = new WeakMap();
    _lr = new WeakSet();
    lr_fn = /* @__PURE__ */ __name(function() {
      __privateGet(this, _As2).resolve(), __privateGet(this, _tr).send("configure", { verbosity: this.verbosity });
    }, "#lr");
    _rr = new WeakSet();
    rr_fn = /* @__PURE__ */ __name(function(e2) {
      __privateSet(this, _ss2, e2), __privateSet(this, _tr, new MessageHandler("main", "worker", e2)), __privateGet(this, _tr).on("ready", () => {
      }), __privateMethod(this, _lr, lr_fn).call(this);
    }, "#rr");
    _or = new WeakSet();
    or_fn = /* @__PURE__ */ __name(function() {
      if (__privateGet(_PDFWorker, _nr) || __privateGet(_PDFWorker, _cr, cr_get))
        return void __privateMethod(this, _hr, hr_fn).call(this);
      let { workerSrc: e2 } = _PDFWorker;
      try {
        _PDFWorker._isSameOrigin(window.location, e2) || (e2 = _PDFWorker._createCDNWrapper(new URL(e2, window.location).href));
        const t2 = new Worker(e2, { type: "module" }), i2 = new MessageHandler("main", "worker", t2), terminateEarly = /* @__PURE__ */ __name(() => {
          a2.abort(), i2.destroy(), t2.terminate(), this.destroyed ? __privateGet(this, _As2).reject(new Error("Worker was destroyed")) : __privateMethod(this, _hr, hr_fn).call(this);
        }, "terminateEarly"), a2 = new AbortController();
        t2.addEventListener("error", () => {
          __privateGet(this, _ir) || terminateEarly();
        }, { signal: a2.signal }), i2.on("test", (e3) => {
          a2.abort(), !this.destroyed && e3 ? (__privateSet(this, _tr, i2), __privateSet(this, _ss2, t2), __privateSet(this, _ir, t2), __privateMethod(this, _lr, lr_fn).call(this)) : terminateEarly();
        }), i2.on("ready", (e3) => {
          if (a2.abort(), this.destroyed)
            terminateEarly();
          else
            try {
              sendTest();
            } catch {
              __privateMethod(this, _hr, hr_fn).call(this);
            }
        });
        const sendTest = /* @__PURE__ */ __name(() => {
          const e3 = new Uint8Array();
          i2.send("test", e3, [e3.buffer]);
        }, "sendTest");
        return void sendTest();
      } catch {
        info3("The worker has been disabled.");
      }
      __privateMethod(this, _hr, hr_fn).call(this);
    }, "#or");
    _hr = new WeakSet();
    hr_fn = /* @__PURE__ */ __name(function() {
      __privateGet(_PDFWorker, _nr) || (warn3("Setting up fake worker."), __privateSet(_PDFWorker, _nr, true)), _PDFWorker._setupFakeWorkerGlobal.then((e2) => {
        if (this.destroyed)
          return void __privateGet(this, _As2).reject(new Error("Worker was destroyed"));
        const t2 = new LoopbackPort();
        __privateSet(this, _ss2, t2);
        const i2 = "fake" + __privateWrapper(_PDFWorker, _ar)._++, a2 = new MessageHandler(i2 + "_worker", i2, t2);
        e2.setup(a2, t2), __privateSet(this, _tr, new MessageHandler(i2, i2 + "_worker", t2)), __privateMethod(this, _lr, lr_fn).call(this);
      }).catch((e2) => {
        __privateGet(this, _As2).reject(new Error(`Setting up fake worker failed: "${e2.message}".`));
      });
    }, "#hr");
    _cr = new WeakSet();
    cr_get = /* @__PURE__ */ __name(function() {
      try {
        return globalThis.pdfjsWorker?.WorkerMessageHandler || null;
      } catch {
        return null;
      }
    }, "#cr");
    __privateAdd(PDFWorker, _cr);
    __privateAdd(PDFWorker, _ar, 0);
    __privateAdd(PDFWorker, _nr, true);
    __privateAdd(PDFWorker, _sr, /* @__PURE__ */ new WeakMap());
    WorkerTransport = class {
      #dr = /* @__PURE__ */ new Map();
      #ur = /* @__PURE__ */ new Map();
      #qe = /* @__PURE__ */ new Map();
      #gr = /* @__PURE__ */ new Map();
      #pr = null;
      constructor(e2, t2, i2, a2, n2, s2) {
        this.messageHandler = e2, this.loadingTask = t2, this.commonObjs = new PDFObjects(), this.fontLoader = new FontLoader({ ownerDocument: a2.ownerDocument, styleElement: a2.styleElement }), this.loadingParams = a2.loadingParams, this._params = a2, this.canvasFactory = n2.canvasFactory, this.filterFactory = n2.filterFactory, this.cMapReaderFactory = n2.cMapReaderFactory, this.standardFontDataFactory = n2.standardFontDataFactory, this.wasmFactory = n2.wasmFactory, this.destroyed = false, this.destroyCapability = null, this._networkStream = i2, this._fullReader = null, this._lastProgress = null, this.downloadInfoCapability = Promise.withResolvers(), this.enableHWA = s2, this.setupMessageHandler();
      }
      #fr(e2, t2 = null) {
        const i2 = this.#dr.get(e2);
        if (i2)
          return i2;
        const a2 = this.messageHandler.sendWithPromise(e2, t2);
        return this.#dr.set(e2, a2), a2;
      }
      get annotationStorage() {
        return shadow(this, "annotationStorage", new AnnotationStorage());
      }
      getRenderingIntent(e2, t2 = Bl.ENABLE, i2 = null, a2 = false, n2 = false) {
        let s2 = Fl, r2 = wc;
        switch (e2) {
          case "any":
            s2 = Il;
            break;
          case "display":
            break;
          case "print":
            s2 = Ml;
            break;
          default:
            warn3(`getRenderingIntent - invalid intent: ${e2}`);
        }
        const o2 = s2 & Ml && i2 instanceof PrintAnnotationStorage ? i2 : this.annotationStorage;
        switch (t2) {
          case Bl.DISABLE:
            s2 += _l2;
            break;
          case Bl.ENABLE:
            break;
          case Bl.ENABLE_FORMS:
            s2 += Dl;
            break;
          case Bl.ENABLE_STORAGE:
            s2 += El, r2 = o2.serializable;
            break;
          default:
            warn3(`getRenderingIntent - invalid annotationMode: ${t2}`);
        }
        a2 && (s2 += Pl), n2 && (s2 += Rl);
        const { ids: l3, hash: c2 } = o2.modifiedIds;
        return { renderingIntent: s2, cacheKey: [s2, r2.hash, c2].join("_"), annotationStorageSerializable: r2, modifiedIds: l3 };
      }
      destroy() {
        if (this.destroyCapability)
          return this.destroyCapability.promise;
        this.destroyed = true, this.destroyCapability = Promise.withResolvers(), this.#pr?.reject(new Error("Worker was destroyed during onPassword callback"));
        const e2 = [];
        for (const t3 of this.#ur.values())
          e2.push(t3._destroy());
        this.#ur.clear(), this.#qe.clear(), this.#gr.clear(), this.hasOwnProperty("annotationStorage") && this.annotationStorage.resetModified();
        const t2 = this.messageHandler.sendWithPromise("Terminate", null);
        return e2.push(t2), Promise.all(e2).then(() => {
          this.commonObjs.clear(), this.fontLoader.clear(), this.#dr.clear(), this.filterFactory.destroy(), TextLayer.cleanup(), this._networkStream?.cancelAllRequests(new AbortException("Worker was terminated.")), this.messageHandler?.destroy(), this.messageHandler = null, this.destroyCapability.resolve();
        }, this.destroyCapability.reject), this.destroyCapability.promise;
      }
      setupMessageHandler() {
        const { messageHandler: e2, loadingTask: t2 } = this;
        e2.on("GetReader", (e3, t3) => {
          assert3(this._networkStream, "GetReader - no `IPDFStream` instance available."), this._fullReader = this._networkStream.getFullReader(), this._fullReader.onProgress = (e4) => {
            this._lastProgress = { loaded: e4.loaded, total: e4.total };
          }, t3.onPull = () => {
            this._fullReader.read().then(function({ value: e4, done: i2 }) {
              i2 ? t3.close() : (assert3(e4 instanceof ArrayBuffer, "GetReader - expected an ArrayBuffer."), t3.enqueue(new Uint8Array(e4), 1, [e4]));
            }).catch((e4) => {
              t3.error(e4);
            });
          }, t3.onCancel = (e4) => {
            this._fullReader.cancel(e4), t3.ready.catch((e5) => {
              if (!this.destroyed)
                throw e5;
            });
          };
        }), e2.on("ReaderHeadersReady", async (e3) => {
          await this._fullReader.headersReady;
          const { isStreamingSupported: i2, isRangeSupported: a2, contentLength: n2 } = this._fullReader;
          return i2 && a2 || (this._lastProgress && t2.onProgress?.(this._lastProgress), this._fullReader.onProgress = (e4) => {
            t2.onProgress?.({ loaded: e4.loaded, total: e4.total });
          }), { isStreamingSupported: i2, isRangeSupported: a2, contentLength: n2 };
        }), e2.on("GetRangeReader", (e3, t3) => {
          assert3(this._networkStream, "GetRangeReader - no `IPDFStream` instance available.");
          const i2 = this._networkStream.getRangeReader(e3.begin, e3.end);
          i2 ? (t3.onPull = () => {
            i2.read().then(function({ value: e4, done: i3 }) {
              i3 ? t3.close() : (assert3(e4 instanceof ArrayBuffer, "GetRangeReader - expected an ArrayBuffer."), t3.enqueue(new Uint8Array(e4), 1, [e4]));
            }).catch((e4) => {
              t3.error(e4);
            });
          }, t3.onCancel = (e4) => {
            i2.cancel(e4), t3.ready.catch((e5) => {
              if (!this.destroyed)
                throw e5;
            });
          }) : t3.close();
        }), e2.on("GetDoc", ({ pdfInfo: e3 }) => {
          this._numPages = e3.numPages, this._htmlForXfa = e3.htmlForXfa, delete e3.htmlForXfa, t2._capability.resolve(new PDFDocumentProxy(e3, this));
        }), e2.on("DocException", (e3) => {
          t2._capability.reject(wrapReason(e3));
        }), e2.on("PasswordRequest", (e3) => {
          this.#pr = Promise.withResolvers();
          try {
            if (!t2.onPassword)
              throw wrapReason(e3);
            const updatePassword = /* @__PURE__ */ __name((e4) => {
              e4 instanceof Error ? this.#pr.reject(e4) : this.#pr.resolve({ password: e4 });
            }, "updatePassword");
            t2.onPassword(updatePassword, e3.code);
          } catch (e4) {
            this.#pr.reject(e4);
          }
          return this.#pr.promise;
        }), e2.on("DataLoaded", (e3) => {
          t2.onProgress?.({ loaded: e3.length, total: e3.length }), this.downloadInfoCapability.resolve(e3);
        }), e2.on("StartRenderPage", (e3) => {
          if (this.destroyed)
            return;
          this.#ur.get(e3.pageIndex)._startRenderPage(e3.transparency, e3.cacheKey);
        }), e2.on("commonobj", ([t3, i2, a2]) => {
          if (this.destroyed)
            return null;
          if (this.commonObjs.has(t3))
            return null;
          switch (i2) {
            case "Font":
              if ("error" in a2) {
                const e3 = a2.error;
                warn3(`Error during font loading: ${e3}`), this.commonObjs.resolve(t3, e3);
                break;
              }
              const n2 = this._params.pdfBug && globalThis.FontInspector?.enabled ? (e3, t4) => globalThis.FontInspector.fontAdded(e3, t4) : null, s2 = new FontFaceObject(a2, n2);
              this.fontLoader.bind(s2).catch(() => e2.sendWithPromise("FontFallback", { id: t3 })).finally(() => {
                !s2.fontExtraProperties && s2.data && (s2.data = null), this.commonObjs.resolve(t3, s2);
              });
              break;
            case "CopyLocalImage":
              const { imageRef: r2 } = a2;
              assert3(r2, "The imageRef must be defined.");
              for (const e3 of this.#ur.values())
                for (const [, i3] of e3.objs)
                  if (i3?.ref === r2)
                    return i3.dataLen ? (this.commonObjs.resolve(t3, structuredClone(i3)), i3.dataLen) : null;
              break;
            case "FontPath":
            case "Image":
            case "Pattern":
              this.commonObjs.resolve(t3, a2);
              break;
            default:
              throw new Error(`Got unknown common object type ${i2}`);
          }
          return null;
        }), e2.on("obj", ([e3, t3, i2, a2]) => {
          if (this.destroyed)
            return;
          const n2 = this.#ur.get(t3);
          if (!n2.objs.has(e3))
            if (0 !== n2._intentStates.size)
              switch (i2) {
                case "Image":
                case "Pattern":
                  n2.objs.resolve(e3, a2);
                  break;
                default:
                  throw new Error(`Got unknown object type ${i2}`);
              }
            else
              a2?.bitmap?.close();
        }), e2.on("DocProgress", (e3) => {
          this.destroyed || t2.onProgress?.({ loaded: e3.loaded, total: e3.total });
        }), e2.on("FetchBinaryData", async (e3) => {
          if (this.destroyed)
            throw new Error("Worker was destroyed.");
          const t3 = this[e3.type];
          if (!t3)
            throw new Error(`${e3.type} not initialized, see the \`useWorkerFetch\` parameter.`);
          return t3.fetch(e3);
        });
      }
      getData() {
        return this.messageHandler.sendWithPromise("GetData", null);
      }
      saveDocument() {
        this.annotationStorage.size <= 0 && warn3("saveDocument called while `annotationStorage` is empty, please use the getData-method instead.");
        const { map: e2, transfer: t2 } = this.annotationStorage.serializable;
        return this.messageHandler.sendWithPromise("SaveDocument", { isPureXfa: !!this._htmlForXfa, numPages: this._numPages, annotationStorage: e2, filename: this._fullReader?.filename ?? null }, t2).finally(() => {
          this.annotationStorage.resetModified();
        });
      }
      getPage(e2) {
        if (!Number.isInteger(e2) || e2 <= 0 || e2 > this._numPages)
          return Promise.reject(new Error("Invalid page request."));
        const t2 = e2 - 1, i2 = this.#qe.get(t2);
        if (i2)
          return i2;
        const a2 = this.messageHandler.sendWithPromise("GetPage", { pageIndex: t2 }).then((i3) => {
          if (this.destroyed)
            throw new Error("Transport destroyed");
          i3.refStr && this.#gr.set(i3.refStr, e2);
          const a3 = new PDFPageProxy(t2, i3, this, this._params.pdfBug);
          return this.#ur.set(t2, a3), a3;
        });
        return this.#qe.set(t2, a2), a2;
      }
      getPageIndex(e2) {
        return isRefProxy(e2) ? this.messageHandler.sendWithPromise("GetPageIndex", { num: e2.num, gen: e2.gen }) : Promise.reject(new Error("Invalid pageIndex request."));
      }
      getAnnotations(e2, t2) {
        return this.messageHandler.sendWithPromise("GetAnnotations", { pageIndex: e2, intent: t2 });
      }
      getFieldObjects() {
        return this.#fr("GetFieldObjects");
      }
      hasJSActions() {
        return this.#fr("HasJSActions");
      }
      getCalculationOrderIds() {
        return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
      }
      getDestinations() {
        return this.messageHandler.sendWithPromise("GetDestinations", null);
      }
      getDestination(e2) {
        return "string" != typeof e2 ? Promise.reject(new Error("Invalid destination request.")) : this.messageHandler.sendWithPromise("GetDestination", { id: e2 });
      }
      getPageLabels() {
        return this.messageHandler.sendWithPromise("GetPageLabels", null);
      }
      getPageLayout() {
        return this.messageHandler.sendWithPromise("GetPageLayout", null);
      }
      getPageMode() {
        return this.messageHandler.sendWithPromise("GetPageMode", null);
      }
      getViewerPreferences() {
        return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
      }
      getOpenAction() {
        return this.messageHandler.sendWithPromise("GetOpenAction", null);
      }
      getAttachments() {
        return this.messageHandler.sendWithPromise("GetAttachments", null);
      }
      getAnnotationsByType(e2, t2) {
        return this.messageHandler.sendWithPromise("GetAnnotationsByType", { types: e2, pageIndexesToSkip: t2 });
      }
      getDocJSActions() {
        return this.#fr("GetDocJSActions");
      }
      getPageJSActions(e2) {
        return this.messageHandler.sendWithPromise("GetPageJSActions", { pageIndex: e2 });
      }
      getStructTree(e2) {
        return this.messageHandler.sendWithPromise("GetStructTree", { pageIndex: e2 });
      }
      getOutline() {
        return this.messageHandler.sendWithPromise("GetOutline", null);
      }
      getOptionalContentConfig(e2) {
        return this.#fr("GetOptionalContentConfig").then((t2) => new OptionalContentConfig(t2, e2));
      }
      getPermissions() {
        return this.messageHandler.sendWithPromise("GetPermissions", null);
      }
      getMetadata() {
        const e2 = "GetMetadata", t2 = this.#dr.get(e2);
        if (t2)
          return t2;
        const i2 = this.messageHandler.sendWithPromise(e2, null).then((e3) => ({ info: e3[0], metadata: e3[1] ? new Metadata(e3[1]) : null, contentDispositionFilename: this._fullReader?.filename ?? null, contentLength: this._fullReader?.contentLength ?? null }));
        return this.#dr.set(e2, i2), i2;
      }
      getMarkInfo() {
        return this.messageHandler.sendWithPromise("GetMarkInfo", null);
      }
      async startCleanup(e2 = false) {
        if (!this.destroyed) {
          await this.messageHandler.sendWithPromise("Cleanup", null);
          for (const e3 of this.#ur.values()) {
            if (!e3.cleanup())
              throw new Error(`startCleanup: Page ${e3.pageNumber} is currently rendering.`);
          }
          this.commonObjs.clear(), e2 || this.fontLoader.clear(), this.#dr.clear(), this.filterFactory.destroy(true), TextLayer.cleanup();
        }
      }
      cachedPageNumber(e2) {
        if (!isRefProxy(e2))
          return null;
        const t2 = 0 === e2.gen ? `${e2.num}R` : `${e2.num}R${e2.gen}`;
        return this.#gr.get(t2) ?? null;
      }
    };
    __name(WorkerTransport, "WorkerTransport");
    RenderTask = class {
      #mr = null;
      onContinue = null;
      onError = null;
      constructor(e2) {
        this.#mr = e2;
      }
      get promise() {
        return this.#mr.capability.promise;
      }
      cancel(e2 = 0) {
        this.#mr.cancel(null, e2);
      }
      get separateAnnots() {
        const { separateAnnots: e2 } = this.#mr.operatorList;
        if (!e2)
          return false;
        const { annotationCanvasMap: t2 } = this.#mr;
        return e2.form || e2.canvas && t2?.size > 0;
      }
    };
    __name(RenderTask, "RenderTask");
    _InternalRenderTask = class {
      constructor({ callback: e2, params: t2, objs: i2, commonObjs: a2, annotationCanvasMap: n2, operatorList: s2, pageIndex: r2, canvasFactory: o2, filterFactory: l3, useRequestAnimationFrame: c2 = false, pdfBug: h2 = false, pageColors: d2 = null, enableHWA: u2 = false, filteredOperationIndexes: g2 = null }) {
        __privateAdd(this, _br, null);
        this.callback = e2, this.params = t2, this.objs = i2, this.commonObjs = a2, this.annotationCanvasMap = n2, this.operatorListIdx = null, this.operatorList = s2, this._pageIndex = r2, this.canvasFactory = o2, this.filterFactory = l3, this._pdfBug = h2, this.pageColors = d2, this.running = false, this.graphicsReadyCallback = null, this.graphicsReady = false, this._useRequestAnimationFrame = true === c2 && "undefined" != typeof window, this.cancelled = false, this.capability = Promise.withResolvers(), this.task = new RenderTask(this), this._cancelBound = this.cancel.bind(this), this._continueBound = this._continue.bind(this), this._scheduleNextBound = this._scheduleNext.bind(this), this._nextBound = this._next.bind(this), this._canvas = t2.canvas, this._canvasContext = t2.canvas ? null : t2.canvasContext, this._enableHWA = u2, this._dependencyTracker = t2.dependencyTracker, this._filteredOperationIndexes = g2;
      }
      get completed() {
        return this.capability.promise.catch(function() {
        });
      }
      initializeGraphics({ transparency: e2 = false, optionalContentConfig: t2 }) {
        if (this.cancelled)
          return;
        if (this._canvas) {
          if (__privateGet(_InternalRenderTask, _yr).has(this._canvas))
            throw new Error("Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed.");
          __privateGet(_InternalRenderTask, _yr).add(this._canvas);
        }
        this._pdfBug && globalThis.StepperManager?.enabled && (this.stepper = globalThis.StepperManager.create(this._pageIndex), this.stepper.init(this.operatorList), this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint());
        const { viewport: i2, transform: a2, background: n2, dependencyTracker: s2 } = this.params, r2 = this._canvasContext || this._canvas.getContext("2d", { alpha: false, willReadFrequently: !this._enableHWA });
        this.gfx = new CanvasGraphics(r2, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, { optionalContentConfig: t2 }, this.annotationCanvasMap, this.pageColors, s2), this.gfx.beginDrawing({ transform: a2, viewport: i2, transparency: e2, background: n2 }), this.operatorListIdx = 0, this.graphicsReady = true, this.graphicsReadyCallback?.();
      }
      cancel(e2 = null, t2 = 0) {
        this.running = false, this.cancelled = true, this.gfx?.endDrawing(), __privateGet(this, _br) && (window.cancelAnimationFrame(__privateGet(this, _br)), __privateSet(this, _br, null)), __privateGet(_InternalRenderTask, _yr).delete(this._canvas), e2 ||= new RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, t2), this.callback(e2), this.task.onError?.(e2);
      }
      operatorListChanged() {
        this.graphicsReady ? (this.stepper?.updateOperatorList(this.operatorList), this.running || this._continue()) : this.graphicsReadyCallback ||= this._continueBound;
      }
      _continue() {
        this.running = true, this.cancelled || (this.task.onContinue ? this.task.onContinue(this._scheduleNextBound) : this._scheduleNext());
      }
      _scheduleNext() {
        this._useRequestAnimationFrame ? __privateSet(this, _br, window.requestAnimationFrame(() => {
          __privateSet(this, _br, null), this._nextBound().catch(this._cancelBound);
        })) : Promise.resolve().then(this._nextBound).catch(this._cancelBound);
      }
      async _next() {
        this.cancelled || (this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper, this._filteredOperationIndexes), this.operatorListIdx === this.operatorList.argsArray.length && (this.running = false, this.operatorList.lastChunk && (this.gfx.endDrawing(), __privateGet(_InternalRenderTask, _yr).delete(this._canvas), this.callback())));
      }
    };
    InternalRenderTask = _InternalRenderTask;
    __name(InternalRenderTask, "InternalRenderTask");
    _br = new WeakMap();
    _yr = new WeakMap();
    __privateAdd(InternalRenderTask, _yr, /* @__PURE__ */ new WeakSet());
    th = "5.4.149";
    ih = "9e2e9e209";
    _ColorPicker = class {
      constructor({ editor: e2 = null, uiManager: t2 = null }) {
        __privateAdd(this, _Dr);
        __privateAdd(this, _Er);
        __privateAdd(this, _Mr);
        __privateAdd(this, _Fr);
        __privateAdd(this, _dt2);
        __privateAdd(this, _Or);
        __privateAdd(this, _wr, null);
        __privateAdd(this, _Ar, null);
        __privateAdd(this, _xr, void 0);
        __privateAdd(this, _Sr, null);
        __privateAdd(this, _vr, false);
        __privateAdd(this, _Cr, false);
        __privateAdd(this, _st3, null);
        __privateAdd(this, _kr, void 0);
        __privateAdd(this, _Tr, null);
        __privateAdd(this, _mt, null);
        e2 ? (__privateSet(this, _Cr, false), __privateSet(this, _st3, e2)) : __privateSet(this, _Cr, true), __privateSet(this, _mt, e2?._uiManager || t2), __privateSet(this, _kr, __privateGet(this, _mt)._eventBus), __privateSet(this, _xr, e2?.color?.toUpperCase() || __privateGet(this, _mt)?.highlightColors.values().next().value || "#FFFF98"), __privateGet(_ColorPicker, _Ir) || __privateSet(_ColorPicker, _Ir, Object.freeze({ blue: "pdfjs-editor-colorpicker-blue", green: "pdfjs-editor-colorpicker-green", pink: "pdfjs-editor-colorpicker-pink", red: "pdfjs-editor-colorpicker-red", yellow: "pdfjs-editor-colorpicker-yellow" }));
      }
      static get _keyboardManager() {
        return shadow(this, "_keyboardManager", new KeyboardManager([[["Escape", "mac+Escape"], _ColorPicker.prototype._hideDropdownFromKeyboard], [[" ", "mac+ "], _ColorPicker.prototype._colorSelectFromKeyboard], [["ArrowDown", "ArrowRight", "mac+ArrowDown", "mac+ArrowRight"], _ColorPicker.prototype._moveToNext], [["ArrowUp", "ArrowLeft", "mac+ArrowUp", "mac+ArrowLeft"], _ColorPicker.prototype._moveToPrevious], [["Home", "mac+Home"], _ColorPicker.prototype._moveToBeginning], [["End", "mac+End"], _ColorPicker.prototype._moveToEnd]]));
      }
      renderButton() {
        const e2 = __privateSet(this, _wr, document.createElement("button"));
        e2.className = "colorPicker", e2.tabIndex = "0", e2.setAttribute("data-l10n-id", "pdfjs-editor-colorpicker-button"), e2.ariaHasPopup = "true", __privateGet(this, _st3) && (e2.ariaControls = `${__privateGet(this, _st3).id}_colorpicker_dropdown`);
        const t2 = __privateGet(this, _mt)._signal;
        e2.addEventListener("click", __privateMethod(this, _Fr, Fr_fn).bind(this), { signal: t2 }), e2.addEventListener("keydown", __privateMethod(this, _Mr, Mr_fn).bind(this), { signal: t2 });
        const i2 = __privateSet(this, _Ar, document.createElement("span"));
        return i2.className = "swatch", i2.ariaHidden = "true", i2.style.backgroundColor = __privateGet(this, _xr), e2.append(i2), e2;
      }
      renderMainDropdown() {
        const e2 = __privateSet(this, _Sr, __privateMethod(this, _Dr, Dr_fn).call(this));
        return e2.ariaOrientation = "horizontal", e2.ariaLabelledBy = "highlightColorPickerLabel", e2;
      }
      _colorSelectFromKeyboard(e2) {
        if (e2.target === __privateGet(this, _wr))
          return void __privateMethod(this, _Fr, Fr_fn).call(this, e2);
        const t2 = e2.target.getAttribute("data-color");
        t2 && __privateMethod(this, _Er, Er_fn).call(this, t2, e2);
      }
      _moveToNext(e2) {
        __privateGet(this, _Or, Or_get) ? e2.target !== __privateGet(this, _wr) ? e2.target.nextSibling?.focus() : __privateGet(this, _Sr).firstChild?.focus() : __privateMethod(this, _Fr, Fr_fn).call(this, e2);
      }
      _moveToPrevious(e2) {
        e2.target !== __privateGet(this, _Sr)?.firstChild && e2.target !== __privateGet(this, _wr) ? (__privateGet(this, _Or, Or_get) || __privateMethod(this, _Fr, Fr_fn).call(this, e2), e2.target.previousSibling?.focus()) : __privateGet(this, _Or, Or_get) && this._hideDropdownFromKeyboard();
      }
      _moveToBeginning(e2) {
        __privateGet(this, _Or, Or_get) ? __privateGet(this, _Sr).firstChild?.focus() : __privateMethod(this, _Fr, Fr_fn).call(this, e2);
      }
      _moveToEnd(e2) {
        __privateGet(this, _Or, Or_get) ? __privateGet(this, _Sr).lastChild?.focus() : __privateMethod(this, _Fr, Fr_fn).call(this, e2);
      }
      hideDropdown() {
        __privateGet(this, _Sr)?.classList.add("hidden"), __privateGet(this, _wr).ariaExpanded = "false", __privateGet(this, _Tr)?.abort(), __privateSet(this, _Tr, null);
      }
      _hideDropdownFromKeyboard() {
        __privateGet(this, _Cr) || (__privateGet(this, _Or, Or_get) ? (this.hideDropdown(), __privateGet(this, _wr).focus({ preventScroll: true, focusVisible: __privateGet(this, _vr) })) : __privateGet(this, _st3)?.unselect());
      }
      updateColor(e2) {
        if (__privateGet(this, _Ar) && (__privateGet(this, _Ar).style.backgroundColor = e2), !__privateGet(this, _Sr))
          return;
        const t2 = __privateGet(this, _mt).highlightColors.values();
        for (const i2 of __privateGet(this, _Sr).children)
          i2.ariaSelected = t2.next().value === e2.toUpperCase();
      }
      destroy() {
        __privateGet(this, _wr)?.remove(), __privateSet(this, _wr, null), __privateSet(this, _Ar, null), __privateGet(this, _Sr)?.remove(), __privateSet(this, _Sr, null);
      }
    };
    ColorPicker = _ColorPicker;
    __name(ColorPicker, "ColorPicker");
    _wr = new WeakMap();
    _Ar = new WeakMap();
    _xr = new WeakMap();
    _Sr = new WeakMap();
    _vr = new WeakMap();
    _Cr = new WeakMap();
    _st3 = new WeakMap();
    _kr = new WeakMap();
    _Tr = new WeakMap();
    _mt = new WeakMap();
    _Ir = new WeakMap();
    _Dr = new WeakSet();
    Dr_fn = /* @__PURE__ */ __name(function() {
      const e2 = document.createElement("div"), t2 = __privateGet(this, _mt)._signal;
      e2.addEventListener("contextmenu", noContextMenu, { signal: t2 }), e2.className = "dropdown", e2.role = "listbox", e2.ariaMultiSelectable = "false", e2.ariaOrientation = "vertical", e2.setAttribute("data-l10n-id", "pdfjs-editor-colorpicker-dropdown"), __privateGet(this, _st3) && (e2.id = `${__privateGet(this, _st3).id}_colorpicker_dropdown`);
      for (const [i2, a2] of __privateGet(this, _mt).highlightColors) {
        const n2 = document.createElement("button");
        n2.tabIndex = "0", n2.role = "option", n2.setAttribute("data-color", a2), n2.title = i2, n2.setAttribute("data-l10n-id", __privateGet(_ColorPicker, _Ir)[i2]);
        const s2 = document.createElement("span");
        n2.append(s2), s2.className = "swatch", s2.style.backgroundColor = a2, n2.ariaSelected = a2 === __privateGet(this, _xr), n2.addEventListener("click", __privateMethod(this, _Er, Er_fn).bind(this, a2), { signal: t2 }), e2.append(n2);
      }
      return e2.addEventListener("keydown", __privateMethod(this, _Mr, Mr_fn).bind(this), { signal: t2 }), e2;
    }, "#Dr");
    _Er = new WeakSet();
    Er_fn = /* @__PURE__ */ __name(function(e2, t2) {
      t2.stopPropagation(), __privateGet(this, _kr).dispatch("switchannotationeditorparams", { source: this, type: jl.HIGHLIGHT_COLOR, value: e2 }), this.updateColor(e2);
    }, "#Er");
    _Mr = new WeakSet();
    Mr_fn = /* @__PURE__ */ __name(function(e2) {
      _ColorPicker._keyboardManager.exec(this, e2);
    }, "#Mr");
    _Fr = new WeakSet();
    Fr_fn = /* @__PURE__ */ __name(function(e2) {
      if (__privateGet(this, _Or, Or_get))
        return void this.hideDropdown();
      if (__privateSet(this, _vr, 0 === e2.detail), __privateGet(this, _Tr) || (__privateSet(this, _Tr, new AbortController()), window.addEventListener("pointerdown", __privateMethod(this, _dt2, dt_fn2).bind(this), { signal: __privateGet(this, _mt).combinedSignal(__privateGet(this, _Tr)) })), __privateGet(this, _wr).ariaExpanded = "true", __privateGet(this, _Sr))
        return void __privateGet(this, _Sr).classList.remove("hidden");
      const t2 = __privateSet(this, _Sr, __privateMethod(this, _Dr, Dr_fn).call(this));
      __privateGet(this, _wr).append(t2);
    }, "#Fr");
    _dt2 = new WeakSet();
    dt_fn2 = /* @__PURE__ */ __name(function(e2) {
      __privateGet(this, _Sr)?.contains(e2.target) || this.hideDropdown();
    }, "#dt");
    _Or = new WeakSet();
    Or_get = /* @__PURE__ */ __name(function() {
      return __privateGet(this, _Sr) && !__privateGet(this, _Sr).classList.contains("hidden");
    }, "#Or");
    __privateAdd(ColorPicker, _Ir, null);
    _BasicColorPicker = class {
      constructor(e2) {
        __privateAdd(this, __r, null);
        __privateAdd(this, _st4, null);
        __privateAdd(this, _mt2, null);
        __privateSet(this, _st4, e2), __privateSet(this, _mt2, e2._uiManager), __privateGet(_BasicColorPicker, _Ir2) || __privateSet(_BasicColorPicker, _Ir2, Object.freeze({ freetext: "pdfjs-editor-color-picker-free-text-input", ink: "pdfjs-editor-color-picker-ink-input" }));
      }
      renderButton() {
        if (__privateGet(this, __r))
          return __privateGet(this, __r);
        const { editorType: e2, colorType: t2, colorValue: i2 } = __privateGet(this, _st4), a2 = __privateSet(this, __r, document.createElement("input"));
        return a2.type = "color", a2.value = i2 || "#000000", a2.className = "basicColorPicker", a2.tabIndex = 0, a2.setAttribute("data-l10n-id", __privateGet(_BasicColorPicker, _Ir2)[e2]), a2.addEventListener("input", () => {
          __privateGet(this, _mt2).updateParams(t2, a2.value);
        }, { signal: __privateGet(this, _mt2)._signal }), a2;
      }
      update(e2) {
        __privateGet(this, __r) && (__privateGet(this, __r).value = e2);
      }
      destroy() {
        __privateGet(this, __r)?.remove(), __privateSet(this, __r, null);
      }
      hideDropdown() {
      }
    };
    BasicColorPicker = _BasicColorPicker;
    __name(BasicColorPicker, "BasicColorPicker");
    __r = new WeakMap();
    _st4 = new WeakMap();
    _mt2 = new WeakMap();
    _Ir2 = new WeakMap();
    __privateAdd(BasicColorPicker, _Ir2, null);
    __name(makeColorComp, "makeColorComp");
    __name(scaleAndClamp, "scaleAndClamp");
    ColorConverters = class {
      static CMYK_G([e2, t2, i2, a2]) {
        return ["G", 1 - Math.min(1, 0.3 * e2 + 0.59 * i2 + 0.11 * t2 + a2)];
      }
      static G_CMYK([e2]) {
        return ["CMYK", 0, 0, 0, 1 - e2];
      }
      static G_RGB([e2]) {
        return ["RGB", e2, e2, e2];
      }
      static G_rgb([e2]) {
        return [e2 = scaleAndClamp(e2), e2, e2];
      }
      static G_HTML([e2]) {
        const t2 = makeColorComp(e2);
        return `#${t2}${t2}${t2}`;
      }
      static RGB_G([e2, t2, i2]) {
        return ["G", 0.3 * e2 + 0.59 * t2 + 0.11 * i2];
      }
      static RGB_rgb(e2) {
        return e2.map(scaleAndClamp);
      }
      static RGB_HTML(e2) {
        return `#${e2.map(makeColorComp).join("")}`;
      }
      static T_HTML() {
        return "#00000000";
      }
      static T_rgb() {
        return [null];
      }
      static CMYK_RGB([e2, t2, i2, a2]) {
        return ["RGB", 1 - Math.min(1, e2 + a2), 1 - Math.min(1, i2 + a2), 1 - Math.min(1, t2 + a2)];
      }
      static CMYK_rgb([e2, t2, i2, a2]) {
        return [scaleAndClamp(1 - Math.min(1, e2 + a2)), scaleAndClamp(1 - Math.min(1, i2 + a2)), scaleAndClamp(1 - Math.min(1, t2 + a2))];
      }
      static CMYK_HTML(e2) {
        const t2 = this.CMYK_RGB(e2).slice(1);
        return this.RGB_HTML(t2);
      }
      static RGB_CMYK([e2, t2, i2]) {
        const a2 = 1 - e2, n2 = 1 - t2, s2 = 1 - i2;
        return ["CMYK", a2, n2, s2, Math.min(a2, n2, s2)];
      }
    };
    __name(ColorConverters, "ColorConverters");
    BaseSVGFactory = class {
      create(e2, t2, i2 = false) {
        if (e2 <= 0 || t2 <= 0)
          throw new Error("Invalid SVG dimensions");
        const a2 = this._createSVG("svg:svg");
        return a2.setAttribute("version", "1.1"), i2 || (a2.setAttribute("width", `${e2}px`), a2.setAttribute("height", `${t2}px`)), a2.setAttribute("preserveAspectRatio", "none"), a2.setAttribute("viewBox", `0 0 ${e2} ${t2}`), a2;
      }
      createElement(e2) {
        if ("string" != typeof e2)
          throw new Error("Invalid SVG element type");
        return this._createSVG(e2);
      }
      _createSVG(e2) {
        unreachable("Abstract method `_createSVG` called.");
      }
    };
    __name(BaseSVGFactory, "BaseSVGFactory");
    DOMSVGFactory = class extends BaseSVGFactory {
      _createSVG(e2) {
        return document.createElementNS(pc, e2);
      }
    };
    __name(DOMSVGFactory, "DOMSVGFactory");
    XfaLayer = class {
      static setupStorage(e2, t2, i2, a2, n2) {
        const s2 = a2.getValue(t2, { value: null });
        switch (i2.name) {
          case "textarea":
            if (null !== s2.value && (e2.textContent = s2.value), "print" === n2)
              break;
            e2.addEventListener("input", (e3) => {
              a2.setValue(t2, { value: e3.target.value });
            });
            break;
          case "input":
            if ("radio" === i2.attributes.type || "checkbox" === i2.attributes.type) {
              if (s2.value === i2.attributes.xfaOn ? e2.setAttribute("checked", true) : s2.value === i2.attributes.xfaOff && e2.removeAttribute("checked"), "print" === n2)
                break;
              e2.addEventListener("change", (e3) => {
                a2.setValue(t2, { value: e3.target.checked ? e3.target.getAttribute("xfaOn") : e3.target.getAttribute("xfaOff") });
              });
            } else {
              if (null !== s2.value && e2.setAttribute("value", s2.value), "print" === n2)
                break;
              e2.addEventListener("input", (e3) => {
                a2.setValue(t2, { value: e3.target.value });
              });
            }
            break;
          case "select":
            if (null !== s2.value) {
              e2.setAttribute("value", s2.value);
              for (const e3 of i2.children)
                e3.attributes.value === s2.value ? e3.attributes.selected = true : e3.attributes.hasOwnProperty("selected") && delete e3.attributes.selected;
            }
            e2.addEventListener("input", (e3) => {
              const i3 = e3.target.options, n3 = -1 === i3.selectedIndex ? "" : i3[i3.selectedIndex].value;
              a2.setValue(t2, { value: n3 });
            });
        }
      }
      static setAttributes({ html: e2, element: t2, storage: i2 = null, intent: a2, linkService: n2 }) {
        const { attributes: s2 } = t2, r2 = e2 instanceof HTMLAnchorElement;
        "radio" === s2.type && (s2.name = `${s2.name}-${a2}`);
        for (const [t3, i3] of Object.entries(s2))
          if (null != i3)
            switch (t3) {
              case "class":
                i3.length && e2.setAttribute(t3, i3.join(" "));
                break;
              case "dataId":
                break;
              case "id":
                e2.setAttribute("data-element-id", i3);
                break;
              case "style":
                Object.assign(e2.style, i3);
                break;
              case "textContent":
                e2.textContent = i3;
                break;
              default:
                (!r2 || "href" !== t3 && "newWindow" !== t3) && e2.setAttribute(t3, i3);
            }
        r2 && n2.addLinkAttributes(e2, s2.href, s2.newWindow), i2 && s2.dataId && this.setupStorage(e2, s2.dataId, t2, i2);
      }
      static render(e2) {
        const t2 = e2.annotationStorage, i2 = e2.linkService, a2 = e2.xfaHtml, n2 = e2.intent || "display", s2 = document.createElement(a2.name);
        a2.attributes && this.setAttributes({ html: s2, element: a2, intent: n2, linkService: i2 });
        const r2 = "richText" !== n2, o2 = e2.div;
        if (o2.append(s2), e2.viewport) {
          const t3 = `matrix(${e2.viewport.transform.join(",")})`;
          o2.style.transform = t3;
        }
        r2 && o2.setAttribute("class", "xfaLayer xfaFont");
        const l3 = [];
        if (0 === a2.children.length) {
          if (a2.value) {
            const e3 = document.createTextNode(a2.value);
            s2.append(e3), r2 && XfaText.shouldBuildText(a2.name) && l3.push(e3);
          }
          return { textDivs: l3 };
        }
        const c2 = [[a2, -1, s2]];
        for (; c2.length > 0; ) {
          const [e3, a3, s3] = c2.at(-1);
          if (a3 + 1 === e3.children.length) {
            c2.pop();
            continue;
          }
          const o3 = e3.children[++c2.at(-1)[1]];
          if (null === o3)
            continue;
          const { name: h2 } = o3;
          if ("#text" === h2) {
            const e4 = document.createTextNode(o3.value);
            l3.push(e4), s3.append(e4);
            continue;
          }
          const d2 = o3?.attributes?.xmlns ? document.createElementNS(o3.attributes.xmlns, h2) : document.createElement(h2);
          if (s3.append(d2), o3.attributes && this.setAttributes({ html: d2, element: o3, storage: t2, intent: n2, linkService: i2 }), o3.children?.length > 0)
            c2.push([o3, -1, d2]);
          else if (o3.value) {
            const e4 = document.createTextNode(o3.value);
            r2 && XfaText.shouldBuildText(h2) && l3.push(e4), d2.append(e4);
          }
        }
        for (const e3 of o2.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea"))
          e3.setAttribute("readOnly", true);
        return { textDivs: l3 };
      }
      static update(e2) {
        const t2 = `matrix(${e2.viewport.transform.join(",")})`;
        e2.div.style.transform = t2, e2.div.hidden = false;
      }
    };
    __name(XfaLayer, "XfaLayer");
    ah = /* @__PURE__ */ new WeakSet();
    nh = 60 * (/* @__PURE__ */ new Date()).getTimezoneOffset() * 1e3;
    AnnotationElementFactory = class {
      static create(e2) {
        switch (e2.data.annotationType) {
          case Kl.LINK:
            return new LinkAnnotationElement(e2);
          case Kl.TEXT:
            return new TextAnnotationElement(e2);
          case Kl.WIDGET:
            switch (e2.data.fieldType) {
              case "Tx":
                return new TextWidgetAnnotationElement(e2);
              case "Btn":
                return e2.data.radioButton ? new RadioButtonWidgetAnnotationElement(e2) : e2.data.checkBox ? new CheckboxWidgetAnnotationElement(e2) : new PushButtonWidgetAnnotationElement(e2);
              case "Ch":
                return new ChoiceWidgetAnnotationElement(e2);
              case "Sig":
                return new SignatureWidgetAnnotationElement(e2);
            }
            return new WidgetAnnotationElement(e2);
          case Kl.POPUP:
            return new PopupAnnotationElement(e2);
          case Kl.FREETEXT:
            return new FreeTextAnnotationElement(e2);
          case Kl.LINE:
            return new LineAnnotationElement(e2);
          case Kl.SQUARE:
            return new SquareAnnotationElement(e2);
          case Kl.CIRCLE:
            return new CircleAnnotationElement(e2);
          case Kl.POLYLINE:
            return new PolylineAnnotationElement(e2);
          case Kl.CARET:
            return new CaretAnnotationElement(e2);
          case Kl.INK:
            return new InkAnnotationElement(e2);
          case Kl.POLYGON:
            return new PolygonAnnotationElement(e2);
          case Kl.HIGHLIGHT:
            return new HighlightAnnotationElement(e2);
          case Kl.UNDERLINE:
            return new UnderlineAnnotationElement(e2);
          case Kl.SQUIGGLY:
            return new SquigglyAnnotationElement(e2);
          case Kl.STRIKEOUT:
            return new StrikeOutAnnotationElement(e2);
          case Kl.STAMP:
            return new StampAnnotationElement(e2);
          case Kl.FILEATTACHMENT:
            return new FileAttachmentAnnotationElement(e2);
          default:
            return new AnnotationElement(e2);
        }
      }
    };
    __name(AnnotationElementFactory, "AnnotationElementFactory");
    AnnotationElement = class {
      #Pr = null;
      #Rr = false;
      #Br = null;
      constructor(e2, { isRenderable: t2 = false, ignoreBorder: i2 = false, createQuadrilaterals: a2 = false } = {}) {
        this.isRenderable = t2, this.data = e2.data, this.layer = e2.layer, this.linkService = e2.linkService, this.downloadManager = e2.downloadManager, this.imageResourcesPath = e2.imageResourcesPath, this.renderForms = e2.renderForms, this.svgFactory = e2.svgFactory, this.annotationStorage = e2.annotationStorage, this.enableComment = e2.enableComment, this.enableScripting = e2.enableScripting, this.hasJSActions = e2.hasJSActions, this._fieldObjects = e2.fieldObjects, this.parent = e2.parent, t2 && (this.container = this._createContainer(i2)), a2 && this._createQuadrilaterals();
      }
      static _hasPopupData({ contentsObj: e2, richText: t2 }) {
        return !(!e2?.str && !t2?.str);
      }
      get _isEditable() {
        return this.data.isEditable;
      }
      get hasPopupData() {
        return AnnotationElement._hasPopupData(this.data);
      }
      get hasCommentButton() {
        return this.enableComment && this._isEditable && this.hasPopupElement;
      }
      get commentButtonPosition() {
        const { quadPoints: e2, rect: t2 } = this.data;
        let i2 = -1 / 0, a2 = -1 / 0;
        if (e2?.length >= 8) {
          for (let t3 = 0; t3 < e2.length; t3 += 8)
            e2[t3 + 1] > a2 ? (a2 = e2[t3 + 1], i2 = e2[t3 + 2]) : e2[t3 + 1] === a2 && (i2 = Math.max(i2, e2[t3 + 2]));
          return [i2, a2];
        }
        return t2 ? [t2[2], t2[3]] : null;
      }
      get commentButtonColor() {
        if (!this.data.color)
          return null;
        const [e2, t2, i2] = this.data.color, a2 = 255 * (1 - (this.data.opacity ?? 1));
        return this.#Nr(Math.min(e2 + a2, 255), Math.min(t2 + a2, 255), Math.min(i2 + a2, 255));
      }
      #Nr(e2, t2, i2) {
        e2 /= 255, t2 /= 255, i2 /= 255;
        const a2 = Math.max(e2, t2, i2), n2 = Math.min(e2, t2, i2), s2 = (a2 + n2) / 2, r2 = ((1 + Math.sqrt(s2)) / 2 * 100).toFixed(2);
        if (a2 === n2)
          return `hsl(0, 0%, ${r2}%)`;
        const o2 = a2 - n2;
        let l3;
        l3 = a2 === e2 ? (t2 - i2) / o2 + (t2 < i2 ? 6 : 0) : a2 === t2 ? (i2 - e2) / o2 + 2 : (e2 - t2) / o2 + 4, l3 = (60 * l3).toFixed(2);
        return `hsl(${l3}, ${(o2 / (1 - Math.abs(2 * s2 - 1)) * 100).toFixed(2)}%, ${r2}%)`;
      }
      _normalizePoint(e2) {
        const { page: { view: t2 }, viewport: { rawDims: { pageWidth: i2, pageHeight: a2, pageX: n2, pageY: s2 } } } = this.parent;
        return e2[1] = t2[3] - e2[1] + t2[1], e2[0] = 100 * (e2[0] - n2) / i2, e2[1] = 100 * (e2[1] - s2) / a2, e2;
      }
      updateEdited(e2) {
        if (!this.container)
          return;
        e2.rect && (this.#Pr ||= { rect: this.data.rect.slice(0) });
        const { rect: t2, popup: i2 } = e2;
        t2 && this.#Lr(t2);
        let a2 = this.#Br?.popup || this.popup;
        !a2 && i2?.text && (this._createPopup(i2), a2 = this.#Br.popup), a2 && (a2.updateEdited(e2), i2?.deleted && (a2.remove(), this.#Br = null, this.popup = null));
      }
      resetEdited() {
        this.#Pr && (this.#Lr(this.#Pr.rect), this.#Br?.popup.resetEdited(), this.#Pr = null);
      }
      #Lr(e2) {
        const { container: { style: t2 }, data: { rect: i2, rotation: a2 }, parent: { viewport: { rawDims: { pageWidth: n2, pageHeight: s2, pageX: r2, pageY: o2 } } } } = this;
        i2?.splice(0, 4, ...e2), t2.left = 100 * (e2[0] - r2) / n2 + "%", t2.top = 100 * (s2 - e2[3] + o2) / s2 + "%", 0 === a2 ? (t2.width = 100 * (e2[2] - e2[0]) / n2 + "%", t2.height = 100 * (e2[3] - e2[1]) / s2 + "%") : this.setRotation(a2);
      }
      _createContainer(e2) {
        const { data: t2, parent: { page: i2, viewport: a2 } } = this, n2 = document.createElement("section");
        n2.setAttribute("data-annotation-id", t2.id), this instanceof WidgetAnnotationElement || this instanceof LinkAnnotationElement || (n2.tabIndex = 0);
        const { style: s2 } = n2;
        if (s2.zIndex = this.parent.zIndex, this.parent.zIndex += 2, t2.alternativeText && (n2.title = t2.alternativeText), t2.noRotate && n2.classList.add("norotate"), !t2.rect || this instanceof PopupAnnotationElement) {
          const { rotation: e3 } = t2;
          return t2.hasOwnCanvas || 0 === e3 || this.setRotation(e3, n2), n2;
        }
        const { width: r2, height: o2 } = this;
        if (!e2 && t2.borderStyle.width > 0) {
          s2.borderWidth = `${t2.borderStyle.width}px`;
          const e3 = t2.borderStyle.horizontalCornerRadius, i3 = t2.borderStyle.verticalCornerRadius;
          if (e3 > 0 || i3 > 0) {
            const t3 = `calc(${e3}px * var(--total-scale-factor)) / calc(${i3}px * var(--total-scale-factor))`;
            s2.borderRadius = t3;
          } else if (this instanceof RadioButtonWidgetAnnotationElement) {
            const e4 = `calc(${r2}px * var(--total-scale-factor)) / calc(${o2}px * var(--total-scale-factor))`;
            s2.borderRadius = e4;
          }
          switch (t2.borderStyle.style) {
            case Yl:
              s2.borderStyle = "solid";
              break;
            case Jl:
              s2.borderStyle = "dashed";
              break;
            case Zl:
              warn3("Unimplemented border style: beveled");
              break;
            case Ql:
              warn3("Unimplemented border style: inset");
              break;
            case ec:
              s2.borderBottomStyle = "solid";
          }
          const a3 = t2.borderColor || null;
          a3 ? (this.#Rr = true, s2.borderColor = Util.makeHexColor(0 | a3[0], 0 | a3[1], 0 | a3[2])) : s2.borderWidth = 0;
        }
        const l3 = Util.normalizeRect([t2.rect[0], i2.view[3] - t2.rect[1] + i2.view[1], t2.rect[2], i2.view[3] - t2.rect[3] + i2.view[1]]), { pageWidth: c2, pageHeight: h2, pageX: d2, pageY: u2 } = a2.rawDims;
        s2.left = 100 * (l3[0] - d2) / c2 + "%", s2.top = 100 * (l3[1] - u2) / h2 + "%";
        const { rotation: g2 } = t2;
        return t2.hasOwnCanvas || 0 === g2 ? (s2.width = 100 * r2 / c2 + "%", s2.height = 100 * o2 / h2 + "%") : this.setRotation(g2, n2), n2;
      }
      setRotation(e2, t2 = this.container) {
        if (!this.data.rect)
          return;
        const { pageWidth: i2, pageHeight: a2 } = this.parent.viewport.rawDims;
        let { width: n2, height: s2 } = this;
        e2 % 180 != 0 && ([n2, s2] = [s2, n2]), t2.style.width = 100 * n2 / i2 + "%", t2.style.height = 100 * s2 / a2 + "%", t2.setAttribute("data-main-rotation", (360 - e2) % 360);
      }
      get _commonActions() {
        const setColor = /* @__PURE__ */ __name((e2, t2, i2) => {
          const a2 = i2.detail[e2], n2 = a2[0], s2 = a2.slice(1);
          i2.target.style[t2] = ColorConverters[`${n2}_HTML`](s2), this.annotationStorage.setValue(this.data.id, { [t2]: ColorConverters[`${n2}_rgb`](s2) });
        }, "setColor");
        return shadow(this, "_commonActions", { display: (e2) => {
          const { display: t2 } = e2.detail, i2 = t2 % 2 == 1;
          this.container.style.visibility = i2 ? "hidden" : "visible", this.annotationStorage.setValue(this.data.id, { noView: i2, noPrint: 1 === t2 || 2 === t2 });
        }, print: (e2) => {
          this.annotationStorage.setValue(this.data.id, { noPrint: !e2.detail.print });
        }, hidden: (e2) => {
          const { hidden: t2 } = e2.detail;
          this.container.style.visibility = t2 ? "hidden" : "visible", this.annotationStorage.setValue(this.data.id, { noPrint: t2, noView: t2 });
        }, focus: (e2) => {
          setTimeout(() => e2.target.focus({ preventScroll: false }), 0);
        }, userName: (e2) => {
          e2.target.title = e2.detail.userName;
        }, readonly: (e2) => {
          e2.target.disabled = e2.detail.readonly;
        }, required: (e2) => {
          this._setRequired(e2.target, e2.detail.required);
        }, bgColor: (e2) => {
          setColor("bgColor", "backgroundColor", e2);
        }, fillColor: (e2) => {
          setColor("fillColor", "backgroundColor", e2);
        }, fgColor: (e2) => {
          setColor("fgColor", "color", e2);
        }, textColor: (e2) => {
          setColor("textColor", "color", e2);
        }, borderColor: (e2) => {
          setColor("borderColor", "borderColor", e2);
        }, strokeColor: (e2) => {
          setColor("strokeColor", "borderColor", e2);
        }, rotation: (e2) => {
          const t2 = e2.detail.rotation;
          this.setRotation(t2), this.annotationStorage.setValue(this.data.id, { rotation: t2 });
        } });
      }
      _dispatchEventFromSandbox(e2, t2) {
        const i2 = this._commonActions;
        for (const a2 of Object.keys(t2.detail)) {
          const n2 = e2[a2] || i2[a2];
          n2?.(t2);
        }
      }
      _setDefaultPropertiesFromJS(e2) {
        if (!this.enableScripting)
          return;
        const t2 = this.annotationStorage.getRawValue(this.data.id);
        if (!t2)
          return;
        const i2 = this._commonActions;
        for (const [a2, n2] of Object.entries(t2)) {
          const s2 = i2[a2];
          if (s2) {
            s2({ detail: { [a2]: n2 }, target: e2 }), delete t2[a2];
          }
        }
      }
      _createQuadrilaterals() {
        if (!this.container)
          return;
        const { quadPoints: e2 } = this.data;
        if (!e2)
          return;
        const [t2, i2, a2, n2] = this.data.rect.map((e3) => Math.fround(e3));
        if (8 === e2.length) {
          const [s3, r3, o3, l4] = e2.subarray(2, 6);
          if (a2 === s3 && n2 === r3 && t2 === o3 && i2 === l4)
            return;
        }
        const { style: s2 } = this.container;
        let r2;
        if (this.#Rr) {
          const { borderColor: e3, borderWidth: t3 } = s2;
          s2.borderWidth = 0, r2 = ["url('data:image/svg+xml;utf8,", '<svg xmlns="http://www.w3.org/2000/svg"', ' preserveAspectRatio="none" viewBox="0 0 1 1">', `<g fill="transparent" stroke="${e3}" stroke-width="${t3}">`], this.container.classList.add("hasBorder");
        }
        const o2 = a2 - t2, l3 = n2 - i2, { svgFactory: c2 } = this, h2 = c2.createElement("svg");
        h2.classList.add("quadrilateralsContainer"), h2.setAttribute("width", 0), h2.setAttribute("height", 0), h2.role = "none";
        const d2 = c2.createElement("defs");
        h2.append(d2);
        const u2 = c2.createElement("clipPath"), g2 = `clippath_${this.data.id}`;
        u2.setAttribute("id", g2), u2.setAttribute("clipPathUnits", "objectBoundingBox"), d2.append(u2);
        for (let i3 = 2, a3 = e2.length; i3 < a3; i3 += 8) {
          const a4 = e2[i3], s3 = e2[i3 + 1], h3 = e2[i3 + 2], d3 = e2[i3 + 3], g3 = c2.createElement("rect"), p2 = (h3 - t2) / o2, f2 = (n2 - s3) / l3, m2 = (a4 - h3) / o2, b2 = (s3 - d3) / l3;
          g3.setAttribute("x", p2), g3.setAttribute("y", f2), g3.setAttribute("width", m2), g3.setAttribute("height", b2), u2.append(g3), r2?.push(`<rect vector-effect="non-scaling-stroke" x="${p2}" y="${f2}" width="${m2}" height="${b2}"/>`);
        }
        this.#Rr && (r2.push("</g></svg>')"), s2.backgroundImage = r2.join("")), this.container.append(h2), this.container.style.clipPath = `url(#${g2})`;
      }
      _createPopup(e2 = null) {
        const { data: t2 } = this;
        let i2, a2;
        e2 ? (i2 = { str: e2.text }, a2 = e2.date) : (i2 = t2.contentsObj, a2 = t2.modificationDate);
        const n2 = this.#Br = new PopupAnnotationElement({ data: { color: t2.color, titleObj: t2.titleObj, modificationDate: a2, contentsObj: i2, richText: t2.richText, parentRect: t2.rect, borderStyle: 0, id: `popup_${t2.id}`, rotation: t2.rotation, noRotate: true }, linkService: this.linkService, parent: this.parent, elements: [this] });
        this.parent.div.append(n2.render());
      }
      get hasPopupElement() {
        return !!(this.#Br || this.popup || this.data.popupRef);
      }
      render() {
        unreachable("Abstract method `AnnotationElement.render` called");
      }
      _getElementsByName(e2, t2 = null) {
        const i2 = [];
        if (this._fieldObjects) {
          const a2 = this._fieldObjects[e2];
          if (a2)
            for (const { page: e3, id: n2, exportValues: s2 } of a2) {
              if (-1 === e3)
                continue;
              if (n2 === t2)
                continue;
              const a3 = "string" == typeof s2 ? s2 : null, r2 = document.querySelector(`[data-element-id="${n2}"]`);
              !r2 || ah.has(r2) ? i2.push({ id: n2, exportValue: a3, domElement: r2 }) : warn3(`_getElementsByName - element not allowed: ${n2}`);
            }
          return i2;
        }
        for (const a2 of document.getElementsByName(e2)) {
          const { exportValue: e3 } = a2, n2 = a2.getAttribute("data-element-id");
          n2 !== t2 && (ah.has(a2) && i2.push({ id: n2, exportValue: e3, domElement: a2 }));
        }
        return i2;
      }
      show() {
        this.container && (this.container.hidden = false), this.popup?.maybeShow();
      }
      hide() {
        this.container && (this.container.hidden = true), this.popup?.forceHide();
      }
      getElementsToTriggerPopup() {
        return this.container;
      }
      addHighlightArea() {
        const e2 = this.getElementsToTriggerPopup();
        if (Array.isArray(e2))
          for (const t2 of e2)
            t2.classList.add("highlightArea");
        else
          e2.classList.add("highlightArea");
      }
      _editOnDoubleClick() {
        if (!this._isEditable)
          return;
        const { annotationEditorType: e2, data: { id: t2 } } = this;
        this.container.addEventListener("dblclick", () => {
          this.linkService.eventBus?.dispatch("switchannotationeditormode", { source: this, mode: e2, editId: t2, mustEnterInEditMode: true });
        });
      }
      get width() {
        return this.data.rect[2] - this.data.rect[0];
      }
      get height() {
        return this.data.rect[3] - this.data.rect[1];
      }
    };
    __name(AnnotationElement, "AnnotationElement");
    LinkAnnotationElement = class extends AnnotationElement {
      constructor(e2, t2 = null) {
        super(e2, { isRenderable: true, ignoreBorder: !!t2?.ignoreBorder, createQuadrilaterals: true }), this.isTooltipOnly = e2.data.isTooltipOnly;
      }
      render() {
        const { data: e2, linkService: t2 } = this, i2 = document.createElement("a");
        i2.setAttribute("data-element-id", e2.id);
        let a2 = false;
        return e2.url ? (t2.addLinkAttributes(i2, e2.url, e2.newWindow), a2 = true) : e2.action ? (this._bindNamedAction(i2, e2.action, e2.overlaidText), a2 = true) : e2.attachment ? (this.#Ur(i2, e2.attachment, e2.overlaidText, e2.attachmentDest), a2 = true) : e2.setOCGState ? (this.#jr(i2, e2.setOCGState, e2.overlaidText), a2 = true) : e2.dest ? (this._bindLink(i2, e2.dest, e2.overlaidText), a2 = true) : (e2.actions && (e2.actions.Action || e2.actions["Mouse Up"] || e2.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions && (this._bindJSAction(i2, e2), a2 = true), e2.resetForm ? (this._bindResetFormAction(i2, e2.resetForm), a2 = true) : this.isTooltipOnly && !a2 && (this._bindLink(i2, ""), a2 = true)), this.container.classList.add("linkAnnotation"), a2 && this.container.append(i2), this.container;
      }
      #$r() {
        this.container.setAttribute("data-internal-link", "");
      }
      _bindLink(e2, t2, i2 = "") {
        e2.href = this.linkService.getDestinationHash(t2), e2.onclick = () => (t2 && this.linkService.goToDestination(t2), false), (t2 || "" === t2) && this.#$r(), i2 && (e2.title = i2);
      }
      _bindNamedAction(e2, t2, i2 = "") {
        e2.href = this.linkService.getAnchorUrl(""), e2.onclick = () => (this.linkService.executeNamedAction(t2), false), i2 && (e2.title = i2), this.#$r();
      }
      #Ur(e2, t2, i2 = "", a2 = null) {
        e2.href = this.linkService.getAnchorUrl(""), t2.description ? e2.title = t2.description : i2 && (e2.title = i2), e2.onclick = () => (this.downloadManager?.openOrDownloadData(t2.content, t2.filename, a2), false), this.#$r();
      }
      #jr(e2, t2, i2 = "") {
        e2.href = this.linkService.getAnchorUrl(""), e2.onclick = () => (this.linkService.executeSetOCGState(t2), false), i2 && (e2.title = i2), this.#$r();
      }
      _bindJSAction(e2, t2) {
        e2.href = this.linkService.getAnchorUrl("");
        const i2 = /* @__PURE__ */ new Map([["Action", "onclick"], ["Mouse Up", "onmouseup"], ["Mouse Down", "onmousedown"]]);
        for (const a2 of Object.keys(t2.actions)) {
          const n2 = i2.get(a2);
          n2 && (e2[n2] = () => (this.linkService.eventBus?.dispatch("dispatcheventinsandbox", { source: this, detail: { id: t2.id, name: a2 } }), false));
        }
        t2.overlaidText && (e2.title = t2.overlaidText), e2.onclick || (e2.onclick = () => false), this.#$r();
      }
      _bindResetFormAction(e2, t2) {
        const i2 = e2.onclick;
        if (i2 || (e2.href = this.linkService.getAnchorUrl("")), this.#$r(), !this._fieldObjects)
          return warn3('_bindResetFormAction - "resetForm" action not supported, ensure that the `fieldObjects` parameter is provided.'), void (i2 || (e2.onclick = () => false));
        e2.onclick = () => {
          i2?.();
          const { fields: e3, refs: a2, include: n2 } = t2, s2 = [];
          if (0 !== e3.length || 0 !== a2.length) {
            const t3 = new Set(a2);
            for (const i3 of e3) {
              const e4 = this._fieldObjects[i3] || [];
              for (const { id: i4 } of e4)
                t3.add(i4);
            }
            for (const e4 of Object.values(this._fieldObjects))
              for (const i3 of e4)
                t3.has(i3.id) === n2 && s2.push(i3);
          } else
            for (const e4 of Object.values(this._fieldObjects))
              s2.push(...e4);
          const r2 = this.annotationStorage, o2 = [];
          for (const e4 of s2) {
            const { id: t3 } = e4;
            switch (o2.push(t3), e4.type) {
              case "text": {
                const i4 = e4.defaultValue || "";
                r2.setValue(t3, { value: i4 });
                break;
              }
              case "checkbox":
              case "radiobutton": {
                const i4 = e4.defaultValue === e4.exportValues;
                r2.setValue(t3, { value: i4 });
                break;
              }
              case "combobox":
              case "listbox": {
                const i4 = e4.defaultValue || "";
                r2.setValue(t3, { value: i4 });
                break;
              }
              default:
                continue;
            }
            const i3 = document.querySelector(`[data-element-id="${t3}"]`);
            i3 && (ah.has(i3) ? i3.dispatchEvent(new Event("resetform")) : warn3(`_bindResetFormAction - element not allowed: ${t3}`));
          }
          return this.enableScripting && this.linkService.eventBus?.dispatch("dispatcheventinsandbox", { source: this, detail: { id: "app", ids: o2, name: "ResetForm" } }), false;
        };
      }
    };
    __name(LinkAnnotationElement, "LinkAnnotationElement");
    TextAnnotationElement = class extends AnnotationElement {
      constructor(e2) {
        super(e2, { isRenderable: true });
      }
      render() {
        this.container.classList.add("textAnnotation");
        const e2 = document.createElement("img");
        return e2.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg", e2.setAttribute("data-l10n-id", "pdfjs-text-annotation-type"), e2.setAttribute("data-l10n-args", JSON.stringify({ type: this.data.name })), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.append(e2), this.container;
      }
    };
    __name(TextAnnotationElement, "TextAnnotationElement");
    WidgetAnnotationElement = class extends AnnotationElement {
      render() {
        return this.container;
      }
      showElementAndHideCanvas(e2) {
        this.data.hasOwnCanvas && ("CANVAS" === e2.previousSibling?.nodeName && (e2.previousSibling.hidden = true), e2.hidden = false);
      }
      _getKeyModifier(e2) {
        return util_FeatureTest.platform.isMac ? e2.metaKey : e2.ctrlKey;
      }
      _setEventListener(e2, t2, i2, a2, n2) {
        i2.includes("mouse") ? e2.addEventListener(i2, (e3) => {
          this.linkService.eventBus?.dispatch("dispatcheventinsandbox", { source: this, detail: { id: this.data.id, name: a2, value: n2(e3), shift: e3.shiftKey, modifier: this._getKeyModifier(e3) } });
        }) : e2.addEventListener(i2, (e3) => {
          if ("blur" === i2) {
            if (!t2.focused || !e3.relatedTarget)
              return;
            t2.focused = false;
          } else if ("focus" === i2) {
            if (t2.focused)
              return;
            t2.focused = true;
          }
          n2 && this.linkService.eventBus?.dispatch("dispatcheventinsandbox", { source: this, detail: { id: this.data.id, name: a2, value: n2(e3) } });
        });
      }
      _setEventListeners(e2, t2, i2, a2) {
        for (const [n2, s2] of i2)
          ("Action" === s2 || this.data.actions?.[s2]) && ("Focus" !== s2 && "Blur" !== s2 || (t2 ||= { focused: false }), this._setEventListener(e2, t2, n2, s2, a2), "Focus" !== s2 || this.data.actions?.Blur ? "Blur" !== s2 || this.data.actions?.Focus || this._setEventListener(e2, t2, "focus", "Focus", null) : this._setEventListener(e2, t2, "blur", "Blur", null));
      }
      _setBackgroundColor(e2) {
        const t2 = this.data.backgroundColor || null;
        e2.style.backgroundColor = null === t2 ? "transparent" : Util.makeHexColor(t2[0], t2[1], t2[2]);
      }
      _setTextStyle(e2) {
        const t2 = ["left", "center", "right"], { fontColor: i2 } = this.data.defaultAppearanceData, a2 = this.data.defaultAppearanceData.fontSize || 9, n2 = e2.style;
        let s2;
        const roundToOneDecimal = /* @__PURE__ */ __name((e3) => Math.round(10 * e3) / 10, "roundToOneDecimal");
        if (this.data.multiLine) {
          const e3 = Math.abs(this.data.rect[3] - this.data.rect[1] - 2), t3 = e3 / (Math.round(e3 / (Tl * a2)) || 1);
          s2 = Math.min(a2, roundToOneDecimal(t3 / Tl));
        } else {
          const e3 = Math.abs(this.data.rect[3] - this.data.rect[1] - 2);
          s2 = Math.min(a2, roundToOneDecimal(e3 / Tl));
        }
        n2.fontSize = `calc(${s2}px * var(--total-scale-factor))`, n2.color = Util.makeHexColor(i2[0], i2[1], i2[2]), null !== this.data.textAlignment && (n2.textAlign = t2[this.data.textAlignment]);
      }
      _setRequired(e2, t2) {
        t2 ? e2.setAttribute("required", true) : e2.removeAttribute("required"), e2.setAttribute("aria-required", t2);
      }
    };
    __name(WidgetAnnotationElement, "WidgetAnnotationElement");
    TextWidgetAnnotationElement = class extends WidgetAnnotationElement {
      constructor(e2) {
        super(e2, { isRenderable: e2.renderForms || e2.data.hasOwnCanvas || !e2.data.hasAppearance && !!e2.data.fieldValue });
      }
      setPropertyOnSiblings(e2, t2, i2, a2) {
        const n2 = this.annotationStorage;
        for (const s2 of this._getElementsByName(e2.name, e2.id))
          s2.domElement && (s2.domElement[t2] = i2), n2.setValue(s2.id, { [a2]: i2 });
      }
      render() {
        const e2 = this.annotationStorage, t2 = this.data.id;
        this.container.classList.add("textWidgetAnnotation");
        let i2 = null;
        if (this.renderForms) {
          const a2 = e2.getValue(t2, { value: this.data.fieldValue });
          let n2 = a2.value || "";
          const s2 = e2.getValue(t2, { charLimit: this.data.maxLen }).charLimit;
          s2 && n2.length > s2 && (n2 = n2.slice(0, s2));
          let r2 = a2.formattedValue || this.data.textContent?.join("\n") || null;
          r2 && this.data.comb && (r2 = r2.replaceAll(/\s+/g, ""));
          const o2 = { userValue: n2, formattedValue: r2, lastCommittedValue: null, commitKey: 1, focused: false };
          this.data.multiLine ? (i2 = document.createElement("textarea"), i2.textContent = r2 ?? n2, this.data.doNotScroll && (i2.style.overflowY = "hidden")) : (i2 = document.createElement("input"), i2.type = this.data.password ? "password" : "text", i2.setAttribute("value", r2 ?? n2), this.data.doNotScroll && (i2.style.overflowX = "hidden")), this.data.hasOwnCanvas && (i2.hidden = true), ah.add(i2), i2.setAttribute("data-element-id", t2), i2.disabled = this.data.readOnly, i2.name = this.data.fieldName, i2.tabIndex = 0;
          const { datetimeFormat: l3, datetimeType: c2, timeStep: h2 } = this.data, d2 = !!c2 && this.enableScripting;
          l3 && (i2.title = l3), this._setRequired(i2, this.data.required), s2 && (i2.maxLength = s2), i2.addEventListener("input", (a3) => {
            e2.setValue(t2, { value: a3.target.value }), this.setPropertyOnSiblings(i2, "value", a3.target.value, "value"), o2.formattedValue = null;
          }), i2.addEventListener("resetform", (e3) => {
            const t3 = this.data.defaultFieldValue ?? "";
            i2.value = o2.userValue = t3, o2.formattedValue = null;
          });
          let blurListener = /* @__PURE__ */ __name((e3) => {
            const { formattedValue: t3 } = o2;
            null != t3 && (e3.target.value = t3), e3.target.scrollLeft = 0;
          }, "blurListener");
          if (this.enableScripting && this.hasJSActions) {
            i2.addEventListener("focus", (e3) => {
              if (o2.focused)
                return;
              const { target: t3 } = e3;
              if (d2 && (t3.type = c2, h2 && (t3.step = h2)), o2.userValue) {
                const e4 = o2.userValue;
                if (d2)
                  if ("time" === c2) {
                    const i3 = new Date(e4), a4 = [i3.getHours(), i3.getMinutes(), i3.getSeconds()];
                    t3.value = a4.map((e5) => e5.toString().padStart(2, "0")).join(":");
                  } else
                    t3.value = new Date(e4 - nh).toISOString().split("date" === c2 ? "T" : ".", 1)[0];
                else
                  t3.value = e4;
              }
              o2.lastCommittedValue = t3.value, o2.commitKey = 1, this.data.actions?.Focus || (o2.focused = true);
            }), i2.addEventListener("updatefromsandbox", (i3) => {
              this.showElementAndHideCanvas(i3.target);
              const a4 = { value(i4) {
                o2.userValue = i4.detail.value ?? "", d2 || e2.setValue(t2, { value: o2.userValue.toString() }), i4.target.value = o2.userValue;
              }, formattedValue(i4) {
                const { formattedValue: a5 } = i4.detail;
                o2.formattedValue = a5, null != a5 && i4.target !== document.activeElement && (i4.target.value = a5);
                const n3 = { formattedValue: a5 };
                d2 && (n3.value = a5), e2.setValue(t2, n3);
              }, selRange(e3) {
                e3.target.setSelectionRange(...e3.detail.selRange);
              }, charLimit: (i4) => {
                const { charLimit: a5 } = i4.detail, { target: n3 } = i4;
                if (0 === a5)
                  return void n3.removeAttribute("maxLength");
                n3.setAttribute("maxLength", a5);
                let s3 = o2.userValue;
                !s3 || s3.length <= a5 || (s3 = s3.slice(0, a5), n3.value = o2.userValue = s3, e2.setValue(t2, { value: s3 }), this.linkService.eventBus?.dispatch("dispatcheventinsandbox", { source: this, detail: { id: t2, name: "Keystroke", value: s3, willCommit: true, commitKey: 1, selStart: n3.selectionStart, selEnd: n3.selectionEnd } }));
              } };
              this._dispatchEventFromSandbox(a4, i3);
            }), i2.addEventListener("keydown", (e3) => {
              o2.commitKey = 1;
              let i3 = -1;
              if ("Escape" === e3.key ? i3 = 0 : "Enter" !== e3.key || this.data.multiLine ? "Tab" === e3.key && (o2.commitKey = 3) : i3 = 2, -1 === i3)
                return;
              const { value: a4 } = e3.target;
              o2.lastCommittedValue !== a4 && (o2.lastCommittedValue = a4, o2.userValue = a4, this.linkService.eventBus?.dispatch("dispatcheventinsandbox", { source: this, detail: { id: t2, name: "Keystroke", value: a4, willCommit: true, commitKey: i3, selStart: e3.target.selectionStart, selEnd: e3.target.selectionEnd } }));
            });
            const a3 = blurListener;
            blurListener = null, i2.addEventListener("blur", (e3) => {
              if (!o2.focused || !e3.relatedTarget)
                return;
              this.data.actions?.Blur || (o2.focused = false);
              const { target: i3 } = e3;
              let { value: n3 } = i3;
              if (d2) {
                if (n3 && "time" === c2) {
                  const e4 = n3.split(":").map((e5) => parseInt(e5, 10));
                  n3 = new Date(2e3, 0, 1, e4[0], e4[1], e4[2] || 0).valueOf(), i3.step = "";
                } else
                  n3 = new Date(n3).valueOf();
                i3.type = "text";
              }
              o2.userValue = n3, o2.lastCommittedValue !== n3 && this.linkService.eventBus?.dispatch("dispatcheventinsandbox", { source: this, detail: { id: t2, name: "Keystroke", value: n3, willCommit: true, commitKey: o2.commitKey, selStart: e3.target.selectionStart, selEnd: e3.target.selectionEnd } }), a3(e3);
            }), this.data.actions?.Keystroke && i2.addEventListener("beforeinput", (e3) => {
              o2.lastCommittedValue = null;
              const { data: i3, target: a4 } = e3, { value: n3, selectionStart: s3, selectionEnd: r3 } = a4;
              let l4 = s3, c3 = r3;
              switch (e3.inputType) {
                case "deleteWordBackward": {
                  const e4 = n3.substring(0, s3).match(/\w*[^\w]*$/);
                  e4 && (l4 -= e4[0].length);
                  break;
                }
                case "deleteWordForward": {
                  const e4 = n3.substring(s3).match(/^[^\w]*\w*/);
                  e4 && (c3 += e4[0].length);
                  break;
                }
                case "deleteContentBackward":
                  s3 === r3 && (l4 -= 1);
                  break;
                case "deleteContentForward":
                  s3 === r3 && (c3 += 1);
              }
              e3.preventDefault(), this.linkService.eventBus?.dispatch("dispatcheventinsandbox", { source: this, detail: { id: t2, name: "Keystroke", value: n3, change: i3 || "", willCommit: false, selStart: l4, selEnd: c3 } });
            }), this._setEventListeners(i2, o2, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (e3) => e3.target.value);
          }
          if (blurListener && i2.addEventListener("blur", blurListener), this.data.comb) {
            const e3 = (this.data.rect[2] - this.data.rect[0]) / s2;
            i2.classList.add("comb"), i2.style.letterSpacing = `calc(${e3}px * var(--total-scale-factor) - 1ch)`;
          }
        } else
          i2 = document.createElement("div"), i2.textContent = this.data.fieldValue, i2.style.verticalAlign = "middle", i2.style.display = "table-cell", this.data.hasOwnCanvas && (i2.hidden = true);
        return this._setTextStyle(i2), this._setBackgroundColor(i2), this._setDefaultPropertiesFromJS(i2), this.container.append(i2), this.container;
      }
    };
    __name(TextWidgetAnnotationElement, "TextWidgetAnnotationElement");
    SignatureWidgetAnnotationElement = class extends WidgetAnnotationElement {
      constructor(e2) {
        super(e2, { isRenderable: !!e2.data.hasOwnCanvas });
      }
    };
    __name(SignatureWidgetAnnotationElement, "SignatureWidgetAnnotationElement");
    CheckboxWidgetAnnotationElement = class extends WidgetAnnotationElement {
      constructor(e2) {
        super(e2, { isRenderable: e2.renderForms });
      }
      render() {
        const e2 = this.annotationStorage, t2 = this.data, i2 = t2.id;
        let a2 = e2.getValue(i2, { value: t2.exportValue === t2.fieldValue }).value;
        "string" == typeof a2 && (a2 = "Off" !== a2, e2.setValue(i2, { value: a2 })), this.container.classList.add("buttonWidgetAnnotation", "checkBox");
        const n2 = document.createElement("input");
        return ah.add(n2), n2.setAttribute("data-element-id", i2), n2.disabled = t2.readOnly, this._setRequired(n2, this.data.required), n2.type = "checkbox", n2.name = t2.fieldName, a2 && n2.setAttribute("checked", true), n2.setAttribute("exportValue", t2.exportValue), n2.tabIndex = 0, n2.addEventListener("change", (a3) => {
          const { name: n3, checked: s2 } = a3.target;
          for (const a4 of this._getElementsByName(n3, i2)) {
            const i3 = s2 && a4.exportValue === t2.exportValue;
            a4.domElement && (a4.domElement.checked = i3), e2.setValue(a4.id, { value: i3 });
          }
          e2.setValue(i2, { value: s2 });
        }), n2.addEventListener("resetform", (e3) => {
          const i3 = t2.defaultFieldValue || "Off";
          e3.target.checked = i3 === t2.exportValue;
        }), this.enableScripting && this.hasJSActions && (n2.addEventListener("updatefromsandbox", (t3) => {
          const a3 = { value(t4) {
            t4.target.checked = "Off" !== t4.detail.value, e2.setValue(i2, { value: t4.target.checked });
          } };
          this._dispatchEventFromSandbox(a3, t3);
        }), this._setEventListeners(n2, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (e3) => e3.target.checked)), this._setBackgroundColor(n2), this._setDefaultPropertiesFromJS(n2), this.container.append(n2), this.container;
      }
    };
    __name(CheckboxWidgetAnnotationElement, "CheckboxWidgetAnnotationElement");
    RadioButtonWidgetAnnotationElement = class extends WidgetAnnotationElement {
      constructor(e2) {
        super(e2, { isRenderable: e2.renderForms });
      }
      render() {
        this.container.classList.add("buttonWidgetAnnotation", "radioButton");
        const e2 = this.annotationStorage, t2 = this.data, i2 = t2.id;
        let a2 = e2.getValue(i2, { value: t2.fieldValue === t2.buttonValue }).value;
        if ("string" == typeof a2 && (a2 = a2 !== t2.buttonValue, e2.setValue(i2, { value: a2 })), a2)
          for (const a3 of this._getElementsByName(t2.fieldName, i2))
            e2.setValue(a3.id, { value: false });
        const n2 = document.createElement("input");
        if (ah.add(n2), n2.setAttribute("data-element-id", i2), n2.disabled = t2.readOnly, this._setRequired(n2, this.data.required), n2.type = "radio", n2.name = t2.fieldName, a2 && n2.setAttribute("checked", true), n2.tabIndex = 0, n2.addEventListener("change", (t3) => {
          const { name: a3, checked: n3 } = t3.target;
          for (const t4 of this._getElementsByName(a3, i2))
            e2.setValue(t4.id, { value: false });
          e2.setValue(i2, { value: n3 });
        }), n2.addEventListener("resetform", (e3) => {
          const i3 = t2.defaultFieldValue;
          e3.target.checked = null != i3 && i3 === t2.buttonValue;
        }), this.enableScripting && this.hasJSActions) {
          const a3 = t2.buttonValue;
          n2.addEventListener("updatefromsandbox", (t3) => {
            const n3 = { value: (t4) => {
              const n4 = a3 === t4.detail.value;
              for (const a4 of this._getElementsByName(t4.target.name)) {
                const t5 = n4 && a4.id === i2;
                a4.domElement && (a4.domElement.checked = t5), e2.setValue(a4.id, { value: t5 });
              }
            } };
            this._dispatchEventFromSandbox(n3, t3);
          }), this._setEventListeners(n2, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (e3) => e3.target.checked);
        }
        return this._setBackgroundColor(n2), this._setDefaultPropertiesFromJS(n2), this.container.append(n2), this.container;
      }
    };
    __name(RadioButtonWidgetAnnotationElement, "RadioButtonWidgetAnnotationElement");
    PushButtonWidgetAnnotationElement = class extends LinkAnnotationElement {
      constructor(e2) {
        super(e2, { ignoreBorder: e2.data.hasAppearance });
      }
      render() {
        const e2 = super.render();
        e2.classList.add("buttonWidgetAnnotation", "pushButton");
        const t2 = e2.lastChild;
        return this.enableScripting && this.hasJSActions && t2 && (this._setDefaultPropertiesFromJS(t2), t2.addEventListener("updatefromsandbox", (e3) => {
          this._dispatchEventFromSandbox({}, e3);
        })), e2;
      }
    };
    __name(PushButtonWidgetAnnotationElement, "PushButtonWidgetAnnotationElement");
    ChoiceWidgetAnnotationElement = class extends WidgetAnnotationElement {
      constructor(e2) {
        super(e2, { isRenderable: e2.renderForms });
      }
      render() {
        this.container.classList.add("choiceWidgetAnnotation");
        const e2 = this.annotationStorage, t2 = this.data.id, i2 = e2.getValue(t2, { value: this.data.fieldValue }), a2 = document.createElement("select");
        ah.add(a2), a2.setAttribute("data-element-id", t2), a2.disabled = this.data.readOnly, this._setRequired(a2, this.data.required), a2.name = this.data.fieldName, a2.tabIndex = 0;
        let n2 = this.data.combo && this.data.options.length > 0;
        this.data.combo || (a2.size = this.data.options.length, this.data.multiSelect && (a2.multiple = true)), a2.addEventListener("resetform", (e3) => {
          const t3 = this.data.defaultFieldValue;
          for (const e4 of a2.options)
            e4.selected = e4.value === t3;
        });
        for (const e3 of this.data.options) {
          const t3 = document.createElement("option");
          t3.textContent = e3.displayValue, t3.value = e3.exportValue, i2.value.includes(e3.exportValue) && (t3.setAttribute("selected", true), n2 = false), a2.append(t3);
        }
        let s2 = null;
        if (n2) {
          const e3 = document.createElement("option");
          e3.value = " ", e3.setAttribute("hidden", true), e3.setAttribute("selected", true), a2.prepend(e3), s2 = /* @__PURE__ */ __name(() => {
            e3.remove(), a2.removeEventListener("input", s2), s2 = null;
          }, "s"), a2.addEventListener("input", s2);
        }
        const getValue = /* @__PURE__ */ __name((e3) => {
          const t3 = e3 ? "value" : "textContent", { options: i3, multiple: n3 } = a2;
          return n3 ? Array.prototype.filter.call(i3, (e4) => e4.selected).map((e4) => e4[t3]) : -1 === i3.selectedIndex ? null : i3[i3.selectedIndex][t3];
        }, "getValue");
        let r2 = getValue(false);
        const getItems = /* @__PURE__ */ __name((e3) => {
          const t3 = e3.target.options;
          return Array.prototype.map.call(t3, (e4) => ({ displayValue: e4.textContent, exportValue: e4.value }));
        }, "getItems");
        return this.enableScripting && this.hasJSActions ? (a2.addEventListener("updatefromsandbox", (i3) => {
          const n3 = { value(i4) {
            s2?.();
            const n4 = i4.detail.value, o2 = new Set(Array.isArray(n4) ? n4 : [n4]);
            for (const e3 of a2.options)
              e3.selected = o2.has(e3.value);
            e2.setValue(t2, { value: getValue(true) }), r2 = getValue(false);
          }, multipleSelection(e3) {
            a2.multiple = true;
          }, remove(i4) {
            const n4 = a2.options, s3 = i4.detail.remove;
            if (n4[s3].selected = false, a2.remove(s3), n4.length > 0) {
              -1 === Array.prototype.findIndex.call(n4, (e3) => e3.selected) && (n4[0].selected = true);
            }
            e2.setValue(t2, { value: getValue(true), items: getItems(i4) }), r2 = getValue(false);
          }, clear(i4) {
            for (; 0 !== a2.length; )
              a2.remove(0);
            e2.setValue(t2, { value: null, items: [] }), r2 = getValue(false);
          }, insert(i4) {
            const { index: n4, displayValue: s3, exportValue: o2 } = i4.detail.insert, l3 = a2.children[n4], c2 = document.createElement("option");
            c2.textContent = s3, c2.value = o2, l3 ? l3.before(c2) : a2.append(c2), e2.setValue(t2, { value: getValue(true), items: getItems(i4) }), r2 = getValue(false);
          }, items(i4) {
            const { items: n4 } = i4.detail;
            for (; 0 !== a2.length; )
              a2.remove(0);
            for (const e3 of n4) {
              const { displayValue: t3, exportValue: i5 } = e3, n5 = document.createElement("option");
              n5.textContent = t3, n5.value = i5, a2.append(n5);
            }
            a2.options.length > 0 && (a2.options[0].selected = true), e2.setValue(t2, { value: getValue(true), items: getItems(i4) }), r2 = getValue(false);
          }, indices(i4) {
            const a3 = new Set(i4.detail.indices);
            for (const e3 of i4.target.options)
              e3.selected = a3.has(e3.index);
            e2.setValue(t2, { value: getValue(true) }), r2 = getValue(false);
          }, editable(e3) {
            e3.target.disabled = !e3.detail.editable;
          } };
          this._dispatchEventFromSandbox(n3, i3);
        }), a2.addEventListener("input", (i3) => {
          const a3 = getValue(true), n3 = getValue(false);
          e2.setValue(t2, { value: a3 }), i3.preventDefault(), this.linkService.eventBus?.dispatch("dispatcheventinsandbox", { source: this, detail: { id: t2, name: "Keystroke", value: r2, change: n3, changeEx: a3, willCommit: false, commitKey: 1, keyDown: false } });
        }), this._setEventListeners(a2, null, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"], ["input", "Action"], ["input", "Validate"]], (e3) => e3.target.value)) : a2.addEventListener("input", function(i3) {
          e2.setValue(t2, { value: getValue(true) });
        }), this.data.combo && this._setTextStyle(a2), this._setBackgroundColor(a2), this._setDefaultPropertiesFromJS(a2), this.container.append(a2), this.container;
      }
    };
    __name(ChoiceWidgetAnnotationElement, "ChoiceWidgetAnnotationElement");
    PopupAnnotationElement = class extends AnnotationElement {
      constructor(e2) {
        const { data: t2, elements: i2 } = e2;
        super(e2, { isRenderable: AnnotationElement._hasPopupData(t2) }), this.elements = i2, this.popup = null;
      }
      render() {
        const { container: e2 } = this;
        e2.classList.add("popupAnnotation"), e2.role = "comment";
        const t2 = this.popup = new PopupElement({ container: this.container, color: this.data.color, titleObj: this.data.titleObj, modificationDate: this.data.modificationDate || this.data.creationDate, contentsObj: this.data.contentsObj, richText: this.data.richText, rect: this.data.rect, parentRect: this.data.parentRect || null, parent: this.parent, elements: this.elements, open: this.data.open, eventBus: this.linkService.eventBus }), i2 = [];
        for (const e3 of this.elements)
          e3.popup = t2, e3.container.ariaHasPopup = "dialog", i2.push(e3.data.id), e3.addHighlightArea();
        return this.container.setAttribute("aria-controls", i2.map((e3) => `${gc}${e3}`).join(",")), this.container;
      }
    };
    __name(PopupAnnotationElement, "PopupAnnotationElement");
    PopupElement = class {
      #Hr = this.#Mr.bind(this);
      #qr = this.#Xr.bind(this);
      #zr = this.#Wr.bind(this);
      #Gr = this.#Vr.bind(this);
      #Kr = null;
      #Ai = null;
      #Yr = null;
      #Jr = null;
      #Zr = null;
      #kr = null;
      #Qr = null;
      #eo = null;
      #to = false;
      #io = null;
      #ao = null;
      #It = null;
      #na = null;
      #no = null;
      #so = null;
      #ro = null;
      #oo = null;
      #lo = null;
      #Pr = null;
      #co = false;
      constructor({ container: e2, color: t2, elements: i2, titleObj: a2, modificationDate: n2, contentsObj: s2, richText: r2, parent: o2, rect: l3, parentRect: c2, open: h2, eventBus: d2 = null }) {
        this.#Ai = e2, this.#lo = a2, this.#Yr = s2, this.#oo = r2, this.#Qr = o2, this.#Kr = t2, this.#ro = l3, this.#eo = c2, this.#Zr = i2, this.#kr = d2, this.#Jr = PDFDateString.toDateObject(n2), this.trigger = i2.flatMap((e3) => e3.getElementsToTriggerPopup()), this.#ho(), this.#Ai.hidden = true, h2 && this.#Vr();
      }
      #ho() {
        if (this.#ao)
          return;
        this.#ao = new AbortController();
        const { signal: e2 } = this.#ao;
        for (const t2 of this.trigger)
          t2.addEventListener("click", this.#Gr, { signal: e2 }), t2.addEventListener("mouseenter", this.#zr, { signal: e2 }), t2.addEventListener("mouseleave", this.#qr, { signal: e2 }), t2.classList.add("popupTriggerArea");
        for (const t2 of this.#Zr)
          t2.container?.addEventListener("keydown", this.#Hr, { signal: e2 });
        this.#do();
      }
      #uo() {
        const e2 = this.#Zr.find((e3) => e3.hasCommentButton);
        e2 && (this.#no = e2._normalizePoint(e2.commentButtonPosition), this.#so = e2.commentButtonColor);
      }
      #do() {
        if (this.#na)
          return;
        if (this.#no || this.#uo(), !this.#no)
          return;
        const e2 = this.#na = document.createElement("button");
        e2.className = "annotationCommentButton";
        const t2 = this.#Zr[0].container;
        e2.style.zIndex = t2.style.zIndex + 1, e2.tabIndex = 0;
        const { signal: i2 } = this.#ao;
        e2.addEventListener("hover", this.#Gr, { signal: i2 }), e2.addEventListener("keydown", this.#Hr, { signal: i2 }), e2.addEventListener("click", () => {
          const [{ data: { id: e3 }, annotationEditorType: t3 }] = this.#Zr;
          this.#kr?.dispatch("switchannotationeditormode", { source: this, editId: e3, mode: t3, editComment: true });
        }, { signal: i2 });
        const { style: a2 } = e2;
        a2.left = `calc(${this.#no[0]}%)`, a2.top = `calc(${this.#no[1]}% - var(--comment-button-dim))`, this.#so && (a2.backgroundColor = this.#so), t2.after(e2);
      }
      render() {
        if (this.#io)
          return;
        const e2 = this.#io = document.createElement("div");
        if (e2.className = "popup", this.#Kr) {
          const t3 = e2.style.outlineColor = Util.makeHexColor(...this.#Kr);
          e2.style.backgroundColor = `color-mix(in srgb, ${t3} 30%, white)`;
        }
        const t2 = document.createElement("span");
        if (t2.className = "header", this.#lo?.str) {
          const e3 = document.createElement("span");
          e3.className = "title", t2.append(e3), { dir: e3.dir, str: e3.textContent } = this.#lo;
        }
        if (e2.append(t2), this.#Jr) {
          const e3 = document.createElement("time");
          e3.className = "popupDate", e3.setAttribute("data-l10n-id", "pdfjs-annotation-date-time-string"), e3.setAttribute("data-l10n-args", JSON.stringify({ dateObj: this.#Jr.valueOf() })), e3.dateTime = this.#Jr.toISOString(), t2.append(e3);
        }
        const i2 = this.#go;
        if (i2)
          XfaLayer.render({ xfaHtml: i2, intent: "richText", div: e2 }), e2.lastChild.classList.add("richText", "popupContent");
        else {
          const t3 = this._formatContents(this.#Yr);
          e2.append(t3);
        }
        this.#Ai.append(e2);
      }
      get #go() {
        const e2 = this.#oo, t2 = this.#Yr;
        return !e2?.str || t2?.str && t2.str !== e2.str ? null : this.#oo.html || null;
      }
      get #po() {
        return this.#go?.attributes?.style?.fontSize || 0;
      }
      get #fo() {
        return this.#go?.attributes?.style?.color || null;
      }
      #mo(e2) {
        const t2 = [], i2 = { str: e2, html: { name: "div", attributes: { dir: "auto" }, children: [{ name: "p", children: t2 }] } }, a2 = { style: { color: this.#fo, fontSize: this.#po ? `calc(${this.#po}px * var(--total-scale-factor))` : "" } };
        for (const i3 of e2.split("\n"))
          t2.push({ name: "span", value: i3, attributes: a2 });
        return i2;
      }
      _formatContents({ str: e2, dir: t2 }) {
        const i2 = document.createElement("p");
        i2.classList.add("popupContent"), i2.dir = t2;
        const a2 = e2.split(/(?:\r\n?|\n)/);
        for (let e3 = 0, t3 = a2.length; e3 < t3; ++e3) {
          const n2 = a2[e3];
          i2.append(document.createTextNode(n2)), e3 < t3 - 1 && i2.append(document.createElement("br"));
        }
        return i2;
      }
      #Mr(e2) {
        e2.altKey || e2.shiftKey || e2.ctrlKey || e2.metaKey || ("Enter" === e2.key || "Escape" === e2.key && this.#to) && this.#Vr();
      }
      updateEdited({ rect: e2, popup: t2, deleted: i2 }) {
        i2 || t2?.deleted ? this.remove() : (this.#ho(), this.#Pr ||= { contentsObj: this.#Yr, richText: this.#oo }, e2 && (this.#It = null), t2 && (this.#oo = this.#mo(t2.text), this.#Jr = PDFDateString.toDateObject(t2.date), this.#Yr = null), this.#io?.remove(), this.#io = null);
      }
      resetEdited() {
        this.#Pr && ({ contentsObj: this.#Yr, richText: this.#oo } = this.#Pr, this.#Pr = null, this.#io?.remove(), this.#io = null, this.#It = null);
      }
      remove() {
        this.#ao?.abort(), this.#ao = null, this.#io?.remove(), this.#io = null, this.#co = false, this.#to = false;
        for (const e2 of this.trigger)
          e2.classList.remove("popupTriggerArea");
      }
      #bo() {
        if (null !== this.#It)
          return;
        const { page: { view: e2 }, viewport: { rawDims: { pageWidth: t2, pageHeight: i2, pageX: a2, pageY: n2 } } } = this.#Qr;
        let s2 = !!this.#eo, r2 = s2 ? this.#eo : this.#ro;
        for (const e3 of this.#Zr)
          if (!r2 || null !== Util.intersect(e3.data.rect, r2)) {
            r2 = e3.data.rect, s2 = true;
            break;
          }
        const o2 = Util.normalizeRect([r2[0], e2[3] - r2[1] + e2[1], r2[2], e2[3] - r2[3] + e2[1]]), l3 = s2 ? r2[2] - r2[0] + 5 : 0, c2 = o2[0] + l3, h2 = o2[1];
        this.#It = [100 * (c2 - a2) / t2, 100 * (h2 - n2) / i2];
        const { style: d2 } = this.#Ai;
        d2.left = `${this.#It[0]}%`, d2.top = `${this.#It[1]}%`;
      }
      #Vr() {
        this.#to = !this.#to, this.#to ? (this.#Wr(), this.#Ai.addEventListener("click", this.#Gr), this.#Ai.addEventListener("keydown", this.#Hr)) : (this.#Xr(), this.#Ai.removeEventListener("click", this.#Gr), this.#Ai.removeEventListener("keydown", this.#Hr));
      }
      #Wr() {
        this.#io || this.render(), this.isVisible ? this.#to && this.#Ai.classList.add("focused") : (this.#bo(), this.#Ai.hidden = false, this.#Ai.style.zIndex = parseInt(this.#Ai.style.zIndex) + 1e3);
      }
      #Xr() {
        this.#Ai.classList.remove("focused"), !this.#to && this.isVisible && (this.#Ai.hidden = true, this.#Ai.style.zIndex = parseInt(this.#Ai.style.zIndex) - 1e3);
      }
      forceHide() {
        this.#co = this.isVisible, this.#co && (this.#Ai.hidden = true);
      }
      maybeShow() {
        this.#ho(), this.#co && (this.#io || this.#Wr(), this.#co = false, this.#Ai.hidden = false);
      }
      get isVisible() {
        return false === this.#Ai.hidden;
      }
    };
    __name(PopupElement, "PopupElement");
    FreeTextAnnotationElement = class extends AnnotationElement {
      constructor(e2) {
        super(e2, { isRenderable: true, ignoreBorder: true }), this.textContent = e2.data.textContent, this.textPosition = e2.data.textPosition, this.annotationEditorType = Ll.FREETEXT;
      }
      render() {
        if (this.container.classList.add("freeTextAnnotation"), this.textContent) {
          const e2 = document.createElement("div");
          e2.classList.add("annotationTextContent"), e2.setAttribute("role", "comment");
          for (const t2 of this.textContent) {
            const i2 = document.createElement("span");
            i2.textContent = t2, e2.append(i2);
          }
          this.container.append(e2);
        }
        return !this.data.popupRef && this.hasPopupData && this._createPopup(), this._editOnDoubleClick(), this.container;
      }
    };
    __name(FreeTextAnnotationElement, "FreeTextAnnotationElement");
    LineAnnotationElement = class extends AnnotationElement {
      #yo = null;
      constructor(e2) {
        super(e2, { isRenderable: true, ignoreBorder: true });
      }
      render() {
        this.container.classList.add("lineAnnotation");
        const { data: e2, width: t2, height: i2 } = this, a2 = this.svgFactory.create(t2, i2, true), n2 = this.#yo = this.svgFactory.createElement("svg:line");
        return n2.setAttribute("x1", e2.rect[2] - e2.lineCoordinates[0]), n2.setAttribute("y1", e2.rect[3] - e2.lineCoordinates[1]), n2.setAttribute("x2", e2.rect[2] - e2.lineCoordinates[2]), n2.setAttribute("y2", e2.rect[3] - e2.lineCoordinates[3]), n2.setAttribute("stroke-width", e2.borderStyle.width || 1), n2.setAttribute("stroke", "transparent"), n2.setAttribute("fill", "transparent"), a2.append(n2), this.container.append(a2), !e2.popupRef && this.hasPopupData && this._createPopup(), this.container;
      }
      getElementsToTriggerPopup() {
        return this.#yo;
      }
      addHighlightArea() {
        this.container.classList.add("highlightArea");
      }
    };
    __name(LineAnnotationElement, "LineAnnotationElement");
    SquareAnnotationElement = class extends AnnotationElement {
      #wo = null;
      constructor(e2) {
        super(e2, { isRenderable: true, ignoreBorder: true });
      }
      render() {
        this.container.classList.add("squareAnnotation");
        const { data: e2, width: t2, height: i2 } = this, a2 = this.svgFactory.create(t2, i2, true), n2 = e2.borderStyle.width, s2 = this.#wo = this.svgFactory.createElement("svg:rect");
        return s2.setAttribute("x", n2 / 2), s2.setAttribute("y", n2 / 2), s2.setAttribute("width", t2 - n2), s2.setAttribute("height", i2 - n2), s2.setAttribute("stroke-width", n2 || 1), s2.setAttribute("stroke", "transparent"), s2.setAttribute("fill", "transparent"), a2.append(s2), this.container.append(a2), !e2.popupRef && this.hasPopupData && this._createPopup(), this.container;
      }
      getElementsToTriggerPopup() {
        return this.#wo;
      }
      addHighlightArea() {
        this.container.classList.add("highlightArea");
      }
    };
    __name(SquareAnnotationElement, "SquareAnnotationElement");
    CircleAnnotationElement = class extends AnnotationElement {
      #Ao = null;
      constructor(e2) {
        super(e2, { isRenderable: true, ignoreBorder: true });
      }
      render() {
        this.container.classList.add("circleAnnotation");
        const { data: e2, width: t2, height: i2 } = this, a2 = this.svgFactory.create(t2, i2, true), n2 = e2.borderStyle.width, s2 = this.#Ao = this.svgFactory.createElement("svg:ellipse");
        return s2.setAttribute("cx", t2 / 2), s2.setAttribute("cy", i2 / 2), s2.setAttribute("rx", t2 / 2 - n2 / 2), s2.setAttribute("ry", i2 / 2 - n2 / 2), s2.setAttribute("stroke-width", n2 || 1), s2.setAttribute("stroke", "transparent"), s2.setAttribute("fill", "transparent"), a2.append(s2), this.container.append(a2), !e2.popupRef && this.hasPopupData && this._createPopup(), this.container;
      }
      getElementsToTriggerPopup() {
        return this.#Ao;
      }
      addHighlightArea() {
        this.container.classList.add("highlightArea");
      }
    };
    __name(CircleAnnotationElement, "CircleAnnotationElement");
    PolylineAnnotationElement = class extends AnnotationElement {
      #xo = null;
      constructor(e2) {
        super(e2, { isRenderable: true, ignoreBorder: true }), this.containerClassName = "polylineAnnotation", this.svgElementName = "svg:polyline";
      }
      render() {
        this.container.classList.add(this.containerClassName);
        const { data: { rect: e2, vertices: t2, borderStyle: i2, popupRef: a2 }, width: n2, height: s2 } = this;
        if (!t2)
          return this.container;
        const r2 = this.svgFactory.create(n2, s2, true);
        let o2 = [];
        for (let i3 = 0, a3 = t2.length; i3 < a3; i3 += 2) {
          const a4 = t2[i3] - e2[0], n3 = e2[3] - t2[i3 + 1];
          o2.push(`${a4},${n3}`);
        }
        o2 = o2.join(" ");
        const l3 = this.#xo = this.svgFactory.createElement(this.svgElementName);
        return l3.setAttribute("points", o2), l3.setAttribute("stroke-width", i2.width || 1), l3.setAttribute("stroke", "transparent"), l3.setAttribute("fill", "transparent"), r2.append(l3), this.container.append(r2), !a2 && this.hasPopupData && this._createPopup(), this.container;
      }
      getElementsToTriggerPopup() {
        return this.#xo;
      }
      addHighlightArea() {
        this.container.classList.add("highlightArea");
      }
    };
    __name(PolylineAnnotationElement, "PolylineAnnotationElement");
    PolygonAnnotationElement = class extends PolylineAnnotationElement {
      constructor(e2) {
        super(e2), this.containerClassName = "polygonAnnotation", this.svgElementName = "svg:polygon";
      }
    };
    __name(PolygonAnnotationElement, "PolygonAnnotationElement");
    CaretAnnotationElement = class extends AnnotationElement {
      constructor(e2) {
        super(e2, { isRenderable: true, ignoreBorder: true });
      }
      render() {
        return this.container.classList.add("caretAnnotation"), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container;
      }
    };
    __name(CaretAnnotationElement, "CaretAnnotationElement");
    InkAnnotationElement = class extends AnnotationElement {
      #So = null;
      #vo = [];
      constructor(e2) {
        super(e2, { isRenderable: true, ignoreBorder: true }), this.containerClassName = "inkAnnotation", this.svgElementName = "svg:polyline", this.annotationEditorType = "InkHighlight" === this.data.it ? Ll.HIGHLIGHT : Ll.INK;
      }
      #Co(e2, t2) {
        switch (e2) {
          case 90:
            return { transform: `rotate(90) translate(${-t2[0]},${t2[1]}) scale(1,-1)`, width: t2[3] - t2[1], height: t2[2] - t2[0] };
          case 180:
            return { transform: `rotate(180) translate(${-t2[2]},${t2[1]}) scale(1,-1)`, width: t2[2] - t2[0], height: t2[3] - t2[1] };
          case 270:
            return { transform: `rotate(270) translate(${-t2[2]},${t2[3]}) scale(1,-1)`, width: t2[3] - t2[1], height: t2[2] - t2[0] };
          default:
            return { transform: `translate(${-t2[0]},${t2[3]}) scale(1,-1)`, width: t2[2] - t2[0], height: t2[3] - t2[1] };
        }
      }
      render() {
        this.container.classList.add(this.containerClassName);
        const { data: { rect: e2, rotation: t2, inkLists: i2, borderStyle: a2, popupRef: n2 } } = this, { transform: s2, width: r2, height: o2 } = this.#Co(t2, e2), l3 = this.svgFactory.create(r2, o2, true), c2 = this.#So = this.svgFactory.createElement("svg:g");
        l3.append(c2), c2.setAttribute("stroke-width", a2.width || 1), c2.setAttribute("stroke-linecap", "round"), c2.setAttribute("stroke-linejoin", "round"), c2.setAttribute("stroke-miterlimit", 10), c2.setAttribute("stroke", "transparent"), c2.setAttribute("fill", "transparent"), c2.setAttribute("transform", s2);
        for (let e3 = 0, t3 = i2.length; e3 < t3; e3++) {
          const t4 = this.svgFactory.createElement(this.svgElementName);
          this.#vo.push(t4), t4.setAttribute("points", i2[e3].join(",")), c2.append(t4);
        }
        return !n2 && this.hasPopupData && this._createPopup(), this.container.append(l3), this._editOnDoubleClick(), this.container;
      }
      updateEdited(e2) {
        super.updateEdited(e2);
        const { thickness: t2, points: i2, rect: a2 } = e2, n2 = this.#So;
        if (t2 >= 0 && n2.setAttribute("stroke-width", t2 || 1), i2)
          for (let e3 = 0, t3 = this.#vo.length; e3 < t3; e3++)
            this.#vo[e3].setAttribute("points", i2[e3].join(","));
        if (a2) {
          const { transform: e3, width: t3, height: i3 } = this.#Co(this.data.rotation, a2);
          n2.parentElement.setAttribute("viewBox", `0 0 ${t3} ${i3}`), n2.setAttribute("transform", e3);
        }
      }
      getElementsToTriggerPopup() {
        return this.#vo;
      }
      addHighlightArea() {
        this.container.classList.add("highlightArea");
      }
      get commentButtonPosition() {
        const { inkLists: e2, rect: t2 } = this.data;
        if (e2?.length >= 1) {
          let t3 = -1 / 0, i2 = -1 / 0;
          for (const a2 of e2)
            for (let e3 = 0, n2 = a2.length; e3 < n2; e3 += 2)
              a2[e3 + 1] > i2 ? (i2 = a2[e3 + 1], t3 = a2[e3]) : a2[e3 + 1] === i2 && (t3 = Math.max(t3, a2[e3]));
          if (t3 !== 1 / 0)
            return [t3, i2];
        }
        return t2 ? [t2[2], t2[3]] : null;
      }
    };
    __name(InkAnnotationElement, "InkAnnotationElement");
    HighlightAnnotationElement = class extends AnnotationElement {
      constructor(e2) {
        super(e2, { isRenderable: true, ignoreBorder: true, createQuadrilaterals: true }), this.annotationEditorType = Ll.HIGHLIGHT;
      }
      render() {
        const { data: { overlaidText: e2, popupRef: t2 } } = this;
        if (!t2 && this.hasPopupData && this._createPopup(), this.container.classList.add("highlightAnnotation"), this._editOnDoubleClick(), e2) {
          const t3 = document.createElement("mark");
          t3.classList.add("overlaidText"), t3.textContent = e2, this.container.append(t3);
        }
        return this.container;
      }
    };
    __name(HighlightAnnotationElement, "HighlightAnnotationElement");
    UnderlineAnnotationElement = class extends AnnotationElement {
      constructor(e2) {
        super(e2, { isRenderable: true, ignoreBorder: true, createQuadrilaterals: true });
      }
      render() {
        const { data: { overlaidText: e2, popupRef: t2 } } = this;
        if (!t2 && this.hasPopupData && this._createPopup(), this.container.classList.add("underlineAnnotation"), e2) {
          const t3 = document.createElement("u");
          t3.classList.add("overlaidText"), t3.textContent = e2, this.container.append(t3);
        }
        return this.container;
      }
    };
    __name(UnderlineAnnotationElement, "UnderlineAnnotationElement");
    SquigglyAnnotationElement = class extends AnnotationElement {
      constructor(e2) {
        super(e2, { isRenderable: true, ignoreBorder: true, createQuadrilaterals: true });
      }
      render() {
        const { data: { overlaidText: e2, popupRef: t2 } } = this;
        if (!t2 && this.hasPopupData && this._createPopup(), this.container.classList.add("squigglyAnnotation"), e2) {
          const t3 = document.createElement("u");
          t3.classList.add("overlaidText"), t3.textContent = e2, this.container.append(t3);
        }
        return this.container;
      }
    };
    __name(SquigglyAnnotationElement, "SquigglyAnnotationElement");
    StrikeOutAnnotationElement = class extends AnnotationElement {
      constructor(e2) {
        super(e2, { isRenderable: true, ignoreBorder: true, createQuadrilaterals: true });
      }
      render() {
        const { data: { overlaidText: e2, popupRef: t2 } } = this;
        if (!t2 && this.hasPopupData && this._createPopup(), this.container.classList.add("strikeoutAnnotation"), e2) {
          const t3 = document.createElement("s");
          t3.classList.add("overlaidText"), t3.textContent = e2, this.container.append(t3);
        }
        return this.container;
      }
    };
    __name(StrikeOutAnnotationElement, "StrikeOutAnnotationElement");
    StampAnnotationElement = class extends AnnotationElement {
      constructor(e2) {
        super(e2, { isRenderable: true, ignoreBorder: true }), this.annotationEditorType = Ll.STAMP;
      }
      render() {
        return this.container.classList.add("stampAnnotation"), this.container.setAttribute("role", "img"), !this.data.popupRef && this.hasPopupData && this._createPopup(), this._editOnDoubleClick(), this.container;
      }
    };
    __name(StampAnnotationElement, "StampAnnotationElement");
    FileAttachmentAnnotationElement = class extends AnnotationElement {
      #ko = null;
      constructor(e2) {
        super(e2, { isRenderable: true });
        const { file: t2 } = this.data;
        this.filename = t2.filename, this.content = t2.content, this.linkService.eventBus?.dispatch("fileattachmentannotation", { source: this, ...t2 });
      }
      render() {
        this.container.classList.add("fileAttachmentAnnotation");
        const { container: e2, data: t2 } = this;
        let i2;
        t2.hasAppearance || 0 === t2.fillAlpha ? i2 = document.createElement("div") : (i2 = document.createElement("img"), i2.src = `${this.imageResourcesPath}annotation-${/paperclip/i.test(t2.name) ? "paperclip" : "pushpin"}.svg`, t2.fillAlpha && t2.fillAlpha < 1 && (i2.style = `filter: opacity(${Math.round(100 * t2.fillAlpha)}%);`)), i2.addEventListener("dblclick", this.#To.bind(this)), this.#ko = i2;
        const { isMac: a2 } = util_FeatureTest.platform;
        return e2.addEventListener("keydown", (e3) => {
          "Enter" === e3.key && (a2 ? e3.metaKey : e3.ctrlKey) && this.#To();
        }), !t2.popupRef && this.hasPopupData ? this._createPopup() : i2.classList.add("popupTriggerArea"), e2.append(i2), e2;
      }
      getElementsToTriggerPopup() {
        return this.#ko;
      }
      addHighlightArea() {
        this.container.classList.add("highlightArea");
      }
      #To() {
        this.downloadManager?.openOrDownloadData(this.content, this.filename);
      }
    };
    __name(FileAttachmentAnnotationElement, "FileAttachmentAnnotationElement");
    AnnotationLayer = class {
      #Io = null;
      #Fo = null;
      #Mo = /* @__PURE__ */ new Map();
      #Do = null;
      constructor({ div: e2, accessibilityManager: t2, annotationCanvasMap: i2, annotationEditorUIManager: a2, page: n2, viewport: s2, structTreeLayer: r2 }) {
        this.div = e2, this.#Io = t2, this.#Fo = i2, this.#Do = r2 || null, this.page = n2, this.viewport = s2, this.zIndex = 0, this._annotationEditorUIManager = a2;
      }
      hasEditableAnnotations() {
        return this.#Mo.size > 0;
      }
      async #Eo(e2, t2, i2) {
        const a2 = e2.firstChild || e2, n2 = a2.id = `${gc}${t2}`, s2 = await this.#Do?.getAriaAttributes(n2);
        if (s2)
          for (const [e3, t3] of s2)
            a2.setAttribute(e3, t3);
        i2 ? i2.at(-1).container.after(e2) : (this.div.append(e2), this.#Io?.moveElementInDOM(this.div, e2, a2, false));
      }
      async render(e2) {
        const { annotations: t2 } = e2, i2 = this.div;
        setLayerDimensions(i2, this.viewport);
        const a2 = /* @__PURE__ */ new Map(), n2 = { data: null, layer: i2, linkService: e2.linkService, downloadManager: e2.downloadManager, imageResourcesPath: e2.imageResourcesPath || "", renderForms: false !== e2.renderForms, svgFactory: new DOMSVGFactory(), annotationStorage: e2.annotationStorage || new AnnotationStorage(), enableComment: true === e2.enableComment, enableScripting: true === e2.enableScripting, hasJSActions: e2.hasJSActions, fieldObjects: e2.fieldObjects, parent: this, elements: null };
        for (const e3 of t2) {
          if (e3.noHTML)
            continue;
          const t3 = e3.annotationType === Kl.POPUP;
          if (t3) {
            const t4 = a2.get(e3.id);
            if (!t4)
              continue;
            n2.elements = t4;
          } else if (e3.rect[2] === e3.rect[0] || e3.rect[3] === e3.rect[1])
            continue;
          n2.data = e3;
          const i3 = AnnotationElementFactory.create(n2);
          if (!i3.isRenderable)
            continue;
          if (!t3 && e3.popupRef) {
            const t4 = a2.get(e3.popupRef);
            t4 ? t4.push(i3) : a2.set(e3.popupRef, [i3]);
          }
          const s2 = i3.render();
          e3.hidden && (s2.style.visibility = "hidden"), await this.#Eo(s2, e3.id, n2.elements), i3._isEditable && (this.#Mo.set(i3.data.id, i3), this._annotationEditorUIManager?.renderAnnotationElement(i3));
        }
        this.#Oo();
      }
      async addLinkAnnotations(e2, t2) {
        const i2 = { data: null, layer: this.div, linkService: t2, svgFactory: new DOMSVGFactory(), parent: this };
        for (const t3 of e2) {
          t3.borderStyle ||= AnnotationLayer._defaultBorderStyle, i2.data = t3;
          const e3 = AnnotationElementFactory.create(i2);
          if (!e3.isRenderable)
            continue;
          const a2 = e3.render();
          await this.#Eo(a2, t3.id, null);
        }
      }
      update({ viewport: e2 }) {
        const t2 = this.div;
        this.viewport = e2, setLayerDimensions(t2, { rotation: e2.rotation }), this.#Oo(), t2.hidden = false;
      }
      #Oo() {
        if (!this.#Fo)
          return;
        const e2 = this.div;
        for (const [t2, i2] of this.#Fo) {
          const a2 = e2.querySelector(`[data-annotation-id="${t2}"]`);
          if (!a2)
            continue;
          i2.className = "annotationContent";
          const { firstChild: n2 } = a2;
          n2 ? "CANVAS" === n2.nodeName ? n2.replaceWith(i2) : n2.classList.contains("annotationContent") ? n2.after(i2) : n2.before(i2) : a2.append(i2);
          const s2 = this.#Mo.get(t2);
          s2 && (s2._hasNoCanvas ? (this._annotationEditorUIManager?.setMissingCanvas(t2, a2.id, i2), s2._hasNoCanvas = false) : s2.canvas = i2);
        }
        this.#Fo.clear();
      }
      getEditableAnnotations() {
        return Array.from(this.#Mo.values());
      }
      getEditableAnnotation(e2) {
        return this.#Mo.get(e2);
      }
      static get _defaultBorderStyle() {
        return shadow(this, "_defaultBorderStyle", Object.freeze({ width: 1, rawWidth: 1, style: Yl, dashArray: [3], horizontalCornerRadius: 0, verticalCornerRadius: 0 }));
      }
    };
    __name(AnnotationLayer, "AnnotationLayer");
    sh = /\r\n?|\n/g;
    _FreeTextEditor = class extends AnnotationEditor {
      constructor(e2) {
        super({ ...e2, name: "freeTextEditor" });
        __privateAdd(this, _Bo);
        __privateAdd(this, _No);
        __privateAdd(this, _Uo);
        __privateAdd(this, _Lo);
        __privateAdd(this, _$o);
        __privateAdd(this, _qo);
        __privateAdd(this, _Xo);
        __privateAdd(this, _Kr, void 0);
        __privateAdd(this, __o, "");
        __privateAdd(this, _Po, `${this.id}-editor`);
        __privateAdd(this, _Ro, null);
        __privateAdd(this, _po, void 0);
        __publicField(this, "_colorPicker", null);
        __privateSet(this, _Kr, e2.color || _FreeTextEditor._defaultColor || AnnotationEditor._defaultLineColor), __privateSet(this, _po, e2.fontSize || _FreeTextEditor._defaultFontSize), this.annotationElementId || this._uiManager.a11yAlert("pdfjs-editor-freetext-added-alert");
      }
      static get _keyboardManager() {
        const e2 = _FreeTextEditor.prototype, arrowChecker = /* @__PURE__ */ __name((e3) => e3.isEmpty(), "arrowChecker"), t2 = AnnotationEditorUIManager.TRANSLATE_SMALL, i2 = AnnotationEditorUIManager.TRANSLATE_BIG;
        return shadow(this, "_keyboardManager", new KeyboardManager([[["ctrl+s", "mac+meta+s", "ctrl+p", "mac+meta+p"], e2.commitOrRemove, { bubbles: true }], [["ctrl+Enter", "mac+meta+Enter", "Escape", "mac+Escape"], e2.commitOrRemove], [["ArrowLeft", "mac+ArrowLeft"], e2._translateEmpty, { args: [-t2, 0], checker: arrowChecker }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], e2._translateEmpty, { args: [-i2, 0], checker: arrowChecker }], [["ArrowRight", "mac+ArrowRight"], e2._translateEmpty, { args: [t2, 0], checker: arrowChecker }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], e2._translateEmpty, { args: [i2, 0], checker: arrowChecker }], [["ArrowUp", "mac+ArrowUp"], e2._translateEmpty, { args: [0, -t2], checker: arrowChecker }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], e2._translateEmpty, { args: [0, -i2], checker: arrowChecker }], [["ArrowDown", "mac+ArrowDown"], e2._translateEmpty, { args: [0, t2], checker: arrowChecker }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], e2._translateEmpty, { args: [0, i2], checker: arrowChecker }]]));
      }
      static initialize(e2, t2) {
        AnnotationEditor.initialize(e2, t2);
        const i2 = getComputedStyle(document.documentElement);
        this._internalPadding = parseFloat(i2.getPropertyValue("--freetext-padding"));
      }
      static updateDefaultParams(e2, t2) {
        switch (e2) {
          case jl.FREETEXT_SIZE:
            _FreeTextEditor._defaultFontSize = t2;
            break;
          case jl.FREETEXT_COLOR:
            _FreeTextEditor._defaultColor = t2;
        }
      }
      updateParams(e2, t2) {
        switch (e2) {
          case jl.FREETEXT_SIZE:
            __privateMethod(this, _Bo, Bo_fn).call(this, t2);
            break;
          case jl.FREETEXT_COLOR:
            __privateMethod(this, _No, No_fn).call(this, t2);
        }
      }
      static get defaultPropertiesToUpdate() {
        return [[jl.FREETEXT_SIZE, _FreeTextEditor._defaultFontSize], [jl.FREETEXT_COLOR, _FreeTextEditor._defaultColor || AnnotationEditor._defaultLineColor]];
      }
      get propertiesToUpdate() {
        return [[jl.FREETEXT_SIZE, __privateGet(this, _po)], [jl.FREETEXT_COLOR, __privateGet(this, _Kr)]];
      }
      get toolbarButtons() {
        return this._colorPicker ||= new BasicColorPicker(this), [["colorPicker", this._colorPicker]];
      }
      get colorType() {
        return jl.FREETEXT_COLOR;
      }
      get colorValue() {
        return __privateGet(this, _Kr);
      }
      _translateEmpty(e2, t2) {
        this._uiManager.translateSelectedEditors(e2, t2, true);
      }
      getInitialTranslation() {
        const e2 = this.parentScale;
        return [-_FreeTextEditor._internalPadding * e2, -(_FreeTextEditor._internalPadding + __privateGet(this, _po)) * e2];
      }
      rebuild() {
        this.parent && (super.rebuild(), null !== this.div && (this.isAttachedToDOM || this.parent.add(this)));
      }
      enableEditMode() {
        if (!super.enableEditMode())
          return false;
        this.overlayDiv.classList.remove("enabled"), this.editorDiv.contentEditable = true, this._isDraggable = false, this.div.removeAttribute("aria-activedescendant"), __privateSet(this, _Ro, new AbortController());
        const e2 = this._uiManager.combinedSignal(__privateGet(this, _Ro));
        return this.editorDiv.addEventListener("keydown", this.editorDivKeydown.bind(this), { signal: e2 }), this.editorDiv.addEventListener("focus", this.editorDivFocus.bind(this), { signal: e2 }), this.editorDiv.addEventListener("blur", this.editorDivBlur.bind(this), { signal: e2 }), this.editorDiv.addEventListener("input", this.editorDivInput.bind(this), { signal: e2 }), this.editorDiv.addEventListener("paste", this.editorDivPaste.bind(this), { signal: e2 }), true;
      }
      disableEditMode() {
        return !!super.disableEditMode() && (this.overlayDiv.classList.add("enabled"), this.editorDiv.contentEditable = false, this.div.setAttribute("aria-activedescendant", __privateGet(this, _Po)), this._isDraggable = true, __privateGet(this, _Ro)?.abort(), __privateSet(this, _Ro, null), this.div.focus({ preventScroll: true }), this.isEditing = false, this.parent.div.classList.add("freetextEditing"), true);
      }
      focusin(e2) {
        this._focusEventsAllowed && (super.focusin(e2), e2.target !== this.editorDiv && this.editorDiv.focus());
      }
      onceAdded(e2) {
        this.width || (this.enableEditMode(), e2 && this.editorDiv.focus(), this._initialOptions?.isCentered && this.center(), this._initialOptions = null);
      }
      isEmpty() {
        return !this.editorDiv || "" === this.editorDiv.innerText.trim();
      }
      remove() {
        this.isEditing = false, this.parent && (this.parent.setEditingState(true), this.parent.div.classList.add("freetextEditing")), super.remove();
      }
      commit() {
        if (!this.isInEditMode())
          return;
        super.commit(), this.disableEditMode();
        const e2 = __privateGet(this, __o), t2 = __privateSet(this, __o, __privateMethod(this, _Uo, Uo_fn).call(this).trimEnd());
        if (e2 === t2)
          return;
        const setText = /* @__PURE__ */ __name((e3) => {
          __privateSet(this, __o, e3), e3 ? (__privateMethod(this, _$o, $o_fn).call(this), this._uiManager.rebuild(this), __privateMethod(this, _Lo, Lo_fn).call(this)) : this.remove();
        }, "setText");
        this.addCommands({ cmd: () => {
          setText(t2);
        }, undo: () => {
          setText(e2);
        }, mustExec: false }), __privateMethod(this, _Lo, Lo_fn).call(this);
      }
      shouldGetKeyboardEvents() {
        return this.isInEditMode();
      }
      enterInEditMode() {
        this.enableEditMode(), this.editorDiv.focus();
      }
      keydown(e2) {
        e2.target === this.div && "Enter" === e2.key && (this.enterInEditMode(), e2.preventDefault());
      }
      editorDivKeydown(e2) {
        _FreeTextEditor._keyboardManager.exec(this, e2);
      }
      editorDivFocus(e2) {
        this.isEditing = true;
      }
      editorDivBlur(e2) {
        this.isEditing = false;
      }
      editorDivInput(e2) {
        this.parent.div.classList.toggle("freetextEditing", this.isEmpty());
      }
      disableEditing() {
        this.editorDiv.setAttribute("role", "comment"), this.editorDiv.removeAttribute("aria-multiline");
      }
      enableEditing() {
        this.editorDiv.setAttribute("role", "textbox"), this.editorDiv.setAttribute("aria-multiline", true);
      }
      get canChangeContent() {
        return true;
      }
      render() {
        if (this.div)
          return this.div;
        let e2, t2;
        (this._isCopy || this.annotationElementId) && (e2 = this.x, t2 = this.y), super.render(), this.editorDiv = document.createElement("div"), this.editorDiv.className = "internal", this.editorDiv.setAttribute("id", __privateGet(this, _Po)), this.editorDiv.setAttribute("data-l10n-id", "pdfjs-free-text2"), this.editorDiv.setAttribute("data-l10n-attrs", "default-content"), this.enableEditing(), this.editorDiv.contentEditable = true;
        const { style: i2 } = this.editorDiv;
        if (i2.fontSize = `calc(${__privateGet(this, _po)}px * var(--total-scale-factor))`, i2.color = __privateGet(this, _Kr), this.div.append(this.editorDiv), this.overlayDiv = document.createElement("div"), this.overlayDiv.classList.add("overlay", "enabled"), this.div.append(this.overlayDiv), this._isCopy || this.annotationElementId) {
          const [i3, a2] = this.parentDimensions;
          if (this.annotationElementId) {
            const { position: n2 } = this._initialData;
            let [s2, r2] = this.getInitialTranslation();
            [s2, r2] = this.pageTranslationToScreen(s2, r2);
            const [o2, l3] = this.pageDimensions, [c2, h2] = this.pageTranslation;
            let d2, u2;
            switch (this.rotation) {
              case 0:
                d2 = e2 + (n2[0] - c2) / o2, u2 = t2 + this.height - (n2[1] - h2) / l3;
                break;
              case 90:
                d2 = e2 + (n2[0] - c2) / o2, u2 = t2 - (n2[1] - h2) / l3, [s2, r2] = [r2, -s2];
                break;
              case 180:
                d2 = e2 - this.width + (n2[0] - c2) / o2, u2 = t2 - (n2[1] - h2) / l3, [s2, r2] = [-s2, -r2];
                break;
              case 270:
                d2 = e2 + (n2[0] - c2 - this.height * l3) / o2, u2 = t2 + (n2[1] - h2 - this.width * o2) / l3, [s2, r2] = [-r2, s2];
            }
            this.setAt(d2 * i3, u2 * a2, s2, r2);
          } else
            this._moveAfterPaste(e2, t2);
          __privateMethod(this, _$o, $o_fn).call(this), this._isDraggable = true, this.editorDiv.contentEditable = false;
        } else
          this._isDraggable = false, this.editorDiv.contentEditable = true;
        return this.div;
      }
      editorDivPaste(e2) {
        var _a4, _b2, _c3;
        const t2 = e2.clipboardData || window.clipboardData, { types: i2 } = t2;
        if (1 === i2.length && "text/plain" === i2[0])
          return;
        e2.preventDefault();
        const a2 = __privateMethod(_a4 = _FreeTextEditor, _Ho, Ho_fn).call(_a4, t2.getData("text") || "").replaceAll(sh, "\n");
        if (!a2)
          return;
        const n2 = window.getSelection();
        if (!n2.rangeCount)
          return;
        this.editorDiv.normalize(), n2.deleteFromDocument();
        const s2 = n2.getRangeAt(0);
        if (!a2.includes("\n"))
          return s2.insertNode(document.createTextNode(a2)), this.editorDiv.normalize(), void n2.collapseToStart();
        const { startContainer: r2, startOffset: o2 } = s2, l3 = [], c2 = [];
        if (r2.nodeType === Node.TEXT_NODE) {
          const e3 = r2.parentElement;
          if (c2.push(r2.nodeValue.slice(o2).replaceAll(sh, "")), e3 !== this.editorDiv) {
            let t3 = l3;
            for (const i3 of this.editorDiv.childNodes)
              i3 !== e3 ? t3.push(__privateMethod(_b2 = _FreeTextEditor, _jo, jo_fn).call(_b2, i3)) : t3 = c2;
          }
          l3.push(r2.nodeValue.slice(0, o2).replaceAll(sh, ""));
        } else if (r2 === this.editorDiv) {
          let e3 = l3, t3 = 0;
          for (const i3 of this.editorDiv.childNodes)
            t3++ === o2 && (e3 = c2), e3.push(__privateMethod(_c3 = _FreeTextEditor, _jo, jo_fn).call(_c3, i3));
        }
        __privateSet(this, __o, `${l3.join("\n")}${a2}${c2.join("\n")}`), __privateMethod(this, _$o, $o_fn).call(this);
        const h2 = new Range();
        let d2 = Math.sumPrecise(l3.map((e3) => e3.length));
        for (const { firstChild: e3 } of this.editorDiv.childNodes)
          if (e3.nodeType === Node.TEXT_NODE) {
            const t3 = e3.nodeValue.length;
            if (d2 <= t3) {
              h2.setStart(e3, d2), h2.setEnd(e3, d2);
              break;
            }
            d2 -= t3;
          }
        n2.removeAllRanges(), n2.addRange(h2);
      }
      get contentDiv() {
        return this.editorDiv;
      }
      getPDFRect() {
        const e2 = _FreeTextEditor._internalPadding * this.parentScale;
        return this.getRect(e2, e2);
      }
      static async deserialize(e2, t2, i2) {
        var _a4;
        let a2 = null;
        if (e2 instanceof FreeTextAnnotationElement) {
          const { data: { defaultAppearanceData: { fontSize: t3, fontColor: i3 }, rect: n3, rotation: s2, id: r2, popupRef: o2, contentsObj: l3 }, textContent: c2, textPosition: h2, parent: { page: { pageNumber: d2 } } } = e2;
          if (!c2 || 0 === c2.length)
            return null;
          a2 = e2 = { annotationType: Ll.FREETEXT, color: Array.from(i3), fontSize: t3, value: c2.join("\n"), position: h2, pageIndex: d2 - 1, rect: n3.slice(0), rotation: s2, annotationElementId: r2, id: r2, deleted: false, popupRef: o2, comment: l3?.str || null };
        }
        const n2 = await super.deserialize(e2, t2, i2);
        return __privateSet(n2, _po, e2.fontSize), __privateSet(n2, _Kr, Util.makeHexColor(...e2.color)), __privateSet(n2, __o, __privateMethod(_a4 = _FreeTextEditor, _Ho, Ho_fn).call(_a4, e2.value)), n2._initialData = a2, e2.comment && n2.setCommentData(e2.comment), n2;
      }
      serialize(e2 = false) {
        if (this.isEmpty())
          return null;
        if (this.deleted)
          return this.serializeDeleted();
        const t2 = this.getPDFRect(), i2 = AnnotationEditor._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : __privateGet(this, _Kr)), a2 = { annotationType: Ll.FREETEXT, color: i2, fontSize: __privateGet(this, _po), value: __privateMethod(this, _qo, qo_fn).call(this), pageIndex: this.pageIndex, rect: t2, rotation: this.rotation, structTreeParentId: this._structTreeParentId };
        return this.addComment(a2), e2 ? (a2.isCopy = true, a2) : this.annotationElementId && !__privateMethod(this, _Xo, Xo_fn).call(this, a2) ? null : (a2.id = this.annotationElementId, a2);
      }
      renderAnnotationElement(e2) {
        const t2 = super.renderAnnotationElement(e2);
        if (!t2)
          return null;
        const { style: i2 } = t2;
        i2.fontSize = `calc(${__privateGet(this, _po)}px * var(--total-scale-factor))`, i2.color = __privateGet(this, _Kr), t2.replaceChildren();
        for (const e3 of __privateGet(this, __o).split("\n")) {
          const i3 = document.createElement("div");
          i3.append(e3 ? document.createTextNode(e3) : document.createElement("br")), t2.append(i3);
        }
        const a2 = { rect: this.getPDFRect() };
        return a2.popup = this.hasEditedComment ? this.comment : { text: __privateGet(this, __o) }, e2.updateEdited(a2), t2;
      }
      resetAnnotationElement(e2) {
        super.resetAnnotationElement(e2), e2.resetEdited();
      }
    };
    FreeTextEditor = _FreeTextEditor;
    __name(FreeTextEditor, "FreeTextEditor");
    _Kr = new WeakMap();
    __o = new WeakMap();
    _Po = new WeakMap();
    _Ro = new WeakMap();
    _po = new WeakMap();
    _Bo = new WeakSet();
    Bo_fn = /* @__PURE__ */ __name(function(e2) {
      const setFontsize = /* @__PURE__ */ __name((e3) => {
        this.editorDiv.style.fontSize = `calc(${e3}px * var(--total-scale-factor))`, this.translate(0, -(e3 - __privateGet(this, _po)) * this.parentScale), __privateSet(this, _po, e3), __privateMethod(this, _Lo, Lo_fn).call(this);
      }, "setFontsize"), t2 = __privateGet(this, _po);
      this.addCommands({ cmd: setFontsize.bind(this, e2), undo: setFontsize.bind(this, t2), post: this._uiManager.updateUI.bind(this._uiManager, this), mustExec: true, type: jl.FREETEXT_SIZE, overwriteIfSameType: true, keepUndo: true });
    }, "#Bo");
    _No = new WeakSet();
    No_fn = /* @__PURE__ */ __name(function(e2) {
      const setColor = /* @__PURE__ */ __name((e3) => {
        __privateSet(this, _Kr, this.editorDiv.style.color = e3), this._colorPicker?.update(e3);
      }, "setColor"), t2 = __privateGet(this, _Kr);
      this.addCommands({ cmd: setColor.bind(this, e2), undo: setColor.bind(this, t2), post: this._uiManager.updateUI.bind(this._uiManager, this), mustExec: true, type: jl.FREETEXT_COLOR, overwriteIfSameType: true, keepUndo: true });
    }, "#No");
    _Uo = new WeakSet();
    Uo_fn = /* @__PURE__ */ __name(function() {
      var _a4;
      const e2 = [];
      this.editorDiv.normalize();
      let t2 = null;
      for (const i2 of this.editorDiv.childNodes)
        t2?.nodeType === Node.TEXT_NODE && "BR" === i2.nodeName || (e2.push(__privateMethod(_a4 = _FreeTextEditor, _jo, jo_fn).call(_a4, i2)), t2 = i2);
      return e2.join("\n");
    }, "#Uo");
    _Lo = new WeakSet();
    Lo_fn = /* @__PURE__ */ __name(function() {
      const [e2, t2] = this.parentDimensions;
      let i2;
      if (this.isAttachedToDOM)
        i2 = this.div.getBoundingClientRect();
      else {
        const { currentLayer: e3, div: t3 } = this, a2 = t3.style.display, n2 = t3.classList.contains("hidden");
        t3.classList.remove("hidden"), t3.style.display = "hidden", e3.div.append(this.div), i2 = t3.getBoundingClientRect(), t3.remove(), t3.style.display = a2, t3.classList.toggle("hidden", n2);
      }
      this.rotation % 180 == this.parentRotation % 180 ? (this.width = i2.width / e2, this.height = i2.height / t2) : (this.width = i2.height / e2, this.height = i2.width / t2), this.fixAndSetPosition();
    }, "#Lo");
    _jo = new WeakSet();
    jo_fn = /* @__PURE__ */ __name(function(e2) {
      return (e2.nodeType === Node.TEXT_NODE ? e2.nodeValue : e2.innerText).replaceAll(sh, "");
    }, "#jo");
    _$o = new WeakSet();
    $o_fn = /* @__PURE__ */ __name(function() {
      if (this.editorDiv.replaceChildren(), __privateGet(this, __o))
        for (const e2 of __privateGet(this, __o).split("\n")) {
          const t2 = document.createElement("div");
          t2.append(e2 ? document.createTextNode(e2) : document.createElement("br")), this.editorDiv.append(t2);
        }
    }, "#$o");
    _qo = new WeakSet();
    qo_fn = /* @__PURE__ */ __name(function() {
      return __privateGet(this, __o).replaceAll("\xA0", " ");
    }, "#qo");
    _Ho = new WeakSet();
    Ho_fn = /* @__PURE__ */ __name(function(e2) {
      return e2.replaceAll(" ", "\xA0");
    }, "#Ho");
    _Xo = new WeakSet();
    Xo_fn = /* @__PURE__ */ __name(function(e2) {
      const { value: t2, fontSize: i2, color: a2, pageIndex: n2 } = this._initialData;
      return this.hasEditedComment || this._hasBeenMoved || e2.value !== t2 || e2.fontSize !== i2 || e2.color.some((e3, t3) => e3 !== a2[t3]) || e2.pageIndex !== n2;
    }, "#Xo");
    __privateAdd(FreeTextEditor, _jo);
    __privateAdd(FreeTextEditor, _Ho);
    __publicField(FreeTextEditor, "_freeTextDefaultContent", "");
    __publicField(FreeTextEditor, "_internalPadding", 0);
    __publicField(FreeTextEditor, "_defaultColor", null);
    __publicField(FreeTextEditor, "_defaultFontSize", 10);
    __publicField(FreeTextEditor, "_type", "freetext");
    __publicField(FreeTextEditor, "_editorType", Ll.FREETEXT);
    Outline = class {
      toSVGPath() {
        unreachable("Abstract method `toSVGPath` must be implemented.");
      }
      get box() {
        unreachable("Abstract getter `box` must be implemented.");
      }
      serialize(e2, t2) {
        unreachable("Abstract method `serialize` must be implemented.");
      }
      static _rescale(e2, t2, i2, a2, n2, s2) {
        s2 ||= new Float32Array(e2.length);
        for (let r2 = 0, o2 = e2.length; r2 < o2; r2 += 2)
          s2[r2] = t2 + e2[r2] * a2, s2[r2 + 1] = i2 + e2[r2 + 1] * n2;
        return s2;
      }
      static _rescaleAndSwap(e2, t2, i2, a2, n2, s2) {
        s2 ||= new Float32Array(e2.length);
        for (let r2 = 0, o2 = e2.length; r2 < o2; r2 += 2)
          s2[r2] = t2 + e2[r2 + 1] * a2, s2[r2 + 1] = i2 + e2[r2] * n2;
        return s2;
      }
      static _translate(e2, t2, i2, a2) {
        a2 ||= new Float32Array(e2.length);
        for (let n2 = 0, s2 = e2.length; n2 < s2; n2 += 2)
          a2[n2] = t2 + e2[n2], a2[n2 + 1] = i2 + e2[n2 + 1];
        return a2;
      }
      static svgRound(e2) {
        return Math.round(1e4 * e2);
      }
      static _normalizePoint(e2, t2, i2, a2, n2) {
        switch (n2) {
          case 90:
            return [1 - t2 / i2, e2 / a2];
          case 180:
            return [1 - e2 / i2, 1 - t2 / a2];
          case 270:
            return [t2 / i2, 1 - e2 / a2];
          default:
            return [e2 / i2, t2 / a2];
        }
      }
      static _normalizePagePoint(e2, t2, i2) {
        switch (i2) {
          case 90:
            return [1 - t2, e2];
          case 180:
            return [1 - e2, 1 - t2];
          case 270:
            return [t2, 1 - e2];
          default:
            return [e2, t2];
        }
      }
      static createBezierPoints(e2, t2, i2, a2, n2, s2) {
        return [(e2 + 5 * i2) / 6, (t2 + 5 * a2) / 6, (5 * i2 + n2) / 6, (5 * a2 + s2) / 6, (i2 + n2) / 2, (a2 + s2) / 2];
      }
    };
    __name(Outline, "Outline");
    __publicField(Outline, "PRECISION", 1e-4);
    _FreeDrawOutliner = class {
      constructor({ x: e2, y: t2 }, i2, a2, n2, s2, r2 = 0) {
        __privateAdd(this, _ol);
        __privateAdd(this, _ll);
        __privateAdd(this, _hl);
        __privateAdd(this, _cl);
        __privateAdd(this, _dl);
        __privateAdd(this, _gl);
        __privateAdd(this, _ul);
        __privateAdd(this, _zo, void 0);
        __privateAdd(this, _Wo, []);
        __privateAdd(this, _Go, void 0);
        __privateAdd(this, _Vo, void 0);
        __privateAdd(this, _Ko, []);
        __privateAdd(this, _Yo, new Float32Array(18));
        __privateAdd(this, _Jo, void 0);
        __privateAdd(this, _Zo, void 0);
        __privateAdd(this, _Qo, void 0);
        __privateAdd(this, _el, void 0);
        __privateAdd(this, _tl, void 0);
        __privateAdd(this, _il, void 0);
        __privateAdd(this, _al, []);
        __privateSet(this, _zo, i2), __privateSet(this, _il, n2 * a2), __privateSet(this, _Vo, s2), __privateGet(this, _Yo).set([NaN, NaN, NaN, NaN, e2, t2], 6), __privateSet(this, _Go, r2), __privateSet(this, _el, __privateGet(_FreeDrawOutliner, _nl) * a2), __privateSet(this, _Qo, __privateGet(_FreeDrawOutliner, _rl) * a2), __privateSet(this, _tl, a2), __privateGet(this, _al).push(e2, t2);
      }
      isEmpty() {
        return isNaN(__privateGet(this, _Yo)[8]);
      }
      add({ x: e2, y: t2 }) {
        __privateSet(this, _Jo, e2), __privateSet(this, _Zo, t2);
        const [i2, a2, n2, s2] = __privateGet(this, _zo);
        let [r2, o2, l3, c2] = __privateGet(this, _Yo).subarray(8, 12);
        const h2 = e2 - l3, d2 = t2 - c2, u2 = Math.hypot(h2, d2);
        if (u2 < __privateGet(this, _Qo))
          return false;
        const g2 = u2 - __privateGet(this, _el), p2 = g2 / u2, f2 = p2 * h2, m2 = p2 * d2;
        let b2 = r2, y2 = o2;
        r2 = l3, o2 = c2, l3 += f2, c2 += m2, __privateGet(this, _al)?.push(e2, t2);
        const w2 = f2 / g2, x2 = -m2 / g2 * __privateGet(this, _il), S2 = w2 * __privateGet(this, _il);
        if (__privateGet(this, _Yo).set(__privateGet(this, _Yo).subarray(2, 8), 0), __privateGet(this, _Yo).set([l3 + x2, c2 + S2], 4), __privateGet(this, _Yo).set(__privateGet(this, _Yo).subarray(14, 18), 12), __privateGet(this, _Yo).set([l3 - x2, c2 - S2], 16), isNaN(__privateGet(this, _Yo)[6]))
          return 0 === __privateGet(this, _Ko).length && (__privateGet(this, _Yo).set([r2 + x2, o2 + S2], 2), __privateGet(this, _Ko).push(NaN, NaN, NaN, NaN, (r2 + x2 - i2) / n2, (o2 + S2 - a2) / s2), __privateGet(this, _Yo).set([r2 - x2, o2 - S2], 14), __privateGet(this, _Wo).push(NaN, NaN, NaN, NaN, (r2 - x2 - i2) / n2, (o2 - S2 - a2) / s2)), __privateGet(this, _Yo).set([b2, y2, r2, o2, l3, c2], 6), !this.isEmpty();
        __privateGet(this, _Yo).set([b2, y2, r2, o2, l3, c2], 6);
        return Math.abs(Math.atan2(y2 - o2, b2 - r2) - Math.atan2(m2, f2)) < Math.PI / 2 ? ([r2, o2, l3, c2] = __privateGet(this, _Yo).subarray(2, 6), __privateGet(this, _Ko).push(NaN, NaN, NaN, NaN, ((r2 + l3) / 2 - i2) / n2, ((o2 + c2) / 2 - a2) / s2), [r2, o2, b2, y2] = __privateGet(this, _Yo).subarray(14, 18), __privateGet(this, _Wo).push(NaN, NaN, NaN, NaN, ((b2 + r2) / 2 - i2) / n2, ((y2 + o2) / 2 - a2) / s2), true) : ([b2, y2, r2, o2, l3, c2] = __privateGet(this, _Yo).subarray(0, 6), __privateGet(this, _Ko).push(((b2 + 5 * r2) / 6 - i2) / n2, ((y2 + 5 * o2) / 6 - a2) / s2, ((5 * r2 + l3) / 6 - i2) / n2, ((5 * o2 + c2) / 6 - a2) / s2, ((r2 + l3) / 2 - i2) / n2, ((o2 + c2) / 2 - a2) / s2), [l3, c2, r2, o2, b2, y2] = __privateGet(this, _Yo).subarray(12, 18), __privateGet(this, _Wo).push(((b2 + 5 * r2) / 6 - i2) / n2, ((y2 + 5 * o2) / 6 - a2) / s2, ((5 * r2 + l3) / 6 - i2) / n2, ((5 * o2 + c2) / 6 - a2) / s2, ((r2 + l3) / 2 - i2) / n2, ((o2 + c2) / 2 - a2) / s2), true);
      }
      toSVGPath() {
        if (this.isEmpty())
          return "";
        const e2 = __privateGet(this, _Ko), t2 = __privateGet(this, _Wo);
        if (isNaN(__privateGet(this, _Yo)[6]) && !this.isEmpty())
          return __privateMethod(this, _ll, ll_fn).call(this);
        const i2 = [];
        i2.push(`M${e2[4]} ${e2[5]}`);
        for (let t3 = 6; t3 < e2.length; t3 += 6)
          isNaN(e2[t3]) ? i2.push(`L${e2[t3 + 4]} ${e2[t3 + 5]}`) : i2.push(`C${e2[t3]} ${e2[t3 + 1]} ${e2[t3 + 2]} ${e2[t3 + 3]} ${e2[t3 + 4]} ${e2[t3 + 5]}`);
        __privateMethod(this, _cl, cl_fn).call(this, i2);
        for (let e3 = t2.length - 6; e3 >= 6; e3 -= 6)
          isNaN(t2[e3]) ? i2.push(`L${t2[e3 + 4]} ${t2[e3 + 5]}`) : i2.push(`C${t2[e3]} ${t2[e3 + 1]} ${t2[e3 + 2]} ${t2[e3 + 3]} ${t2[e3 + 4]} ${t2[e3 + 5]}`);
        return __privateMethod(this, _hl, hl_fn).call(this, i2), i2.join(" ");
      }
      newFreeDrawOutline(e2, t2, i2, a2, n2, s2) {
        return new FreeDrawOutline(e2, t2, i2, a2, n2, s2);
      }
      getOutlines() {
        const e2 = __privateGet(this, _Ko), t2 = __privateGet(this, _Wo), i2 = __privateGet(this, _Yo), [a2, n2, s2, r2] = __privateGet(this, _zo), o2 = new Float32Array((__privateGet(this, _al)?.length ?? 0) + 2);
        for (let e3 = 0, t3 = o2.length - 2; e3 < t3; e3 += 2)
          o2[e3] = (__privateGet(this, _al)[e3] - a2) / s2, o2[e3 + 1] = (__privateGet(this, _al)[e3 + 1] - n2) / r2;
        if (o2[o2.length - 2] = (__privateGet(this, _Jo) - a2) / s2, o2[o2.length - 1] = (__privateGet(this, _Zo) - n2) / r2, isNaN(i2[6]) && !this.isEmpty())
          return __privateMethod(this, _dl, dl_fn).call(this, o2);
        const l3 = new Float32Array(__privateGet(this, _Ko).length + 24 + __privateGet(this, _Wo).length);
        let c2 = e2.length;
        for (let t3 = 0; t3 < c2; t3 += 2)
          isNaN(e2[t3]) ? l3[t3] = l3[t3 + 1] = NaN : (l3[t3] = e2[t3], l3[t3 + 1] = e2[t3 + 1]);
        c2 = __privateMethod(this, _ul, ul_fn).call(this, l3, c2);
        for (let e3 = t2.length - 6; e3 >= 6; e3 -= 6)
          for (let i3 = 0; i3 < 6; i3 += 2)
            isNaN(t2[e3 + i3]) ? (l3[c2] = l3[c2 + 1] = NaN, c2 += 2) : (l3[c2] = t2[e3 + i3], l3[c2 + 1] = t2[e3 + i3 + 1], c2 += 2);
        return __privateMethod(this, _gl, gl_fn).call(this, l3, c2), this.newFreeDrawOutline(l3, o2, __privateGet(this, _zo), __privateGet(this, _tl), __privateGet(this, _Go), __privateGet(this, _Vo));
      }
    };
    FreeDrawOutliner = _FreeDrawOutliner;
    __name(FreeDrawOutliner, "FreeDrawOutliner");
    _zo = new WeakMap();
    _Wo = new WeakMap();
    _Go = new WeakMap();
    _Vo = new WeakMap();
    _Ko = new WeakMap();
    _Yo = new WeakMap();
    _Jo = new WeakMap();
    _Zo = new WeakMap();
    _Qo = new WeakMap();
    _el = new WeakMap();
    _tl = new WeakMap();
    _il = new WeakMap();
    _al = new WeakMap();
    _nl = new WeakMap();
    _sl = new WeakMap();
    _rl = new WeakMap();
    _ol = new WeakSet();
    ol_fn = /* @__PURE__ */ __name(function() {
      const e2 = __privateGet(this, _Yo).subarray(4, 6), t2 = __privateGet(this, _Yo).subarray(16, 18), [i2, a2, n2, s2] = __privateGet(this, _zo);
      return [(__privateGet(this, _Jo) + (e2[0] - t2[0]) / 2 - i2) / n2, (__privateGet(this, _Zo) + (e2[1] - t2[1]) / 2 - a2) / s2, (__privateGet(this, _Jo) + (t2[0] - e2[0]) / 2 - i2) / n2, (__privateGet(this, _Zo) + (t2[1] - e2[1]) / 2 - a2) / s2];
    }, "#ol");
    _ll = new WeakSet();
    ll_fn = /* @__PURE__ */ __name(function() {
      const [e2, t2, i2, a2] = __privateGet(this, _zo), [n2, s2, r2, o2] = __privateMethod(this, _ol, ol_fn).call(this);
      return `M${(__privateGet(this, _Yo)[2] - e2) / i2} ${(__privateGet(this, _Yo)[3] - t2) / a2} L${(__privateGet(this, _Yo)[4] - e2) / i2} ${(__privateGet(this, _Yo)[5] - t2) / a2} L${n2} ${s2} L${r2} ${o2} L${(__privateGet(this, _Yo)[16] - e2) / i2} ${(__privateGet(this, _Yo)[17] - t2) / a2} L${(__privateGet(this, _Yo)[14] - e2) / i2} ${(__privateGet(this, _Yo)[15] - t2) / a2} Z`;
    }, "#ll");
    _hl = new WeakSet();
    hl_fn = /* @__PURE__ */ __name(function(e2) {
      const t2 = __privateGet(this, _Wo);
      e2.push(`L${t2[4]} ${t2[5]} Z`);
    }, "#hl");
    _cl = new WeakSet();
    cl_fn = /* @__PURE__ */ __name(function(e2) {
      const [t2, i2, a2, n2] = __privateGet(this, _zo), s2 = __privateGet(this, _Yo).subarray(4, 6), r2 = __privateGet(this, _Yo).subarray(16, 18), [o2, l3, c2, h2] = __privateMethod(this, _ol, ol_fn).call(this);
      e2.push(`L${(s2[0] - t2) / a2} ${(s2[1] - i2) / n2} L${o2} ${l3} L${c2} ${h2} L${(r2[0] - t2) / a2} ${(r2[1] - i2) / n2}`);
    }, "#cl");
    _dl = new WeakSet();
    dl_fn = /* @__PURE__ */ __name(function(e2) {
      const t2 = __privateGet(this, _Yo), [i2, a2, n2, s2] = __privateGet(this, _zo), [r2, o2, l3, c2] = __privateMethod(this, _ol, ol_fn).call(this), h2 = new Float32Array(36);
      return h2.set([NaN, NaN, NaN, NaN, (t2[2] - i2) / n2, (t2[3] - a2) / s2, NaN, NaN, NaN, NaN, (t2[4] - i2) / n2, (t2[5] - a2) / s2, NaN, NaN, NaN, NaN, r2, o2, NaN, NaN, NaN, NaN, l3, c2, NaN, NaN, NaN, NaN, (t2[16] - i2) / n2, (t2[17] - a2) / s2, NaN, NaN, NaN, NaN, (t2[14] - i2) / n2, (t2[15] - a2) / s2], 0), this.newFreeDrawOutline(h2, e2, __privateGet(this, _zo), __privateGet(this, _tl), __privateGet(this, _Go), __privateGet(this, _Vo));
    }, "#dl");
    _gl = new WeakSet();
    gl_fn = /* @__PURE__ */ __name(function(e2, t2) {
      const i2 = __privateGet(this, _Wo);
      return e2.set([NaN, NaN, NaN, NaN, i2[4], i2[5]], t2), t2 + 6;
    }, "#gl");
    _ul = new WeakSet();
    ul_fn = /* @__PURE__ */ __name(function(e2, t2) {
      const i2 = __privateGet(this, _Yo).subarray(4, 6), a2 = __privateGet(this, _Yo).subarray(16, 18), [n2, s2, r2, o2] = __privateGet(this, _zo), [l3, c2, h2, d2] = __privateMethod(this, _ol, ol_fn).call(this);
      return e2.set([NaN, NaN, NaN, NaN, (i2[0] - n2) / r2, (i2[1] - s2) / o2, NaN, NaN, NaN, NaN, l3, c2, NaN, NaN, NaN, NaN, h2, d2, NaN, NaN, NaN, NaN, (a2[0] - n2) / r2, (a2[1] - s2) / o2], t2), t2 + 24;
    }, "#ul");
    __privateAdd(FreeDrawOutliner, _nl, 8);
    __privateAdd(FreeDrawOutliner, _sl, 2);
    __privateAdd(FreeDrawOutliner, _rl, __privateGet(_FreeDrawOutliner, _nl) + __privateGet(_FreeDrawOutliner, _sl));
    FreeDrawOutline = class extends Outline {
      #zo;
      #pl = new Float32Array(4);
      #Go;
      #Vo;
      #al;
      #tl;
      #fl;
      constructor(e2, t2, i2, a2, n2, s2) {
        super(), this.#fl = e2, this.#al = t2, this.#zo = i2, this.#tl = a2, this.#Go = n2, this.#Vo = s2, this.lastPoint = [NaN, NaN], this.#ml(s2);
        const [r2, o2, l3, c2] = this.#pl;
        for (let t3 = 0, i3 = e2.length; t3 < i3; t3 += 2)
          e2[t3] = (e2[t3] - r2) / l3, e2[t3 + 1] = (e2[t3 + 1] - o2) / c2;
        for (let e3 = 0, i3 = t2.length; e3 < i3; e3 += 2)
          t2[e3] = (t2[e3] - r2) / l3, t2[e3 + 1] = (t2[e3 + 1] - o2) / c2;
      }
      toSVGPath() {
        const e2 = [`M${this.#fl[4]} ${this.#fl[5]}`];
        for (let t2 = 6, i2 = this.#fl.length; t2 < i2; t2 += 6)
          isNaN(this.#fl[t2]) ? e2.push(`L${this.#fl[t2 + 4]} ${this.#fl[t2 + 5]}`) : e2.push(`C${this.#fl[t2]} ${this.#fl[t2 + 1]} ${this.#fl[t2 + 2]} ${this.#fl[t2 + 3]} ${this.#fl[t2 + 4]} ${this.#fl[t2 + 5]}`);
        return e2.push("Z"), e2.join(" ");
      }
      serialize([e2, t2, i2, a2], n2) {
        const s2 = i2 - e2, r2 = a2 - t2;
        let o2, l3;
        switch (n2) {
          case 0:
            o2 = Outline._rescale(this.#fl, e2, a2, s2, -r2), l3 = Outline._rescale(this.#al, e2, a2, s2, -r2);
            break;
          case 90:
            o2 = Outline._rescaleAndSwap(this.#fl, e2, t2, s2, r2), l3 = Outline._rescaleAndSwap(this.#al, e2, t2, s2, r2);
            break;
          case 180:
            o2 = Outline._rescale(this.#fl, i2, t2, -s2, r2), l3 = Outline._rescale(this.#al, i2, t2, -s2, r2);
            break;
          case 270:
            o2 = Outline._rescaleAndSwap(this.#fl, i2, a2, -s2, -r2), l3 = Outline._rescaleAndSwap(this.#al, i2, a2, -s2, -r2);
        }
        return { outline: Array.from(o2), points: [Array.from(l3)] };
      }
      #ml(e2) {
        const t2 = this.#fl;
        let i2 = t2[4], a2 = t2[5];
        const n2 = [i2, a2, i2, a2];
        let s2 = i2, r2 = a2;
        const o2 = e2 ? Math.max : Math.min;
        for (let e3 = 6, l4 = t2.length; e3 < l4; e3 += 6) {
          const l5 = t2[e3 + 4], c2 = t2[e3 + 5];
          if (isNaN(t2[e3]))
            Util.pointBoundingBox(l5, c2, n2), r2 < c2 ? (s2 = l5, r2 = c2) : r2 === c2 && (s2 = o2(s2, l5));
          else {
            const l6 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
            Util.bezierBoundingBox(i2, a2, ...t2.slice(e3, e3 + 6), l6), Util.rectBoundingBox(...l6, n2), r2 < l6[3] ? (s2 = l6[2], r2 = l6[3]) : r2 === l6[3] && (s2 = o2(s2, l6[2]));
          }
          i2 = l5, a2 = c2;
        }
        const l3 = this.#pl;
        l3[0] = n2[0] - this.#Go, l3[1] = n2[1] - this.#Go, l3[2] = n2[2] - n2[0] + 2 * this.#Go, l3[3] = n2[3] - n2[1] + 2 * this.#Go, this.lastPoint = [s2, r2];
      }
      get box() {
        return this.#pl;
      }
      newOutliner(e2, t2, i2, a2, n2, s2 = 0) {
        return new FreeDrawOutliner(e2, t2, i2, a2, n2, s2);
      }
      getNewOutline(e2, t2) {
        const [i2, a2, n2, s2] = this.#pl, [r2, o2, l3, c2] = this.#zo, h2 = n2 * l3, d2 = s2 * c2, u2 = i2 * l3 + r2, g2 = a2 * c2 + o2, p2 = this.newOutliner({ x: this.#al[0] * h2 + u2, y: this.#al[1] * d2 + g2 }, this.#zo, this.#tl, e2, this.#Vo, t2 ?? this.#Go);
        for (let e3 = 2; e3 < this.#al.length; e3 += 2)
          p2.add({ x: this.#al[e3] * h2 + u2, y: this.#al[e3 + 1] * d2 + g2 });
        return p2.getOutlines();
      }
    };
    __name(FreeDrawOutline, "FreeDrawOutline");
    HighlightOutliner = class {
      #zo;
      #bl;
      #yl = [];
      #wl = [];
      constructor(e2, t2 = 0, i2 = 0, a2 = true) {
        const n2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], s2 = 1e-4;
        for (const { x: i3, y: a3, width: r3, height: o3 } of e2) {
          const e3 = Math.floor((i3 - t2) / s2) * s2, l4 = Math.ceil((i3 + r3 + t2) / s2) * s2, c3 = Math.floor((a3 - t2) / s2) * s2, h3 = Math.ceil((a3 + o3 + t2) / s2) * s2, d3 = [e3, c3, h3, true], u2 = [l4, c3, h3, false];
          this.#yl.push(d3, u2), Util.rectBoundingBox(e3, c3, l4, h3, n2);
        }
        const r2 = n2[2] - n2[0] + 2 * i2, o2 = n2[3] - n2[1] + 2 * i2, l3 = n2[0] - i2, c2 = n2[1] - i2, h2 = this.#yl.at(a2 ? -1 : -2), d2 = [h2[0], h2[2]];
        for (const e3 of this.#yl) {
          const [t3, i3, a3] = e3;
          e3[0] = (t3 - l3) / r2, e3[1] = (i3 - c2) / o2, e3[2] = (a3 - c2) / o2;
        }
        this.#zo = new Float32Array([l3, c2, r2, o2]), this.#bl = d2;
      }
      getOutlines() {
        this.#yl.sort((e3, t2) => e3[0] - t2[0] || e3[1] - t2[1] || e3[2] - t2[2]);
        const e2 = [];
        for (const t2 of this.#yl)
          t2[3] ? (e2.push(...this.#Al(t2)), this.#xl(t2)) : (this.#Sl(t2), e2.push(...this.#Al(t2)));
        return this.#vl(e2);
      }
      #vl(e2) {
        const t2 = [], i2 = /* @__PURE__ */ new Set();
        for (const i3 of e2) {
          const [e3, a3, n3] = i3;
          t2.push([e3, a3, i3], [e3, n3, i3]);
        }
        t2.sort((e3, t3) => e3[1] - t3[1] || e3[0] - t3[0]);
        for (let e3 = 0, a3 = t2.length; e3 < a3; e3 += 2) {
          const a4 = t2[e3][2], n3 = t2[e3 + 1][2];
          a4.push(n3), n3.push(a4), i2.add(a4), i2.add(n3);
        }
        const a2 = [];
        let n2;
        for (; i2.size > 0; ) {
          const e3 = i2.values().next().value;
          let [t3, s2, r2, o2, l3] = e3;
          i2.delete(e3);
          let c2 = t3, h2 = s2;
          for (n2 = [t3, r2], a2.push(n2); ; ) {
            let e4;
            if (i2.has(o2))
              e4 = o2;
            else {
              if (!i2.has(l3))
                break;
              e4 = l3;
            }
            i2.delete(e4), [t3, s2, r2, o2, l3] = e4, c2 !== t3 && (n2.push(c2, h2, t3, h2 === s2 ? s2 : r2), c2 = t3), h2 = h2 === s2 ? r2 : s2;
          }
          n2.push(c2, h2);
        }
        return new HighlightOutline(a2, this.#zo, this.#bl);
      }
      #Cl(e2) {
        const t2 = this.#wl;
        let i2 = 0, a2 = t2.length - 1;
        for (; i2 <= a2; ) {
          const n2 = i2 + a2 >> 1, s2 = t2[n2][0];
          if (s2 === e2)
            return n2;
          s2 < e2 ? i2 = n2 + 1 : a2 = n2 - 1;
        }
        return a2 + 1;
      }
      #xl([, e2, t2]) {
        const i2 = this.#Cl(e2);
        this.#wl.splice(i2, 0, [e2, t2]);
      }
      #Sl([, e2, t2]) {
        const i2 = this.#Cl(e2);
        for (let a2 = i2; a2 < this.#wl.length; a2++) {
          const [i3, n2] = this.#wl[a2];
          if (i3 !== e2)
            break;
          if (i3 === e2 && n2 === t2)
            return void this.#wl.splice(a2, 1);
        }
        for (let a2 = i2 - 1; a2 >= 0; a2--) {
          const [i3, n2] = this.#wl[a2];
          if (i3 !== e2)
            break;
          if (i3 === e2 && n2 === t2)
            return void this.#wl.splice(a2, 1);
        }
      }
      #Al(e2) {
        const [t2, i2, a2] = e2, n2 = [[t2, i2, a2]], s2 = this.#Cl(a2);
        for (let e3 = 0; e3 < s2; e3++) {
          const [i3, a3] = this.#wl[e3];
          for (let e4 = 0, s3 = n2.length; e4 < s3; e4++) {
            const [, r2, o2] = n2[e4];
            if (!(a3 <= r2 || o2 <= i3))
              if (r2 >= i3)
                if (o2 > a3)
                  n2[e4][1] = a3;
                else {
                  if (1 === s3)
                    return [];
                  n2.splice(e4, 1), e4--, s3--;
                }
              else
                n2[e4][2] = i3, o2 > a3 && n2.push([t2, a3, o2]);
          }
        }
        return n2;
      }
    };
    __name(HighlightOutliner, "HighlightOutliner");
    HighlightOutline = class extends Outline {
      #zo;
      #kl;
      constructor(e2, t2, i2) {
        super(), this.#kl = e2, this.#zo = t2, this.lastPoint = i2;
      }
      toSVGPath() {
        const e2 = [];
        for (const t2 of this.#kl) {
          let [i2, a2] = t2;
          e2.push(`M${i2} ${a2}`);
          for (let n2 = 2; n2 < t2.length; n2 += 2) {
            const s2 = t2[n2], r2 = t2[n2 + 1];
            s2 === i2 ? (e2.push(`V${r2}`), a2 = r2) : r2 === a2 && (e2.push(`H${s2}`), i2 = s2);
          }
          e2.push("Z");
        }
        return e2.join(" ");
      }
      serialize([e2, t2, i2, a2], n2) {
        const s2 = [], r2 = i2 - e2, o2 = a2 - t2;
        for (const t3 of this.#kl) {
          const i3 = new Array(t3.length);
          for (let n3 = 0; n3 < t3.length; n3 += 2)
            i3[n3] = e2 + t3[n3] * r2, i3[n3 + 1] = a2 - t3[n3 + 1] * o2;
          s2.push(i3);
        }
        return s2;
      }
      get box() {
        return this.#zo;
      }
      get classNamesForOutlining() {
        return ["highlightOutline"];
      }
    };
    __name(HighlightOutline, "HighlightOutline");
    FreeHighlightOutliner = class extends FreeDrawOutliner {
      newFreeDrawOutline(e2, t2, i2, a2, n2, s2) {
        return new FreeHighlightOutline(e2, t2, i2, a2, n2, s2);
      }
    };
    __name(FreeHighlightOutliner, "FreeHighlightOutliner");
    FreeHighlightOutline = class extends FreeDrawOutline {
      newOutliner(e2, t2, i2, a2, n2, s2 = 0) {
        return new FreeHighlightOutliner(e2, t2, i2, a2, n2, s2);
      }
    };
    __name(FreeHighlightOutline, "FreeHighlightOutline");
    _HighlightEditor = class extends AnnotationEditor {
      constructor(e2) {
        super({ ...e2, name: "highlightEditor" });
        __privateAdd(this, _$l);
        __privateAdd(this, _Ul);
        __privateAdd(this, _No2);
        __privateAdd(this, _ql);
        __privateAdd(this, _Xl);
        __privateAdd(this, _Wl);
        __privateAdd(this, _jl);
        __privateAdd(this, _Gl);
        __privateAdd(this, _Vl);
        __privateAdd(this, _zl);
        __privateAdd(this, _Kl);
        __privateAdd(this, _Yl);
        __privateAdd(this, _Xo2);
        __privateAdd(this, _Tl, null);
        __privateAdd(this, _Il, 0);
        __privateAdd(this, _Fl, void 0);
        __privateAdd(this, _Ml, null);
        __privateAdd(this, _nt2, null);
        __privateAdd(this, _Dl, null);
        __privateAdd(this, _El, null);
        __privateAdd(this, _Ol, 0);
        __privateAdd(this, __l, null);
        __privateAdd(this, _Pl, null);
        __privateAdd(this, _At, null);
        __privateAdd(this, _Rl, false);
        __privateAdd(this, _bl, null);
        __privateAdd(this, _Bl, void 0);
        __privateAdd(this, _Nl, null);
        __privateAdd(this, _ve, "");
        __privateAdd(this, _il2, void 0);
        __privateAdd(this, _Ll, "");
        this.color = e2.color || _HighlightEditor._defaultColor, __privateSet(this, _il2, e2.thickness || _HighlightEditor._defaultThickness), __privateSet(this, _Bl, e2.opacity || _HighlightEditor._defaultOpacity), __privateSet(this, _Fl, e2.boxes || null), __privateSet(this, _Ll, e2.methodOfCreation || ""), __privateSet(this, _ve, e2.text || ""), this._isDraggable = false, this.defaultL10nId = "pdfjs-editor-highlight-editor", e2.highlightId > -1 ? (__privateSet(this, _Rl, true), __privateMethod(this, _Ul, Ul_fn).call(this, e2), __privateMethod(this, _jl, jl_fn).call(this)) : __privateGet(this, _Fl) && (__privateSet(this, _Tl, e2.anchorNode), __privateSet(this, _Il, e2.anchorOffset), __privateSet(this, _El, e2.focusNode), __privateSet(this, _Ol, e2.focusOffset), __privateMethod(this, _$l, $l_fn).call(this), __privateMethod(this, _jl, jl_fn).call(this), this.rotate(this.rotation)), this.annotationElementId || this._uiManager.a11yAlert("pdfjs-editor-highlight-added-alert");
      }
      static get _keyboardManager() {
        const e2 = _HighlightEditor.prototype;
        return shadow(this, "_keyboardManager", new KeyboardManager([[["ArrowLeft", "mac+ArrowLeft"], e2._moveCaret, { args: [0] }], [["ArrowRight", "mac+ArrowRight"], e2._moveCaret, { args: [1] }], [["ArrowUp", "mac+ArrowUp"], e2._moveCaret, { args: [2] }], [["ArrowDown", "mac+ArrowDown"], e2._moveCaret, { args: [3] }]]));
      }
      get telemetryInitialData() {
        return { action: "added", type: __privateGet(this, _Rl) ? "free_highlight" : "highlight", color: this._uiManager.getNonHCMColorName(this.color), thickness: __privateGet(this, _il2), methodOfCreation: __privateGet(this, _Ll) };
      }
      get telemetryFinalData() {
        return { type: "highlight", color: this._uiManager.getNonHCMColorName(this.color) };
      }
      get commentColor() {
        return this.color;
      }
      static computeTelemetryFinalData(e2) {
        return { numberOfColors: e2.get("color").size };
      }
      static initialize(e2, t2) {
        AnnotationEditor.initialize(e2, t2), _HighlightEditor._defaultColor ||= t2.highlightColors?.values().next().value || "#fff066";
      }
      static updateDefaultParams(e2, t2) {
        switch (e2) {
          case jl.HIGHLIGHT_COLOR:
            _HighlightEditor._defaultColor = t2;
            break;
          case jl.HIGHLIGHT_THICKNESS:
            _HighlightEditor._defaultThickness = t2;
        }
      }
      translateInPage(e2, t2) {
      }
      get toolbarPosition() {
        return __privateGet(this, _bl);
      }
      updateParams(e2, t2) {
        switch (e2) {
          case jl.HIGHLIGHT_COLOR:
            __privateMethod(this, _No2, No_fn2).call(this, t2);
            break;
          case jl.HIGHLIGHT_THICKNESS:
            __privateMethod(this, _ql, ql_fn).call(this, t2);
        }
      }
      static get defaultPropertiesToUpdate() {
        return [[jl.HIGHLIGHT_COLOR, _HighlightEditor._defaultColor], [jl.HIGHLIGHT_THICKNESS, _HighlightEditor._defaultThickness]];
      }
      get propertiesToUpdate() {
        return [[jl.HIGHLIGHT_COLOR, this.color || _HighlightEditor._defaultColor], [jl.HIGHLIGHT_THICKNESS, __privateGet(this, _il2) || _HighlightEditor._defaultThickness], [jl.HIGHLIGHT_FREE, __privateGet(this, _Rl)]];
      }
      get toolbarButtons() {
        if (this._uiManager.highlightColors) {
          return [["colorPicker", __privateSet(this, _nt2, new ColorPicker({ editor: this }))]];
        }
        return super.toolbarButtons;
      }
      disableEditing() {
        super.disableEditing(), this.div.classList.toggle("disabled", true);
      }
      enableEditing() {
        super.enableEditing(), this.div.classList.toggle("disabled", false);
      }
      fixAndSetPosition() {
        return super.fixAndSetPosition(__privateMethod(this, _zl, zl_fn).call(this));
      }
      getBaseTranslation() {
        return [0, 0];
      }
      getRect(e2, t2) {
        return super.getRect(e2, t2, __privateMethod(this, _zl, zl_fn).call(this));
      }
      onceAdded(e2) {
        this.annotationElementId || this.parent.addUndoableEditor(this), e2 && this.div.focus();
      }
      remove() {
        __privateMethod(this, _Wl, Wl_fn).call(this), this._reportTelemetry({ action: "deleted" }), super.remove();
      }
      rebuild() {
        this.parent && (super.rebuild(), null !== this.div && (__privateMethod(this, _jl, jl_fn).call(this), this.isAttachedToDOM || this.parent.add(this)));
      }
      setParent(e2) {
        let t2 = false;
        this.parent && !e2 ? __privateMethod(this, _Wl, Wl_fn).call(this) : e2 && (__privateMethod(this, _jl, jl_fn).call(this, e2), t2 = !this.parent && this.div?.classList.contains("selectedEditor")), super.setParent(e2), this.show(this._isVisible), t2 && this.select();
      }
      rotate(e2) {
        var _a4, _b2, _c3;
        const { drawLayer: t2 } = this.parent;
        let i2;
        __privateGet(this, _Rl) ? (e2 = (e2 - this.rotation + 360) % 360, i2 = __privateMethod(_a4 = _HighlightEditor, _Hl, Hl_fn).call(_a4, __privateGet(this, _Pl).box, e2)) : i2 = __privateMethod(_b2 = _HighlightEditor, _Hl, Hl_fn).call(_b2, [this.x, this.y, this.width, this.height], e2), t2.updateProperties(__privateGet(this, _At), { bbox: i2, root: { "data-main-rotation": e2 } }), t2.updateProperties(__privateGet(this, _Nl), { bbox: __privateMethod(_c3 = _HighlightEditor, _Hl, Hl_fn).call(_c3, __privateGet(this, _Dl).box, e2), root: { "data-main-rotation": e2 } });
      }
      render() {
        if (this.div)
          return this.div;
        const e2 = super.render();
        __privateGet(this, _ve) && (e2.setAttribute("aria-label", __privateGet(this, _ve)), e2.setAttribute("role", "mark")), __privateGet(this, _Rl) ? e2.classList.add("free") : this.div.addEventListener("keydown", __privateMethod(this, _Gl, Gl_fn).bind(this), { signal: this._uiManager._signal });
        const t2 = __privateSet(this, __l, document.createElement("div"));
        e2.append(t2), t2.setAttribute("aria-hidden", "true"), t2.className = "internal", t2.style.clipPath = __privateGet(this, _Ml);
        const [i2, a2] = this.parentDimensions;
        return this.setDims(this.width * i2, this.height * a2), bindEvents(this, __privateGet(this, __l), ["pointerover", "pointerleave"]), this.enableEditing(), e2;
      }
      pointerover() {
        this.isSelected || this.parent?.drawLayer.updateProperties(__privateGet(this, _Nl), { rootClass: { hovered: true } });
      }
      pointerleave() {
        this.isSelected || this.parent?.drawLayer.updateProperties(__privateGet(this, _Nl), { rootClass: { hovered: false } });
      }
      _moveCaret(e2) {
        switch (this.parent.unselect(this), e2) {
          case 0:
          case 2:
            __privateMethod(this, _Vl, Vl_fn).call(this, true);
            break;
          case 1:
          case 3:
            __privateMethod(this, _Vl, Vl_fn).call(this, false);
        }
      }
      select() {
        super.select(), __privateGet(this, _Nl) && this.parent?.drawLayer.updateProperties(__privateGet(this, _Nl), { rootClass: { hovered: false, selected: true } });
      }
      unselect() {
        super.unselect(), __privateGet(this, _Nl) && (this.parent?.drawLayer.updateProperties(__privateGet(this, _Nl), { rootClass: { selected: false } }), __privateGet(this, _Rl) || __privateMethod(this, _Vl, Vl_fn).call(this, false));
      }
      get _mustFixPosition() {
        return !__privateGet(this, _Rl);
      }
      show(e2 = this._isVisible) {
        super.show(e2), this.parent && (this.parent.drawLayer.updateProperties(__privateGet(this, _At), { rootClass: { hidden: !e2 } }), this.parent.drawLayer.updateProperties(__privateGet(this, _Nl), { rootClass: { hidden: !e2 } }));
      }
      static startHighlighting(e2, t2, { target: i2, x: a2, y: n2 }) {
        const { x: s2, y: r2, width: o2, height: l3 } = i2.getBoundingClientRect(), c2 = new AbortController(), h2 = e2.combinedSignal(c2), pointerUpCallback = /* @__PURE__ */ __name((t3) => {
          c2.abort(), __privateMethod(this, _Jl, Jl_fn).call(this, e2, t3);
        }, "pointerUpCallback");
        window.addEventListener("blur", pointerUpCallback, { signal: h2 }), window.addEventListener("pointerup", pointerUpCallback, { signal: h2 }), window.addEventListener("pointerdown", stopEvent, { capture: true, passive: false, signal: h2 }), window.addEventListener("contextmenu", noContextMenu, { signal: h2 }), i2.addEventListener("pointermove", __privateMethod(this, _Zl, Zl_fn).bind(this, e2), { signal: h2 }), this._freeHighlight = new FreeHighlightOutliner({ x: a2, y: n2 }, [s2, r2, o2, l3], e2.scale, this._defaultThickness / 2, t2, 1e-3), { id: this._freeHighlightId, clipPathId: this._freeHighlightClipId } = e2.drawLayer.draw({ bbox: [0, 0, 1, 1], root: { viewBox: "0 0 1 1", fill: this._defaultColor, "fill-opacity": this._defaultOpacity }, rootClass: { highlight: true, free: true }, path: { d: this._freeHighlight.toSVGPath() } }, true, true);
      }
      static async deserialize(e2, t2, i2) {
        var _a4, _b2, _c3, _d2;
        let a2 = null;
        if (e2 instanceof HighlightAnnotationElement) {
          const { data: { quadPoints: t3, rect: i3, rotation: n3, id: s3, color: r3, opacity: o3, popupRef: l4, contentsObj: c3 }, parent: { page: { pageNumber: h3 } } } = e2;
          a2 = e2 = { annotationType: Ll.HIGHLIGHT, color: Array.from(r3), opacity: o3, quadPoints: t3, boxes: null, pageIndex: h3 - 1, rect: i3.slice(0), rotation: n3, annotationElementId: s3, id: s3, deleted: false, popupRef: l4, comment: c3?.str || null };
        } else if (e2 instanceof InkAnnotationElement) {
          const { data: { inkLists: t3, rect: i3, rotation: n3, id: s3, color: r3, borderStyle: { rawWidth: o3 }, popupRef: l4, contentsObj: c3 }, parent: { page: { pageNumber: h3 } } } = e2;
          a2 = e2 = { annotationType: Ll.HIGHLIGHT, color: Array.from(r3), thickness: o3, inkLists: t3, boxes: null, pageIndex: h3 - 1, rect: i3.slice(0), rotation: n3, annotationElementId: s3, id: s3, deleted: false, popupRef: l4, comment: c3?.str || null };
        }
        const { color: n2, quadPoints: s2, inkLists: r2, opacity: o2 } = e2, l3 = await super.deserialize(e2, t2, i2);
        l3.color = Util.makeHexColor(...n2), __privateSet(l3, _Bl, o2 || 1), r2 && __privateSet(l3, _il2, e2.thickness), l3._initialData = a2, e2.comment && l3.setCommentData(e2.comment);
        const [c2, h2] = l3.pageDimensions, [d2, u2] = l3.pageTranslation;
        if (s2) {
          const e3 = __privateSet(l3, _Fl, []);
          for (let t3 = 0; t3 < s2.length; t3 += 8)
            e3.push({ x: (s2[t3] - d2) / c2, y: 1 - (s2[t3 + 1] - u2) / h2, width: (s2[t3 + 2] - s2[t3]) / c2, height: (s2[t3 + 1] - s2[t3 + 5]) / h2 });
          __privateMethod(_a4 = l3, _$l, $l_fn).call(_a4), __privateMethod(_b2 = l3, _jl, jl_fn).call(_b2), l3.rotate(l3.rotation);
        } else if (r2) {
          __privateSet(l3, _Rl, true);
          const e3 = r2[0], i3 = { x: e3[0] - d2, y: h2 - (e3[1] - u2) }, a3 = new FreeHighlightOutliner(i3, [0, 0, c2, h2], 1, __privateGet(l3, _il2) / 2, true, 1e-3);
          for (let t3 = 0, n4 = e3.length; t3 < n4; t3 += 2)
            i3.x = e3[t3] - d2, i3.y = h2 - (e3[t3 + 1] - u2), a3.add(i3);
          const { id: n3, clipPathId: s3 } = t2.drawLayer.draw({ bbox: [0, 0, 1, 1], root: { viewBox: "0 0 1 1", fill: l3.color, "fill-opacity": l3._defaultOpacity }, rootClass: { highlight: true, free: true }, path: { d: a3.toSVGPath() } }, true, true);
          __privateMethod(_c3 = l3, _Ul, Ul_fn).call(_c3, { highlightOutlines: a3.getOutlines(), highlightId: n3, clipPathId: s3 }), __privateMethod(_d2 = l3, _jl, jl_fn).call(_d2), l3.rotate(l3.parentRotation);
        }
        return l3;
      }
      serialize(e2 = false) {
        if (this.isEmpty() || e2)
          return null;
        if (this.deleted)
          return this.serializeDeleted();
        const t2 = this.getPDFRect(), i2 = AnnotationEditor._colorManager.convert(this._uiManager.getNonHCMColor(this.color)), a2 = { annotationType: Ll.HIGHLIGHT, color: i2, opacity: __privateGet(this, _Bl), thickness: __privateGet(this, _il2), quadPoints: __privateMethod(this, _Kl, Kl_fn).call(this), outlines: __privateMethod(this, _Yl, Yl_fn).call(this, t2), pageIndex: this.pageIndex, rect: t2, rotation: __privateMethod(this, _zl, zl_fn).call(this), structTreeParentId: this._structTreeParentId };
        return this.addComment(a2), this.annotationElementId && !__privateMethod(this, _Xo2, Xo_fn2).call(this, a2) ? null : (a2.id = this.annotationElementId, a2);
      }
      renderAnnotationElement(e2) {
        if (this.deleted)
          return e2.hide(), null;
        const t2 = { rect: this.getPDFRect() };
        return this.hasEditedComment && (t2.popup = this.comment), e2.updateEdited(t2), null;
      }
      static canCreateNewEmptyEditor() {
        return false;
      }
    };
    HighlightEditor = _HighlightEditor;
    __name(HighlightEditor, "HighlightEditor");
    _Tl = new WeakMap();
    _Il = new WeakMap();
    _Fl = new WeakMap();
    _Ml = new WeakMap();
    _nt2 = new WeakMap();
    _Dl = new WeakMap();
    _El = new WeakMap();
    _Ol = new WeakMap();
    __l = new WeakMap();
    _Pl = new WeakMap();
    _At = new WeakMap();
    _Rl = new WeakMap();
    _bl = new WeakMap();
    _Bl = new WeakMap();
    _Nl = new WeakMap();
    _ve = new WeakMap();
    _il2 = new WeakMap();
    _Ll = new WeakMap();
    _$l = new WeakSet();
    $l_fn = /* @__PURE__ */ __name(function() {
      const e2 = new HighlightOutliner(__privateGet(this, _Fl), 1e-3);
      __privateSet(this, _Pl, e2.getOutlines()), [this.x, this.y, this.width, this.height] = __privateGet(this, _Pl).box;
      const t2 = new HighlightOutliner(__privateGet(this, _Fl), 25e-4, 1e-3, "ltr" === this._uiManager.direction);
      __privateSet(this, _Dl, t2.getOutlines());
      const { lastPoint: i2 } = __privateGet(this, _Dl);
      __privateSet(this, _bl, [(i2[0] - this.x) / this.width, (i2[1] - this.y) / this.height]);
    }, "#$l");
    _Ul = new WeakSet();
    Ul_fn = /* @__PURE__ */ __name(function({ highlightOutlines: e2, highlightId: t2, clipPathId: i2 }) {
      var _a4, _b2;
      __privateSet(this, _Pl, e2);
      if (__privateSet(this, _Dl, e2.getNewOutline(__privateGet(this, _il2) / 2 + 1.5, 25e-4)), t2 >= 0)
        __privateSet(this, _At, t2), __privateSet(this, _Ml, i2), this.parent.drawLayer.finalizeDraw(t2, { bbox: e2.box, path: { d: e2.toSVGPath() } }), __privateSet(this, _Nl, this.parent.drawLayer.drawOutline({ rootClass: { highlightOutline: true, free: true }, bbox: __privateGet(this, _Dl).box, path: { d: __privateGet(this, _Dl).toSVGPath() } }, true));
      else if (this.parent) {
        const t3 = this.parent.viewport.rotation;
        this.parent.drawLayer.updateProperties(__privateGet(this, _At), { bbox: __privateMethod(_a4 = _HighlightEditor, _Hl, Hl_fn).call(_a4, __privateGet(this, _Pl).box, (t3 - this.rotation + 360) % 360), path: { d: e2.toSVGPath() } }), this.parent.drawLayer.updateProperties(__privateGet(this, _Nl), { bbox: __privateMethod(_b2 = _HighlightEditor, _Hl, Hl_fn).call(_b2, __privateGet(this, _Dl).box, t3), path: { d: __privateGet(this, _Dl).toSVGPath() } });
      }
      const [a2, n2, s2, r2] = e2.box;
      switch (this.rotation) {
        case 0:
          this.x = a2, this.y = n2, this.width = s2, this.height = r2;
          break;
        case 90: {
          const [e3, t3] = this.parentDimensions;
          this.x = n2, this.y = 1 - a2, this.width = s2 * t3 / e3, this.height = r2 * e3 / t3;
          break;
        }
        case 180:
          this.x = 1 - a2, this.y = 1 - n2, this.width = s2, this.height = r2;
          break;
        case 270: {
          const [e3, t3] = this.parentDimensions;
          this.x = 1 - n2, this.y = a2, this.width = s2 * t3 / e3, this.height = r2 * e3 / t3;
          break;
        }
      }
      const { lastPoint: o2 } = __privateGet(this, _Dl);
      __privateSet(this, _bl, [(o2[0] - a2) / s2, (o2[1] - n2) / r2]);
    }, "#Ul");
    _No2 = new WeakSet();
    No_fn2 = /* @__PURE__ */ __name(function(e2) {
      const setColorAndOpacity = /* @__PURE__ */ __name((e3, t3) => {
        this.color = e3, __privateSet(this, _Bl, t3), this.parent?.drawLayer.updateProperties(__privateGet(this, _At), { root: { fill: e3, "fill-opacity": t3 } }), __privateGet(this, _nt2)?.updateColor(e3);
      }, "setColorAndOpacity"), t2 = this.color, i2 = __privateGet(this, _Bl);
      this.addCommands({ cmd: setColorAndOpacity.bind(this, e2, _HighlightEditor._defaultOpacity), undo: setColorAndOpacity.bind(this, t2, i2), post: this._uiManager.updateUI.bind(this._uiManager, this), mustExec: true, type: jl.HIGHLIGHT_COLOR, overwriteIfSameType: true, keepUndo: true }), this._reportTelemetry({ action: "color_changed", color: this._uiManager.getNonHCMColorName(e2) }, true);
    }, "#No");
    _ql = new WeakSet();
    ql_fn = /* @__PURE__ */ __name(function(e2) {
      const t2 = __privateGet(this, _il2), setThickness = /* @__PURE__ */ __name((e3) => {
        __privateSet(this, _il2, e3), __privateMethod(this, _Xl, Xl_fn).call(this, e3);
      }, "setThickness");
      this.addCommands({ cmd: setThickness.bind(this, e2), undo: setThickness.bind(this, t2), post: this._uiManager.updateUI.bind(this._uiManager, this), mustExec: true, type: jl.INK_THICKNESS, overwriteIfSameType: true, keepUndo: true }), this._reportTelemetry({ action: "thickness_changed", thickness: e2 }, true);
    }, "#ql");
    _Xl = new WeakSet();
    Xl_fn = /* @__PURE__ */ __name(function(e2) {
      if (!__privateGet(this, _Rl))
        return;
      __privateMethod(this, _Ul, Ul_fn).call(this, { highlightOutlines: __privateGet(this, _Pl).getNewOutline(e2 / 2) }), this.fixAndSetPosition();
      const [t2, i2] = this.parentDimensions;
      this.setDims(this.width * t2, this.height * i2);
    }, "#Xl");
    _Wl = new WeakSet();
    Wl_fn = /* @__PURE__ */ __name(function() {
      null !== __privateGet(this, _At) && this.parent && (this.parent.drawLayer.remove(__privateGet(this, _At)), __privateSet(this, _At, null), this.parent.drawLayer.remove(__privateGet(this, _Nl)), __privateSet(this, _Nl, null));
    }, "#Wl");
    _jl = new WeakSet();
    jl_fn = /* @__PURE__ */ __name(function(e2 = this.parent) {
      null === __privateGet(this, _At) && ({ id: __privateWrapper(this, _At)._, clipPathId: __privateWrapper(this, _Ml)._ } = e2.drawLayer.draw({ bbox: __privateGet(this, _Pl).box, root: { viewBox: "0 0 1 1", fill: this.color, "fill-opacity": __privateGet(this, _Bl) }, rootClass: { highlight: true, free: __privateGet(this, _Rl) }, path: { d: __privateGet(this, _Pl).toSVGPath() } }, false, true), __privateSet(this, _Nl, e2.drawLayer.drawOutline({ rootClass: { highlightOutline: true, free: __privateGet(this, _Rl) }, bbox: __privateGet(this, _Dl).box, path: { d: __privateGet(this, _Dl).toSVGPath() } }, __privateGet(this, _Rl))), __privateGet(this, __l) && (__privateGet(this, __l).style.clipPath = __privateGet(this, _Ml)));
    }, "#jl");
    _Hl = new WeakSet();
    Hl_fn = /* @__PURE__ */ __name(function([e2, t2, i2, a2], n2) {
      switch (n2) {
        case 90:
          return [1 - t2 - a2, e2, a2, i2];
        case 180:
          return [1 - e2 - i2, 1 - t2 - a2, i2, a2];
        case 270:
          return [t2, 1 - e2 - i2, a2, i2];
      }
      return [e2, t2, i2, a2];
    }, "#Hl");
    _Gl = new WeakSet();
    Gl_fn = /* @__PURE__ */ __name(function(e2) {
      _HighlightEditor._keyboardManager.exec(this, e2);
    }, "#Gl");
    _Vl = new WeakSet();
    Vl_fn = /* @__PURE__ */ __name(function(e2) {
      if (!__privateGet(this, _Tl))
        return;
      const t2 = window.getSelection();
      e2 ? t2.setPosition(__privateGet(this, _Tl), __privateGet(this, _Il)) : t2.setPosition(__privateGet(this, _El), __privateGet(this, _Ol));
    }, "#Vl");
    _zl = new WeakSet();
    zl_fn = /* @__PURE__ */ __name(function() {
      return __privateGet(this, _Rl) ? this.rotation : 0;
    }, "#zl");
    _Kl = new WeakSet();
    Kl_fn = /* @__PURE__ */ __name(function() {
      if (__privateGet(this, _Rl))
        return null;
      const [e2, t2] = this.pageDimensions, [i2, a2] = this.pageTranslation, n2 = __privateGet(this, _Fl), s2 = new Float32Array(8 * n2.length);
      let r2 = 0;
      for (const { x: o2, y: l3, width: c2, height: h2 } of n2) {
        const n3 = o2 * e2 + i2, d2 = (1 - l3) * t2 + a2;
        s2[r2] = s2[r2 + 4] = n3, s2[r2 + 1] = s2[r2 + 3] = d2, s2[r2 + 2] = s2[r2 + 6] = n3 + c2 * e2, s2[r2 + 5] = s2[r2 + 7] = d2 - h2 * t2, r2 += 8;
      }
      return s2;
    }, "#Kl");
    _Yl = new WeakSet();
    Yl_fn = /* @__PURE__ */ __name(function(e2) {
      return __privateGet(this, _Pl).serialize(e2, __privateMethod(this, _zl, zl_fn).call(this));
    }, "#Yl");
    _Zl = new WeakSet();
    Zl_fn = /* @__PURE__ */ __name(function(e2, t2) {
      this._freeHighlight.add(t2) && e2.drawLayer.updateProperties(this._freeHighlightId, { path: { d: this._freeHighlight.toSVGPath() } });
    }, "#Zl");
    _Jl = new WeakSet();
    Jl_fn = /* @__PURE__ */ __name(function(e2, t2) {
      this._freeHighlight.isEmpty() ? e2.drawLayer.remove(this._freeHighlightId) : e2.createAndAddNewEditor(t2, false, { highlightId: this._freeHighlightId, highlightOutlines: this._freeHighlight.getOutlines(), clipPathId: this._freeHighlightClipId, methodOfCreation: "main_toolbar" }), this._freeHighlightId = -1, this._freeHighlight = null, this._freeHighlightClipId = "";
    }, "#Jl");
    _Xo2 = new WeakSet();
    Xo_fn2 = /* @__PURE__ */ __name(function(e2) {
      const { color: t2 } = this._initialData;
      return this.hasEditedComment || e2.color.some((e3, i2) => e3 !== t2[i2]);
    }, "#Xo");
    __privateAdd(HighlightEditor, _Hl);
    __privateAdd(HighlightEditor, _Zl);
    __privateAdd(HighlightEditor, _Jl);
    __publicField(HighlightEditor, "_defaultColor", null);
    __publicField(HighlightEditor, "_defaultOpacity", 1);
    __publicField(HighlightEditor, "_defaultThickness", 12);
    __publicField(HighlightEditor, "_type", "highlight");
    __publicField(HighlightEditor, "_editorType", Ll.HIGHLIGHT);
    __publicField(HighlightEditor, "_freeHighlightId", -1);
    __publicField(HighlightEditor, "_freeHighlight", null);
    __publicField(HighlightEditor, "_freeHighlightClipId", "");
    DrawingOptions = class {
      #Ql = /* @__PURE__ */ Object.create(null);
      updateProperty(e2, t2) {
        this[e2] = t2, this.updateSVGProperty(e2, t2);
      }
      updateProperties(e2) {
        if (e2)
          for (const [t2, i2] of Object.entries(e2))
            t2.startsWith("_") || this.updateProperty(t2, i2);
      }
      updateSVGProperty(e2, t2) {
        this.#Ql[e2] = t2;
      }
      toSVGProperties() {
        const e2 = this.#Ql;
        return this.#Ql = /* @__PURE__ */ Object.create(null), { root: e2 };
      }
      reset() {
        this.#Ql = /* @__PURE__ */ Object.create(null);
      }
      updateAll(e2 = this) {
        this.updateProperties(e2);
      }
      clone() {
        unreachable("Not implemented");
      }
    };
    __name(DrawingOptions, "DrawingOptions");
    _DrawingEditor = class extends AnnotationEditor {
      constructor(e2) {
        super(e2);
        __privateAdd(this, _cc);
        __privateAdd(this, _hc);
        __privateAdd(this, _Wl2);
        __privateAdd(this, _jl2);
        __privateAdd(this, _pc);
        __privateAdd(this, _uc);
        __privateAdd(this, _dc);
        __privateAdd(this, _gc);
        __privateAdd(this, _ec, null);
        __privateAdd(this, _tc, void 0);
        __publicField(this, "_colorPicker", null);
        __publicField(this, "_drawId", null);
        __privateSet(this, _tc, e2.mustBeCommitted || false), this._addOutlines(e2);
      }
      _addOutlines(e2) {
        e2.drawOutlines && (__privateMethod(this, _cc, cc_fn).call(this, e2), __privateMethod(this, _jl2, jl_fn2).call(this));
      }
      static _mergeSVGProperties(e2, t2) {
        const i2 = new Set(Object.keys(e2));
        for (const [a2, n2] of Object.entries(t2))
          i2.has(a2) ? Object.assign(e2[a2], n2) : e2[a2] = n2;
        return e2;
      }
      static getDefaultDrawingOptions(e2) {
        unreachable("Not implemented");
      }
      static get typesMap() {
        unreachable("Not implemented");
      }
      static get isDrawer() {
        return true;
      }
      static get supportMultipleDrawings() {
        return false;
      }
      static updateDefaultParams(e2, t2) {
        const i2 = this.typesMap.get(e2);
        i2 && this._defaultDrawingOptions.updateProperty(i2, t2), this._currentParent && (__privateGet(_DrawingEditor, _ic).updateProperty(i2, t2), this._currentParent.drawLayer.updateProperties(this._currentDrawId, this._defaultDrawingOptions.toSVGProperties()));
      }
      updateParams(e2, t2) {
        const i2 = this.constructor.typesMap.get(e2);
        i2 && this._updateProperty(e2, i2, t2);
      }
      static get defaultPropertiesToUpdate() {
        const e2 = [], t2 = this._defaultDrawingOptions;
        for (const [i2, a2] of this.typesMap)
          e2.push([i2, t2[a2]]);
        return e2;
      }
      get propertiesToUpdate() {
        const e2 = [], { _drawingOptions: t2 } = this;
        for (const [i2, a2] of this.constructor.typesMap)
          e2.push([i2, t2[a2]]);
        return e2;
      }
      _updateProperty(e2, t2, i2) {
        const a2 = this._drawingOptions, n2 = a2[t2], setter = /* @__PURE__ */ __name((i3) => {
          a2.updateProperty(t2, i3);
          const n3 = __privateGet(this, _ec).updateProperty(t2, i3);
          n3 && __privateMethod(this, _dc, dc_fn).call(this, n3), this.parent?.drawLayer.updateProperties(this._drawId, a2.toSVGProperties()), e2 === this.colorType && this._colorPicker?.update(i3);
        }, "setter");
        this.addCommands({ cmd: setter.bind(this, i2), undo: setter.bind(this, n2), post: this._uiManager.updateUI.bind(this._uiManager, this), mustExec: true, type: e2, overwriteIfSameType: true, keepUndo: true });
      }
      _onResizing() {
        this.parent?.drawLayer.updateProperties(this._drawId, _DrawingEditor._mergeSVGProperties(__privateGet(this, _ec).getPathResizingSVGProperties(__privateMethod(this, _uc, uc_fn).call(this)), { bbox: __privateMethod(this, _gc, gc_fn).call(this) }));
      }
      _onResized() {
        this.parent?.drawLayer.updateProperties(this._drawId, _DrawingEditor._mergeSVGProperties(__privateGet(this, _ec).getPathResizedSVGProperties(__privateMethod(this, _uc, uc_fn).call(this)), { bbox: __privateMethod(this, _gc, gc_fn).call(this) }));
      }
      _onTranslating(e2, t2) {
        this.parent?.drawLayer.updateProperties(this._drawId, { bbox: __privateMethod(this, _gc, gc_fn).call(this) });
      }
      _onTranslated() {
        this.parent?.drawLayer.updateProperties(this._drawId, _DrawingEditor._mergeSVGProperties(__privateGet(this, _ec).getPathTranslatedSVGProperties(__privateMethod(this, _uc, uc_fn).call(this), this.parentDimensions), { bbox: __privateMethod(this, _gc, gc_fn).call(this) }));
      }
      _onStartDragging() {
        this.parent?.drawLayer.updateProperties(this._drawId, { rootClass: { moving: true } });
      }
      _onStopDragging() {
        this.parent?.drawLayer.updateProperties(this._drawId, { rootClass: { moving: false } });
      }
      commit() {
        super.commit(), this.disableEditMode(), this.disableEditing();
      }
      disableEditing() {
        super.disableEditing(), this.div.classList.toggle("disabled", true);
      }
      enableEditing() {
        super.enableEditing(), this.div.classList.toggle("disabled", false);
      }
      getBaseTranslation() {
        return [0, 0];
      }
      get isResizable() {
        return true;
      }
      onceAdded(e2) {
        this.annotationElementId || this.parent.addUndoableEditor(this), this._isDraggable = true, __privateGet(this, _tc) && (__privateSet(this, _tc, false), this.commit(), this.parent.setSelected(this), e2 && this.isOnScreen && this.div.focus());
      }
      remove() {
        __privateMethod(this, _Wl2, Wl_fn2).call(this), super.remove();
      }
      rebuild() {
        this.parent && (super.rebuild(), null !== this.div && (__privateMethod(this, _jl2, jl_fn2).call(this), __privateMethod(this, _dc, dc_fn).call(this, __privateGet(this, _ec).box), this.isAttachedToDOM || this.parent.add(this)));
      }
      setParent(e2) {
        let t2 = false;
        this.parent && !e2 ? (this._uiManager.removeShouldRescale(this), __privateMethod(this, _Wl2, Wl_fn2).call(this)) : e2 && (this._uiManager.addShouldRescale(this), __privateMethod(this, _jl2, jl_fn2).call(this, e2), t2 = !this.parent && this.div?.classList.contains("selectedEditor")), super.setParent(e2), t2 && this.select();
      }
      rotate() {
        this.parent && this.parent.drawLayer.updateProperties(this._drawId, _DrawingEditor._mergeSVGProperties({ bbox: __privateMethod(this, _gc, gc_fn).call(this) }, __privateGet(this, _ec).updateRotation((this.parentRotation - this.rotation + 360) % 360)));
      }
      onScaleChanging() {
        this.parent && __privateMethod(this, _dc, dc_fn).call(this, __privateGet(this, _ec).updateParentDimensions(this.parentDimensions, this.parent.scale));
      }
      static onScaleChangingWhenDrawing() {
      }
      render() {
        if (this.div)
          return this.div;
        let e2, t2;
        this._isCopy && (e2 = this.x, t2 = this.y);
        const i2 = super.render();
        i2.classList.add("draw");
        const a2 = document.createElement("div");
        i2.append(a2), a2.setAttribute("aria-hidden", "true"), a2.className = "internal";
        const [n2, s2] = this.parentDimensions;
        return this.setDims(this.width * n2, this.height * s2), this._uiManager.addShouldRescale(this), this.disableEditing(), this._isCopy && this._moveAfterPaste(e2, t2), i2;
      }
      static createDrawerInstance(e2, t2, i2, a2, n2) {
        unreachable("Not implemented");
      }
      static startDrawing(e2, t2, i2, a2) {
        const { target: n2, offsetX: s2, offsetY: r2, pointerId: o2, pointerType: l3 } = a2;
        if (__privateGet(_DrawingEditor, _rc) && __privateGet(_DrawingEditor, _rc) !== l3)
          return;
        const { viewport: { rotation: c2 } } = e2, { width: h2, height: d2 } = n2.getBoundingClientRect(), u2 = __privateSet(_DrawingEditor, _ac, new AbortController()), g2 = e2.combinedSignal(u2);
        __privateGet(_DrawingEditor, _sc) || __privateSet(_DrawingEditor, _sc, o2), __privateGet(_DrawingEditor, _rc) ?? __privateSet(_DrawingEditor, _rc, l3), window.addEventListener("pointerup", (e3) => {
          __privateGet(_DrawingEditor, _sc) === e3.pointerId ? this._endDraw(e3) : __privateGet(_DrawingEditor, _oc)?.delete(e3.pointerId);
        }, { signal: g2 }), window.addEventListener("pointercancel", (e3) => {
          __privateGet(_DrawingEditor, _sc) === e3.pointerId ? this._currentParent.endDrawingSession() : __privateGet(_DrawingEditor, _oc)?.delete(e3.pointerId);
        }, { signal: g2 }), window.addEventListener("pointerdown", (e3) => {
          __privateGet(_DrawingEditor, _rc) === e3.pointerType && ((__privateGet(_DrawingEditor, _oc) || __privateSet(_DrawingEditor, _oc, /* @__PURE__ */ new Set())).add(e3.pointerId), __privateGet(_DrawingEditor, _ic).isCancellable() && (__privateGet(_DrawingEditor, _ic).removeLastElement(), __privateGet(_DrawingEditor, _ic).isEmpty() ? this._currentParent.endDrawingSession(true) : this._endDraw(null)));
        }, { capture: true, passive: false, signal: g2 }), window.addEventListener("contextmenu", noContextMenu, { signal: g2 }), n2.addEventListener("pointermove", this._drawMove.bind(this), { signal: g2 }), n2.addEventListener("touchmove", (e3) => {
          e3.timeStamp === __privateGet(_DrawingEditor, _lc) && stopEvent(e3);
        }, { signal: g2 }), e2.toggleDrawing(), t2._editorUndoBar?.hide(), __privateGet(_DrawingEditor, _ic) ? e2.drawLayer.updateProperties(this._currentDrawId, __privateGet(_DrawingEditor, _ic).startNew(s2, r2, h2, d2, c2)) : (t2.updateUIForDefaultProperties(this), __privateSet(_DrawingEditor, _ic, this.createDrawerInstance(s2, r2, h2, d2, c2)), __privateSet(_DrawingEditor, _nc, this.getDefaultDrawingOptions()), this._currentParent = e2, { id: this._currentDrawId } = e2.drawLayer.draw(this._mergeSVGProperties(__privateGet(_DrawingEditor, _nc).toSVGProperties(), __privateGet(_DrawingEditor, _ic).defaultSVGProperties), true, false));
      }
      static _drawMove(e2) {
        if (__privateSet(_DrawingEditor, _lc, -1), !__privateGet(_DrawingEditor, _ic))
          return;
        const { offsetX: t2, offsetY: i2, pointerId: a2 } = e2;
        __privateGet(_DrawingEditor, _sc) === a2 && (__privateGet(_DrawingEditor, _oc)?.size >= 1 ? this._endDraw(e2) : (this._currentParent.drawLayer.updateProperties(this._currentDrawId, __privateGet(_DrawingEditor, _ic).add(t2, i2)), __privateSet(_DrawingEditor, _lc, e2.timeStamp), stopEvent(e2)));
      }
      static _cleanup(e2) {
        e2 && (this._currentDrawId = -1, this._currentParent = null, __privateSet(_DrawingEditor, _ic, null), __privateSet(_DrawingEditor, _nc, null), __privateSet(_DrawingEditor, _rc, null), __privateSet(_DrawingEditor, _lc, NaN)), __privateGet(_DrawingEditor, _ac) && (__privateGet(_DrawingEditor, _ac).abort(), __privateSet(_DrawingEditor, _ac, null), __privateSet(_DrawingEditor, _sc, NaN), __privateSet(_DrawingEditor, _oc, null));
      }
      static _endDraw(e2) {
        const t2 = this._currentParent;
        if (t2) {
          if (t2.toggleDrawing(true), this._cleanup(false), e2?.target === t2.div && t2.drawLayer.updateProperties(this._currentDrawId, __privateGet(_DrawingEditor, _ic).end(e2.offsetX, e2.offsetY)), this.supportMultipleDrawings) {
            const e3 = __privateGet(_DrawingEditor, _ic), i2 = this._currentDrawId, a2 = e3.getLastElement();
            return void t2.addCommands({ cmd: () => {
              t2.drawLayer.updateProperties(i2, e3.setLastElement(a2));
            }, undo: () => {
              t2.drawLayer.updateProperties(i2, e3.removeLastElement());
            }, mustExec: false, type: jl.DRAW_STEP });
          }
          this.endDrawing(false);
        }
      }
      static endDrawing(e2) {
        const t2 = this._currentParent;
        if (!t2)
          return null;
        if (t2.toggleDrawing(true), t2.cleanUndoStack(jl.DRAW_STEP), !__privateGet(_DrawingEditor, _ic).isEmpty()) {
          const { pageDimensions: [i2, a2], scale: n2 } = t2, s2 = t2.createAndAddNewEditor({ offsetX: 0, offsetY: 0 }, false, { drawId: this._currentDrawId, drawOutlines: __privateGet(_DrawingEditor, _ic).getOutlines(i2 * n2, a2 * n2, n2, this._INNER_MARGIN), drawingOptions: __privateGet(_DrawingEditor, _nc), mustBeCommitted: !e2 });
          return this._cleanup(true), s2;
        }
        return t2.drawLayer.remove(this._currentDrawId), this._cleanup(true), null;
      }
      createDrawingOptions(e2) {
      }
      static deserializeDraw(e2, t2, i2, a2, n2, s2) {
        unreachable("Not implemented");
      }
      static async deserialize(e2, t2, i2) {
        var _a4, _b2;
        const { rawDims: { pageWidth: a2, pageHeight: n2, pageX: s2, pageY: r2 } } = t2.viewport, o2 = this.deserializeDraw(s2, r2, a2, n2, this._INNER_MARGIN, e2), l3 = await super.deserialize(e2, t2, i2);
        return l3.createDrawingOptions(e2), __privateMethod(_a4 = l3, _cc, cc_fn).call(_a4, { drawOutlines: o2 }), __privateMethod(_b2 = l3, _jl2, jl_fn2).call(_b2), l3.onScaleChanging(), l3.rotate(), l3;
      }
      serializeDraw(e2) {
        const [t2, i2] = this.pageTranslation, [a2, n2] = this.pageDimensions;
        return __privateGet(this, _ec).serialize([t2, i2, a2, n2], e2);
      }
      renderAnnotationElement(e2) {
        return e2.updateEdited({ rect: this.getPDFRect() }), null;
      }
      static canCreateNewEmptyEditor() {
        return false;
      }
    };
    DrawingEditor = _DrawingEditor;
    __name(DrawingEditor, "DrawingEditor");
    _ec = new WeakMap();
    _tc = new WeakMap();
    _ic = new WeakMap();
    _ac = new WeakMap();
    _nc = new WeakMap();
    _sc = new WeakMap();
    _rc = new WeakMap();
    _oc = new WeakMap();
    _lc = new WeakMap();
    _cc = new WeakSet();
    cc_fn = /* @__PURE__ */ __name(function({ drawOutlines: e2, drawId: t2, drawingOptions: i2 }) {
      __privateSet(this, _ec, e2), this._drawingOptions ||= i2, this.annotationElementId || this._uiManager.a11yAlert(`pdfjs-editor-${this.editorType}-added-alert`), t2 >= 0 ? (this._drawId = t2, this.parent.drawLayer.finalizeDraw(t2, e2.defaultProperties)) : this._drawId = __privateMethod(this, _hc, hc_fn).call(this, e2, this.parent), __privateMethod(this, _dc, dc_fn).call(this, e2.box);
    }, "#cc");
    _hc = new WeakSet();
    hc_fn = /* @__PURE__ */ __name(function(e2, t2) {
      const { id: i2 } = t2.drawLayer.draw(_DrawingEditor._mergeSVGProperties(this._drawingOptions.toSVGProperties(), e2.defaultSVGProperties), false, false);
      return i2;
    }, "#hc");
    _Wl2 = new WeakSet();
    Wl_fn2 = /* @__PURE__ */ __name(function() {
      null !== this._drawId && this.parent && (this.parent.drawLayer.remove(this._drawId), this._drawId = null, this._drawingOptions.reset());
    }, "#Wl");
    _jl2 = new WeakSet();
    jl_fn2 = /* @__PURE__ */ __name(function(e2 = this.parent) {
      null !== this._drawId && this.parent === e2 || (null === this._drawId ? (this._drawingOptions.updateAll(), this._drawId = __privateMethod(this, _hc, hc_fn).call(this, __privateGet(this, _ec), e2)) : this.parent.drawLayer.updateParent(this._drawId, e2.drawLayer));
    }, "#jl");
    _pc = new WeakSet();
    pc_fn = /* @__PURE__ */ __name(function([e2, t2, i2, a2]) {
      const { parentDimensions: [n2, s2], rotation: r2 } = this;
      switch (r2) {
        case 90:
          return [t2, 1 - e2, i2 * (s2 / n2), a2 * (n2 / s2)];
        case 180:
          return [1 - e2, 1 - t2, i2, a2];
        case 270:
          return [1 - t2, e2, i2 * (s2 / n2), a2 * (n2 / s2)];
        default:
          return [e2, t2, i2, a2];
      }
    }, "#pc");
    _uc = new WeakSet();
    uc_fn = /* @__PURE__ */ __name(function() {
      const { x: e2, y: t2, width: i2, height: a2, parentDimensions: [n2, s2], rotation: r2 } = this;
      switch (r2) {
        case 90:
          return [1 - t2, e2, i2 * (n2 / s2), a2 * (s2 / n2)];
        case 180:
          return [1 - e2, 1 - t2, i2, a2];
        case 270:
          return [t2, 1 - e2, i2 * (n2 / s2), a2 * (s2 / n2)];
        default:
          return [e2, t2, i2, a2];
      }
    }, "#uc");
    _dc = new WeakSet();
    dc_fn = /* @__PURE__ */ __name(function(e2) {
      if ([this.x, this.y, this.width, this.height] = __privateMethod(this, _pc, pc_fn).call(this, e2), this.div) {
        this.fixAndSetPosition();
        const [e3, t2] = this.parentDimensions;
        this.setDims(this.width * e3, this.height * t2);
      }
      this._onResized();
    }, "#dc");
    _gc = new WeakSet();
    gc_fn = /* @__PURE__ */ __name(function() {
      const { x: e2, y: t2, width: i2, height: a2, rotation: n2, parentRotation: s2, parentDimensions: [r2, o2] } = this;
      switch ((4 * n2 + s2) / 90) {
        case 1:
          return [1 - t2 - a2, e2, a2, i2];
        case 2:
          return [1 - e2 - i2, 1 - t2 - a2, i2, a2];
        case 3:
          return [t2, 1 - e2 - i2, a2, i2];
        case 4:
          return [e2, t2 - i2 * (r2 / o2), a2 * (o2 / r2), i2 * (r2 / o2)];
        case 5:
          return [1 - t2, e2, i2 * (r2 / o2), a2 * (o2 / r2)];
        case 6:
          return [1 - e2 - a2 * (o2 / r2), 1 - t2, a2 * (o2 / r2), i2 * (r2 / o2)];
        case 7:
          return [t2 - i2 * (r2 / o2), 1 - e2 - a2 * (o2 / r2), i2 * (r2 / o2), a2 * (o2 / r2)];
        case 8:
          return [e2 - i2, t2 - a2, i2, a2];
        case 9:
          return [1 - t2, e2 - i2, a2, i2];
        case 10:
          return [1 - e2, 1 - t2, i2, a2];
        case 11:
          return [t2 - a2, 1 - e2, a2, i2];
        case 12:
          return [e2 - a2 * (o2 / r2), t2, a2 * (o2 / r2), i2 * (r2 / o2)];
        case 13:
          return [1 - t2 - i2 * (r2 / o2), e2 - a2 * (o2 / r2), i2 * (r2 / o2), a2 * (o2 / r2)];
        case 14:
          return [1 - e2, 1 - t2 - i2 * (r2 / o2), a2 * (o2 / r2), i2 * (r2 / o2)];
        case 15:
          return [t2, 1 - e2, i2 * (r2 / o2), a2 * (o2 / r2)];
        default:
          return [e2, t2, i2, a2];
      }
    }, "#gc");
    __publicField(DrawingEditor, "_currentDrawId", -1);
    __publicField(DrawingEditor, "_currentParent", null);
    __privateAdd(DrawingEditor, _ic, null);
    __privateAdd(DrawingEditor, _ac, null);
    __privateAdd(DrawingEditor, _nc, null);
    __privateAdd(DrawingEditor, _sc, NaN);
    __privateAdd(DrawingEditor, _rc, null);
    __privateAdd(DrawingEditor, _oc, null);
    __privateAdd(DrawingEditor, _lc, NaN);
    __publicField(DrawingEditor, "_INNER_MARGIN", 3);
    InkDrawOutliner = class {
      #Yo = new Float64Array(6);
      #yo;
      #fc;
      #Ms;
      #il;
      #al;
      #mc = "";
      #bc = 0;
      #kl = new InkDrawOutline();
      #yc;
      #wc;
      constructor(e2, t2, i2, a2, n2, s2) {
        this.#yc = i2, this.#wc = a2, this.#Ms = n2, this.#il = s2, [e2, t2] = this.#Ac(e2, t2);
        const r2 = this.#yo = [NaN, NaN, NaN, NaN, e2, t2];
        this.#al = [e2, t2], this.#fc = [{ line: r2, points: this.#al }], this.#Yo.set(r2, 0);
      }
      updateProperty(e2, t2) {
        "stroke-width" === e2 && (this.#il = t2);
      }
      #Ac(e2, t2) {
        return Outline._normalizePoint(e2, t2, this.#yc, this.#wc, this.#Ms);
      }
      isEmpty() {
        return !this.#fc || 0 === this.#fc.length;
      }
      isCancellable() {
        return this.#al.length <= 10;
      }
      add(e2, t2) {
        [e2, t2] = this.#Ac(e2, t2);
        const [i2, a2, n2, s2] = this.#Yo.subarray(2, 6), r2 = e2 - n2, o2 = t2 - s2;
        return Math.hypot(this.#yc * r2, this.#wc * o2) <= 2 ? null : (this.#al.push(e2, t2), isNaN(i2) ? (this.#Yo.set([n2, s2, e2, t2], 2), this.#yo.push(NaN, NaN, NaN, NaN, e2, t2), { path: { d: this.toSVGPath() } }) : (isNaN(this.#Yo[0]) && this.#yo.splice(6, 6), this.#Yo.set([i2, a2, n2, s2, e2, t2], 0), this.#yo.push(...Outline.createBezierPoints(i2, a2, n2, s2, e2, t2)), { path: { d: this.toSVGPath() } }));
      }
      end(e2, t2) {
        const i2 = this.add(e2, t2);
        return i2 || (2 === this.#al.length ? { path: { d: this.toSVGPath() } } : null);
      }
      startNew(e2, t2, i2, a2, n2) {
        this.#yc = i2, this.#wc = a2, this.#Ms = n2, [e2, t2] = this.#Ac(e2, t2);
        const s2 = this.#yo = [NaN, NaN, NaN, NaN, e2, t2];
        this.#al = [e2, t2];
        const r2 = this.#fc.at(-1);
        return r2 && (r2.line = new Float32Array(r2.line), r2.points = new Float32Array(r2.points)), this.#fc.push({ line: s2, points: this.#al }), this.#Yo.set(s2, 0), this.#bc = 0, this.toSVGPath(), null;
      }
      getLastElement() {
        return this.#fc.at(-1);
      }
      setLastElement(e2) {
        return this.#fc ? (this.#fc.push(e2), this.#yo = e2.line, this.#al = e2.points, this.#bc = 0, { path: { d: this.toSVGPath() } }) : this.#kl.setLastElement(e2);
      }
      removeLastElement() {
        if (!this.#fc)
          return this.#kl.removeLastElement();
        this.#fc.pop(), this.#mc = "";
        for (let e2 = 0, t2 = this.#fc.length; e2 < t2; e2++) {
          const { line: t3, points: i2 } = this.#fc[e2];
          this.#yo = t3, this.#al = i2, this.#bc = 0, this.toSVGPath();
        }
        return { path: { d: this.#mc } };
      }
      toSVGPath() {
        const e2 = Outline.svgRound(this.#yo[4]), t2 = Outline.svgRound(this.#yo[5]);
        if (2 === this.#al.length)
          return this.#mc = `${this.#mc} M ${e2} ${t2} Z`, this.#mc;
        if (this.#al.length <= 6) {
          const i3 = this.#mc.lastIndexOf("M");
          this.#mc = `${this.#mc.slice(0, i3)} M ${e2} ${t2}`, this.#bc = 6;
        }
        if (4 === this.#al.length) {
          const e3 = Outline.svgRound(this.#yo[10]), t3 = Outline.svgRound(this.#yo[11]);
          return this.#mc = `${this.#mc} L ${e3} ${t3}`, this.#bc = 12, this.#mc;
        }
        const i2 = [];
        0 === this.#bc && (i2.push(`M ${e2} ${t2}`), this.#bc = 6);
        for (let e3 = this.#bc, t3 = this.#yo.length; e3 < t3; e3 += 6) {
          const [t4, a2, n2, s2, r2, o2] = this.#yo.slice(e3, e3 + 6).map(Outline.svgRound);
          i2.push(`C${t4} ${a2} ${n2} ${s2} ${r2} ${o2}`);
        }
        return this.#mc += i2.join(" "), this.#bc = this.#yo.length, this.#mc;
      }
      getOutlines(e2, t2, i2, a2) {
        const n2 = this.#fc.at(-1);
        return n2.line = new Float32Array(n2.line), n2.points = new Float32Array(n2.points), this.#kl.build(this.#fc, e2, t2, i2, this.#Ms, this.#il, a2), this.#Yo = null, this.#yo = null, this.#fc = null, this.#mc = null, this.#kl;
      }
      get defaultSVGProperties() {
        return { root: { viewBox: "0 0 10000 10000" }, rootClass: { draw: true }, bbox: [0, 0, 1, 1] };
      }
    };
    __name(InkDrawOutliner, "InkDrawOutliner");
    InkDrawOutline = class extends Outline {
      #pl;
      #xc = 0;
      #Go;
      #fc;
      #yc;
      #wc;
      #Sc;
      #Ms;
      #il;
      build(e2, t2, i2, a2, n2, s2, r2) {
        this.#yc = t2, this.#wc = i2, this.#Sc = a2, this.#Ms = n2, this.#il = s2, this.#Go = r2 ?? 0, this.#fc = e2, this.#vc();
      }
      get thickness() {
        return this.#il;
      }
      setLastElement(e2) {
        return this.#fc.push(e2), { path: { d: this.toSVGPath() } };
      }
      removeLastElement() {
        return this.#fc.pop(), { path: { d: this.toSVGPath() } };
      }
      toSVGPath() {
        const e2 = [];
        for (const { line: t2 } of this.#fc)
          if (e2.push(`M${Outline.svgRound(t2[4])} ${Outline.svgRound(t2[5])}`), 6 !== t2.length)
            if (12 === t2.length && isNaN(t2[6]))
              e2.push(`L${Outline.svgRound(t2[10])} ${Outline.svgRound(t2[11])}`);
            else
              for (let i2 = 6, a2 = t2.length; i2 < a2; i2 += 6) {
                const [a3, n2, s2, r2, o2, l3] = t2.subarray(i2, i2 + 6).map(Outline.svgRound);
                e2.push(`C${a3} ${n2} ${s2} ${r2} ${o2} ${l3}`);
              }
          else
            e2.push("Z");
        return e2.join("");
      }
      serialize([e2, t2, i2, a2], n2) {
        const s2 = [], r2 = [], [o2, l3, c2, h2] = this.#Cc();
        let d2, u2, g2, p2, f2, m2, b2, y2, w2;
        switch (this.#Ms) {
          case 0:
            w2 = Outline._rescale, d2 = e2, u2 = t2 + a2, g2 = i2, p2 = -a2, f2 = e2 + o2 * i2, m2 = t2 + (1 - l3 - h2) * a2, b2 = e2 + (o2 + c2) * i2, y2 = t2 + (1 - l3) * a2;
            break;
          case 90:
            w2 = Outline._rescaleAndSwap, d2 = e2, u2 = t2, g2 = i2, p2 = a2, f2 = e2 + l3 * i2, m2 = t2 + o2 * a2, b2 = e2 + (l3 + h2) * i2, y2 = t2 + (o2 + c2) * a2;
            break;
          case 180:
            w2 = Outline._rescale, d2 = e2 + i2, u2 = t2, g2 = -i2, p2 = a2, f2 = e2 + (1 - o2 - c2) * i2, m2 = t2 + l3 * a2, b2 = e2 + (1 - o2) * i2, y2 = t2 + (l3 + h2) * a2;
            break;
          case 270:
            w2 = Outline._rescaleAndSwap, d2 = e2 + i2, u2 = t2 + a2, g2 = -i2, p2 = -a2, f2 = e2 + (1 - l3 - h2) * i2, m2 = t2 + (1 - o2 - c2) * a2, b2 = e2 + (1 - l3) * i2, y2 = t2 + (1 - o2) * a2;
        }
        for (const { line: e3, points: t3 } of this.#fc)
          s2.push(w2(e3, d2, u2, g2, p2, n2 ? new Array(e3.length) : null)), r2.push(w2(t3, d2, u2, g2, p2, n2 ? new Array(t3.length) : null));
        return { lines: s2, points: r2, rect: [f2, m2, b2, y2] };
      }
      static deserialize(e2, t2, i2, a2, n2, { paths: { lines: s2, points: r2 }, rotation: o2, thickness: l3 }) {
        const c2 = [];
        let h2, d2, u2, g2, p2;
        switch (o2) {
          case 0:
            p2 = Outline._rescale, h2 = -e2 / i2, d2 = t2 / a2 + 1, u2 = 1 / i2, g2 = -1 / a2;
            break;
          case 90:
            p2 = Outline._rescaleAndSwap, h2 = -t2 / a2, d2 = -e2 / i2, u2 = 1 / a2, g2 = 1 / i2;
            break;
          case 180:
            p2 = Outline._rescale, h2 = e2 / i2 + 1, d2 = -t2 / a2, u2 = -1 / i2, g2 = 1 / a2;
            break;
          case 270:
            p2 = Outline._rescaleAndSwap, h2 = t2 / a2 + 1, d2 = e2 / i2 + 1, u2 = -1 / a2, g2 = -1 / i2;
        }
        if (!s2) {
          s2 = [];
          for (const e3 of r2) {
            const t3 = e3.length;
            if (2 === t3) {
              s2.push(new Float32Array([NaN, NaN, NaN, NaN, e3[0], e3[1]]));
              continue;
            }
            if (4 === t3) {
              s2.push(new Float32Array([NaN, NaN, NaN, NaN, e3[0], e3[1], NaN, NaN, NaN, NaN, e3[2], e3[3]]));
              continue;
            }
            const i3 = new Float32Array(3 * (t3 - 2));
            s2.push(i3);
            let [a3, n3, r3, o3] = e3.subarray(0, 4);
            i3.set([NaN, NaN, NaN, NaN, a3, n3], 0);
            for (let s3 = 4; s3 < t3; s3 += 2) {
              const t4 = e3[s3], l4 = e3[s3 + 1];
              i3.set(Outline.createBezierPoints(a3, n3, r3, o3, t4, l4), 3 * (s3 - 2)), [a3, n3, r3, o3] = [r3, o3, t4, l4];
            }
          }
        }
        for (let e3 = 0, t3 = s2.length; e3 < t3; e3++)
          c2.push({ line: p2(s2[e3].map((e4) => e4 ?? NaN), h2, d2, u2, g2), points: p2(r2[e3].map((e4) => e4 ?? NaN), h2, d2, u2, g2) });
        const f2 = new this.prototype.constructor();
        return f2.build(c2, i2, a2, 1, o2, l3, n2), f2;
      }
      #kc(e2 = this.#il) {
        const t2 = this.#Go + e2 / 2 * this.#Sc;
        return this.#Ms % 180 == 0 ? [t2 / this.#yc, t2 / this.#wc] : [t2 / this.#wc, t2 / this.#yc];
      }
      #Cc() {
        const [e2, t2, i2, a2] = this.#pl, [n2, s2] = this.#kc(0);
        return [e2 + n2, t2 + s2, i2 - 2 * n2, a2 - 2 * s2];
      }
      #vc() {
        const e2 = this.#pl = new Float32Array([1 / 0, 1 / 0, -1 / 0, -1 / 0]);
        for (const { line: t3 } of this.#fc) {
          if (t3.length <= 12) {
            for (let i4 = 4, a3 = t3.length; i4 < a3; i4 += 6)
              Util.pointBoundingBox(t3[i4], t3[i4 + 1], e2);
            continue;
          }
          let i3 = t3[4], a2 = t3[5];
          for (let n2 = 6, s2 = t3.length; n2 < s2; n2 += 6) {
            const [s3, r2, o2, l3, c2, h2] = t3.subarray(n2, n2 + 6);
            Util.bezierBoundingBox(i3, a2, s3, r2, o2, l3, c2, h2, e2), i3 = c2, a2 = h2;
          }
        }
        const [t2, i2] = this.#kc();
        e2[0] = MathClamp(e2[0] - t2, 0, 1), e2[1] = MathClamp(e2[1] - i2, 0, 1), e2[2] = MathClamp(e2[2] + t2, 0, 1), e2[3] = MathClamp(e2[3] + i2, 0, 1), e2[2] -= e2[0], e2[3] -= e2[1];
      }
      get box() {
        return this.#pl;
      }
      updateProperty(e2, t2) {
        return "stroke-width" === e2 ? this.#ql(t2) : null;
      }
      #ql(e2) {
        const [t2, i2] = this.#kc();
        this.#il = e2;
        const [a2, n2] = this.#kc(), [s2, r2] = [a2 - t2, n2 - i2], o2 = this.#pl;
        return o2[0] -= s2, o2[1] -= r2, o2[2] += 2 * s2, o2[3] += 2 * r2, o2;
      }
      updateParentDimensions([e2, t2], i2) {
        const [a2, n2] = this.#kc();
        this.#yc = e2, this.#wc = t2, this.#Sc = i2;
        const [s2, r2] = this.#kc(), o2 = s2 - a2, l3 = r2 - n2, c2 = this.#pl;
        return c2[0] -= o2, c2[1] -= l3, c2[2] += 2 * o2, c2[3] += 2 * l3, c2;
      }
      updateRotation(e2) {
        return this.#xc = e2, { path: { transform: this.rotationTransform } };
      }
      get viewBox() {
        return this.#pl.map(Outline.svgRound).join(" ");
      }
      get defaultProperties() {
        const [e2, t2] = this.#pl;
        return { root: { viewBox: this.viewBox }, path: { "transform-origin": `${Outline.svgRound(e2)} ${Outline.svgRound(t2)}` } };
      }
      get rotationTransform() {
        const [, , e2, t2] = this.#pl;
        let i2 = 0, a2 = 0, n2 = 0, s2 = 0, r2 = 0, o2 = 0;
        switch (this.#xc) {
          case 90:
            a2 = t2 / e2, n2 = -e2 / t2, r2 = e2;
            break;
          case 180:
            i2 = -1, s2 = -1, r2 = e2, o2 = t2;
            break;
          case 270:
            a2 = -t2 / e2, n2 = e2 / t2, o2 = t2;
            break;
          default:
            return "";
        }
        return `matrix(${i2} ${a2} ${n2} ${s2} ${Outline.svgRound(r2)} ${Outline.svgRound(o2)})`;
      }
      getPathResizingSVGProperties([e2, t2, i2, a2]) {
        const [n2, s2] = this.#kc(), [r2, o2, l3, c2] = this.#pl;
        if (Math.abs(l3 - n2) <= Outline.PRECISION || Math.abs(c2 - s2) <= Outline.PRECISION) {
          const n3 = e2 + i2 / 2 - (r2 + l3 / 2), s3 = t2 + a2 / 2 - (o2 + c2 / 2);
          return { path: { "transform-origin": `${Outline.svgRound(e2)} ${Outline.svgRound(t2)}`, transform: `${this.rotationTransform} translate(${n3} ${s3})` } };
        }
        const h2 = (i2 - 2 * n2) / (l3 - 2 * n2), d2 = (a2 - 2 * s2) / (c2 - 2 * s2), u2 = l3 / i2, g2 = c2 / a2;
        return { path: { "transform-origin": `${Outline.svgRound(r2)} ${Outline.svgRound(o2)}`, transform: `${this.rotationTransform} scale(${u2} ${g2}) translate(${Outline.svgRound(n2)} ${Outline.svgRound(s2)}) scale(${h2} ${d2}) translate(${Outline.svgRound(-n2)} ${Outline.svgRound(-s2)})` } };
      }
      getPathResizedSVGProperties([e2, t2, i2, a2]) {
        const [n2, s2] = this.#kc(), r2 = this.#pl, [o2, l3, c2, h2] = r2;
        if (r2[0] = e2, r2[1] = t2, r2[2] = i2, r2[3] = a2, Math.abs(c2 - n2) <= Outline.PRECISION || Math.abs(h2 - s2) <= Outline.PRECISION) {
          const n3 = e2 + i2 / 2 - (o2 + c2 / 2), s3 = t2 + a2 / 2 - (l3 + h2 / 2);
          for (const { line: e3, points: t3 } of this.#fc)
            Outline._translate(e3, n3, s3, e3), Outline._translate(t3, n3, s3, t3);
          return { root: { viewBox: this.viewBox }, path: { "transform-origin": `${Outline.svgRound(e2)} ${Outline.svgRound(t2)}`, transform: this.rotationTransform || null, d: this.toSVGPath() } };
        }
        const d2 = (i2 - 2 * n2) / (c2 - 2 * n2), u2 = (a2 - 2 * s2) / (h2 - 2 * s2), g2 = -d2 * (o2 + n2) + e2 + n2, p2 = -u2 * (l3 + s2) + t2 + s2;
        if (1 !== d2 || 1 !== u2 || 0 !== g2 || 0 !== p2)
          for (const { line: e3, points: t3 } of this.#fc)
            Outline._rescale(e3, g2, p2, d2, u2, e3), Outline._rescale(t3, g2, p2, d2, u2, t3);
        return { root: { viewBox: this.viewBox }, path: { "transform-origin": `${Outline.svgRound(e2)} ${Outline.svgRound(t2)}`, transform: this.rotationTransform || null, d: this.toSVGPath() } };
      }
      getPathTranslatedSVGProperties([e2, t2], i2) {
        const [a2, n2] = i2, s2 = this.#pl, r2 = e2 - s2[0], o2 = t2 - s2[1];
        if (this.#yc === a2 && this.#wc === n2)
          for (const { line: e3, points: t3 } of this.#fc)
            Outline._translate(e3, r2, o2, e3), Outline._translate(t3, r2, o2, t3);
        else {
          const e3 = this.#yc / a2, t3 = this.#wc / n2;
          this.#yc = a2, this.#wc = n2;
          for (const { line: i3, points: a3 } of this.#fc)
            Outline._rescale(i3, r2, o2, e3, t3, i3), Outline._rescale(a3, r2, o2, e3, t3, a3);
          s2[2] *= e3, s2[3] *= t3;
        }
        return s2[0] = e2, s2[1] = t2, { root: { viewBox: this.viewBox }, path: { d: this.toSVGPath(), "transform-origin": `${Outline.svgRound(e2)} ${Outline.svgRound(t2)}` } };
      }
      get defaultSVGProperties() {
        const e2 = this.#pl;
        return { root: { viewBox: this.viewBox }, rootClass: { draw: true }, path: { d: this.toSVGPath(), "transform-origin": `${Outline.svgRound(e2[0])} ${Outline.svgRound(e2[1])}`, transform: this.rotationTransform || null }, bbox: e2 };
      }
    };
    __name(InkDrawOutline, "InkDrawOutline");
    InkDrawingOptions = class extends DrawingOptions {
      constructor(e2) {
        super(), this._viewParameters = e2, super.updateProperties({ fill: "none", stroke: AnnotationEditor._defaultLineColor, "stroke-opacity": 1, "stroke-width": 1, "stroke-linecap": "round", "stroke-linejoin": "round", "stroke-miterlimit": 10 });
      }
      updateSVGProperty(e2, t2) {
        "stroke-width" === e2 && (t2 ??= this["stroke-width"], t2 *= this._viewParameters.realScale), super.updateSVGProperty(e2, t2);
      }
      clone() {
        const e2 = new InkDrawingOptions(this._viewParameters);
        return e2.updateAll(this), e2;
      }
    };
    __name(InkDrawingOptions, "InkDrawingOptions");
    _InkEditor = class extends DrawingEditor {
      constructor(e2) {
        super({ ...e2, name: "inkEditor" });
        __privateAdd(this, _Xo3);
        this._willKeepAspectRatio = true, this.defaultL10nId = "pdfjs-editor-ink-editor";
      }
      static initialize(e2, t2) {
        AnnotationEditor.initialize(e2, t2), this._defaultDrawingOptions = new InkDrawingOptions(t2.viewParameters);
      }
      static getDefaultDrawingOptions(e2) {
        const t2 = this._defaultDrawingOptions.clone();
        return t2.updateProperties(e2), t2;
      }
      static get supportMultipleDrawings() {
        return true;
      }
      static get typesMap() {
        return shadow(this, "typesMap", /* @__PURE__ */ new Map([[jl.INK_THICKNESS, "stroke-width"], [jl.INK_COLOR, "stroke"], [jl.INK_OPACITY, "stroke-opacity"]]));
      }
      static createDrawerInstance(e2, t2, i2, a2, n2) {
        return new InkDrawOutliner(e2, t2, i2, a2, n2, this._defaultDrawingOptions["stroke-width"]);
      }
      static deserializeDraw(e2, t2, i2, a2, n2, s2) {
        return InkDrawOutline.deserialize(e2, t2, i2, a2, n2, s2);
      }
      static async deserialize(e2, t2, i2) {
        let a2 = null;
        if (e2 instanceof InkAnnotationElement) {
          const { data: { inkLists: t3, rect: i3, rotation: n3, id: s2, color: r2, opacity: o2, borderStyle: { rawWidth: l3 }, popupRef: c2, contentsObj: h2 }, parent: { page: { pageNumber: d2 } } } = e2;
          a2 = e2 = { annotationType: Ll.INK, color: Array.from(r2), thickness: l3, opacity: o2, paths: { points: t3 }, boxes: null, pageIndex: d2 - 1, rect: i3.slice(0), rotation: n3, annotationElementId: s2, id: s2, deleted: false, popupRef: c2, comment: h2?.str || null };
        }
        const n2 = await super.deserialize(e2, t2, i2);
        return n2._initialData = a2, e2.comment && n2.setCommentData(e2.comment), n2;
      }
      get toolbarButtons() {
        return this._colorPicker ||= new BasicColorPicker(this), [["colorPicker", this._colorPicker]];
      }
      get colorType() {
        return jl.INK_COLOR;
      }
      get colorValue() {
        return this._drawingOptions.stroke;
      }
      onScaleChanging() {
        if (!this.parent)
          return;
        super.onScaleChanging();
        const { _drawId: e2, _drawingOptions: t2, parent: i2 } = this;
        t2.updateSVGProperty("stroke-width"), i2.drawLayer.updateProperties(e2, t2.toSVGProperties());
      }
      static onScaleChangingWhenDrawing() {
        const e2 = this._currentParent;
        e2 && (super.onScaleChangingWhenDrawing(), this._defaultDrawingOptions.updateSVGProperty("stroke-width"), e2.drawLayer.updateProperties(this._currentDrawId, this._defaultDrawingOptions.toSVGProperties()));
      }
      createDrawingOptions({ color: e2, thickness: t2, opacity: i2 }) {
        this._drawingOptions = _InkEditor.getDefaultDrawingOptions({ stroke: Util.makeHexColor(...e2), "stroke-width": t2, "stroke-opacity": i2 });
      }
      serialize(e2 = false) {
        if (this.isEmpty())
          return null;
        if (this.deleted)
          return this.serializeDeleted();
        const { lines: t2, points: i2, rect: a2 } = this.serializeDraw(e2), { _drawingOptions: { stroke: n2, "stroke-opacity": s2, "stroke-width": r2 } } = this, o2 = { annotationType: Ll.INK, color: AnnotationEditor._colorManager.convert(n2), opacity: s2, thickness: r2, paths: { lines: t2, points: i2 }, pageIndex: this.pageIndex, rect: a2, rotation: this.rotation, structTreeParentId: this._structTreeParentId };
        return this.addComment(o2), e2 ? (o2.isCopy = true, o2) : this.annotationElementId && !__privateMethod(this, _Xo3, Xo_fn3).call(this, o2) ? null : (o2.id = this.annotationElementId, o2);
      }
      renderAnnotationElement(e2) {
        if (this.deleted)
          return e2.hide(), null;
        const { points: t2, rect: i2 } = this.serializeDraw(false), a2 = { rect: i2, thickness: this._drawingOptions["stroke-width"], points: t2 };
        return this.hasEditedComment && (a2.popup = this.comment), e2.updateEdited(a2), null;
      }
    };
    InkEditor = _InkEditor;
    __name(InkEditor, "InkEditor");
    _Xo3 = new WeakSet();
    Xo_fn3 = /* @__PURE__ */ __name(function(e2) {
      const { color: t2, thickness: i2, opacity: a2, pageIndex: n2 } = this._initialData;
      return this.hasEditedComment || this._hasBeenMoved || this._hasBeenResized || e2.color.some((e3, i3) => e3 !== t2[i3]) || e2.thickness !== i2 || e2.opacity !== a2 || e2.pageIndex !== n2;
    }, "#Xo");
    __publicField(InkEditor, "_type", "ink");
    __publicField(InkEditor, "_editorType", Ll.INK);
    __publicField(InkEditor, "_defaultDrawingOptions", null);
    ContourDrawOutline = class extends InkDrawOutline {
      toSVGPath() {
        let e2 = super.toSVGPath();
        return e2.endsWith("Z") || (e2 += "Z"), e2;
      }
    };
    __name(ContourDrawOutline, "ContourDrawOutline");
    SignatureExtractor = class {
      static extractContoursFromText(e2, { fontFamily: t2, fontStyle: i2, fontWeight: a2 }, n2, s2, r2, o2) {
        let l3 = new OffscreenCanvas(1, 1), c2 = l3.getContext("2d", { alpha: false });
        const h2 = c2.font = `${i2} ${a2} 200px ${t2}`, { actualBoundingBoxLeft: d2, actualBoundingBoxRight: u2, actualBoundingBoxAscent: g2, actualBoundingBoxDescent: p2, fontBoundingBoxAscent: f2, fontBoundingBoxDescent: m2, width: b2 } = c2.measureText(e2), y2 = 1.5, w2 = Math.ceil(Math.max(Math.abs(d2) + Math.abs(u2) || 0, b2) * y2), x2 = Math.ceil(Math.max(Math.abs(g2) + Math.abs(p2) || 200, Math.abs(f2) + Math.abs(m2) || 200) * y2);
        l3 = new OffscreenCanvas(w2, x2), c2 = l3.getContext("2d", { alpha: true, willReadFrequently: true }), c2.font = h2, c2.filter = "grayscale(1)", c2.fillStyle = "white", c2.fillRect(0, 0, w2, x2), c2.fillStyle = "black", c2.fillText(e2, 0.5 * w2 / 2, 1.5 * x2 / 2);
        const S2 = __privateMethod(this, _Bc, Bc_fn).call(this, c2.getImageData(0, 0, w2, x2).data), v2 = __privateMethod(this, _Rc, Rc_fn).call(this, S2), C2 = __privateMethod(this, _Nc, Nc_fn).call(this, v2), k2 = __privateMethod(this, _Ec, Ec_fn).call(this, S2, w2, x2, C2);
        return this.processDrawnLines({ lines: { curves: k2, width: w2, height: x2 }, pageWidth: n2, pageHeight: s2, rotation: r2, innerMargin: o2, mustSmooth: true, areContours: true });
      }
      static process(e2, t2, i2, a2, n2) {
        const [s2, r2, o2] = __privateMethod(this, _Lc, Lc_fn).call(this, e2), [l3, c2] = __privateMethod(this, _Pc, Pc_fn).call(this, s2, r2, o2, Math.hypot(r2, o2) * __privateGet(this, _Tc).sigmaSFactor, __privateGet(this, _Tc).sigmaR, __privateGet(this, _Tc).kernelSize), h2 = __privateMethod(this, _Nc, Nc_fn).call(this, c2), d2 = __privateMethod(this, _Ec, Ec_fn).call(this, l3, r2, o2, h2);
        return this.processDrawnLines({ lines: { curves: d2, width: r2, height: o2 }, pageWidth: t2, pageHeight: i2, rotation: a2, innerMargin: n2, mustSmooth: true, areContours: true });
      }
      static processDrawnLines({ lines: e2, pageWidth: t2, pageHeight: i2, rotation: a2, innerMargin: n2, mustSmooth: s2, areContours: r2 }) {
        a2 % 180 != 0 && ([t2, i2] = [i2, t2]);
        const { curves: o2, width: l3, height: c2 } = e2, h2 = e2.thickness ?? 0, d2 = [], u2 = Math.min(t2 / l3, i2 / c2), g2 = u2 / t2, p2 = u2 / i2, f2 = [];
        for (const { points: e3 } of o2) {
          const t3 = s2 ? __privateMethod(this, __c, _c_fn).call(this, e3) : e3;
          if (!t3)
            continue;
          f2.push(t3);
          const i3 = t3.length, a3 = new Float32Array(i3), n3 = new Float32Array(3 * (2 === i3 ? 2 : i3 - 2));
          if (d2.push({ line: n3, points: a3 }), 2 === i3) {
            a3[0] = t3[0] * g2, a3[1] = t3[1] * p2, n3.set([NaN, NaN, NaN, NaN, a3[0], a3[1]], 0);
            continue;
          }
          let [r3, o3, l4, c3] = t3;
          r3 *= g2, o3 *= p2, l4 *= g2, c3 *= p2, a3.set([r3, o3, l4, c3], 0), n3.set([NaN, NaN, NaN, NaN, r3, o3], 0);
          for (let e4 = 4; e4 < i3; e4 += 2) {
            const i4 = a3[e4] = t3[e4] * g2, s3 = a3[e4 + 1] = t3[e4 + 1] * p2;
            n3.set(Outline.createBezierPoints(r3, o3, l4, c3, i4, s3), 3 * (e4 - 2)), [r3, o3, l4, c3] = [l4, c3, i4, s3];
          }
        }
        if (0 === d2.length)
          return null;
        const m2 = r2 ? new ContourDrawOutline() : new InkDrawOutline();
        return m2.build(d2, t2, i2, 1, a2, r2 ? 0 : h2, n2), { outline: m2, newCurves: f2, areContours: r2, thickness: h2, width: l3, height: c2 };
      }
      static async compressSignature({ outlines: e2, areContours: t2, thickness: i2, width: a2, height: n2 }) {
        let s2, r2 = 1 / 0, o2 = -1 / 0, l3 = 0;
        for (const t3 of e2) {
          l3 += t3.length;
          for (let e3 = 2, i3 = t3.length; e3 < i3; e3++) {
            const i4 = t3[e3] - t3[e3 - 2];
            r2 = Math.min(r2, i4), o2 = Math.max(o2, i4);
          }
        }
        s2 = r2 >= -128 && o2 <= 127 ? Int8Array : r2 >= -32768 && o2 <= 32767 ? Int16Array : Int32Array;
        const c2 = e2.length, h2 = 8 + 3 * c2, d2 = new Uint32Array(h2);
        let u2 = 0;
        d2[u2++] = h2 * Uint32Array.BYTES_PER_ELEMENT + (l3 - 2 * c2) * s2.BYTES_PER_ELEMENT, d2[u2++] = 0, d2[u2++] = a2, d2[u2++] = n2, d2[u2++] = t2 ? 0 : 1, d2[u2++] = Math.max(0, Math.floor(i2 ?? 0)), d2[u2++] = c2, d2[u2++] = s2.BYTES_PER_ELEMENT;
        for (const t3 of e2)
          d2[u2++] = t3.length - 2, d2[u2++] = t3[0], d2[u2++] = t3[1];
        const g2 = new CompressionStream("deflate-raw"), p2 = g2.writable.getWriter();
        await p2.ready, p2.write(d2);
        const f2 = s2.prototype.constructor;
        for (const t3 of e2) {
          const e3 = new f2(t3.length - 2);
          for (let i3 = 2, a3 = t3.length; i3 < a3; i3++)
            e3[i3 - 2] = t3[i3] - t3[i3 - 2];
          p2.write(e3);
        }
        p2.close();
        const m2 = await new Response(g2.readable).arrayBuffer();
        return toBase64Util(new Uint8Array(m2));
      }
      static async decompressSignature(e2) {
        try {
          const i2 = (t2 = e2, Uint8Array.fromBase64 ? Uint8Array.fromBase64(t2) : stringToBytes(atob(t2))), { readable: a2, writable: n2 } = new DecompressionStream("deflate-raw"), s2 = n2.getWriter();
          await s2.ready, s2.write(i2).then(async () => {
            await s2.ready, await s2.close();
          }).catch(() => {
          });
          let r2 = null, o2 = 0;
          for await (const e3 of a2)
            r2 ||= new Uint8Array(new Uint32Array(e3.buffer, 0, 4)[0]), r2.set(e3, o2), o2 += e3.length;
          const l3 = new Uint32Array(r2.buffer, 0, r2.length >> 2), c2 = l3[1];
          if (0 !== c2)
            throw new Error(`Invalid version: ${c2}`);
          const h2 = l3[2], d2 = l3[3], u2 = 0 === l3[4], g2 = l3[5], p2 = l3[6], f2 = l3[7], m2 = [], b2 = (8 + 3 * p2) * Uint32Array.BYTES_PER_ELEMENT;
          let y2;
          switch (f2) {
            case Int8Array.BYTES_PER_ELEMENT:
              y2 = new Int8Array(r2.buffer, b2);
              break;
            case Int16Array.BYTES_PER_ELEMENT:
              y2 = new Int16Array(r2.buffer, b2);
              break;
            case Int32Array.BYTES_PER_ELEMENT:
              y2 = new Int32Array(r2.buffer, b2);
          }
          o2 = 0;
          for (let e3 = 0; e3 < p2; e3++) {
            const t3 = l3[3 * e3 + 8], i3 = new Float32Array(t3 + 2);
            m2.push(i3);
            for (let t4 = 0; t4 < 2; t4++)
              i3[t4] = l3[3 * e3 + 8 + t4 + 1];
            for (let e4 = 0; e4 < t3; e4++)
              i3[e4 + 2] = i3[e4] + y2[o2++];
          }
          return { areContours: u2, thickness: g2, outlines: m2, width: h2, height: d2 };
        } catch (e3) {
          return warn3(`decompressSignature: ${e3}`), null;
        }
        var t2;
      }
    };
    __name(SignatureExtractor, "SignatureExtractor");
    _Tc = new WeakMap();
    _Ic = new WeakSet();
    Ic_fn = /* @__PURE__ */ __name(function(e2, t2, i2, a2) {
      return a2 -= t2, 0 === (i2 -= e2) ? a2 > 0 ? 0 : 4 : 1 === i2 ? a2 + 6 : 2 - a2;
    }, "#Ic");
    _Fc = new WeakMap();
    _Mc = new WeakSet();
    Mc_fn = /* @__PURE__ */ __name(function(e2, t2, i2, a2, n2, s2, r2) {
      const o2 = __privateMethod(this, _Ic, Ic_fn).call(this, i2, a2, n2, s2);
      for (let n3 = 0; n3 < 8; n3++) {
        const s3 = (-n3 + o2 - r2 + 16) % 8;
        if (0 !== e2[(i2 + __privateGet(this, _Fc)[2 * s3]) * t2 + (a2 + __privateGet(this, _Fc)[2 * s3 + 1])])
          return s3;
      }
      return -1;
    }, "#Mc");
    _Dc = new WeakSet();
    Dc_fn = /* @__PURE__ */ __name(function(e2, t2, i2, a2, n2, s2, r2) {
      const o2 = __privateMethod(this, _Ic, Ic_fn).call(this, i2, a2, n2, s2);
      for (let n3 = 0; n3 < 8; n3++) {
        const s3 = (n3 + o2 + r2 + 16) % 8;
        if (0 !== e2[(i2 + __privateGet(this, _Fc)[2 * s3]) * t2 + (a2 + __privateGet(this, _Fc)[2 * s3 + 1])])
          return s3;
      }
      return -1;
    }, "#Dc");
    _Ec = new WeakSet();
    Ec_fn = /* @__PURE__ */ __name(function(e2, t2, i2, a2) {
      const n2 = e2.length, s2 = new Int32Array(n2);
      for (let t3 = 0; t3 < n2; t3++)
        s2[t3] = e2[t3] <= a2 ? 1 : 0;
      for (let e3 = 1; e3 < i2 - 1; e3++)
        s2[e3 * t2] = s2[e3 * t2 + t2 - 1] = 0;
      for (let e3 = 0; e3 < t2; e3++)
        s2[e3] = s2[t2 * i2 - 1 - e3] = 0;
      let r2, o2 = 1;
      const l3 = [];
      for (let e3 = 1; e3 < i2 - 1; e3++) {
        r2 = 1;
        for (let i3 = 1; i3 < t2 - 1; i3++) {
          const a3 = e3 * t2 + i3, n3 = s2[a3];
          if (0 === n3)
            continue;
          let c2 = e3, h2 = i3;
          if (1 === n3 && 0 === s2[a3 - 1])
            o2 += 1, h2 -= 1;
          else {
            if (!(n3 >= 1 && 0 === s2[a3 + 1])) {
              1 !== n3 && (r2 = Math.abs(n3));
              continue;
            }
            o2 += 1, h2 += 1, n3 > 1 && (r2 = n3);
          }
          const d2 = [i3, e3], u2 = h2 === i3 + 1, g2 = { isHole: u2, points: d2, id: o2, parent: 0 };
          let p2;
          l3.push(g2);
          for (const e4 of l3)
            if (e4.id === r2) {
              p2 = e4;
              break;
            }
          p2 ? p2.isHole ? g2.parent = u2 ? p2.parent : r2 : g2.parent = u2 ? r2 : p2.parent : g2.parent = u2 ? r2 : 0;
          const f2 = __privateMethod(this, _Mc, Mc_fn).call(this, s2, t2, e3, i3, c2, h2, 0);
          if (-1 === f2) {
            s2[a3] = -o2, 1 !== s2[a3] && (r2 = Math.abs(s2[a3]));
            continue;
          }
          let m2 = __privateGet(this, _Fc)[2 * f2], b2 = __privateGet(this, _Fc)[2 * f2 + 1];
          const y2 = e3 + m2, w2 = i3 + b2;
          c2 = y2, h2 = w2;
          let x2 = e3, S2 = i3;
          for (; ; ) {
            const n4 = __privateMethod(this, _Dc, Dc_fn).call(this, s2, t2, x2, S2, c2, h2, 1);
            m2 = __privateGet(this, _Fc)[2 * n4], b2 = __privateGet(this, _Fc)[2 * n4 + 1];
            const l4 = x2 + m2, u3 = S2 + b2;
            d2.push(u3, l4);
            const g3 = x2 * t2 + S2;
            if (0 === s2[g3 + 1] ? s2[g3] = -o2 : 1 === s2[g3] && (s2[g3] = o2), l4 === e3 && u3 === i3 && x2 === y2 && S2 === w2) {
              1 !== s2[a3] && (r2 = Math.abs(s2[a3]));
              break;
            }
            c2 = x2, h2 = S2, x2 = l4, S2 = u3;
          }
        }
      }
      return l3;
    }, "#Ec");
    _Oc = new WeakSet();
    Oc_fn = /* @__PURE__ */ __name(function(e2, t2, i2, a2) {
      if (i2 - t2 <= 4) {
        for (let n3 = t2; n3 < i2 - 2; n3 += 2)
          a2.push(e2[n3], e2[n3 + 1]);
        return;
      }
      const n2 = e2[t2], s2 = e2[t2 + 1], r2 = e2[i2 - 4] - n2, o2 = e2[i2 - 3] - s2, l3 = Math.hypot(r2, o2), c2 = r2 / l3, h2 = o2 / l3, d2 = c2 * s2 - h2 * n2, u2 = o2 / r2, g2 = 1 / l3, p2 = Math.atan(u2), f2 = Math.cos(p2), m2 = Math.sin(p2), b2 = g2 * (Math.abs(f2) + Math.abs(m2)), y2 = g2 * (1 - b2 + b2 ** 2), w2 = Math.max(Math.atan(Math.abs(m2 + f2) * y2), Math.atan(Math.abs(m2 - f2) * y2));
      let x2 = 0, S2 = t2;
      for (let a3 = t2 + 2; a3 < i2 - 2; a3 += 2) {
        const t3 = Math.abs(d2 - c2 * e2[a3 + 1] + h2 * e2[a3]);
        t3 > x2 && (S2 = a3, x2 = t3);
      }
      x2 > (l3 * w2) ** 2 ? (__privateMethod(this, _Oc, Oc_fn).call(this, e2, t2, S2 + 2, a2), __privateMethod(this, _Oc, Oc_fn).call(this, e2, S2, i2, a2)) : a2.push(n2, s2);
    }, "#Oc");
    __c = new WeakSet();
    _c_fn = /* @__PURE__ */ __name(function(e2) {
      const t2 = [], i2 = e2.length;
      return __privateMethod(this, _Oc, Oc_fn).call(this, e2, 0, i2, t2), t2.push(e2[i2 - 2], e2[i2 - 1]), t2.length <= 4 ? null : t2;
    }, "#_c");
    _Pc = new WeakSet();
    Pc_fn = /* @__PURE__ */ __name(function(e2, t2, i2, a2, n2, s2) {
      const r2 = new Float32Array(s2 ** 2), o2 = -2 * a2 ** 2, l3 = s2 >> 1;
      for (let e3 = 0; e3 < s2; e3++) {
        const t3 = (e3 - l3) ** 2;
        for (let i3 = 0; i3 < s2; i3++)
          r2[e3 * s2 + i3] = Math.exp((t3 + (i3 - l3) ** 2) / o2);
      }
      const c2 = new Float32Array(256), h2 = -2 * n2 ** 2;
      for (let e3 = 0; e3 < 256; e3++)
        c2[e3] = Math.exp(e3 ** 2 / h2);
      const d2 = e2.length, u2 = new Uint8Array(d2), g2 = new Uint32Array(256);
      for (let a3 = 0; a3 < i2; a3++)
        for (let n3 = 0; n3 < t2; n3++) {
          const o3 = a3 * t2 + n3, h3 = e2[o3];
          let d3 = 0, p2 = 0;
          for (let o4 = 0; o4 < s2; o4++) {
            const u3 = a3 + o4 - l3;
            if (!(u3 < 0 || u3 >= i2))
              for (let i3 = 0; i3 < s2; i3++) {
                const a4 = n3 + i3 - l3;
                if (a4 < 0 || a4 >= t2)
                  continue;
                const g3 = e2[u3 * t2 + a4], f2 = r2[o4 * s2 + i3] * c2[Math.abs(g3 - h3)];
                d3 += g3 * f2, p2 += f2;
              }
          }
          g2[u2[o3] = Math.round(d3 / p2)]++;
        }
      return [u2, g2];
    }, "#Pc");
    _Rc = new WeakSet();
    Rc_fn = /* @__PURE__ */ __name(function(e2) {
      const t2 = new Uint32Array(256);
      for (const i2 of e2)
        t2[i2]++;
      return t2;
    }, "#Rc");
    _Bc = new WeakSet();
    Bc_fn = /* @__PURE__ */ __name(function(e2) {
      const t2 = e2.length, i2 = new Uint8ClampedArray(t2 >> 2);
      let a2 = -1 / 0, n2 = 1 / 0;
      for (let t3 = 0, s3 = i2.length; t3 < s3; t3++) {
        const s4 = i2[t3] = e2[t3 << 2];
        a2 = Math.max(a2, s4), n2 = Math.min(n2, s4);
      }
      const s2 = 255 / (a2 - n2);
      for (let e3 = 0, t3 = i2.length; e3 < t3; e3++)
        i2[e3] = (i2[e3] - n2) * s2;
      return i2;
    }, "#Bc");
    _Nc = new WeakSet();
    Nc_fn = /* @__PURE__ */ __name(function(e2) {
      let t2, i2 = -1 / 0, a2 = -1 / 0;
      const n2 = e2.findIndex((e3) => 0 !== e3);
      let s2 = n2, r2 = n2;
      for (t2 = n2; t2 < 256; t2++) {
        const n3 = e2[t2];
        n3 > i2 && (t2 - s2 > a2 && (a2 = t2 - s2, r2 = t2 - 1), i2 = n3, s2 = t2);
      }
      for (t2 = r2 - 1; t2 >= 0 && !(e2[t2] > e2[t2 + 1]); t2--)
        ;
      return t2;
    }, "#Nc");
    _Lc = new WeakSet();
    Lc_fn = /* @__PURE__ */ __name(function(e2) {
      const t2 = e2, { width: i2, height: a2 } = e2, { maxDim: n2 } = __privateGet(this, _Tc);
      let s2 = i2, r2 = a2;
      if (i2 > n2 || a2 > n2) {
        let o3 = i2, l4 = a2, c2 = Math.log2(Math.max(i2, a2) / n2);
        const h2 = Math.floor(c2);
        c2 = c2 === h2 ? h2 - 1 : h2;
        for (let i3 = 0; i3 < c2; i3++) {
          s2 = Math.ceil(o3 / 2), r2 = Math.ceil(l4 / 2);
          const i4 = new OffscreenCanvas(s2, r2);
          i4.getContext("2d").drawImage(e2, 0, 0, o3, l4, 0, 0, s2, r2), o3 = s2, l4 = r2, e2 !== t2 && e2.close(), e2 = i4.transferToImageBitmap();
        }
        const d2 = Math.min(n2 / s2, n2 / r2);
        s2 = Math.round(s2 * d2), r2 = Math.round(r2 * d2);
      }
      const o2 = new OffscreenCanvas(s2, r2).getContext("2d", { willReadFrequently: true });
      o2.fillStyle = "white", o2.fillRect(0, 0, s2, r2), o2.filter = "grayscale(1)", o2.drawImage(e2, 0, 0, e2.width, e2.height, 0, 0, s2, r2);
      const l3 = o2.getImageData(0, 0, s2, r2).data;
      return [__privateMethod(this, _Bc, Bc_fn).call(this, l3), s2, r2];
    }, "#Lc");
    __privateAdd(SignatureExtractor, _Ic);
    __privateAdd(SignatureExtractor, _Mc);
    __privateAdd(SignatureExtractor, _Dc);
    __privateAdd(SignatureExtractor, _Ec);
    __privateAdd(SignatureExtractor, _Oc);
    __privateAdd(SignatureExtractor, __c);
    __privateAdd(SignatureExtractor, _Pc);
    __privateAdd(SignatureExtractor, _Rc);
    __privateAdd(SignatureExtractor, _Bc);
    __privateAdd(SignatureExtractor, _Nc);
    __privateAdd(SignatureExtractor, _Lc);
    __privateAdd(SignatureExtractor, _Tc, { maxDim: 512, sigmaSFactor: 0.02, sigmaR: 25, kernelSize: 16 });
    __privateAdd(SignatureExtractor, _Fc, new Int32Array([0, 1, -1, 1, -1, 0, -1, -1, 0, -1, 1, -1, 1, 0, 1, 1]));
    SignatureOptions = class extends DrawingOptions {
      constructor() {
        super(), super.updateProperties({ fill: AnnotationEditor._defaultLineColor, "stroke-width": 0 });
      }
      clone() {
        const e2 = new SignatureOptions();
        return e2.updateAll(this), e2;
      }
    };
    __name(SignatureOptions, "SignatureOptions");
    DrawnSignatureOptions = class extends InkDrawingOptions {
      constructor(e2) {
        super(e2), super.updateProperties({ stroke: AnnotationEditor._defaultLineColor, "stroke-width": 1 });
      }
      clone() {
        const e2 = new DrawnSignatureOptions(this._viewParameters);
        return e2.updateAll(this), e2;
      }
    };
    __name(DrawnSignatureOptions, "DrawnSignatureOptions");
    _SignatureEditor = class extends DrawingEditor {
      constructor(e2) {
        super({ ...e2, mustBeCommitted: true, name: "signatureEditor" });
        __privateAdd(this, _Uc, false);
        __privateAdd(this, _jc, null);
        __privateAdd(this, _$c, null);
        __privateAdd(this, _Hc, null);
        this._willKeepAspectRatio = true, __privateSet(this, _$c, e2.signatureData || null), __privateSet(this, _jc, null), this.defaultL10nId = "pdfjs-editor-signature-editor1";
      }
      static initialize(e2, t2) {
        AnnotationEditor.initialize(e2, t2), this._defaultDrawingOptions = new SignatureOptions(), this._defaultDrawnSignatureOptions = new DrawnSignatureOptions(t2.viewParameters);
      }
      static getDefaultDrawingOptions(e2) {
        const t2 = this._defaultDrawingOptions.clone();
        return t2.updateProperties(e2), t2;
      }
      static get supportMultipleDrawings() {
        return false;
      }
      static get typesMap() {
        return shadow(this, "typesMap", /* @__PURE__ */ new Map());
      }
      static get isDrawer() {
        return false;
      }
      get telemetryFinalData() {
        return { type: "signature", hasDescription: !!__privateGet(this, _jc) };
      }
      static computeTelemetryFinalData(e2) {
        const t2 = e2.get("hasDescription");
        return { hasAltText: t2.get(true) ?? 0, hasNoAltText: t2.get(false) ?? 0 };
      }
      get isResizable() {
        return true;
      }
      onScaleChanging() {
        null !== this._drawId && super.onScaleChanging();
      }
      render() {
        if (this.div)
          return this.div;
        let e2, t2;
        const { _isCopy: i2 } = this;
        if (i2 && (this._isCopy = false, e2 = this.x, t2 = this.y), super.render(), null === this._drawId)
          if (__privateGet(this, _$c)) {
            const { lines: e3, mustSmooth: t3, areContours: i3, description: a2, uuid: n2, heightInPage: s2 } = __privateGet(this, _$c), { rawDims: { pageWidth: r2, pageHeight: o2 }, rotation: l3 } = this.parent.viewport, c2 = SignatureExtractor.processDrawnLines({ lines: e3, pageWidth: r2, pageHeight: o2, rotation: l3, innerMargin: _SignatureEditor._INNER_MARGIN, mustSmooth: t3, areContours: i3 });
            this.addSignature(c2, s2, a2, n2);
          } else
            this.div.setAttribute("data-l10n-args", JSON.stringify({ description: "" })), this.div.hidden = true, this._uiManager.getSignature(this);
        else
          this.div.setAttribute("data-l10n-args", JSON.stringify({ description: __privateGet(this, _jc) || "" }));
        return i2 && (this._isCopy = true, this._moveAfterPaste(e2, t2)), this.div;
      }
      setUuid(e2) {
        __privateSet(this, _Hc, e2), this.addEditToolbar();
      }
      getUuid() {
        return __privateGet(this, _Hc);
      }
      get description() {
        return __privateGet(this, _jc);
      }
      set description(e2) {
        __privateSet(this, _jc, e2), this.div && (this.div.setAttribute("data-l10n-args", JSON.stringify({ description: e2 })), super.addEditToolbar().then((t2) => {
          t2?.updateEditSignatureButton(e2);
        }));
      }
      getSignaturePreview() {
        const { newCurves: e2, areContours: t2, thickness: i2, width: a2, height: n2 } = __privateGet(this, _$c), s2 = Math.max(a2, n2);
        return { areContours: t2, outline: SignatureExtractor.processDrawnLines({ lines: { curves: e2.map((e3) => ({ points: e3 })), thickness: i2, width: a2, height: n2 }, pageWidth: s2, pageHeight: s2, rotation: 0, innerMargin: 0, mustSmooth: false, areContours: t2 }).outline };
      }
      get toolbarButtons() {
        return this._uiManager.signatureManager ? [["editSignature", this._uiManager.signatureManager]] : super.toolbarButtons;
      }
      addSignature(e2, t2, i2, a2) {
        const { x: n2, y: s2 } = this, { outline: r2 } = __privateSet(this, _$c, e2);
        let o2;
        __privateSet(this, _Uc, r2 instanceof ContourDrawOutline), this.description = i2, __privateGet(this, _Uc) ? o2 = _SignatureEditor.getDefaultDrawingOptions() : (o2 = _SignatureEditor._defaultDrawnSignatureOptions.clone(), o2.updateProperties({ "stroke-width": r2.thickness })), this._addOutlines({ drawOutlines: r2, drawingOptions: o2 });
        const [l3, c2] = this.parentDimensions, [, h2] = this.pageDimensions;
        let d2 = t2 / h2;
        d2 = d2 >= 1 ? 0.5 : d2, this.width *= d2 / this.height, this.width >= 1 && (d2 *= 0.9 / this.width, this.width = 0.9), this.height = d2, this.setDims(l3 * this.width, c2 * this.height), this.x = n2, this.y = s2, this.center(), this._onResized(), this.onScaleChanging(), this.rotate(), this._uiManager.addToAnnotationStorage(this), this.setUuid(a2), this._reportTelemetry({ action: "pdfjs.signature.inserted", data: { hasBeenSaved: !!a2, hasDescription: !!i2 } }), this.div.hidden = false;
      }
      getFromImage(e2) {
        const { rawDims: { pageWidth: t2, pageHeight: i2 }, rotation: a2 } = this.parent.viewport;
        return SignatureExtractor.process(e2, t2, i2, a2, _SignatureEditor._INNER_MARGIN);
      }
      getFromText(e2, t2) {
        const { rawDims: { pageWidth: i2, pageHeight: a2 }, rotation: n2 } = this.parent.viewport;
        return SignatureExtractor.extractContoursFromText(e2, t2, i2, a2, n2, _SignatureEditor._INNER_MARGIN);
      }
      getDrawnSignature(e2) {
        const { rawDims: { pageWidth: t2, pageHeight: i2 }, rotation: a2 } = this.parent.viewport;
        return SignatureExtractor.processDrawnLines({ lines: e2, pageWidth: t2, pageHeight: i2, rotation: a2, innerMargin: _SignatureEditor._INNER_MARGIN, mustSmooth: false, areContours: false });
      }
      createDrawingOptions({ areContours: e2, thickness: t2 }) {
        e2 ? this._drawingOptions = _SignatureEditor.getDefaultDrawingOptions() : (this._drawingOptions = _SignatureEditor._defaultDrawnSignatureOptions.clone(), this._drawingOptions.updateProperties({ "stroke-width": t2 }));
      }
      serialize(e2 = false) {
        if (this.isEmpty())
          return null;
        const { lines: t2, points: i2, rect: a2 } = this.serializeDraw(e2), { _drawingOptions: { "stroke-width": n2 } } = this, s2 = { annotationType: Ll.SIGNATURE, isSignature: true, areContours: __privateGet(this, _Uc), color: [0, 0, 0], thickness: __privateGet(this, _Uc) ? 0 : n2, pageIndex: this.pageIndex, rect: a2, rotation: this.rotation, structTreeParentId: this._structTreeParentId };
        return this.addComment(s2), e2 ? (s2.paths = { lines: t2, points: i2 }, s2.uuid = __privateGet(this, _Hc), s2.isCopy = true) : s2.lines = t2, __privateGet(this, _jc) && (s2.accessibilityData = { type: "Figure", alt: __privateGet(this, _jc) }), s2;
      }
      static deserializeDraw(e2, t2, i2, a2, n2, s2) {
        return s2.areContours ? ContourDrawOutline.deserialize(e2, t2, i2, a2, n2, s2) : InkDrawOutline.deserialize(e2, t2, i2, a2, n2, s2);
      }
      static async deserialize(e2, t2, i2) {
        const a2 = await super.deserialize(e2, t2, i2);
        return __privateSet(a2, _Uc, e2.areContours), a2.description = e2.accessibilityData?.alt || "", __privateSet(a2, _Hc, e2.uuid), a2;
      }
    };
    SignatureEditor = _SignatureEditor;
    __name(SignatureEditor, "SignatureEditor");
    _Uc = new WeakMap();
    _jc = new WeakMap();
    _$c = new WeakMap();
    _Hc = new WeakMap();
    __publicField(SignatureEditor, "_type", "signature");
    __publicField(SignatureEditor, "_editorType", Ll.SIGNATURE);
    __publicField(SignatureEditor, "_defaultDrawingOptions", null);
    StampEditor = class extends AnnotationEditor {
      constructor(e2) {
        super({ ...e2, name: "stampEditor" });
        __privateAdd(this, _eh);
        __privateAdd(this, _ih);
        __privateAdd(this, _ah);
        __privateAdd(this, _th);
        __privateAdd(this, _sh);
        __privateAdd(this, _nh);
        __privateAdd(this, _rh);
        __privateAdd(this, _Xo4);
        __privateAdd(this, _qc, null);
        __privateAdd(this, _Xc, null);
        __privateAdd(this, _zc, null);
        __privateAdd(this, _Wc, null);
        __privateAdd(this, _Gc, null);
        __privateAdd(this, _Vc, "");
        __privateAdd(this, _Kc, null);
        __privateAdd(this, _Yc, false);
        __privateAdd(this, _Jc, null);
        __privateAdd(this, _Zc, false);
        __privateAdd(this, _Qc, false);
        __privateSet(this, _Wc, e2.bitmapUrl), __privateSet(this, _Gc, e2.bitmapFile), this.defaultL10nId = "pdfjs-editor-stamp-editor";
      }
      static initialize(e2, t2) {
        AnnotationEditor.initialize(e2, t2);
      }
      static isHandlingMimeForPasting(e2) {
        return fc.includes(e2);
      }
      static paste(e2, t2) {
        t2.pasteEditor({ mode: Ll.STAMP }, { bitmapFile: e2.getAsFile() });
      }
      altTextFinish() {
        this._uiManager.useNewAltTextFlow && (this.div.hidden = false), super.altTextFinish();
      }
      get telemetryFinalData() {
        return { type: "stamp", hasAltText: !!this.altTextData?.altText };
      }
      static computeTelemetryFinalData(e2) {
        const t2 = e2.get("hasAltText");
        return { hasAltText: t2.get(true) ?? 0, hasNoAltText: t2.get(false) ?? 0 };
      }
      async mlGuessAltText(e2 = null, t2 = true) {
        if (this.hasAltTextData())
          return null;
        const { mlManager: i2 } = this._uiManager;
        if (!i2)
          throw new Error("No ML.");
        if (!await i2.isEnabledFor("altText"))
          throw new Error("ML isn't enabled for alt text.");
        const { data: a2, width: n2, height: s2 } = e2 || this.copyCanvas(null, null, true).imageData, r2 = await i2.guess({ name: "altText", request: { data: a2, width: n2, height: s2, channels: a2.length / (n2 * s2) } });
        if (!r2)
          throw new Error("No response from the AI service.");
        if (r2.error)
          throw new Error("Error from the AI service.");
        if (r2.cancel)
          return null;
        if (!r2.output)
          throw new Error("No valid response from the AI service.");
        const o2 = r2.output;
        return await this.setGuessedAltText(o2), t2 && !this.hasAltTextData() && (this.altTextData = { alt: o2, decorative: false }), o2;
      }
      remove() {
        __privateGet(this, _Xc) && (__privateSet(this, _qc, null), this._uiManager.imageManager.deleteId(__privateGet(this, _Xc)), __privateGet(this, _Kc)?.remove(), __privateSet(this, _Kc, null), __privateGet(this, _Jc) && (clearTimeout(__privateGet(this, _Jc)), __privateSet(this, _Jc, null))), super.remove();
      }
      rebuild() {
        this.parent ? (super.rebuild(), null !== this.div && (__privateGet(this, _Xc) && null === __privateGet(this, _Kc) && __privateMethod(this, _ah, ah_fn).call(this), this.isAttachedToDOM || this.parent.add(this))) : __privateGet(this, _Xc) && __privateMethod(this, _ah, ah_fn).call(this);
      }
      onceAdded(e2) {
        this._isDraggable = true, e2 && this.div.focus();
      }
      isEmpty() {
        return !(__privateGet(this, _zc) || __privateGet(this, _qc) || __privateGet(this, _Wc) || __privateGet(this, _Gc) || __privateGet(this, _Xc) || __privateGet(this, _Yc));
      }
      get toolbarButtons() {
        return [["altText", this.createAltText()]];
      }
      get isResizable() {
        return true;
      }
      render() {
        if (this.div)
          return this.div;
        let e2, t2;
        return this._isCopy && (e2 = this.x, t2 = this.y), super.render(), this.div.hidden = true, this.createAltText(), __privateGet(this, _Yc) || (__privateGet(this, _qc) ? __privateMethod(this, _th, th_fn).call(this) : __privateMethod(this, _ah, ah_fn).call(this)), this._isCopy && this._moveAfterPaste(e2, t2), this._uiManager.addShouldRescale(this), this.div;
      }
      setCanvas(e2, t2) {
        const { id: i2, bitmap: a2 } = this._uiManager.imageManager.getFromCanvas(e2, t2);
        t2.remove(), i2 && this._uiManager.imageManager.isValidId(i2) && (__privateSet(this, _Xc, i2), a2 && __privateSet(this, _qc, a2), __privateSet(this, _Yc, false), __privateMethod(this, _th, th_fn).call(this));
      }
      _onResized() {
        this.onScaleChanging();
      }
      onScaleChanging() {
        if (!this.parent)
          return;
        null !== __privateGet(this, _Jc) && clearTimeout(__privateGet(this, _Jc));
        __privateSet(this, _Jc, setTimeout(() => {
          __privateSet(this, _Jc, null), __privateMethod(this, _nh, nh_fn).call(this);
        }, 200));
      }
      copyCanvas(e2, t2, i2 = false) {
        e2 || (e2 = 224);
        const { width: a2, height: n2 } = __privateGet(this, _qc), s2 = new OutputScale();
        let r2 = __privateGet(this, _qc), o2 = a2, l3 = n2, c2 = null;
        if (t2) {
          if (a2 > t2 || n2 > t2) {
            const e4 = Math.min(t2 / a2, t2 / n2);
            o2 = Math.floor(a2 * e4), l3 = Math.floor(n2 * e4);
          }
          c2 = document.createElement("canvas");
          const e3 = c2.width = Math.ceil(o2 * s2.sx), i3 = c2.height = Math.ceil(l3 * s2.sy);
          __privateGet(this, _Zc) || (r2 = __privateMethod(this, _sh, sh_fn).call(this, e3, i3));
          const h3 = c2.getContext("2d");
          h3.filter = this._uiManager.hcmFilter;
          let d2 = "white", u2 = "#cfcfd8";
          "none" !== this._uiManager.hcmFilter ? u2 = "black" : window.matchMedia?.("(prefers-color-scheme: dark)").matches && (d2 = "#8f8f9d", u2 = "#42414d");
          const g2 = 15, p2 = g2 * s2.sx, f2 = g2 * s2.sy, m2 = new OffscreenCanvas(2 * p2, 2 * f2), b2 = m2.getContext("2d");
          b2.fillStyle = d2, b2.fillRect(0, 0, 2 * p2, 2 * f2), b2.fillStyle = u2, b2.fillRect(0, 0, p2, f2), b2.fillRect(p2, f2, p2, f2), h3.fillStyle = h3.createPattern(m2, "repeat"), h3.fillRect(0, 0, e3, i3), h3.drawImage(r2, 0, 0, r2.width, r2.height, 0, 0, e3, i3);
        }
        let h2 = null;
        if (i2) {
          let t3, i3;
          if (s2.symmetric && r2.width < e2 && r2.height < e2)
            t3 = r2.width, i3 = r2.height;
          else if (r2 = __privateGet(this, _qc), a2 > e2 || n2 > e2) {
            const s3 = Math.min(e2 / a2, e2 / n2);
            t3 = Math.floor(a2 * s3), i3 = Math.floor(n2 * s3), __privateGet(this, _Zc) || (r2 = __privateMethod(this, _sh, sh_fn).call(this, t3, i3));
          }
          const o3 = new OffscreenCanvas(t3, i3).getContext("2d", { willReadFrequently: true });
          o3.drawImage(r2, 0, 0, r2.width, r2.height, 0, 0, t3, i3), h2 = { width: t3, height: i3, data: o3.getImageData(0, 0, t3, i3).data };
        }
        return { canvas: c2, width: o2, height: l3, imageData: h2 };
      }
      static async deserialize(e2, t2, i2) {
        let a2 = null, n2 = false;
        if (e2 instanceof StampAnnotationElement) {
          const { data: { rect: s3, rotation: r3, id: o3, structParent: l4, popupRef: c3, contentsObj: h3 }, container: d3, parent: { page: { pageNumber: u3 } }, canvas: g3 } = e2;
          let p2, f2;
          g3 ? (delete e2.canvas, { id: p2, bitmap: f2 } = i2.imageManager.getFromCanvas(d3.id, g3), g3.remove()) : (n2 = true, e2._hasNoCanvas = true);
          const m2 = (await t2._structTree.getAriaAttributes(`${gc}${o3}`))?.get("aria-label") || "";
          a2 = e2 = { annotationType: Ll.STAMP, bitmapId: p2, bitmap: f2, pageIndex: u3 - 1, rect: s3.slice(0), rotation: r3, annotationElementId: o3, id: o3, deleted: false, accessibilityData: { decorative: false, altText: m2 }, isSvg: false, structParent: l4, popupRef: c3, comment: h3?.str || null };
        }
        const s2 = await super.deserialize(e2, t2, i2), { rect: r2, bitmap: o2, bitmapUrl: l3, bitmapId: c2, isSvg: h2, accessibilityData: d2 } = e2;
        n2 ? (i2.addMissingCanvas(e2.id, s2), __privateSet(s2, _Yc, true)) : c2 && i2.imageManager.isValidId(c2) ? (__privateSet(s2, _Xc, c2), o2 && __privateSet(s2, _qc, o2)) : __privateSet(s2, _Wc, l3), __privateSet(s2, _Zc, h2);
        const [u2, g2] = s2.pageDimensions;
        return s2.width = (r2[2] - r2[0]) / u2, s2.height = (r2[3] - r2[1]) / g2, d2 && (s2.altTextData = d2), s2._initialData = a2, e2.comment && s2.setCommentData(e2.comment), __privateSet(s2, _Qc, !!a2), s2;
      }
      serialize(e2 = false, t2 = null) {
        if (this.isEmpty())
          return null;
        if (this.deleted)
          return this.serializeDeleted();
        const i2 = { annotationType: Ll.STAMP, bitmapId: __privateGet(this, _Xc), pageIndex: this.pageIndex, rect: this.getPDFRect(), rotation: this.rotation, isSvg: __privateGet(this, _Zc), structTreeParentId: this._structTreeParentId };
        if (this.addComment(i2), e2)
          return i2.bitmapUrl = __privateMethod(this, _rh, rh_fn).call(this, true), i2.accessibilityData = this.serializeAltText(true), i2.isCopy = true, i2;
        const { decorative: a2, altText: n2 } = this.serializeAltText(false);
        if (!a2 && n2 && (i2.accessibilityData = { type: "Figure", alt: n2 }), this.annotationElementId) {
          const e3 = __privateMethod(this, _Xo4, Xo_fn4).call(this, i2);
          if (e3.isSame)
            return null;
          e3.isSameAltText ? delete i2.accessibilityData : i2.accessibilityData.structParent = this._initialData.structParent ?? -1;
        }
        if (i2.id = this.annotationElementId, null === t2)
          return i2;
        t2.stamps ||= /* @__PURE__ */ new Map();
        const s2 = __privateGet(this, _Zc) ? (i2.rect[2] - i2.rect[0]) * (i2.rect[3] - i2.rect[1]) : null;
        if (t2.stamps.has(__privateGet(this, _Xc))) {
          if (__privateGet(this, _Zc)) {
            const e3 = t2.stamps.get(__privateGet(this, _Xc));
            s2 > e3.area && (e3.area = s2, e3.serialized.bitmap.close(), e3.serialized.bitmap = __privateMethod(this, _rh, rh_fn).call(this, false));
          }
        } else
          t2.stamps.set(__privateGet(this, _Xc), { area: s2, serialized: i2 }), i2.bitmap = __privateMethod(this, _rh, rh_fn).call(this, false);
        return i2;
      }
      renderAnnotationElement(e2) {
        if (this.deleted)
          return e2.hide(), null;
        const t2 = { rect: this.getPDFRect() };
        return this.hasEditedComment && (t2.popup = this.comment), e2.updateEdited(t2), null;
      }
    };
    __name(StampEditor, "StampEditor");
    _qc = new WeakMap();
    _Xc = new WeakMap();
    _zc = new WeakMap();
    _Wc = new WeakMap();
    _Gc = new WeakMap();
    _Vc = new WeakMap();
    _Kc = new WeakMap();
    _Yc = new WeakMap();
    _Jc = new WeakMap();
    _Zc = new WeakMap();
    _Qc = new WeakMap();
    _eh = new WeakSet();
    eh_fn = /* @__PURE__ */ __name(function(e2, t2 = false) {
      e2 ? (__privateSet(this, _qc, e2.bitmap), t2 || (__privateSet(this, _Xc, e2.id), __privateSet(this, _Zc, e2.isSvg)), e2.file && __privateSet(this, _Vc, e2.file.name), __privateMethod(this, _th, th_fn).call(this)) : this.remove();
    }, "#eh");
    _ih = new WeakSet();
    ih_fn = /* @__PURE__ */ __name(function() {
      if (__privateSet(this, _zc, null), this._uiManager.enableWaiting(false), __privateGet(this, _Kc))
        if (this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && __privateGet(this, _qc))
          this.addEditToolbar().then(() => {
            this._editToolbar.hide(), this._uiManager.editAltText(this, true);
          });
        else {
          if (!this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && __privateGet(this, _qc)) {
            this._reportTelemetry({ action: "pdfjs.image.image_added", data: { alt_text_modal: false, alt_text_type: "empty" } });
            try {
              this.mlGuessAltText();
            } catch {
            }
          }
          this.div.focus();
        }
    }, "#ih");
    _ah = new WeakSet();
    ah_fn = /* @__PURE__ */ __name(function() {
      if (__privateGet(this, _Xc))
        return this._uiManager.enableWaiting(true), void this._uiManager.imageManager.getFromId(__privateGet(this, _Xc)).then((e3) => __privateMethod(this, _eh, eh_fn).call(this, e3, true)).finally(() => __privateMethod(this, _ih, ih_fn).call(this));
      if (__privateGet(this, _Wc)) {
        const e3 = __privateGet(this, _Wc);
        return __privateSet(this, _Wc, null), this._uiManager.enableWaiting(true), void __privateSet(this, _zc, this._uiManager.imageManager.getFromUrl(e3).then((e4) => __privateMethod(this, _eh, eh_fn).call(this, e4)).finally(() => __privateMethod(this, _ih, ih_fn).call(this)));
      }
      if (__privateGet(this, _Gc)) {
        const e3 = __privateGet(this, _Gc);
        return __privateSet(this, _Gc, null), this._uiManager.enableWaiting(true), void __privateSet(this, _zc, this._uiManager.imageManager.getFromFile(e3).then((e4) => __privateMethod(this, _eh, eh_fn).call(this, e4)).finally(() => __privateMethod(this, _ih, ih_fn).call(this)));
      }
      const e2 = document.createElement("input");
      e2.type = "file", e2.accept = fc.join(",");
      const t2 = this._uiManager._signal;
      __privateSet(this, _zc, new Promise((i2) => {
        e2.addEventListener("change", async () => {
          if (e2.files && 0 !== e2.files.length) {
            this._uiManager.enableWaiting(true);
            const t3 = await this._uiManager.imageManager.getFromFile(e2.files[0]);
            this._reportTelemetry({ action: "pdfjs.image.image_selected", data: { alt_text_modal: this._uiManager.useNewAltTextFlow } }), __privateMethod(this, _eh, eh_fn).call(this, t3);
          } else
            this.remove();
          i2();
        }, { signal: t2 }), e2.addEventListener("cancel", () => {
          this.remove(), i2();
        }, { signal: t2 });
      }).finally(() => __privateMethod(this, _ih, ih_fn).call(this))), e2.click();
    }, "#ah");
    _th = new WeakSet();
    th_fn = /* @__PURE__ */ __name(function() {
      const { div: e2 } = this;
      let { width: t2, height: i2 } = __privateGet(this, _qc);
      const [a2, n2] = this.pageDimensions, s2 = 0.75;
      if (this.width)
        t2 = this.width * a2, i2 = this.height * n2;
      else if (t2 > s2 * a2 || i2 > s2 * n2) {
        const e3 = Math.min(s2 * a2 / t2, s2 * n2 / i2);
        t2 *= e3, i2 *= e3;
      }
      const [r2, o2] = this.parentDimensions;
      this.setDims(t2 * r2 / a2, i2 * o2 / n2), this._uiManager.enableWaiting(false);
      const l3 = __privateSet(this, _Kc, document.createElement("canvas"));
      l3.setAttribute("role", "img"), this.addContainer(l3), this.width = t2 / a2, this.height = i2 / n2, this._initialOptions?.isCentered ? this.center() : this.fixAndSetPosition(), this._initialOptions = null, this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && !this.annotationElementId || (e2.hidden = false), __privateMethod(this, _nh, nh_fn).call(this), __privateGet(this, _Qc) || (this.parent.addUndoableEditor(this), __privateSet(this, _Qc, true)), this._reportTelemetry({ action: "inserted_image" }), __privateGet(this, _Vc) && this.div.setAttribute("aria-description", __privateGet(this, _Vc)), this.annotationElementId || this._uiManager.a11yAlert("pdfjs-editor-stamp-added-alert");
    }, "#th");
    _sh = new WeakSet();
    sh_fn = /* @__PURE__ */ __name(function(e2, t2) {
      const { width: i2, height: a2 } = __privateGet(this, _qc);
      let n2 = i2, s2 = a2, r2 = __privateGet(this, _qc);
      for (; n2 > 2 * e2 || s2 > 2 * t2; ) {
        const i3 = n2, a3 = s2;
        n2 > 2 * e2 && (n2 = n2 >= 16384 ? Math.floor(n2 / 2) - 1 : Math.ceil(n2 / 2)), s2 > 2 * t2 && (s2 = s2 >= 16384 ? Math.floor(s2 / 2) - 1 : Math.ceil(s2 / 2));
        const o2 = new OffscreenCanvas(n2, s2);
        o2.getContext("2d").drawImage(r2, 0, 0, i3, a3, 0, 0, n2, s2), r2 = o2.transferToImageBitmap();
      }
      return r2;
    }, "#sh");
    _nh = new WeakSet();
    nh_fn = /* @__PURE__ */ __name(function() {
      const [e2, t2] = this.parentDimensions, { width: i2, height: a2 } = this, n2 = new OutputScale(), s2 = Math.ceil(i2 * e2 * n2.sx), r2 = Math.ceil(a2 * t2 * n2.sy), o2 = __privateGet(this, _Kc);
      if (!o2 || o2.width === s2 && o2.height === r2)
        return;
      o2.width = s2, o2.height = r2;
      const l3 = __privateGet(this, _Zc) ? __privateGet(this, _qc) : __privateMethod(this, _sh, sh_fn).call(this, s2, r2), c2 = o2.getContext("2d");
      c2.filter = this._uiManager.hcmFilter, c2.drawImage(l3, 0, 0, l3.width, l3.height, 0, 0, s2, r2);
    }, "#nh");
    _rh = new WeakSet();
    rh_fn = /* @__PURE__ */ __name(function(e2) {
      if (e2) {
        if (__privateGet(this, _Zc)) {
          const e4 = this._uiManager.imageManager.getSvgUrl(__privateGet(this, _Xc));
          if (e4)
            return e4;
        }
        const e3 = document.createElement("canvas");
        ({ width: e3.width, height: e3.height } = __privateGet(this, _qc));
        return e3.getContext("2d").drawImage(__privateGet(this, _qc), 0, 0), e3.toDataURL();
      }
      if (__privateGet(this, _Zc)) {
        const [e3, t2] = this.pageDimensions, i2 = Math.round(this.width * e3 * PixelsPerInch.PDF_TO_CSS_UNITS), a2 = Math.round(this.height * t2 * PixelsPerInch.PDF_TO_CSS_UNITS), n2 = new OffscreenCanvas(i2, a2);
        return n2.getContext("2d").drawImage(__privateGet(this, _qc), 0, 0, __privateGet(this, _qc).width, __privateGet(this, _qc).height, 0, 0, i2, a2), n2.transferToImageBitmap();
      }
      return structuredClone(__privateGet(this, _qc));
    }, "#rh");
    _Xo4 = new WeakSet();
    Xo_fn4 = /* @__PURE__ */ __name(function(e2) {
      const { pageIndex: t2, accessibilityData: { altText: i2 } } = this._initialData, a2 = e2.pageIndex === t2, n2 = (e2.accessibilityData?.alt || "") === i2;
      return { isSame: !this.hasEditedComment && !this._hasBeenMoved && !this._hasBeenResized && a2 && n2, isSameAltText: n2 };
    }, "#Xo");
    __publicField(StampEditor, "_type", "stamp");
    __publicField(StampEditor, "_editorType", Ll.STAMP);
    _AnnotationEditorLayer = class {
      constructor({ uiManager: e2, pageIndex: t2, div: i2, structTreeLayer: a2, accessibilityManager: n2, annotationLayer: s2, drawLayer: r2, textLayer: o2, viewport: l3, l10n: c2 }) {
        __privateAdd(this, _Sh);
        __privateAdd(this, _vh);
        __privateAdd(this, _Ch);
        __privateAdd(this, _kh);
        __privateAdd(this, _xh);
        __privateAdd(this, _Io, void 0);
        __privateAdd(this, _oh, false);
        __privateAdd(this, _lh, null);
        __privateAdd(this, _ch, null);
        __privateAdd(this, _hh, null);
        __privateAdd(this, _dh, /* @__PURE__ */ new Map());
        __privateAdd(this, _uh, false);
        __privateAdd(this, _gh, false);
        __privateAdd(this, _ph, false);
        __privateAdd(this, _fh, null);
        __privateAdd(this, _mh, null);
        __privateAdd(this, _bh, null);
        __privateAdd(this, _yh, null);
        __privateAdd(this, _wh, null);
        __privateAdd(this, _Ah, -1);
        __privateAdd(this, _mt3, void 0);
        const h2 = [...__privateGet(_AnnotationEditorLayer, _Xt2).values()];
        if (!_AnnotationEditorLayer._initialized) {
          _AnnotationEditorLayer._initialized = true;
          for (const t3 of h2)
            t3.initialize(c2, e2);
        }
        e2.registerEditorTypes(h2), __privateSet(this, _mt3, e2), this.pageIndex = t2, this.div = i2, __privateSet(this, _Io, n2), __privateSet(this, _lh, s2), this.viewport = l3, __privateSet(this, _bh, o2), this.drawLayer = r2, this._structTree = a2, __privateGet(this, _mt3).addLayer(this);
      }
      get isEmpty() {
        return 0 === __privateGet(this, _dh).size;
      }
      get isInvisible() {
        return this.isEmpty && __privateGet(this, _mt3).getMode() === Ll.NONE;
      }
      updateToolbar(e2) {
        __privateGet(this, _mt3).updateToolbar(e2);
      }
      updateMode(e2 = __privateGet(this, _mt3).getMode()) {
        switch (__privateMethod(this, _xh, xh_fn).call(this), e2) {
          case Ll.NONE:
            return this.disableTextSelection(), this.togglePointerEvents(false), this.toggleAnnotationLayerPointerEvents(true), void this.disableClick();
          case Ll.INK:
            this.disableTextSelection(), this.togglePointerEvents(true), this.enableClick();
            break;
          case Ll.HIGHLIGHT:
            this.enableTextSelection(), this.togglePointerEvents(false), this.disableClick();
            break;
          default:
            this.disableTextSelection(), this.togglePointerEvents(true), this.enableClick();
        }
        this.toggleAnnotationLayerPointerEvents(false);
        const { classList: t2 } = this.div;
        for (const i2 of __privateGet(_AnnotationEditorLayer, _Xt2).values())
          t2.toggle(`${i2._type}Editing`, e2 === i2._editorType);
        this.div.hidden = false;
      }
      hasTextLayer(e2) {
        return e2 === __privateGet(this, _bh)?.div;
      }
      setEditingState(e2) {
        __privateGet(this, _mt3).setEditingState(e2);
      }
      addCommands(e2) {
        __privateGet(this, _mt3).addCommands(e2);
      }
      cleanUndoStack(e2) {
        __privateGet(this, _mt3).cleanUndoStack(e2);
      }
      toggleDrawing(e2 = false) {
        this.div.classList.toggle("drawing", !e2);
      }
      togglePointerEvents(e2 = false) {
        this.div.classList.toggle("disabled", !e2);
      }
      toggleAnnotationLayerPointerEvents(e2 = false) {
        __privateGet(this, _lh)?.div.classList.toggle("disabled", !e2);
      }
      async enable() {
        __privateSet(this, _ph, true), this.div.tabIndex = 0, this.togglePointerEvents(true), __privateGet(this, _wh)?.abort(), __privateSet(this, _wh, null);
        const e2 = /* @__PURE__ */ new Set();
        for (const t3 of __privateGet(this, _dh).values())
          t3.enableEditing(), t3.show(true), t3.annotationElementId && (__privateGet(this, _mt3).removeChangedExistingAnnotation(t3), e2.add(t3.annotationElementId));
        if (!__privateGet(this, _lh))
          return void __privateSet(this, _ph, false);
        const t2 = __privateGet(this, _lh).getEditableAnnotations();
        for (const i2 of t2) {
          if (i2.hide(), __privateGet(this, _mt3).isDeletedAnnotationElement(i2.data.id))
            continue;
          if (e2.has(i2.data.id))
            continue;
          const t3 = await this.deserialize(i2);
          t3 && (this.addOrRebuild(t3), t3.enableEditing());
        }
        __privateSet(this, _ph, false);
      }
      disable() {
        if (__privateSet(this, _gh, true), this.div.tabIndex = -1, this.togglePointerEvents(false), __privateGet(this, _bh) && !__privateGet(this, _wh)) {
          __privateSet(this, _wh, new AbortController());
          const e3 = __privateGet(this, _mt3).combinedSignal(__privateGet(this, _wh));
          __privateGet(this, _bh).div.addEventListener("pointerdown", (e4) => {
            const { clientX: t3, clientY: i3, timeStamp: a2 } = e4;
            if (a2 - __privateGet(this, _Ah) > 500)
              return void __privateSet(this, _Ah, a2);
            __privateSet(this, _Ah, -1);
            const { classList: n2 } = this.div;
            n2.toggle("getElements", true);
            const s2 = document.elementsFromPoint(t3, i3);
            if (n2.toggle("getElements", false), !this.div.contains(s2[0]))
              return;
            let r2;
            const o2 = new RegExp(`^${Nl}[0-9]+$`);
            for (const e5 of s2)
              if (o2.test(e5.id)) {
                r2 = e5.id;
                break;
              }
            if (!r2)
              return;
            const l3 = __privateGet(this, _dh).get(r2);
            null === l3?.annotationElementId && (e4.stopPropagation(), e4.preventDefault(), l3.dblclick());
          }, { signal: e3, capture: true });
        }
        const e2 = /* @__PURE__ */ new Map(), t2 = /* @__PURE__ */ new Map();
        for (const i3 of __privateGet(this, _dh).values())
          i3.disableEditing(), i3.annotationElementId && (null === i3.serialize() ? (t2.set(i3.annotationElementId, i3), this.getEditableAnnotation(i3.annotationElementId)?.show(), i3.remove()) : e2.set(i3.annotationElementId, i3));
        if (__privateGet(this, _lh)) {
          const i3 = __privateGet(this, _lh).getEditableAnnotations();
          for (const a2 of i3) {
            const { id: i4 } = a2.data;
            if (__privateGet(this, _mt3).isDeletedAnnotationElement(i4)) {
              a2.updateEdited({ deleted: true });
              continue;
            }
            let n2 = t2.get(i4);
            n2 ? (n2.resetAnnotationElement(a2), n2.show(false), a2.show()) : (n2 = e2.get(i4), n2 && (__privateGet(this, _mt3).addChangedExistingAnnotation(n2), n2.renderAnnotationElement(a2) && n2.show(false)), a2.show());
          }
        }
        __privateMethod(this, _xh, xh_fn).call(this), this.isEmpty && (this.div.hidden = true);
        const { classList: i2 } = this.div;
        for (const e3 of __privateGet(_AnnotationEditorLayer, _Xt2).values())
          i2.remove(`${e3._type}Editing`);
        this.disableTextSelection(), this.toggleAnnotationLayerPointerEvents(true), __privateSet(this, _gh, false);
      }
      getEditableAnnotation(e2) {
        return __privateGet(this, _lh)?.getEditableAnnotation(e2) || null;
      }
      setActiveEditor(e2) {
        __privateGet(this, _mt3).getActive() !== e2 && __privateGet(this, _mt3).setActiveEditor(e2);
      }
      enableTextSelection() {
        if (this.div.tabIndex = -1, __privateGet(this, _bh)?.div && !__privateGet(this, _yh)) {
          __privateSet(this, _yh, new AbortController());
          const e2 = __privateGet(this, _mt3).combinedSignal(__privateGet(this, _yh));
          __privateGet(this, _bh).div.addEventListener("pointerdown", __privateMethod(this, _Sh, Sh_fn).bind(this), { signal: e2 }), __privateGet(this, _bh).div.classList.add("highlighting");
        }
      }
      disableTextSelection() {
        this.div.tabIndex = 0, __privateGet(this, _bh)?.div && __privateGet(this, _yh) && (__privateGet(this, _yh).abort(), __privateSet(this, _yh, null), __privateGet(this, _bh).div.classList.remove("highlighting"));
      }
      enableClick() {
        if (__privateGet(this, _ch))
          return;
        __privateSet(this, _ch, new AbortController());
        const e2 = __privateGet(this, _mt3).combinedSignal(__privateGet(this, _ch));
        this.div.addEventListener("pointerdown", this.pointerdown.bind(this), { signal: e2 });
        const t2 = this.pointerup.bind(this);
        this.div.addEventListener("pointerup", t2, { signal: e2 }), this.div.addEventListener("pointercancel", t2, { signal: e2 });
      }
      disableClick() {
        __privateGet(this, _ch)?.abort(), __privateSet(this, _ch, null);
      }
      attach(e2) {
        __privateGet(this, _dh).set(e2.id, e2);
        const { annotationElementId: t2 } = e2;
        t2 && __privateGet(this, _mt3).isDeletedAnnotationElement(t2) && __privateGet(this, _mt3).removeDeletedAnnotationElement(e2);
      }
      detach(e2) {
        __privateGet(this, _dh).delete(e2.id), __privateGet(this, _Io)?.removePointerInTextLayer(e2.contentDiv), !__privateGet(this, _gh) && e2.annotationElementId && __privateGet(this, _mt3).addDeletedAnnotationElement(e2);
      }
      remove(e2) {
        this.detach(e2), __privateGet(this, _mt3).removeEditor(e2), e2.div.remove(), e2.isAttachedToDOM = false;
      }
      changeParent(e2) {
        e2.parent !== this && (e2.parent && e2.annotationElementId && (__privateGet(this, _mt3).addDeletedAnnotationElement(e2.annotationElementId), AnnotationEditor.deleteAnnotationElement(e2), e2.annotationElementId = null), this.attach(e2), e2.parent?.detach(e2), e2.setParent(this), e2.div && e2.isAttachedToDOM && (e2.div.remove(), this.div.append(e2.div)));
      }
      add(e2) {
        if (e2.parent !== this || !e2.isAttachedToDOM) {
          if (this.changeParent(e2), __privateGet(this, _mt3).addEditor(e2), this.attach(e2), !e2.isAttachedToDOM) {
            const t2 = e2.render();
            this.div.append(t2), e2.isAttachedToDOM = true;
          }
          e2.fixAndSetPosition(), e2.onceAdded(!__privateGet(this, _ph)), __privateGet(this, _mt3).addToAnnotationStorage(e2), e2._reportTelemetry(e2.telemetryInitialData);
        }
      }
      moveEditorInDOM(e2) {
        if (!e2.isAttachedToDOM)
          return;
        const { activeElement: t2 } = document;
        e2.div.contains(t2) && !__privateGet(this, _hh) && (e2._focusEventsAllowed = false, __privateSet(this, _hh, setTimeout(() => {
          __privateSet(this, _hh, null), e2.div.contains(document.activeElement) ? e2._focusEventsAllowed = true : (e2.div.addEventListener("focusin", () => {
            e2._focusEventsAllowed = true;
          }, { once: true, signal: __privateGet(this, _mt3)._signal }), t2.focus());
        }, 0))), e2._structTreeParentId = __privateGet(this, _Io)?.moveElementInDOM(this.div, e2.div, e2.contentDiv, true);
      }
      addOrRebuild(e2) {
        e2.needsToBeRebuilt() ? (e2.parent ||= this, e2.rebuild(), e2.show()) : this.add(e2);
      }
      addUndoableEditor(e2) {
        this.addCommands({ cmd: () => e2._uiManager.rebuild(e2), undo: () => {
          e2.remove();
        }, mustExec: false });
      }
      getNextId() {
        return __privateGet(this, _mt3).getId();
      }
      combinedSignal(e2) {
        return __privateGet(this, _mt3).combinedSignal(e2);
      }
      canCreateNewEmptyEditor() {
        return __privateGet(this, _vh, vh_get)?.canCreateNewEmptyEditor();
      }
      async pasteEditor(e2, t2) {
        this.updateToolbar(e2), await __privateGet(this, _mt3).updateMode(e2.mode);
        const { offsetX: i2, offsetY: a2 } = __privateMethod(this, _kh, kh_fn).call(this), n2 = this.getNextId(), s2 = __privateMethod(this, _Ch, Ch_fn).call(this, { parent: this, id: n2, x: i2, y: a2, uiManager: __privateGet(this, _mt3), isCentered: true, ...t2 });
        s2 && this.add(s2);
      }
      async deserialize(e2) {
        return await __privateGet(_AnnotationEditorLayer, _Xt2).get(e2.annotationType ?? e2.annotationEditorType)?.deserialize(e2, this, __privateGet(this, _mt3)) || null;
      }
      createAndAddNewEditor(e2, t2, i2 = {}) {
        const a2 = this.getNextId(), n2 = __privateMethod(this, _Ch, Ch_fn).call(this, { parent: this, id: a2, x: e2.offsetX, y: e2.offsetY, uiManager: __privateGet(this, _mt3), isCentered: t2, ...i2 });
        return n2 && this.add(n2), n2;
      }
      addNewEditor(e2 = {}) {
        this.createAndAddNewEditor(__privateMethod(this, _kh, kh_fn).call(this), true, e2);
      }
      setSelected(e2) {
        __privateGet(this, _mt3).setSelected(e2);
      }
      toggleSelected(e2) {
        __privateGet(this, _mt3).toggleSelected(e2);
      }
      unselect(e2) {
        __privateGet(this, _mt3).unselect(e2);
      }
      pointerup(e2) {
        const { isMac: t2 } = util_FeatureTest.platform;
        if (0 !== e2.button || e2.ctrlKey && t2)
          return;
        if (e2.target !== this.div)
          return;
        if (!__privateGet(this, _uh))
          return;
        if (__privateSet(this, _uh, false), __privateGet(this, _vh, vh_get)?.isDrawer && __privateGet(this, _vh, vh_get).supportMultipleDrawings)
          return;
        if (!__privateGet(this, _oh))
          return void __privateSet(this, _oh, true);
        const i2 = __privateGet(this, _mt3).getMode();
        i2 !== Ll.STAMP && i2 !== Ll.SIGNATURE ? this.createAndAddNewEditor(e2, false) : __privateGet(this, _mt3).unselectAll();
      }
      pointerdown(e2) {
        if (__privateGet(this, _mt3).getMode() === Ll.HIGHLIGHT && this.enableTextSelection(), __privateGet(this, _uh))
          return void __privateSet(this, _uh, false);
        const { isMac: t2 } = util_FeatureTest.platform;
        if (0 !== e2.button || e2.ctrlKey && t2)
          return;
        if (e2.target !== this.div)
          return;
        if (__privateSet(this, _uh, true), __privateGet(this, _vh, vh_get)?.isDrawer)
          return void this.startDrawingSession(e2);
        const i2 = __privateGet(this, _mt3).getActive();
        __privateSet(this, _oh, !i2 || i2.isEmpty());
      }
      startDrawingSession(e2) {
        if (this.div.focus({ preventScroll: true }), __privateGet(this, _fh))
          return void __privateGet(this, _vh, vh_get).startDrawing(this, __privateGet(this, _mt3), false, e2);
        __privateGet(this, _mt3).setCurrentDrawingSession(this), __privateSet(this, _fh, new AbortController());
        const t2 = __privateGet(this, _mt3).combinedSignal(__privateGet(this, _fh));
        this.div.addEventListener("blur", ({ relatedTarget: e3 }) => {
          e3 && !this.div.contains(e3) && (__privateSet(this, _mh, null), this.commitOrRemove());
        }, { signal: t2 }), __privateGet(this, _vh, vh_get).startDrawing(this, __privateGet(this, _mt3), false, e2);
      }
      pause(e2) {
        if (e2) {
          const { activeElement: e3 } = document;
          return void (this.div.contains(e3) && __privateSet(this, _mh, e3));
        }
        __privateGet(this, _mh) && setTimeout(() => {
          __privateGet(this, _mh)?.focus(), __privateSet(this, _mh, null);
        }, 0);
      }
      endDrawingSession(e2 = false) {
        return __privateGet(this, _fh) ? (__privateGet(this, _mt3).setCurrentDrawingSession(null), __privateGet(this, _fh).abort(), __privateSet(this, _fh, null), __privateSet(this, _mh, null), __privateGet(this, _vh, vh_get).endDrawing(e2)) : null;
      }
      findNewParent(e2, t2, i2) {
        const a2 = __privateGet(this, _mt3).findParent(t2, i2);
        return null !== a2 && a2 !== this && (a2.changeParent(e2), true);
      }
      commitOrRemove() {
        return !!__privateGet(this, _fh) && (this.endDrawingSession(), true);
      }
      onScaleChanging() {
        __privateGet(this, _fh) && __privateGet(this, _vh, vh_get).onScaleChangingWhenDrawing(this);
      }
      destroy() {
        this.commitOrRemove(), __privateGet(this, _mt3).getActive()?.parent === this && (__privateGet(this, _mt3).commitOrRemove(), __privateGet(this, _mt3).setActiveEditor(null)), __privateGet(this, _hh) && (clearTimeout(__privateGet(this, _hh)), __privateSet(this, _hh, null));
        for (const e2 of __privateGet(this, _dh).values())
          __privateGet(this, _Io)?.removePointerInTextLayer(e2.contentDiv), e2.setParent(null), e2.isAttachedToDOM = false, e2.div.remove();
        this.div = null, __privateGet(this, _dh).clear(), __privateGet(this, _mt3).removeLayer(this);
      }
      render({ viewport: e2 }) {
        this.viewport = e2, setLayerDimensions(this.div, e2);
        for (const e3 of __privateGet(this, _mt3).getEditors(this.pageIndex))
          this.add(e3), e3.rebuild();
        this.updateMode();
      }
      update({ viewport: e2 }) {
        __privateGet(this, _mt3).commitOrRemove(), __privateMethod(this, _xh, xh_fn).call(this);
        const t2 = this.viewport.rotation, i2 = e2.rotation;
        if (this.viewport = e2, setLayerDimensions(this.div, { rotation: i2 }), t2 !== i2)
          for (const e3 of __privateGet(this, _dh).values())
            e3.rotate(i2);
      }
      get pageDimensions() {
        const { pageWidth: e2, pageHeight: t2 } = this.viewport.rawDims;
        return [e2, t2];
      }
      get scale() {
        return __privateGet(this, _mt3).viewParameters.realScale;
      }
    };
    AnnotationEditorLayer = _AnnotationEditorLayer;
    __name(AnnotationEditorLayer, "AnnotationEditorLayer");
    _Io = new WeakMap();
    _oh = new WeakMap();
    _lh = new WeakMap();
    _ch = new WeakMap();
    _hh = new WeakMap();
    _dh = new WeakMap();
    _uh = new WeakMap();
    _gh = new WeakMap();
    _ph = new WeakMap();
    _fh = new WeakMap();
    _mh = new WeakMap();
    _bh = new WeakMap();
    _yh = new WeakMap();
    _wh = new WeakMap();
    _Ah = new WeakMap();
    _mt3 = new WeakMap();
    _Xt2 = new WeakMap();
    _Sh = new WeakSet();
    Sh_fn = /* @__PURE__ */ __name(function(e2) {
      __privateGet(this, _mt3).unselectAll();
      const { target: t2 } = e2;
      if (t2 === __privateGet(this, _bh).div || ("img" === t2.getAttribute("role") || t2.classList.contains("endOfContent")) && __privateGet(this, _bh).div.contains(t2)) {
        const { isMac: t3 } = util_FeatureTest.platform;
        if (0 !== e2.button || e2.ctrlKey && t3)
          return;
        __privateGet(this, _mt3).showAllEditors("highlight", true, true), __privateGet(this, _bh).div.classList.add("free"), this.toggleDrawing(), HighlightEditor.startHighlighting(this, "ltr" === __privateGet(this, _mt3).direction, { target: __privateGet(this, _bh).div, x: e2.x, y: e2.y }), __privateGet(this, _bh).div.addEventListener("pointerup", () => {
          __privateGet(this, _bh).div.classList.remove("free"), this.toggleDrawing(true);
        }, { once: true, signal: __privateGet(this, _mt3)._signal }), e2.preventDefault();
      }
    }, "#Sh");
    _vh = new WeakSet();
    vh_get = /* @__PURE__ */ __name(function() {
      return __privateGet(_AnnotationEditorLayer, _Xt2).get(__privateGet(this, _mt3).getMode());
    }, "#vh");
    _Ch = new WeakSet();
    Ch_fn = /* @__PURE__ */ __name(function(e2) {
      const t2 = __privateGet(this, _vh, vh_get);
      return t2 ? new t2.prototype.constructor(e2) : null;
    }, "#Ch");
    _kh = new WeakSet();
    kh_fn = /* @__PURE__ */ __name(function() {
      const { x: e2, y: t2, width: i2, height: a2 } = this.div.getBoundingClientRect(), n2 = Math.max(0, e2), s2 = Math.max(0, t2), r2 = (n2 + Math.min(window.innerWidth, e2 + i2)) / 2 - e2, o2 = (s2 + Math.min(window.innerHeight, t2 + a2)) / 2 - t2, [l3, c2] = this.viewport.rotation % 180 == 0 ? [r2, o2] : [o2, r2];
      return { offsetX: l3, offsetY: c2 };
    }, "#kh");
    _xh = new WeakSet();
    xh_fn = /* @__PURE__ */ __name(function() {
      for (const e2 of __privateGet(this, _dh).values())
        e2.isEmpty() && e2.remove();
    }, "#xh");
    __publicField(AnnotationEditorLayer, "_initialized", false);
    __privateAdd(AnnotationEditorLayer, _Xt2, new Map([FreeTextEditor, InkEditor, StampEditor, HighlightEditor, SignatureEditor].map((e2) => [e2._editorType, e2])));
    _DrawLayer = class {
      constructor({ pageIndex: e2 }) {
        __privateAdd(this, _Mh);
        __privateAdd(this, _Dh);
        __privateAdd(this, _Eh);
        __privateAdd(this, _Qr, null);
        __privateAdd(this, _Th, /* @__PURE__ */ new Map());
        __privateAdd(this, _Ih, /* @__PURE__ */ new Map());
        this.pageIndex = e2;
      }
      setParent(e2) {
        if (__privateGet(this, _Qr)) {
          if (__privateGet(this, _Qr) !== e2) {
            if (__privateGet(this, _Th).size > 0)
              for (const t2 of __privateGet(this, _Th).values())
                t2.remove(), e2.append(t2);
            __privateSet(this, _Qr, e2);
          }
        } else
          __privateSet(this, _Qr, e2);
      }
      static get _svgFactory() {
        return shadow(this, "_svgFactory", new DOMSVGFactory());
      }
      draw(e2, t2 = false, i2 = false) {
        const a2 = __privateWrapper(_DrawLayer, _At2)._++, n2 = __privateMethod(this, _Mh, Mh_fn).call(this), s2 = _DrawLayer._svgFactory.createElement("defs");
        n2.append(s2);
        const r2 = _DrawLayer._svgFactory.createElement("path");
        s2.append(r2);
        const o2 = `path_p${this.pageIndex}_${a2}`;
        r2.setAttribute("id", o2), r2.setAttribute("vector-effect", "non-scaling-stroke"), t2 && __privateGet(this, _Ih).set(a2, r2);
        const l3 = i2 ? __privateMethod(this, _Dh, Dh_fn).call(this, s2, o2) : null, c2 = _DrawLayer._svgFactory.createElement("use");
        return n2.append(c2), c2.setAttribute("href", `#${o2}`), this.updateProperties(n2, e2), __privateGet(this, _Th).set(a2, n2), { id: a2, clipPathId: `url(#${l3})` };
      }
      drawOutline(e2, t2) {
        const i2 = __privateWrapper(_DrawLayer, _At2)._++, a2 = __privateMethod(this, _Mh, Mh_fn).call(this), n2 = _DrawLayer._svgFactory.createElement("defs");
        a2.append(n2);
        const s2 = _DrawLayer._svgFactory.createElement("path");
        n2.append(s2);
        const r2 = `path_p${this.pageIndex}_${i2}`;
        let o2;
        if (s2.setAttribute("id", r2), s2.setAttribute("vector-effect", "non-scaling-stroke"), t2) {
          const e3 = _DrawLayer._svgFactory.createElement("mask");
          n2.append(e3), o2 = `mask_p${this.pageIndex}_${i2}`, e3.setAttribute("id", o2), e3.setAttribute("maskUnits", "objectBoundingBox");
          const t3 = _DrawLayer._svgFactory.createElement("rect");
          e3.append(t3), t3.setAttribute("width", "1"), t3.setAttribute("height", "1"), t3.setAttribute("fill", "white");
          const a3 = _DrawLayer._svgFactory.createElement("use");
          e3.append(a3), a3.setAttribute("href", `#${r2}`), a3.setAttribute("stroke", "none"), a3.setAttribute("fill", "black"), a3.setAttribute("fill-rule", "nonzero"), a3.classList.add("mask");
        }
        const l3 = _DrawLayer._svgFactory.createElement("use");
        a2.append(l3), l3.setAttribute("href", `#${r2}`), o2 && l3.setAttribute("mask", `url(#${o2})`);
        const c2 = l3.cloneNode();
        return a2.append(c2), l3.classList.add("mainOutline"), c2.classList.add("secondaryOutline"), this.updateProperties(a2, e2), __privateGet(this, _Th).set(i2, a2), i2;
      }
      finalizeDraw(e2, t2) {
        __privateGet(this, _Ih).delete(e2), this.updateProperties(e2, t2);
      }
      updateProperties(e2, t2) {
        var _a4;
        if (!t2)
          return;
        const { root: i2, bbox: a2, rootClass: n2, path: s2 } = t2, r2 = "number" == typeof e2 ? __privateGet(this, _Th).get(e2) : e2;
        if (r2) {
          if (i2 && __privateMethod(this, _Eh, Eh_fn).call(this, r2, i2), a2 && __privateMethod(_a4 = _DrawLayer, _Fh, Fh_fn).call(_a4, r2, a2), n2) {
            const { classList: e3 } = r2;
            for (const [t3, i3] of Object.entries(n2))
              e3.toggle(t3, i3);
          }
          if (s2) {
            const e3 = r2.firstChild.firstChild;
            __privateMethod(this, _Eh, Eh_fn).call(this, e3, s2);
          }
        }
      }
      updateParent(e2, t2) {
        if (t2 === this)
          return;
        const i2 = __privateGet(this, _Th).get(e2);
        i2 && (__privateGet(t2, _Qr).append(i2), __privateGet(this, _Th).delete(e2), __privateGet(t2, _Th).set(e2, i2));
      }
      remove(e2) {
        __privateGet(this, _Ih).delete(e2), null !== __privateGet(this, _Qr) && (__privateGet(this, _Th).get(e2).remove(), __privateGet(this, _Th).delete(e2));
      }
      destroy() {
        __privateSet(this, _Qr, null);
        for (const e2 of __privateGet(this, _Th).values())
          e2.remove();
        __privateGet(this, _Th).clear(), __privateGet(this, _Ih).clear();
      }
    };
    DrawLayer = _DrawLayer;
    __name(DrawLayer, "DrawLayer");
    _Qr = new WeakMap();
    _Th = new WeakMap();
    _Ih = new WeakMap();
    _At2 = new WeakMap();
    _Fh = new WeakSet();
    Fh_fn = /* @__PURE__ */ __name(function(e2, [t2, i2, a2, n2]) {
      const { style: s2 } = e2;
      s2.top = 100 * i2 + "%", s2.left = 100 * t2 + "%", s2.width = 100 * a2 + "%", s2.height = 100 * n2 + "%";
    }, "#Fh");
    _Mh = new WeakSet();
    Mh_fn = /* @__PURE__ */ __name(function() {
      const e2 = _DrawLayer._svgFactory.create(1, 1, true);
      return __privateGet(this, _Qr).append(e2), e2.setAttribute("aria-hidden", true), e2;
    }, "#Mh");
    _Dh = new WeakSet();
    Dh_fn = /* @__PURE__ */ __name(function(e2, t2) {
      const i2 = _DrawLayer._svgFactory.createElement("clipPath");
      e2.append(i2);
      const a2 = `clip_${t2}`;
      i2.setAttribute("id", a2), i2.setAttribute("clipPathUnits", "objectBoundingBox");
      const n2 = _DrawLayer._svgFactory.createElement("use");
      return i2.append(n2), n2.setAttribute("href", `#${t2}`), n2.classList.add("clip"), a2;
    }, "#Dh");
    _Eh = new WeakSet();
    Eh_fn = /* @__PURE__ */ __name(function(e2, t2) {
      for (const [i2, a2] of Object.entries(t2))
        null === a2 ? e2.removeAttribute(i2) : e2.setAttribute(i2, a2);
    }, "#Eh");
    __privateAdd(DrawLayer, _Fh);
    __privateAdd(DrawLayer, _At2, 0);
    globalThis._pdfjsTestingUtils = { HighlightOutliner }, globalThis.pdfjsLib = { AbortException, AnnotationEditorLayer, AnnotationEditorParamsType: jl, AnnotationEditorType: Ll, AnnotationEditorUIManager, AnnotationLayer, AnnotationMode: Bl, AnnotationType: Kl, build: ih, ColorPicker, createValidAbsoluteUrl, DOMSVGFactory, DrawLayer, FeatureTest: util_FeatureTest, fetchData, getDocument, getFilenameFromUrl, getPdfFilenameFromUrl, getRGB, getUuid, getXfaPageViewport, GlobalWorkerOptions, ImageKind: Vl, InvalidPDFException, isDataScheme, isPdfFile, isValidExplicitDest: Ac, MathClamp, noContextMenu, normalizeUnicode, OPS: ic, OutputScale, PasswordResponses: oc, PDFDataRangeTransport, PDFDateString, PDFWorker, PermissionFlag: $l, PixelsPerInch, RenderingCancelledException, ResponseException, setLayerDimensions, shadow, SignatureExtractor, stopEvent, SupportedImageMimeTypes: fc, TextLayer, TouchManager, updateUrlHash, Util, VerbosityLevel: tc, version: th, XfaLayer };
  }
});

// node_modules/unpdf/dist/index.mjs
var dist_exports = {};
__export(dist_exports, {
  configureUnPDF: () => configureUnPDF,
  definePDFJSModule: () => definePDFJSModule,
  extractImages: () => extractImages,
  extractLinks: () => extractLinks,
  extractText: () => extractText,
  getDocumentProxy: () => getDocumentProxy,
  getMeta: () => getMeta,
  getResolvedPDFJS: () => getResolvedPDFJS,
  renderPageAsImage: () => renderPageAsImage,
  resolvePDFJSImport: () => resolvePDFJSImport
});
async function getDocumentProxy(data, options = {}) {
  const { getDocument: getDocument2 } = await getResolvedPDFJS();
  const pdf = await getDocument2({
    data,
    isEvalSupported: false,
    // See: https://github.com/mozilla/pdf.js/issues/4244#issuecomment-1479534301
    useSystemFonts: true,
    ...options
  }).promise;
  return pdf;
}
async function getResolvedPDFJS() {
  if (!resolvedModule) {
    await resolvePDFJSImport();
  }
  return resolvedModule;
}
async function resolvePDFJSImport(pdfjsResolver, { reload = false } = {}) {
  if (resolvedModule && !reload) {
    return;
  }
  if (pdfjsResolver) {
    try {
      resolvedModule = await interopDefault(pdfjsResolver());
      return;
    } catch (error3) {
      throw new Error(`PDF.js could not be resolved: ${error3}`);
    }
  }
  try {
    resolvedModule = await Promise.resolve().then(() => (init_pdfjs(), pdfjs_exports));
  } catch (error3) {
    throw new Error(`Serverless PDF.js bundle could not be resolved: ${error3}`);
  }
}
function isPDFDocumentProxy(data) {
  return typeof data === "object" && data !== null && "_pdfInfo" in data;
}
async function interopDefault(m2) {
  const resolved = await m2;
  return resolved.default || resolved;
}
async function resolveCanvasModule(canvasImport) {
  resolvedCanvasModule ??= await interopDefault(canvasImport());
}
function injectCanvasConstructors() {
  if (!resolvedCanvasModule)
    return;
  if (typeof globalThis.DOMMatrix === "undefined")
    globalThis.DOMMatrix = resolvedCanvasModule.DOMMatrix;
  if (typeof globalThis.ImageData === "undefined")
    globalThis.ImageData = resolvedCanvasModule.ImageData;
  if (typeof globalThis.Path2D === "undefined")
    globalThis.Path2D = resolvedCanvasModule.Path2D;
}
async function extractImages$1(data, pageNumber) {
  const pdf = isPDFDocumentProxy(data) ? data : await getDocumentProxy(data);
  if (pageNumber < 1 || pageNumber > pdf.numPages) {
    throw new Error(`Invalid page number. Must be between 1 and ${pdf.numPages}.`);
  }
  const page = await pdf.getPage(pageNumber);
  const operatorList = await page.getOperatorList();
  const { OPS } = await getResolvedPDFJS();
  const images = [];
  for (let i2 = 0; i2 < operatorList.fnArray.length; i2++) {
    const op = operatorList.fnArray[i2];
    if (op !== OPS.paintImageXObject) {
      continue;
    }
    const imageKey = operatorList.argsArray[i2][0];
    const image = imageKey.startsWith("g_") ? await new Promise((resolve) => page.commonObjs.get(imageKey, (resolvedImage) => resolve(resolvedImage))) : await new Promise((resolve) => page.objs.get(imageKey, (resolvedImage) => resolve(resolvedImage)));
    if (!image || !image.data || !image.width || !image.height) {
      continue;
    }
    const { width, height, data: data2 } = image;
    const calculatedChannels = data2.length / (width * height);
    if (![1, 3, 4].includes(calculatedChannels)) {
      continue;
    }
    const channels = calculatedChannels;
    images.push({
      data: data2,
      width,
      height,
      channels,
      key: imageKey
    });
  }
  return images;
}
async function renderPageAsImage$1(data, pageNumber, options = {}) {
  const CanvasFactory = await createIsomorphicCanvasFactory(options.canvasImport);
  const pdf = isPDFDocumentProxy(data) ? data : await getDocumentProxy(data, { CanvasFactory });
  const page = await pdf.getPage(pageNumber);
  if (pageNumber < 1 || pageNumber > pdf.numPages) {
    throw new Error(`Invalid page number. Must be between 1 and ${pdf.numPages}.`);
  }
  const defaultViewport = page.getViewport({ scale: 1 });
  let scale = options.scale || 1;
  if (options.width) {
    scale = options.width / defaultViewport.width;
  } else if (options.height) {
    scale = options.height / defaultViewport.height;
  }
  const viewport = page.getViewport({ scale: Math.max(0, scale) });
  const drawingContext = new CanvasFactory().create(viewport.width, viewport.height);
  await page.render({
    canvas: drawingContext.canvas,
    canvasContext: drawingContext.context,
    viewport
  }).promise;
  const dataUrl = drawingContext.canvas.toDataURL();
  if (options.toDataURL) {
    return dataUrl;
  }
  const response = await fetch(dataUrl);
  return await response.arrayBuffer();
}
async function createIsomorphicCanvasFactory(canvasImport) {
  if (isBrowser)
    return DOMCanvasFactory2;
  if (isNode2) {
    if (!canvasImport) {
      throw new Error('Parameter "canvasImport" is required in Node.js environment.');
    }
    await resolveCanvasModule(canvasImport);
    injectCanvasConstructors();
    return NodeCanvasFactory2;
  }
  throw new Error("Unsupported environment for canvas creation.");
}
async function extractLinks$1(data) {
  const pdf = isPDFDocumentProxy(data) ? data : await getDocumentProxy(data);
  const pageLinks = await Promise.all(
    Array.from({ length: pdf.numPages }, (_2, i2) => getPageLinks(pdf, i2 + 1))
  );
  return {
    totalPages: pdf.numPages,
    links: pageLinks.flat()
  };
}
async function getPageLinks(document2, pageNumber) {
  const page = await document2.getPage(pageNumber);
  const annotations = await page.getAnnotations();
  const links = [];
  for (const annotation of annotations) {
    if (annotation.subtype === "Link" && annotation.url) {
      links.push(annotation.url);
    }
  }
  return links;
}
async function getMeta$1(data, options = {}) {
  const pdf = isPDFDocumentProxy(data) ? data : await getDocumentProxy(data);
  const meta = await pdf.getMetadata();
  const info4 = meta?.info || {};
  if (options.parseDates) {
    const { PDFDateString: PDFDateString2 } = await getResolvedPDFJS();
    if (info4?.CreationDate) {
      info4.CreationDate = PDFDateString2.toDateObject(info4?.CreationDate);
    }
    if (info4?.ModDate) {
      info4.ModDate = PDFDateString2.toDateObject(info4?.ModDate);
    }
    if (meta.metadata) {
      meta.metadata = new Proxy(meta.metadata, {
        get(target, prop) {
          if (prop === "get") {
            return (name) => {
              const value = target.get(name);
              if (XMP_DATE_PROPERTIES.includes(name) && value) {
                return parseISODateString(value);
              }
              return value;
            };
          }
          return target[prop];
        }
      });
    }
  }
  return {
    info: info4,
    metadata: meta?.metadata || {}
  };
}
function parseISODateString(isoDateString) {
  if (!isoDateString)
    return;
  const parsedDate = Date.parse(isoDateString);
  if (!Number.isNaN(parsedDate)) {
    return new Date(parsedDate);
  }
}
async function extractText$1(data, options = {}) {
  const { mergePages = false } = options;
  const pdf = isPDFDocumentProxy(data) ? data : await getDocumentProxy(data);
  const texts = await Promise.all(
    Array.from({ length: pdf.numPages }, (_2, i2) => getPageText(pdf, i2 + 1))
  );
  return {
    totalPages: pdf.numPages,
    text: mergePages ? texts.join("\n").replace(/\s+/g, " ") : texts
  };
}
async function getPageText(document2, pageNumber) {
  const page = await document2.getPage(pageNumber);
  const content = await page.getTextContent();
  return content.items.filter((item) => item.str != null).map((item) => item.str + (item.hasEOL ? "\n" : "")).join("");
}
async function definePDFJSModule(pdfjs) {
  await resolvePDFJSImport(pdfjs, { reload: true });
}
async function configureUnPDF(options) {
  await resolvePDFJSImport(options.pdfjs, { reload: true });
}
var resolvedModule, isNode2, isBrowser, resolvedCanvasModule, BaseCanvasFactory2, DOMCanvasFactory2, NodeCanvasFactory2, XMP_DATE_PROPERTIES, getMeta, extractText, extractImages, renderPageAsImage, extractLinks;
var init_dist = __esm({
  "node_modules/unpdf/dist/index.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    isNode2 = globalThis.process?.release?.name === "node";
    isBrowser = typeof window !== "undefined";
    __name(getDocumentProxy, "getDocumentProxy");
    __name(getResolvedPDFJS, "getResolvedPDFJS");
    __name(resolvePDFJSImport, "resolvePDFJSImport");
    __name(isPDFDocumentProxy, "isPDFDocumentProxy");
    __name(interopDefault, "interopDefault");
    BaseCanvasFactory2 = class {
      #enableHWA = false;
      constructor({ enableHWA = false } = {}) {
        this.#enableHWA = enableHWA;
      }
      create(width, height) {
        const canvas = this._createCanvas(width, height);
        return {
          canvas,
          context: canvas.getContext("2d", {
            willReadFrequently: !this.#enableHWA
          })
        };
      }
      reset({ canvas }, width, height) {
        if (!canvas) {
          throw new Error("Canvas is not specified");
        }
        canvas.width = width;
        canvas.height = height;
      }
      destroy(context2) {
        if (!context2.canvas) {
          throw new Error("Canvas is not specified");
        }
        context2.canvas.width = 0;
        context2.canvas.height = 0;
        context2.canvas = void 0;
        context2.context = void 0;
      }
      // eslint-disable-next-line unused-imports/no-unused-vars
      _createCanvas(width, height) {
        throw new Error("Not implemented");
      }
    };
    __name(BaseCanvasFactory2, "BaseCanvasFactory");
    DOMCanvasFactory2 = class extends BaseCanvasFactory2 {
      _document;
      constructor({ ownerDocument = globalThis.document, enableHWA = false } = {}) {
        super({ enableHWA });
        this._document = ownerDocument;
      }
      _createCanvas(width, height) {
        const canvas = this._document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        return canvas;
      }
    };
    __name(DOMCanvasFactory2, "DOMCanvasFactory");
    NodeCanvasFactory2 = class extends BaseCanvasFactory2 {
      constructor({ enableHWA = false } = {}) {
        super({ enableHWA });
      }
      _createCanvas(width, height) {
        if (!resolvedCanvasModule) {
          throw new Error("@napi-rs/canvas module is not resolved");
        }
        return resolvedCanvasModule.createCanvas(width, height);
      }
    };
    __name(NodeCanvasFactory2, "NodeCanvasFactory");
    __name(resolveCanvasModule, "resolveCanvasModule");
    __name(injectCanvasConstructors, "injectCanvasConstructors");
    __name(extractImages$1, "extractImages$1");
    __name(renderPageAsImage$1, "renderPageAsImage$1");
    __name(createIsomorphicCanvasFactory, "createIsomorphicCanvasFactory");
    __name(extractLinks$1, "extractLinks$1");
    __name(getPageLinks, "getPageLinks");
    XMP_DATE_PROPERTIES = [
      "xmp:createdate",
      "xmp:modifydate",
      "xmp:metadatadate",
      "xap:createdate",
      "xap:modifydate",
      "xap:metadatadate"
    ];
    __name(getMeta$1, "getMeta$1");
    __name(parseISODateString, "parseISODateString");
    __name(extractText$1, "extractText$1");
    __name(getPageText, "getPageText");
    __name(definePDFJSModule, "definePDFJSModule");
    __name(configureUnPDF, "configureUnPDF");
    getMeta = /* @__PURE__ */ __name(async (...args) => {
      await resolvePDFJSImport();
      return await getMeta$1(...args);
    }, "getMeta");
    extractText = /* @__PURE__ */ __name(async (...args) => {
      await resolvePDFJSImport();
      return await extractText$1(...args);
    }, "extractText");
    extractImages = /* @__PURE__ */ __name(async (...args) => {
      await resolvePDFJSImport();
      return await extractImages$1(...args);
    }, "extractImages");
    renderPageAsImage = /* @__PURE__ */ __name(async (...args) => {
      await resolvePDFJSImport();
      return await renderPageAsImage$1(...args);
    }, "renderPageAsImage");
    extractLinks = /* @__PURE__ */ __name(async (...args) => {
      await resolvePDFJSImport();
      return await extractLinks$1(...args);
    }, "extractLinks");
  }
});

// node_modules/underscore/underscore-umd.js
var require_underscore_umd = __commonJS({
  "node_modules/underscore/underscore-umd.js"(exports2, module2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define("underscore", factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, function() {
        var current = global2._;
        var exports3 = global2._ = factory();
        exports3.noConflict = function() {
          global2._ = current;
          return exports3;
        };
      }());
    })(exports2, function() {
      var VERSION = "1.13.7";
      var root = typeof self == "object" && self.self === self && self || typeof global == "object" && global.global === global && global || Function("return this")() || {};
      var ArrayProto = Array.prototype, ObjProto = Object.prototype;
      var SymbolProto = typeof Symbol !== "undefined" ? Symbol.prototype : null;
      var push = ArrayProto.push, slice = ArrayProto.slice, toString = ObjProto.toString, hasOwnProperty = ObjProto.hasOwnProperty;
      var supportsArrayBuffer = typeof ArrayBuffer !== "undefined", supportsDataView = typeof DataView !== "undefined";
      var nativeIsArray = Array.isArray, nativeKeys = Object.keys, nativeCreate = Object.create, nativeIsView = supportsArrayBuffer && ArrayBuffer.isView;
      var _isNaN = isNaN, _isFinite = isFinite;
      var hasEnumBug = !{ toString: null }.propertyIsEnumerable("toString");
      var nonEnumerableProps = [
        "valueOf",
        "isPrototypeOf",
        "toString",
        "propertyIsEnumerable",
        "hasOwnProperty",
        "toLocaleString"
      ];
      var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
      function restArguments(func, startIndex) {
        startIndex = startIndex == null ? func.length - 1 : +startIndex;
        return function() {
          var length = Math.max(arguments.length - startIndex, 0), rest2 = Array(length), index = 0;
          for (; index < length; index++) {
            rest2[index] = arguments[index + startIndex];
          }
          switch (startIndex) {
            case 0:
              return func.call(this, rest2);
            case 1:
              return func.call(this, arguments[0], rest2);
            case 2:
              return func.call(this, arguments[0], arguments[1], rest2);
          }
          var args = Array(startIndex + 1);
          for (index = 0; index < startIndex; index++) {
            args[index] = arguments[index];
          }
          args[startIndex] = rest2;
          return func.apply(this, args);
        };
      }
      __name(restArguments, "restArguments");
      function isObject2(obj2) {
        var type = typeof obj2;
        return type === "function" || type === "object" && !!obj2;
      }
      __name(isObject2, "isObject");
      function isNull(obj2) {
        return obj2 === null;
      }
      __name(isNull, "isNull");
      function isUndefined(obj2) {
        return obj2 === void 0;
      }
      __name(isUndefined, "isUndefined");
      function isBoolean(obj2) {
        return obj2 === true || obj2 === false || toString.call(obj2) === "[object Boolean]";
      }
      __name(isBoolean, "isBoolean");
      function isElement(obj2) {
        return !!(obj2 && obj2.nodeType === 1);
      }
      __name(isElement, "isElement");
      function tagTester(name) {
        var tag = "[object " + name + "]";
        return function(obj2) {
          return toString.call(obj2) === tag;
        };
      }
      __name(tagTester, "tagTester");
      var isString = tagTester("String");
      var isNumber = tagTester("Number");
      var isDate = tagTester("Date");
      var isRegExp = tagTester("RegExp");
      var isError2 = tagTester("Error");
      var isSymbol = tagTester("Symbol");
      var isArrayBuffer = tagTester("ArrayBuffer");
      var isFunction = tagTester("Function");
      var nodelist = root.document && root.document.childNodes;
      if (typeof /./ != "function" && typeof Int8Array != "object" && typeof nodelist != "function") {
        isFunction = /* @__PURE__ */ __name(function(obj2) {
          return typeof obj2 == "function" || false;
        }, "isFunction");
      }
      var isFunction$1 = isFunction;
      var hasObjectTag = tagTester("Object");
      var hasDataViewBug = supportsDataView && (!/\[native code\]/.test(String(DataView)) || hasObjectTag(new DataView(new ArrayBuffer(8)))), isIE11 = typeof Map !== "undefined" && hasObjectTag(/* @__PURE__ */ new Map());
      var isDataView = tagTester("DataView");
      function alternateIsDataView(obj2) {
        return obj2 != null && isFunction$1(obj2.getInt8) && isArrayBuffer(obj2.buffer);
      }
      __name(alternateIsDataView, "alternateIsDataView");
      var isDataView$1 = hasDataViewBug ? alternateIsDataView : isDataView;
      var isArray = nativeIsArray || tagTester("Array");
      function has$1(obj2, key) {
        return obj2 != null && hasOwnProperty.call(obj2, key);
      }
      __name(has$1, "has$1");
      var isArguments = tagTester("Arguments");
      (function() {
        if (!isArguments(arguments)) {
          isArguments = /* @__PURE__ */ __name(function(obj2) {
            return has$1(obj2, "callee");
          }, "isArguments");
        }
      })();
      var isArguments$1 = isArguments;
      function isFinite$1(obj2) {
        return !isSymbol(obj2) && _isFinite(obj2) && !isNaN(parseFloat(obj2));
      }
      __name(isFinite$1, "isFinite$1");
      function isNaN$1(obj2) {
        return isNumber(obj2) && _isNaN(obj2);
      }
      __name(isNaN$1, "isNaN$1");
      function constant(value) {
        return function() {
          return value;
        };
      }
      __name(constant, "constant");
      function createSizePropertyCheck(getSizeProperty) {
        return function(collection) {
          var sizeProperty = getSizeProperty(collection);
          return typeof sizeProperty == "number" && sizeProperty >= 0 && sizeProperty <= MAX_ARRAY_INDEX;
        };
      }
      __name(createSizePropertyCheck, "createSizePropertyCheck");
      function shallowProperty(key) {
        return function(obj2) {
          return obj2 == null ? void 0 : obj2[key];
        };
      }
      __name(shallowProperty, "shallowProperty");
      var getByteLength = shallowProperty("byteLength");
      var isBufferLike = createSizePropertyCheck(getByteLength);
      var typedArrayPattern = /\[object ((I|Ui)nt(8|16|32)|Float(32|64)|Uint8Clamped|Big(I|Ui)nt64)Array\]/;
      function isTypedArray(obj2) {
        return nativeIsView ? nativeIsView(obj2) && !isDataView$1(obj2) : isBufferLike(obj2) && typedArrayPattern.test(toString.call(obj2));
      }
      __name(isTypedArray, "isTypedArray");
      var isTypedArray$1 = supportsArrayBuffer ? isTypedArray : constant(false);
      var getLength = shallowProperty("length");
      function emulatedSet(keys2) {
        var hash = {};
        for (var l3 = keys2.length, i2 = 0; i2 < l3; ++i2)
          hash[keys2[i2]] = true;
        return {
          contains: function(key) {
            return hash[key] === true;
          },
          push: function(key) {
            hash[key] = true;
            return keys2.push(key);
          }
        };
      }
      __name(emulatedSet, "emulatedSet");
      function collectNonEnumProps(obj2, keys2) {
        keys2 = emulatedSet(keys2);
        var nonEnumIdx = nonEnumerableProps.length;
        var constructor = obj2.constructor;
        var proto = isFunction$1(constructor) && constructor.prototype || ObjProto;
        var prop = "constructor";
        if (has$1(obj2, prop) && !keys2.contains(prop))
          keys2.push(prop);
        while (nonEnumIdx--) {
          prop = nonEnumerableProps[nonEnumIdx];
          if (prop in obj2 && obj2[prop] !== proto[prop] && !keys2.contains(prop)) {
            keys2.push(prop);
          }
        }
      }
      __name(collectNonEnumProps, "collectNonEnumProps");
      function keys(obj2) {
        if (!isObject2(obj2))
          return [];
        if (nativeKeys)
          return nativeKeys(obj2);
        var keys2 = [];
        for (var key in obj2)
          if (has$1(obj2, key))
            keys2.push(key);
        if (hasEnumBug)
          collectNonEnumProps(obj2, keys2);
        return keys2;
      }
      __name(keys, "keys");
      function isEmpty(obj2) {
        if (obj2 == null)
          return true;
        var length = getLength(obj2);
        if (typeof length == "number" && (isArray(obj2) || isString(obj2) || isArguments$1(obj2)))
          return length === 0;
        return getLength(keys(obj2)) === 0;
      }
      __name(isEmpty, "isEmpty");
      function isMatch(object2, attrs) {
        var _keys = keys(attrs), length = _keys.length;
        if (object2 == null)
          return !length;
        var obj2 = Object(object2);
        for (var i2 = 0; i2 < length; i2++) {
          var key = _keys[i2];
          if (attrs[key] !== obj2[key] || !(key in obj2))
            return false;
        }
        return true;
      }
      __name(isMatch, "isMatch");
      function _$1(obj2) {
        if (obj2 instanceof _$1)
          return obj2;
        if (!(this instanceof _$1))
          return new _$1(obj2);
        this._wrapped = obj2;
      }
      __name(_$1, "_$1");
      _$1.VERSION = VERSION;
      _$1.prototype.value = function() {
        return this._wrapped;
      };
      _$1.prototype.valueOf = _$1.prototype.toJSON = _$1.prototype.value;
      _$1.prototype.toString = function() {
        return String(this._wrapped);
      };
      function toBufferView(bufferSource) {
        return new Uint8Array(
          bufferSource.buffer || bufferSource,
          bufferSource.byteOffset || 0,
          getByteLength(bufferSource)
        );
      }
      __name(toBufferView, "toBufferView");
      var tagDataView = "[object DataView]";
      function eq(a2, b2, aStack, bStack) {
        if (a2 === b2)
          return a2 !== 0 || 1 / a2 === 1 / b2;
        if (a2 == null || b2 == null)
          return false;
        if (a2 !== a2)
          return b2 !== b2;
        var type = typeof a2;
        if (type !== "function" && type !== "object" && typeof b2 != "object")
          return false;
        return deepEq(a2, b2, aStack, bStack);
      }
      __name(eq, "eq");
      function deepEq(a2, b2, aStack, bStack) {
        if (a2 instanceof _$1)
          a2 = a2._wrapped;
        if (b2 instanceof _$1)
          b2 = b2._wrapped;
        var className = toString.call(a2);
        if (className !== toString.call(b2))
          return false;
        if (hasDataViewBug && className == "[object Object]" && isDataView$1(a2)) {
          if (!isDataView$1(b2))
            return false;
          className = tagDataView;
        }
        switch (className) {
          case "[object RegExp]":
          case "[object String]":
            return "" + a2 === "" + b2;
          case "[object Number]":
            if (+a2 !== +a2)
              return +b2 !== +b2;
            return +a2 === 0 ? 1 / +a2 === 1 / b2 : +a2 === +b2;
          case "[object Date]":
          case "[object Boolean]":
            return +a2 === +b2;
          case "[object Symbol]":
            return SymbolProto.valueOf.call(a2) === SymbolProto.valueOf.call(b2);
          case "[object ArrayBuffer]":
          case tagDataView:
            return deepEq(toBufferView(a2), toBufferView(b2), aStack, bStack);
        }
        var areArrays = className === "[object Array]";
        if (!areArrays && isTypedArray$1(a2)) {
          var byteLength = getByteLength(a2);
          if (byteLength !== getByteLength(b2))
            return false;
          if (a2.buffer === b2.buffer && a2.byteOffset === b2.byteOffset)
            return true;
          areArrays = true;
        }
        if (!areArrays) {
          if (typeof a2 != "object" || typeof b2 != "object")
            return false;
          var aCtor = a2.constructor, bCtor = b2.constructor;
          if (aCtor !== bCtor && !(isFunction$1(aCtor) && aCtor instanceof aCtor && isFunction$1(bCtor) && bCtor instanceof bCtor) && ("constructor" in a2 && "constructor" in b2)) {
            return false;
          }
        }
        aStack = aStack || [];
        bStack = bStack || [];
        var length = aStack.length;
        while (length--) {
          if (aStack[length] === a2)
            return bStack[length] === b2;
        }
        aStack.push(a2);
        bStack.push(b2);
        if (areArrays) {
          length = a2.length;
          if (length !== b2.length)
            return false;
          while (length--) {
            if (!eq(a2[length], b2[length], aStack, bStack))
              return false;
          }
        } else {
          var _keys = keys(a2), key;
          length = _keys.length;
          if (keys(b2).length !== length)
            return false;
          while (length--) {
            key = _keys[length];
            if (!(has$1(b2, key) && eq(a2[key], b2[key], aStack, bStack)))
              return false;
          }
        }
        aStack.pop();
        bStack.pop();
        return true;
      }
      __name(deepEq, "deepEq");
      function isEqual(a2, b2) {
        return eq(a2, b2);
      }
      __name(isEqual, "isEqual");
      function allKeys(obj2) {
        if (!isObject2(obj2))
          return [];
        var keys2 = [];
        for (var key in obj2)
          keys2.push(key);
        if (hasEnumBug)
          collectNonEnumProps(obj2, keys2);
        return keys2;
      }
      __name(allKeys, "allKeys");
      function ie11fingerprint(methods) {
        var length = getLength(methods);
        return function(obj2) {
          if (obj2 == null)
            return false;
          var keys2 = allKeys(obj2);
          if (getLength(keys2))
            return false;
          for (var i2 = 0; i2 < length; i2++) {
            if (!isFunction$1(obj2[methods[i2]]))
              return false;
          }
          return methods !== weakMapMethods || !isFunction$1(obj2[forEachName]);
        };
      }
      __name(ie11fingerprint, "ie11fingerprint");
      var forEachName = "forEach", hasName = "has", commonInit = ["clear", "delete"], mapTail = ["get", hasName, "set"];
      var mapMethods = commonInit.concat(forEachName, mapTail), weakMapMethods = commonInit.concat(mapTail), setMethods = ["add"].concat(commonInit, forEachName, hasName);
      var isMap = isIE11 ? ie11fingerprint(mapMethods) : tagTester("Map");
      var isWeakMap = isIE11 ? ie11fingerprint(weakMapMethods) : tagTester("WeakMap");
      var isSet = isIE11 ? ie11fingerprint(setMethods) : tagTester("Set");
      var isWeakSet = tagTester("WeakSet");
      function values(obj2) {
        var _keys = keys(obj2);
        var length = _keys.length;
        var values2 = Array(length);
        for (var i2 = 0; i2 < length; i2++) {
          values2[i2] = obj2[_keys[i2]];
        }
        return values2;
      }
      __name(values, "values");
      function pairs(obj2) {
        var _keys = keys(obj2);
        var length = _keys.length;
        var pairs2 = Array(length);
        for (var i2 = 0; i2 < length; i2++) {
          pairs2[i2] = [_keys[i2], obj2[_keys[i2]]];
        }
        return pairs2;
      }
      __name(pairs, "pairs");
      function invert(obj2) {
        var result2 = {};
        var _keys = keys(obj2);
        for (var i2 = 0, length = _keys.length; i2 < length; i2++) {
          result2[obj2[_keys[i2]]] = _keys[i2];
        }
        return result2;
      }
      __name(invert, "invert");
      function functions(obj2) {
        var names = [];
        for (var key in obj2) {
          if (isFunction$1(obj2[key]))
            names.push(key);
        }
        return names.sort();
      }
      __name(functions, "functions");
      function createAssigner(keysFunc, defaults2) {
        return function(obj2) {
          var length = arguments.length;
          if (defaults2)
            obj2 = Object(obj2);
          if (length < 2 || obj2 == null)
            return obj2;
          for (var index = 1; index < length; index++) {
            var source = arguments[index], keys2 = keysFunc(source), l3 = keys2.length;
            for (var i2 = 0; i2 < l3; i2++) {
              var key = keys2[i2];
              if (!defaults2 || obj2[key] === void 0)
                obj2[key] = source[key];
            }
          }
          return obj2;
        };
      }
      __name(createAssigner, "createAssigner");
      var extend = createAssigner(allKeys);
      var extendOwn = createAssigner(keys);
      var defaults = createAssigner(allKeys, true);
      function ctor() {
        return function() {
        };
      }
      __name(ctor, "ctor");
      function baseCreate(prototype) {
        if (!isObject2(prototype))
          return {};
        if (nativeCreate)
          return nativeCreate(prototype);
        var Ctor = ctor();
        Ctor.prototype = prototype;
        var result2 = new Ctor();
        Ctor.prototype = null;
        return result2;
      }
      __name(baseCreate, "baseCreate");
      function create(prototype, props) {
        var result2 = baseCreate(prototype);
        if (props)
          extendOwn(result2, props);
        return result2;
      }
      __name(create, "create");
      function clone(obj2) {
        if (!isObject2(obj2))
          return obj2;
        return isArray(obj2) ? obj2.slice() : extend({}, obj2);
      }
      __name(clone, "clone");
      function tap(obj2, interceptor) {
        interceptor(obj2);
        return obj2;
      }
      __name(tap, "tap");
      function toPath$1(path) {
        return isArray(path) ? path : [path];
      }
      __name(toPath$1, "toPath$1");
      _$1.toPath = toPath$1;
      function toPath(path) {
        return _$1.toPath(path);
      }
      __name(toPath, "toPath");
      function deepGet(obj2, path) {
        var length = path.length;
        for (var i2 = 0; i2 < length; i2++) {
          if (obj2 == null)
            return void 0;
          obj2 = obj2[path[i2]];
        }
        return length ? obj2 : void 0;
      }
      __name(deepGet, "deepGet");
      function get(object2, path, defaultValue) {
        var value = deepGet(object2, toPath(path));
        return isUndefined(value) ? defaultValue : value;
      }
      __name(get, "get");
      function has(obj2, path) {
        path = toPath(path);
        var length = path.length;
        for (var i2 = 0; i2 < length; i2++) {
          var key = path[i2];
          if (!has$1(obj2, key))
            return false;
          obj2 = obj2[key];
        }
        return !!length;
      }
      __name(has, "has");
      function identity(value) {
        return value;
      }
      __name(identity, "identity");
      function matcher(attrs) {
        attrs = extendOwn({}, attrs);
        return function(obj2) {
          return isMatch(obj2, attrs);
        };
      }
      __name(matcher, "matcher");
      function property(path) {
        path = toPath(path);
        return function(obj2) {
          return deepGet(obj2, path);
        };
      }
      __name(property, "property");
      function optimizeCb(func, context2, argCount) {
        if (context2 === void 0)
          return func;
        switch (argCount == null ? 3 : argCount) {
          case 1:
            return function(value) {
              return func.call(context2, value);
            };
          case 3:
            return function(value, index, collection) {
              return func.call(context2, value, index, collection);
            };
          case 4:
            return function(accumulator, value, index, collection) {
              return func.call(context2, accumulator, value, index, collection);
            };
        }
        return function() {
          return func.apply(context2, arguments);
        };
      }
      __name(optimizeCb, "optimizeCb");
      function baseIteratee(value, context2, argCount) {
        if (value == null)
          return identity;
        if (isFunction$1(value))
          return optimizeCb(value, context2, argCount);
        if (isObject2(value) && !isArray(value))
          return matcher(value);
        return property(value);
      }
      __name(baseIteratee, "baseIteratee");
      function iteratee(value, context2) {
        return baseIteratee(value, context2, Infinity);
      }
      __name(iteratee, "iteratee");
      _$1.iteratee = iteratee;
      function cb(value, context2, argCount) {
        if (_$1.iteratee !== iteratee)
          return _$1.iteratee(value, context2);
        return baseIteratee(value, context2, argCount);
      }
      __name(cb, "cb");
      function mapObject(obj2, iteratee2, context2) {
        iteratee2 = cb(iteratee2, context2);
        var _keys = keys(obj2), length = _keys.length, results = {};
        for (var index = 0; index < length; index++) {
          var currentKey = _keys[index];
          results[currentKey] = iteratee2(obj2[currentKey], currentKey, obj2);
        }
        return results;
      }
      __name(mapObject, "mapObject");
      function noop() {
      }
      __name(noop, "noop");
      function propertyOf(obj2) {
        if (obj2 == null)
          return noop;
        return function(path) {
          return get(obj2, path);
        };
      }
      __name(propertyOf, "propertyOf");
      function times(n2, iteratee2, context2) {
        var accum = Array(Math.max(0, n2));
        iteratee2 = optimizeCb(iteratee2, context2, 1);
        for (var i2 = 0; i2 < n2; i2++)
          accum[i2] = iteratee2(i2);
        return accum;
      }
      __name(times, "times");
      function random(min2, max2) {
        if (max2 == null) {
          max2 = min2;
          min2 = 0;
        }
        return min2 + Math.floor(Math.random() * (max2 - min2 + 1));
      }
      __name(random, "random");
      var now = Date.now || function() {
        return (/* @__PURE__ */ new Date()).getTime();
      };
      function createEscaper(map2) {
        var escaper = /* @__PURE__ */ __name(function(match) {
          return map2[match];
        }, "escaper");
        var source = "(?:" + keys(map2).join("|") + ")";
        var testRegexp = RegExp(source);
        var replaceRegexp = RegExp(source, "g");
        return function(string) {
          string = string == null ? "" : "" + string;
          return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
        };
      }
      __name(createEscaper, "createEscaper");
      var escapeMap = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#x27;",
        "`": "&#x60;"
      };
      var _escape = createEscaper(escapeMap);
      var unescapeMap = invert(escapeMap);
      var _unescape = createEscaper(unescapeMap);
      var templateSettings = _$1.templateSettings = {
        evaluate: /<%([\s\S]+?)%>/g,
        interpolate: /<%=([\s\S]+?)%>/g,
        escape: /<%-([\s\S]+?)%>/g
      };
      var noMatch = /(.)^/;
      var escapes = {
        "'": "'",
        "\\": "\\",
        "\r": "r",
        "\n": "n",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;
      function escapeChar(match) {
        return "\\" + escapes[match];
      }
      __name(escapeChar, "escapeChar");
      var bareIdentifier = /^\s*(\w|\$)+\s*$/;
      function template(text, settings, oldSettings) {
        if (!settings && oldSettings)
          settings = oldSettings;
        settings = defaults({}, settings, _$1.templateSettings);
        var matcher2 = RegExp([
          (settings.escape || noMatch).source,
          (settings.interpolate || noMatch).source,
          (settings.evaluate || noMatch).source
        ].join("|") + "|$", "g");
        var index = 0;
        var source = "__p+='";
        text.replace(matcher2, function(match, escape2, interpolate, evaluate, offset) {
          source += text.slice(index, offset).replace(escapeRegExp, escapeChar);
          index = offset + match.length;
          if (escape2) {
            source += "'+\n((__t=(" + escape2 + "))==null?'':_.escape(__t))+\n'";
          } else if (interpolate) {
            source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
          } else if (evaluate) {
            source += "';\n" + evaluate + "\n__p+='";
          }
          return match;
        });
        source += "';\n";
        var argument = settings.variable;
        if (argument) {
          if (!bareIdentifier.test(argument))
            throw new Error(
              "variable is not a bare identifier: " + argument
            );
        } else {
          source = "with(obj||{}){\n" + source + "}\n";
          argument = "obj";
        }
        source = "var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n" + source + "return __p;\n";
        var render;
        try {
          render = new Function(argument, "_", source);
        } catch (e2) {
          e2.source = source;
          throw e2;
        }
        var template2 = /* @__PURE__ */ __name(function(data) {
          return render.call(this, data, _$1);
        }, "template");
        template2.source = "function(" + argument + "){\n" + source + "}";
        return template2;
      }
      __name(template, "template");
      function result(obj2, path, fallback) {
        path = toPath(path);
        var length = path.length;
        if (!length) {
          return isFunction$1(fallback) ? fallback.call(obj2) : fallback;
        }
        for (var i2 = 0; i2 < length; i2++) {
          var prop = obj2 == null ? void 0 : obj2[path[i2]];
          if (prop === void 0) {
            prop = fallback;
            i2 = length;
          }
          obj2 = isFunction$1(prop) ? prop.call(obj2) : prop;
        }
        return obj2;
      }
      __name(result, "result");
      var idCounter = 0;
      function uniqueId(prefix) {
        var id = ++idCounter + "";
        return prefix ? prefix + id : id;
      }
      __name(uniqueId, "uniqueId");
      function chain(obj2) {
        var instance = _$1(obj2);
        instance._chain = true;
        return instance;
      }
      __name(chain, "chain");
      function executeBound(sourceFunc, boundFunc, context2, callingContext, args) {
        if (!(callingContext instanceof boundFunc))
          return sourceFunc.apply(context2, args);
        var self2 = baseCreate(sourceFunc.prototype);
        var result2 = sourceFunc.apply(self2, args);
        if (isObject2(result2))
          return result2;
        return self2;
      }
      __name(executeBound, "executeBound");
      var partial = restArguments(function(func, boundArgs) {
        var placeholder = partial.placeholder;
        var bound = /* @__PURE__ */ __name(function() {
          var position = 0, length = boundArgs.length;
          var args = Array(length);
          for (var i2 = 0; i2 < length; i2++) {
            args[i2] = boundArgs[i2] === placeholder ? arguments[position++] : boundArgs[i2];
          }
          while (position < arguments.length)
            args.push(arguments[position++]);
          return executeBound(func, bound, this, this, args);
        }, "bound");
        return bound;
      });
      partial.placeholder = _$1;
      var bind = restArguments(function(func, context2, args) {
        if (!isFunction$1(func))
          throw new TypeError("Bind must be called on a function");
        var bound = restArguments(function(callArgs) {
          return executeBound(func, bound, context2, this, args.concat(callArgs));
        });
        return bound;
      });
      var isArrayLike = createSizePropertyCheck(getLength);
      function flatten$1(input, depth, strict, output) {
        output = output || [];
        if (!depth && depth !== 0) {
          depth = Infinity;
        } else if (depth <= 0) {
          return output.concat(input);
        }
        var idx = output.length;
        for (var i2 = 0, length = getLength(input); i2 < length; i2++) {
          var value = input[i2];
          if (isArrayLike(value) && (isArray(value) || isArguments$1(value))) {
            if (depth > 1) {
              flatten$1(value, depth - 1, strict, output);
              idx = output.length;
            } else {
              var j2 = 0, len = value.length;
              while (j2 < len)
                output[idx++] = value[j2++];
            }
          } else if (!strict) {
            output[idx++] = value;
          }
        }
        return output;
      }
      __name(flatten$1, "flatten$1");
      var bindAll = restArguments(function(obj2, keys2) {
        keys2 = flatten$1(keys2, false, false);
        var index = keys2.length;
        if (index < 1)
          throw new Error("bindAll must be passed function names");
        while (index--) {
          var key = keys2[index];
          obj2[key] = bind(obj2[key], obj2);
        }
        return obj2;
      });
      function memoize(func, hasher) {
        var memoize2 = /* @__PURE__ */ __name(function(key) {
          var cache = memoize2.cache;
          var address = "" + (hasher ? hasher.apply(this, arguments) : key);
          if (!has$1(cache, address))
            cache[address] = func.apply(this, arguments);
          return cache[address];
        }, "memoize");
        memoize2.cache = {};
        return memoize2;
      }
      __name(memoize, "memoize");
      var delay = restArguments(function(func, wait, args) {
        return setTimeout(function() {
          return func.apply(null, args);
        }, wait);
      });
      var defer = partial(delay, _$1, 1);
      function throttle(func, wait, options) {
        var timeout, context2, args, result2;
        var previous = 0;
        if (!options)
          options = {};
        var later = /* @__PURE__ */ __name(function() {
          previous = options.leading === false ? 0 : now();
          timeout = null;
          result2 = func.apply(context2, args);
          if (!timeout)
            context2 = args = null;
        }, "later");
        var throttled = /* @__PURE__ */ __name(function() {
          var _now = now();
          if (!previous && options.leading === false)
            previous = _now;
          var remaining = wait - (_now - previous);
          context2 = this;
          args = arguments;
          if (remaining <= 0 || remaining > wait) {
            if (timeout) {
              clearTimeout(timeout);
              timeout = null;
            }
            previous = _now;
            result2 = func.apply(context2, args);
            if (!timeout)
              context2 = args = null;
          } else if (!timeout && options.trailing !== false) {
            timeout = setTimeout(later, remaining);
          }
          return result2;
        }, "throttled");
        throttled.cancel = function() {
          clearTimeout(timeout);
          previous = 0;
          timeout = context2 = args = null;
        };
        return throttled;
      }
      __name(throttle, "throttle");
      function debounce(func, wait, immediate) {
        var timeout, previous, args, result2, context2;
        var later = /* @__PURE__ */ __name(function() {
          var passed = now() - previous;
          if (wait > passed) {
            timeout = setTimeout(later, wait - passed);
          } else {
            timeout = null;
            if (!immediate)
              result2 = func.apply(context2, args);
            if (!timeout)
              args = context2 = null;
          }
        }, "later");
        var debounced = restArguments(function(_args) {
          context2 = this;
          args = _args;
          previous = now();
          if (!timeout) {
            timeout = setTimeout(later, wait);
            if (immediate)
              result2 = func.apply(context2, args);
          }
          return result2;
        });
        debounced.cancel = function() {
          clearTimeout(timeout);
          timeout = args = context2 = null;
        };
        return debounced;
      }
      __name(debounce, "debounce");
      function wrap(func, wrapper) {
        return partial(wrapper, func);
      }
      __name(wrap, "wrap");
      function negate(predicate) {
        return function() {
          return !predicate.apply(this, arguments);
        };
      }
      __name(negate, "negate");
      function compose() {
        var args = arguments;
        var start = args.length - 1;
        return function() {
          var i2 = start;
          var result2 = args[start].apply(this, arguments);
          while (i2--)
            result2 = args[i2].call(this, result2);
          return result2;
        };
      }
      __name(compose, "compose");
      function after(times2, func) {
        return function() {
          if (--times2 < 1) {
            return func.apply(this, arguments);
          }
        };
      }
      __name(after, "after");
      function before(times2, func) {
        var memo;
        return function() {
          if (--times2 > 0) {
            memo = func.apply(this, arguments);
          }
          if (times2 <= 1)
            func = null;
          return memo;
        };
      }
      __name(before, "before");
      var once2 = partial(before, 2);
      function findKey(obj2, predicate, context2) {
        predicate = cb(predicate, context2);
        var _keys = keys(obj2), key;
        for (var i2 = 0, length = _keys.length; i2 < length; i2++) {
          key = _keys[i2];
          if (predicate(obj2[key], key, obj2))
            return key;
        }
      }
      __name(findKey, "findKey");
      function createPredicateIndexFinder(dir3) {
        return function(array, predicate, context2) {
          predicate = cb(predicate, context2);
          var length = getLength(array);
          var index = dir3 > 0 ? 0 : length - 1;
          for (; index >= 0 && index < length; index += dir3) {
            if (predicate(array[index], index, array))
              return index;
          }
          return -1;
        };
      }
      __name(createPredicateIndexFinder, "createPredicateIndexFinder");
      var findIndex = createPredicateIndexFinder(1);
      var findLastIndex = createPredicateIndexFinder(-1);
      function sortedIndex(array, obj2, iteratee2, context2) {
        iteratee2 = cb(iteratee2, context2, 1);
        var value = iteratee2(obj2);
        var low = 0, high = getLength(array);
        while (low < high) {
          var mid = Math.floor((low + high) / 2);
          if (iteratee2(array[mid]) < value)
            low = mid + 1;
          else
            high = mid;
        }
        return low;
      }
      __name(sortedIndex, "sortedIndex");
      function createIndexFinder(dir3, predicateFind, sortedIndex2) {
        return function(array, item, idx) {
          var i2 = 0, length = getLength(array);
          if (typeof idx == "number") {
            if (dir3 > 0) {
              i2 = idx >= 0 ? idx : Math.max(idx + length, i2);
            } else {
              length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
            }
          } else if (sortedIndex2 && idx && length) {
            idx = sortedIndex2(array, item);
            return array[idx] === item ? idx : -1;
          }
          if (item !== item) {
            idx = predicateFind(slice.call(array, i2, length), isNaN$1);
            return idx >= 0 ? idx + i2 : -1;
          }
          for (idx = dir3 > 0 ? i2 : length - 1; idx >= 0 && idx < length; idx += dir3) {
            if (array[idx] === item)
              return idx;
          }
          return -1;
        };
      }
      __name(createIndexFinder, "createIndexFinder");
      var indexOf = createIndexFinder(1, findIndex, sortedIndex);
      var lastIndexOf = createIndexFinder(-1, findLastIndex);
      function find2(obj2, predicate, context2) {
        var keyFinder = isArrayLike(obj2) ? findIndex : findKey;
        var key = keyFinder(obj2, predicate, context2);
        if (key !== void 0 && key !== -1)
          return obj2[key];
      }
      __name(find2, "find");
      function findWhere(obj2, attrs) {
        return find2(obj2, matcher(attrs));
      }
      __name(findWhere, "findWhere");
      function each(obj2, iteratee2, context2) {
        iteratee2 = optimizeCb(iteratee2, context2);
        var i2, length;
        if (isArrayLike(obj2)) {
          for (i2 = 0, length = obj2.length; i2 < length; i2++) {
            iteratee2(obj2[i2], i2, obj2);
          }
        } else {
          var _keys = keys(obj2);
          for (i2 = 0, length = _keys.length; i2 < length; i2++) {
            iteratee2(obj2[_keys[i2]], _keys[i2], obj2);
          }
        }
        return obj2;
      }
      __name(each, "each");
      function map(obj2, iteratee2, context2) {
        iteratee2 = cb(iteratee2, context2);
        var _keys = !isArrayLike(obj2) && keys(obj2), length = (_keys || obj2).length, results = Array(length);
        for (var index = 0; index < length; index++) {
          var currentKey = _keys ? _keys[index] : index;
          results[index] = iteratee2(obj2[currentKey], currentKey, obj2);
        }
        return results;
      }
      __name(map, "map");
      function createReduce(dir3) {
        var reducer = /* @__PURE__ */ __name(function(obj2, iteratee2, memo, initial2) {
          var _keys = !isArrayLike(obj2) && keys(obj2), length = (_keys || obj2).length, index = dir3 > 0 ? 0 : length - 1;
          if (!initial2) {
            memo = obj2[_keys ? _keys[index] : index];
            index += dir3;
          }
          for (; index >= 0 && index < length; index += dir3) {
            var currentKey = _keys ? _keys[index] : index;
            memo = iteratee2(memo, obj2[currentKey], currentKey, obj2);
          }
          return memo;
        }, "reducer");
        return function(obj2, iteratee2, memo, context2) {
          var initial2 = arguments.length >= 3;
          return reducer(obj2, optimizeCb(iteratee2, context2, 4), memo, initial2);
        };
      }
      __name(createReduce, "createReduce");
      var reduce = createReduce(1);
      var reduceRight = createReduce(-1);
      function filter(obj2, predicate, context2) {
        var results = [];
        predicate = cb(predicate, context2);
        each(obj2, function(value, index, list) {
          if (predicate(value, index, list))
            results.push(value);
        });
        return results;
      }
      __name(filter, "filter");
      function reject(obj2, predicate, context2) {
        return filter(obj2, negate(cb(predicate)), context2);
      }
      __name(reject, "reject");
      function every(obj2, predicate, context2) {
        predicate = cb(predicate, context2);
        var _keys = !isArrayLike(obj2) && keys(obj2), length = (_keys || obj2).length;
        for (var index = 0; index < length; index++) {
          var currentKey = _keys ? _keys[index] : index;
          if (!predicate(obj2[currentKey], currentKey, obj2))
            return false;
        }
        return true;
      }
      __name(every, "every");
      function some(obj2, predicate, context2) {
        predicate = cb(predicate, context2);
        var _keys = !isArrayLike(obj2) && keys(obj2), length = (_keys || obj2).length;
        for (var index = 0; index < length; index++) {
          var currentKey = _keys ? _keys[index] : index;
          if (predicate(obj2[currentKey], currentKey, obj2))
            return true;
        }
        return false;
      }
      __name(some, "some");
      function contains(obj2, item, fromIndex, guard) {
        if (!isArrayLike(obj2))
          obj2 = values(obj2);
        if (typeof fromIndex != "number" || guard)
          fromIndex = 0;
        return indexOf(obj2, item, fromIndex) >= 0;
      }
      __name(contains, "contains");
      var invoke = restArguments(function(obj2, path, args) {
        var contextPath, func;
        if (isFunction$1(path)) {
          func = path;
        } else {
          path = toPath(path);
          contextPath = path.slice(0, -1);
          path = path[path.length - 1];
        }
        return map(obj2, function(context2) {
          var method = func;
          if (!method) {
            if (contextPath && contextPath.length) {
              context2 = deepGet(context2, contextPath);
            }
            if (context2 == null)
              return void 0;
            method = context2[path];
          }
          return method == null ? method : method.apply(context2, args);
        });
      });
      function pluck(obj2, key) {
        return map(obj2, property(key));
      }
      __name(pluck, "pluck");
      function where(obj2, attrs) {
        return filter(obj2, matcher(attrs));
      }
      __name(where, "where");
      function max(obj2, iteratee2, context2) {
        var result2 = -Infinity, lastComputed = -Infinity, value, computed;
        if (iteratee2 == null || typeof iteratee2 == "number" && typeof obj2[0] != "object" && obj2 != null) {
          obj2 = isArrayLike(obj2) ? obj2 : values(obj2);
          for (var i2 = 0, length = obj2.length; i2 < length; i2++) {
            value = obj2[i2];
            if (value != null && value > result2) {
              result2 = value;
            }
          }
        } else {
          iteratee2 = cb(iteratee2, context2);
          each(obj2, function(v2, index, list) {
            computed = iteratee2(v2, index, list);
            if (computed > lastComputed || computed === -Infinity && result2 === -Infinity) {
              result2 = v2;
              lastComputed = computed;
            }
          });
        }
        return result2;
      }
      __name(max, "max");
      function min(obj2, iteratee2, context2) {
        var result2 = Infinity, lastComputed = Infinity, value, computed;
        if (iteratee2 == null || typeof iteratee2 == "number" && typeof obj2[0] != "object" && obj2 != null) {
          obj2 = isArrayLike(obj2) ? obj2 : values(obj2);
          for (var i2 = 0, length = obj2.length; i2 < length; i2++) {
            value = obj2[i2];
            if (value != null && value < result2) {
              result2 = value;
            }
          }
        } else {
          iteratee2 = cb(iteratee2, context2);
          each(obj2, function(v2, index, list) {
            computed = iteratee2(v2, index, list);
            if (computed < lastComputed || computed === Infinity && result2 === Infinity) {
              result2 = v2;
              lastComputed = computed;
            }
          });
        }
        return result2;
      }
      __name(min, "min");
      var reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
      function toArray(obj2) {
        if (!obj2)
          return [];
        if (isArray(obj2))
          return slice.call(obj2);
        if (isString(obj2)) {
          return obj2.match(reStrSymbol);
        }
        if (isArrayLike(obj2))
          return map(obj2, identity);
        return values(obj2);
      }
      __name(toArray, "toArray");
      function sample(obj2, n2, guard) {
        if (n2 == null || guard) {
          if (!isArrayLike(obj2))
            obj2 = values(obj2);
          return obj2[random(obj2.length - 1)];
        }
        var sample2 = toArray(obj2);
        var length = getLength(sample2);
        n2 = Math.max(Math.min(n2, length), 0);
        var last2 = length - 1;
        for (var index = 0; index < n2; index++) {
          var rand = random(index, last2);
          var temp = sample2[index];
          sample2[index] = sample2[rand];
          sample2[rand] = temp;
        }
        return sample2.slice(0, n2);
      }
      __name(sample, "sample");
      function shuffle(obj2) {
        return sample(obj2, Infinity);
      }
      __name(shuffle, "shuffle");
      function sortBy(obj2, iteratee2, context2) {
        var index = 0;
        iteratee2 = cb(iteratee2, context2);
        return pluck(map(obj2, function(value, key, list) {
          return {
            value,
            index: index++,
            criteria: iteratee2(value, key, list)
          };
        }).sort(function(left, right) {
          var a2 = left.criteria;
          var b2 = right.criteria;
          if (a2 !== b2) {
            if (a2 > b2 || a2 === void 0)
              return 1;
            if (a2 < b2 || b2 === void 0)
              return -1;
          }
          return left.index - right.index;
        }), "value");
      }
      __name(sortBy, "sortBy");
      function group3(behavior, partition2) {
        return function(obj2, iteratee2, context2) {
          var result2 = partition2 ? [[], []] : {};
          iteratee2 = cb(iteratee2, context2);
          each(obj2, function(value, index) {
            var key = iteratee2(value, index, obj2);
            behavior(result2, value, key);
          });
          return result2;
        };
      }
      __name(group3, "group");
      var groupBy = group3(function(result2, value, key) {
        if (has$1(result2, key))
          result2[key].push(value);
        else
          result2[key] = [value];
      });
      var indexBy = group3(function(result2, value, key) {
        result2[key] = value;
      });
      var countBy = group3(function(result2, value, key) {
        if (has$1(result2, key))
          result2[key]++;
        else
          result2[key] = 1;
      });
      var partition = group3(function(result2, value, pass) {
        result2[pass ? 0 : 1].push(value);
      }, true);
      function size(obj2) {
        if (obj2 == null)
          return 0;
        return isArrayLike(obj2) ? obj2.length : keys(obj2).length;
      }
      __name(size, "size");
      function keyInObj(value, key, obj2) {
        return key in obj2;
      }
      __name(keyInObj, "keyInObj");
      var pick = restArguments(function(obj2, keys2) {
        var result2 = {}, iteratee2 = keys2[0];
        if (obj2 == null)
          return result2;
        if (isFunction$1(iteratee2)) {
          if (keys2.length > 1)
            iteratee2 = optimizeCb(iteratee2, keys2[1]);
          keys2 = allKeys(obj2);
        } else {
          iteratee2 = keyInObj;
          keys2 = flatten$1(keys2, false, false);
          obj2 = Object(obj2);
        }
        for (var i2 = 0, length = keys2.length; i2 < length; i2++) {
          var key = keys2[i2];
          var value = obj2[key];
          if (iteratee2(value, key, obj2))
            result2[key] = value;
        }
        return result2;
      });
      var omit = restArguments(function(obj2, keys2) {
        var iteratee2 = keys2[0], context2;
        if (isFunction$1(iteratee2)) {
          iteratee2 = negate(iteratee2);
          if (keys2.length > 1)
            context2 = keys2[1];
        } else {
          keys2 = map(flatten$1(keys2, false, false), String);
          iteratee2 = /* @__PURE__ */ __name(function(value, key) {
            return !contains(keys2, key);
          }, "iteratee");
        }
        return pick(obj2, iteratee2, context2);
      });
      function initial(array, n2, guard) {
        return slice.call(array, 0, Math.max(0, array.length - (n2 == null || guard ? 1 : n2)));
      }
      __name(initial, "initial");
      function first(array, n2, guard) {
        if (array == null || array.length < 1)
          return n2 == null || guard ? void 0 : [];
        if (n2 == null || guard)
          return array[0];
        return initial(array, array.length - n2);
      }
      __name(first, "first");
      function rest(array, n2, guard) {
        return slice.call(array, n2 == null || guard ? 1 : n2);
      }
      __name(rest, "rest");
      function last(array, n2, guard) {
        if (array == null || array.length < 1)
          return n2 == null || guard ? void 0 : [];
        if (n2 == null || guard)
          return array[array.length - 1];
        return rest(array, Math.max(0, array.length - n2));
      }
      __name(last, "last");
      function compact(array) {
        return filter(array, Boolean);
      }
      __name(compact, "compact");
      function flatten(array, depth) {
        return flatten$1(array, depth, false);
      }
      __name(flatten, "flatten");
      var difference = restArguments(function(array, rest2) {
        rest2 = flatten$1(rest2, true, true);
        return filter(array, function(value) {
          return !contains(rest2, value);
        });
      });
      var without = restArguments(function(array, otherArrays) {
        return difference(array, otherArrays);
      });
      function uniq(array, isSorted, iteratee2, context2) {
        if (!isBoolean(isSorted)) {
          context2 = iteratee2;
          iteratee2 = isSorted;
          isSorted = false;
        }
        if (iteratee2 != null)
          iteratee2 = cb(iteratee2, context2);
        var result2 = [];
        var seen = [];
        for (var i2 = 0, length = getLength(array); i2 < length; i2++) {
          var value = array[i2], computed = iteratee2 ? iteratee2(value, i2, array) : value;
          if (isSorted && !iteratee2) {
            if (!i2 || seen !== computed)
              result2.push(value);
            seen = computed;
          } else if (iteratee2) {
            if (!contains(seen, computed)) {
              seen.push(computed);
              result2.push(value);
            }
          } else if (!contains(result2, value)) {
            result2.push(value);
          }
        }
        return result2;
      }
      __name(uniq, "uniq");
      var union = restArguments(function(arrays) {
        return uniq(flatten$1(arrays, true, true));
      });
      function intersection(array) {
        var result2 = [];
        var argsLength = arguments.length;
        for (var i2 = 0, length = getLength(array); i2 < length; i2++) {
          var item = array[i2];
          if (contains(result2, item))
            continue;
          var j2;
          for (j2 = 1; j2 < argsLength; j2++) {
            if (!contains(arguments[j2], item))
              break;
          }
          if (j2 === argsLength)
            result2.push(item);
        }
        return result2;
      }
      __name(intersection, "intersection");
      function unzip(array) {
        var length = array && max(array, getLength).length || 0;
        var result2 = Array(length);
        for (var index = 0; index < length; index++) {
          result2[index] = pluck(array, index);
        }
        return result2;
      }
      __name(unzip, "unzip");
      var zip = restArguments(unzip);
      function object(list, values2) {
        var result2 = {};
        for (var i2 = 0, length = getLength(list); i2 < length; i2++) {
          if (values2) {
            result2[list[i2]] = values2[i2];
          } else {
            result2[list[i2][0]] = list[i2][1];
          }
        }
        return result2;
      }
      __name(object, "object");
      function range(start, stop, step) {
        if (stop == null) {
          stop = start || 0;
          start = 0;
        }
        if (!step) {
          step = stop < start ? -1 : 1;
        }
        var length = Math.max(Math.ceil((stop - start) / step), 0);
        var range2 = Array(length);
        for (var idx = 0; idx < length; idx++, start += step) {
          range2[idx] = start;
        }
        return range2;
      }
      __name(range, "range");
      function chunk(array, count3) {
        if (count3 == null || count3 < 1)
          return [];
        var result2 = [];
        var i2 = 0, length = array.length;
        while (i2 < length) {
          result2.push(slice.call(array, i2, i2 += count3));
        }
        return result2;
      }
      __name(chunk, "chunk");
      function chainResult(instance, obj2) {
        return instance._chain ? _$1(obj2).chain() : obj2;
      }
      __name(chainResult, "chainResult");
      function mixin(obj2) {
        each(functions(obj2), function(name) {
          var func = _$1[name] = obj2[name];
          _$1.prototype[name] = function() {
            var args = [this._wrapped];
            push.apply(args, arguments);
            return chainResult(this, func.apply(_$1, args));
          };
        });
        return _$1;
      }
      __name(mixin, "mixin");
      each(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function(name) {
        var method = ArrayProto[name];
        _$1.prototype[name] = function() {
          var obj2 = this._wrapped;
          if (obj2 != null) {
            method.apply(obj2, arguments);
            if ((name === "shift" || name === "splice") && obj2.length === 0) {
              delete obj2[0];
            }
          }
          return chainResult(this, obj2);
        };
      });
      each(["concat", "join", "slice"], function(name) {
        var method = ArrayProto[name];
        _$1.prototype[name] = function() {
          var obj2 = this._wrapped;
          if (obj2 != null)
            obj2 = method.apply(obj2, arguments);
          return chainResult(this, obj2);
        };
      });
      var allExports = {
        __proto__: null,
        VERSION,
        restArguments,
        isObject: isObject2,
        isNull,
        isUndefined,
        isBoolean,
        isElement,
        isString,
        isNumber,
        isDate,
        isRegExp,
        isError: isError2,
        isSymbol,
        isArrayBuffer,
        isDataView: isDataView$1,
        isArray,
        isFunction: isFunction$1,
        isArguments: isArguments$1,
        isFinite: isFinite$1,
        isNaN: isNaN$1,
        isTypedArray: isTypedArray$1,
        isEmpty,
        isMatch,
        isEqual,
        isMap,
        isWeakMap,
        isSet,
        isWeakSet,
        keys,
        allKeys,
        values,
        pairs,
        invert,
        functions,
        methods: functions,
        extend,
        extendOwn,
        assign: extendOwn,
        defaults,
        create,
        clone,
        tap,
        get,
        has,
        mapObject,
        identity,
        constant,
        noop,
        toPath: toPath$1,
        property,
        propertyOf,
        matcher,
        matches: matcher,
        times,
        random,
        now,
        escape: _escape,
        unescape: _unescape,
        templateSettings,
        template,
        result,
        uniqueId,
        chain,
        iteratee,
        partial,
        bind,
        bindAll,
        memoize,
        delay,
        defer,
        throttle,
        debounce,
        wrap,
        negate,
        compose,
        after,
        before,
        once: once2,
        findKey,
        findIndex,
        findLastIndex,
        sortedIndex,
        indexOf,
        lastIndexOf,
        find: find2,
        detect: find2,
        findWhere,
        each,
        forEach: each,
        map,
        collect: map,
        reduce,
        foldl: reduce,
        inject: reduce,
        reduceRight,
        foldr: reduceRight,
        filter,
        select: filter,
        reject,
        every,
        all: every,
        some,
        any: some,
        contains,
        includes: contains,
        include: contains,
        invoke,
        pluck,
        where,
        max,
        min,
        shuffle,
        sample,
        sortBy,
        groupBy,
        indexBy,
        countBy,
        partition,
        toArray,
        size,
        pick,
        omit,
        first,
        head: first,
        take: first,
        initial,
        last,
        rest,
        tail: rest,
        drop: rest,
        compact,
        flatten,
        without,
        uniq,
        unique: uniq,
        union,
        intersection,
        difference,
        unzip,
        transpose: unzip,
        zip,
        object,
        range,
        chunk,
        mixin,
        "default": _$1
      };
      var _2 = mixin(allExports);
      _2._ = _2;
      return _2;
    });
  }
});

// node_modules/bluebird/js/release/es5.js
var require_es5 = __commonJS({
  "node_modules/bluebird/js/release/es5.js"(exports2, module2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var isES5 = function() {
      "use strict";
      return this === void 0;
    }();
    if (isES5) {
      module2.exports = {
        freeze: Object.freeze,
        defineProperty: Object.defineProperty,
        getDescriptor: Object.getOwnPropertyDescriptor,
        keys: Object.keys,
        names: Object.getOwnPropertyNames,
        getPrototypeOf: Object.getPrototypeOf,
        isArray: Array.isArray,
        isES5,
        propertyIsWritable: function(obj2, prop) {
          var descriptor = Object.getOwnPropertyDescriptor(obj2, prop);
          return !!(!descriptor || descriptor.writable || descriptor.set);
        }
      };
    } else {
      has = {}.hasOwnProperty;
      str = {}.toString;
      proto = {}.constructor.prototype;
      ObjectKeys = /* @__PURE__ */ __name(function(o2) {
        var ret2 = [];
        for (var key in o2) {
          if (has.call(o2, key)) {
            ret2.push(key);
          }
        }
        return ret2;
      }, "ObjectKeys");
      ObjectGetDescriptor = /* @__PURE__ */ __name(function(o2, key) {
        return { value: o2[key] };
      }, "ObjectGetDescriptor");
      ObjectDefineProperty = /* @__PURE__ */ __name(function(o2, key, desc) {
        o2[key] = desc.value;
        return o2;
      }, "ObjectDefineProperty");
      ObjectFreeze = /* @__PURE__ */ __name(function(obj2) {
        return obj2;
      }, "ObjectFreeze");
      ObjectGetPrototypeOf = /* @__PURE__ */ __name(function(obj2) {
        try {
          return Object(obj2).constructor.prototype;
        } catch (e2) {
          return proto;
        }
      }, "ObjectGetPrototypeOf");
      ArrayIsArray = /* @__PURE__ */ __name(function(obj2) {
        try {
          return str.call(obj2) === "[object Array]";
        } catch (e2) {
          return false;
        }
      }, "ArrayIsArray");
      module2.exports = {
        isArray: ArrayIsArray,
        keys: ObjectKeys,
        names: ObjectKeys,
        defineProperty: ObjectDefineProperty,
        getDescriptor: ObjectGetDescriptor,
        freeze: ObjectFreeze,
        getPrototypeOf: ObjectGetPrototypeOf,
        isES5,
        propertyIsWritable: function() {
          return true;
        }
      };
    }
    var has;
    var str;
    var proto;
    var ObjectKeys;
    var ObjectGetDescriptor;
    var ObjectDefineProperty;
    var ObjectFreeze;
    var ObjectGetPrototypeOf;
    var ArrayIsArray;
  }
});

// node_modules/bluebird/js/release/util.js
var require_util = __commonJS({
  "node_modules/bluebird/js/release/util.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var es5 = require_es5();
    var canEvaluate = typeof navigator == "undefined";
    var errorObj = { e: {} };
    var tryCatchTarget;
    var globalObject = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : exports !== void 0 ? exports : null;
    function tryCatcher() {
      try {
        var target = tryCatchTarget;
        tryCatchTarget = null;
        return target.apply(this, arguments);
      } catch (e2) {
        errorObj.e = e2;
        return errorObj;
      }
    }
    __name(tryCatcher, "tryCatcher");
    function tryCatch(fn2) {
      tryCatchTarget = fn2;
      return tryCatcher;
    }
    __name(tryCatch, "tryCatch");
    var inherits = /* @__PURE__ */ __name(function(Child, Parent) {
      var hasProp = {}.hasOwnProperty;
      function T2() {
        this.constructor = Child;
        this.constructor$ = Parent;
        for (var propertyName in Parent.prototype) {
          if (hasProp.call(Parent.prototype, propertyName) && propertyName.charAt(propertyName.length - 1) !== "$") {
            this[propertyName + "$"] = Parent.prototype[propertyName];
          }
        }
      }
      __name(T2, "T");
      T2.prototype = Parent.prototype;
      Child.prototype = new T2();
      return Child.prototype;
    }, "inherits");
    function isPrimitive(val) {
      return val == null || val === true || val === false || typeof val === "string" || typeof val === "number";
    }
    __name(isPrimitive, "isPrimitive");
    function isObject(value) {
      return typeof value === "function" || typeof value === "object" && value !== null;
    }
    __name(isObject, "isObject");
    function maybeWrapAsError(maybeError) {
      if (!isPrimitive(maybeError))
        return maybeError;
      return new Error(safeToString(maybeError));
    }
    __name(maybeWrapAsError, "maybeWrapAsError");
    function withAppended(target, appendee) {
      var len = target.length;
      var ret2 = new Array(len + 1);
      var i2;
      for (i2 = 0; i2 < len; ++i2) {
        ret2[i2] = target[i2];
      }
      ret2[i2] = appendee;
      return ret2;
    }
    __name(withAppended, "withAppended");
    function getDataPropertyOrDefault(obj2, key, defaultValue) {
      if (es5.isES5) {
        var desc = Object.getOwnPropertyDescriptor(obj2, key);
        if (desc != null) {
          return desc.get == null && desc.set == null ? desc.value : defaultValue;
        }
      } else {
        return {}.hasOwnProperty.call(obj2, key) ? obj2[key] : void 0;
      }
    }
    __name(getDataPropertyOrDefault, "getDataPropertyOrDefault");
    function notEnumerableProp(obj2, name, value) {
      if (isPrimitive(obj2))
        return obj2;
      var descriptor = {
        value,
        configurable: true,
        enumerable: false,
        writable: true
      };
      es5.defineProperty(obj2, name, descriptor);
      return obj2;
    }
    __name(notEnumerableProp, "notEnumerableProp");
    function thrower(r2) {
      throw r2;
    }
    __name(thrower, "thrower");
    var inheritedDataKeys = function() {
      var excludedPrototypes = [
        Array.prototype,
        Object.prototype,
        Function.prototype
      ];
      var isExcludedProto = /* @__PURE__ */ __name(function(val) {
        for (var i2 = 0; i2 < excludedPrototypes.length; ++i2) {
          if (excludedPrototypes[i2] === val) {
            return true;
          }
        }
        return false;
      }, "isExcludedProto");
      if (es5.isES5) {
        var getKeys = Object.getOwnPropertyNames;
        return function(obj2) {
          var ret2 = [];
          var visitedKeys = /* @__PURE__ */ Object.create(null);
          while (obj2 != null && !isExcludedProto(obj2)) {
            var keys;
            try {
              keys = getKeys(obj2);
            } catch (e2) {
              return ret2;
            }
            for (var i2 = 0; i2 < keys.length; ++i2) {
              var key = keys[i2];
              if (visitedKeys[key])
                continue;
              visitedKeys[key] = true;
              var desc = Object.getOwnPropertyDescriptor(obj2, key);
              if (desc != null && desc.get == null && desc.set == null) {
                ret2.push(key);
              }
            }
            obj2 = es5.getPrototypeOf(obj2);
          }
          return ret2;
        };
      } else {
        var hasProp = {}.hasOwnProperty;
        return function(obj2) {
          if (isExcludedProto(obj2))
            return [];
          var ret2 = [];
          enumeration:
            for (var key in obj2) {
              if (hasProp.call(obj2, key)) {
                ret2.push(key);
              } else {
                for (var i2 = 0; i2 < excludedPrototypes.length; ++i2) {
                  if (hasProp.call(excludedPrototypes[i2], key)) {
                    continue enumeration;
                  }
                }
                ret2.push(key);
              }
            }
          return ret2;
        };
      }
    }();
    var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
    function isClass(fn2) {
      try {
        if (typeof fn2 === "function") {
          var keys = es5.names(fn2.prototype);
          var hasMethods = es5.isES5 && keys.length > 1;
          var hasMethodsOtherThanConstructor = keys.length > 0 && !(keys.length === 1 && keys[0] === "constructor");
          var hasThisAssignmentAndStaticMethods = thisAssignmentPattern.test(fn2 + "") && es5.names(fn2).length > 0;
          if (hasMethods || hasMethodsOtherThanConstructor || hasThisAssignmentAndStaticMethods) {
            return true;
          }
        }
        return false;
      } catch (e2) {
        return false;
      }
    }
    __name(isClass, "isClass");
    function toFastProperties(obj) {
      function FakeConstructor() {
      }
      __name(FakeConstructor, "FakeConstructor");
      FakeConstructor.prototype = obj;
      var l = 8;
      while (l--)
        new FakeConstructor();
      return obj;
      eval(obj);
    }
    __name(toFastProperties, "toFastProperties");
    var rident = /^[a-z$_][a-z$_0-9]*$/i;
    function isIdentifier(str) {
      return rident.test(str);
    }
    __name(isIdentifier, "isIdentifier");
    function filledRange(count3, prefix, suffix) {
      var ret2 = new Array(count3);
      for (var i2 = 0; i2 < count3; ++i2) {
        ret2[i2] = prefix + i2 + suffix;
      }
      return ret2;
    }
    __name(filledRange, "filledRange");
    function safeToString(obj2) {
      try {
        return obj2 + "";
      } catch (e2) {
        return "[no string representation]";
      }
    }
    __name(safeToString, "safeToString");
    function isError(obj2) {
      return obj2 !== null && typeof obj2 === "object" && typeof obj2.message === "string" && typeof obj2.name === "string";
    }
    __name(isError, "isError");
    function markAsOriginatingFromRejection(e2) {
      try {
        notEnumerableProp(e2, "isOperational", true);
      } catch (ignore) {
      }
    }
    __name(markAsOriginatingFromRejection, "markAsOriginatingFromRejection");
    function originatesFromRejection(e2) {
      if (e2 == null)
        return false;
      return e2 instanceof Error["__BluebirdErrorTypes__"].OperationalError || e2["isOperational"] === true;
    }
    __name(originatesFromRejection, "originatesFromRejection");
    function canAttachTrace(obj2) {
      return isError(obj2) && es5.propertyIsWritable(obj2, "stack");
    }
    __name(canAttachTrace, "canAttachTrace");
    var ensureErrorObject = function() {
      if (!("stack" in new Error())) {
        return function(value) {
          if (canAttachTrace(value))
            return value;
          try {
            throw new Error(safeToString(value));
          } catch (err) {
            return err;
          }
        };
      } else {
        return function(value) {
          if (canAttachTrace(value))
            return value;
          return new Error(safeToString(value));
        };
      }
    }();
    function classString(obj2) {
      return {}.toString.call(obj2);
    }
    __name(classString, "classString");
    function copyDescriptors(from, to2, filter) {
      var keys = es5.names(from);
      for (var i2 = 0; i2 < keys.length; ++i2) {
        var key = keys[i2];
        if (filter(key)) {
          try {
            es5.defineProperty(to2, key, es5.getDescriptor(from, key));
          } catch (ignore) {
          }
        }
      }
    }
    __name(copyDescriptors, "copyDescriptors");
    var asArray = /* @__PURE__ */ __name(function(v2) {
      if (es5.isArray(v2)) {
        return v2;
      }
      return null;
    }, "asArray");
    if (typeof Symbol !== "undefined" && Symbol.iterator) {
      ArrayFrom = typeof Array.from === "function" ? function(v2) {
        return Array.from(v2);
      } : function(v2) {
        var ret2 = [];
        var it2 = v2[Symbol.iterator]();
        var itResult;
        while (!(itResult = it2.next()).done) {
          ret2.push(itResult.value);
        }
        return ret2;
      };
      asArray = /* @__PURE__ */ __name(function(v2) {
        if (es5.isArray(v2)) {
          return v2;
        } else if (v2 != null && typeof v2[Symbol.iterator] === "function") {
          return ArrayFrom(v2);
        }
        return null;
      }, "asArray");
    }
    var ArrayFrom;
    var isNode = typeof process !== "undefined" && classString(process).toLowerCase() === "[object process]";
    var hasEnvVariables = typeof process !== "undefined" && typeof process.env !== "undefined";
    function env(key) {
      return hasEnvVariables ? process.env[key] : void 0;
    }
    __name(env, "env");
    function getNativePromise() {
      if (typeof Promise === "function") {
        try {
          var promise = new Promise(function() {
          });
          if ({}.toString.call(promise) === "[object Promise]") {
            return Promise;
          }
        } catch (e2) {
        }
      }
    }
    __name(getNativePromise, "getNativePromise");
    function domainBind(self2, cb) {
      return self2.bind(cb);
    }
    __name(domainBind, "domainBind");
    var ret = {
      isClass,
      isIdentifier,
      inheritedDataKeys,
      getDataPropertyOrDefault,
      thrower,
      isArray: es5.isArray,
      asArray,
      notEnumerableProp,
      isPrimitive,
      isObject,
      isError,
      canEvaluate,
      errorObj,
      tryCatch,
      inherits,
      withAppended,
      maybeWrapAsError,
      toFastProperties,
      filledRange,
      toString: safeToString,
      canAttachTrace,
      ensureErrorObject,
      originatesFromRejection,
      markAsOriginatingFromRejection,
      classString,
      copyDescriptors,
      hasDevTools: typeof chrome !== "undefined" && chrome && typeof chrome.loadTimes === "function",
      isNode,
      hasEnvVariables,
      env,
      global: globalObject,
      getNativePromise,
      domainBind
    };
    ret.isRecentNode = ret.isNode && function() {
      var version2 = process.versions.node.split(".").map(Number);
      return version2[0] === 0 && version2[1] > 10 || version2[0] > 0;
    }();
    if (ret.isNode)
      ret.toFastProperties(process);
    try {
      throw new Error();
    } catch (e2) {
      ret.lastLineError = e2;
    }
    module.exports = ret;
  }
});

// node_modules/bluebird/js/release/schedule.js
var require_schedule = __commonJS({
  "node_modules/bluebird/js/release/schedule.js"(exports2, module2) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var util = require_util();
    var schedule;
    var noAsyncScheduler = /* @__PURE__ */ __name(function() {
      throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n");
    }, "noAsyncScheduler");
    var NativePromise = util.getNativePromise();
    if (util.isNode && typeof MutationObserver === "undefined") {
      GlobalSetImmediate = global.setImmediate;
      ProcessNextTick = process.nextTick;
      schedule = util.isRecentNode ? function(fn2) {
        GlobalSetImmediate.call(global, fn2);
      } : function(fn2) {
        ProcessNextTick.call(process, fn2);
      };
    } else if (typeof NativePromise === "function" && typeof NativePromise.resolve === "function") {
      nativePromise = NativePromise.resolve();
      schedule = /* @__PURE__ */ __name(function(fn2) {
        nativePromise.then(fn2);
      }, "schedule");
    } else if (typeof MutationObserver !== "undefined" && !(typeof window !== "undefined" && window.navigator && (window.navigator.standalone || window.cordova))) {
      schedule = function() {
        var div = document.createElement("div");
        var opts = { attributes: true };
        var toggleScheduled = false;
        var div2 = document.createElement("div");
        var o2 = new MutationObserver(function() {
          div.classList.toggle("foo");
          toggleScheduled = false;
        });
        o2.observe(div2, opts);
        var scheduleToggle = /* @__PURE__ */ __name(function() {
          if (toggleScheduled)
            return;
          toggleScheduled = true;
          div2.classList.toggle("foo");
        }, "scheduleToggle");
        return /* @__PURE__ */ __name(function schedule2(fn2) {
          var o3 = new MutationObserver(function() {
            o3.disconnect();
            fn2();
          });
          o3.observe(div, opts);
          scheduleToggle();
        }, "schedule");
      }();
    } else if (typeof setImmediate !== "undefined") {
      schedule = /* @__PURE__ */ __name(function(fn2) {
        setImmediate(fn2);
      }, "schedule");
    } else if (typeof setTimeout !== "undefined") {
      schedule = /* @__PURE__ */ __name(function(fn2) {
        setTimeout(fn2, 0);
      }, "schedule");
    } else {
      schedule = noAsyncScheduler;
    }
    var GlobalSetImmediate;
    var ProcessNextTick;
    var nativePromise;
    module2.exports = schedule;
  }
});

// node_modules/bluebird/js/release/queue.js
var require_queue = __commonJS({
  "node_modules/bluebird/js/release/queue.js"(exports2, module2) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function arrayMove(src, srcIndex, dst, dstIndex, len) {
      for (var j2 = 0; j2 < len; ++j2) {
        dst[j2 + dstIndex] = src[j2 + srcIndex];
        src[j2 + srcIndex] = void 0;
      }
    }
    __name(arrayMove, "arrayMove");
    function Queue(capacity) {
      this._capacity = capacity;
      this._length = 0;
      this._front = 0;
    }
    __name(Queue, "Queue");
    Queue.prototype._willBeOverCapacity = function(size) {
      return this._capacity < size;
    };
    Queue.prototype._pushOne = function(arg) {
      var length = this.length();
      this._checkCapacity(length + 1);
      var i2 = this._front + length & this._capacity - 1;
      this[i2] = arg;
      this._length = length + 1;
    };
    Queue.prototype.push = function(fn2, receiver, arg) {
      var length = this.length() + 3;
      if (this._willBeOverCapacity(length)) {
        this._pushOne(fn2);
        this._pushOne(receiver);
        this._pushOne(arg);
        return;
      }
      var j2 = this._front + length - 3;
      this._checkCapacity(length);
      var wrapMask = this._capacity - 1;
      this[j2 + 0 & wrapMask] = fn2;
      this[j2 + 1 & wrapMask] = receiver;
      this[j2 + 2 & wrapMask] = arg;
      this._length = length;
    };
    Queue.prototype.shift = function() {
      var front = this._front, ret2 = this[front];
      this[front] = void 0;
      this._front = front + 1 & this._capacity - 1;
      this._length--;
      return ret2;
    };
    Queue.prototype.length = function() {
      return this._length;
    };
    Queue.prototype._checkCapacity = function(size) {
      if (this._capacity < size) {
        this._resizeTo(this._capacity << 1);
      }
    };
    Queue.prototype._resizeTo = function(capacity) {
      var oldCapacity = this._capacity;
      this._capacity = capacity;
      var front = this._front;
      var length = this._length;
      var moveItemsCount = front + length & oldCapacity - 1;
      arrayMove(this, 0, this, oldCapacity, moveItemsCount);
    };
    module2.exports = Queue;
  }
});

// node_modules/bluebird/js/release/async.js
var require_async = __commonJS({
  "node_modules/bluebird/js/release/async.js"(exports2, module2) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var firstLineError;
    try {
      throw new Error();
    } catch (e2) {
      firstLineError = e2;
    }
    var schedule = require_schedule();
    var Queue = require_queue();
    var util = require_util();
    function Async() {
      this._customScheduler = false;
      this._isTickUsed = false;
      this._lateQueue = new Queue(16);
      this._normalQueue = new Queue(16);
      this._haveDrainedQueues = false;
      this._trampolineEnabled = true;
      var self2 = this;
      this.drainQueues = function() {
        self2._drainQueues();
      };
      this._schedule = schedule;
    }
    __name(Async, "Async");
    Async.prototype.setScheduler = function(fn2) {
      var prev = this._schedule;
      this._schedule = fn2;
      this._customScheduler = true;
      return prev;
    };
    Async.prototype.hasCustomScheduler = function() {
      return this._customScheduler;
    };
    Async.prototype.enableTrampoline = function() {
      this._trampolineEnabled = true;
    };
    Async.prototype.disableTrampolineIfNecessary = function() {
      if (util.hasDevTools) {
        this._trampolineEnabled = false;
      }
    };
    Async.prototype.haveItemsQueued = function() {
      return this._isTickUsed || this._haveDrainedQueues;
    };
    Async.prototype.fatalError = function(e2, isNode3) {
      if (isNode3) {
        process.stderr.write("Fatal " + (e2 instanceof Error ? e2.stack : e2) + "\n");
        process.exit(2);
      } else {
        this.throwLater(e2);
      }
    };
    Async.prototype.throwLater = function(fn2, arg) {
      if (arguments.length === 1) {
        arg = fn2;
        fn2 = /* @__PURE__ */ __name(function() {
          throw arg;
        }, "fn");
      }
      if (typeof setTimeout !== "undefined") {
        setTimeout(function() {
          fn2(arg);
        }, 0);
      } else
        try {
          this._schedule(function() {
            fn2(arg);
          });
        } catch (e2) {
          throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n");
        }
    };
    function AsyncInvokeLater(fn2, receiver, arg) {
      this._lateQueue.push(fn2, receiver, arg);
      this._queueTick();
    }
    __name(AsyncInvokeLater, "AsyncInvokeLater");
    function AsyncInvoke(fn2, receiver, arg) {
      this._normalQueue.push(fn2, receiver, arg);
      this._queueTick();
    }
    __name(AsyncInvoke, "AsyncInvoke");
    function AsyncSettlePromises(promise) {
      this._normalQueue._pushOne(promise);
      this._queueTick();
    }
    __name(AsyncSettlePromises, "AsyncSettlePromises");
    if (!util.hasDevTools) {
      Async.prototype.invokeLater = AsyncInvokeLater;
      Async.prototype.invoke = AsyncInvoke;
      Async.prototype.settlePromises = AsyncSettlePromises;
    } else {
      Async.prototype.invokeLater = function(fn2, receiver, arg) {
        if (this._trampolineEnabled) {
          AsyncInvokeLater.call(this, fn2, receiver, arg);
        } else {
          this._schedule(function() {
            setTimeout(function() {
              fn2.call(receiver, arg);
            }, 100);
          });
        }
      };
      Async.prototype.invoke = function(fn2, receiver, arg) {
        if (this._trampolineEnabled) {
          AsyncInvoke.call(this, fn2, receiver, arg);
        } else {
          this._schedule(function() {
            fn2.call(receiver, arg);
          });
        }
      };
      Async.prototype.settlePromises = function(promise) {
        if (this._trampolineEnabled) {
          AsyncSettlePromises.call(this, promise);
        } else {
          this._schedule(function() {
            promise._settlePromises();
          });
        }
      };
    }
    Async.prototype._drainQueue = function(queue) {
      while (queue.length() > 0) {
        var fn2 = queue.shift();
        if (typeof fn2 !== "function") {
          fn2._settlePromises();
          continue;
        }
        var receiver = queue.shift();
        var arg = queue.shift();
        fn2.call(receiver, arg);
      }
    };
    Async.prototype._drainQueues = function() {
      this._drainQueue(this._normalQueue);
      this._reset();
      this._haveDrainedQueues = true;
      this._drainQueue(this._lateQueue);
    };
    Async.prototype._queueTick = function() {
      if (!this._isTickUsed) {
        this._isTickUsed = true;
        this._schedule(this.drainQueues);
      }
    };
    Async.prototype._reset = function() {
      this._isTickUsed = false;
    };
    module2.exports = Async;
    module2.exports.firstLineError = firstLineError;
  }
});

// node_modules/bluebird/js/release/errors.js
var require_errors = __commonJS({
  "node_modules/bluebird/js/release/errors.js"(exports2, module2) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var es52 = require_es5();
    var Objectfreeze = es52.freeze;
    var util = require_util();
    var inherits2 = util.inherits;
    var notEnumerableProp2 = util.notEnumerableProp;
    function subError(nameProperty, defaultMessage) {
      function SubError(message) {
        if (!(this instanceof SubError))
          return new SubError(message);
        notEnumerableProp2(
          this,
          "message",
          typeof message === "string" ? message : defaultMessage
        );
        notEnumerableProp2(this, "name", nameProperty);
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        } else {
          Error.call(this);
        }
      }
      __name(SubError, "SubError");
      inherits2(SubError, Error);
      return SubError;
    }
    __name(subError, "subError");
    var _TypeError;
    var _RangeError;
    var Warning = subError("Warning", "warning");
    var CancellationError = subError("CancellationError", "cancellation error");
    var TimeoutError = subError("TimeoutError", "timeout error");
    var AggregateError = subError("AggregateError", "aggregate error");
    try {
      _TypeError = TypeError;
      _RangeError = RangeError;
    } catch (e2) {
      _TypeError = subError("TypeError", "type error");
      _RangeError = subError("RangeError", "range error");
    }
    var methods = "join pop push shift unshift slice filter forEach some every map indexOf lastIndexOf reduce reduceRight sort reverse".split(" ");
    for (i2 = 0; i2 < methods.length; ++i2) {
      if (typeof Array.prototype[methods[i2]] === "function") {
        AggregateError.prototype[methods[i2]] = Array.prototype[methods[i2]];
      }
    }
    var i2;
    es52.defineProperty(AggregateError.prototype, "length", {
      value: 0,
      configurable: false,
      writable: true,
      enumerable: true
    });
    AggregateError.prototype["isOperational"] = true;
    var level = 0;
    AggregateError.prototype.toString = function() {
      var indent = Array(level * 4 + 1).join(" ");
      var ret2 = "\n" + indent + "AggregateError of:\n";
      level++;
      indent = Array(level * 4 + 1).join(" ");
      for (var i3 = 0; i3 < this.length; ++i3) {
        var str = this[i3] === this ? "[Circular AggregateError]" : this[i3] + "";
        var lines = str.split("\n");
        for (var j2 = 0; j2 < lines.length; ++j2) {
          lines[j2] = indent + lines[j2];
        }
        str = lines.join("\n");
        ret2 += str + "\n";
      }
      level--;
      return ret2;
    };
    function OperationalError(message) {
      if (!(this instanceof OperationalError))
        return new OperationalError(message);
      notEnumerableProp2(this, "name", "OperationalError");
      notEnumerableProp2(this, "message", message);
      this.cause = message;
      this["isOperational"] = true;
      if (message instanceof Error) {
        notEnumerableProp2(this, "message", message.message);
        notEnumerableProp2(this, "stack", message.stack);
      } else if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      }
    }
    __name(OperationalError, "OperationalError");
    inherits2(OperationalError, Error);
    var errorTypes = Error["__BluebirdErrorTypes__"];
    if (!errorTypes) {
      errorTypes = Objectfreeze({
        CancellationError,
        TimeoutError,
        OperationalError,
        RejectionError: OperationalError,
        AggregateError
      });
      es52.defineProperty(Error, "__BluebirdErrorTypes__", {
        value: errorTypes,
        writable: false,
        enumerable: false,
        configurable: false
      });
    }
    module2.exports = {
      Error,
      TypeError: _TypeError,
      RangeError: _RangeError,
      CancellationError: errorTypes.CancellationError,
      OperationalError: errorTypes.OperationalError,
      TimeoutError: errorTypes.TimeoutError,
      AggregateError: errorTypes.AggregateError,
      Warning
    };
  }
});

// node_modules/bluebird/js/release/thenables.js
var require_thenables = __commonJS({
  "node_modules/bluebird/js/release/thenables.js"(exports2, module2) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = function(Promise2, INTERNAL) {
      var util = require_util();
      var errorObj2 = util.errorObj;
      var isObject2 = util.isObject;
      function tryConvertToPromise(obj2, context2) {
        if (isObject2(obj2)) {
          if (obj2 instanceof Promise2)
            return obj2;
          var then = getThen(obj2);
          if (then === errorObj2) {
            if (context2)
              context2._pushContext();
            var ret2 = Promise2.reject(then.e);
            if (context2)
              context2._popContext();
            return ret2;
          } else if (typeof then === "function") {
            if (isAnyBluebirdPromise(obj2)) {
              var ret2 = new Promise2(INTERNAL);
              obj2._then(
                ret2._fulfill,
                ret2._reject,
                void 0,
                ret2,
                null
              );
              return ret2;
            }
            return doThenable(obj2, then, context2);
          }
        }
        return obj2;
      }
      __name(tryConvertToPromise, "tryConvertToPromise");
      function doGetThen(obj2) {
        return obj2.then;
      }
      __name(doGetThen, "doGetThen");
      function getThen(obj2) {
        try {
          return doGetThen(obj2);
        } catch (e2) {
          errorObj2.e = e2;
          return errorObj2;
        }
      }
      __name(getThen, "getThen");
      var hasProp = {}.hasOwnProperty;
      function isAnyBluebirdPromise(obj2) {
        try {
          return hasProp.call(obj2, "_promise0");
        } catch (e2) {
          return false;
        }
      }
      __name(isAnyBluebirdPromise, "isAnyBluebirdPromise");
      function doThenable(x2, then, context2) {
        var promise = new Promise2(INTERNAL);
        var ret2 = promise;
        if (context2)
          context2._pushContext();
        promise._captureStackTrace();
        if (context2)
          context2._popContext();
        var synchronous = true;
        var result = util.tryCatch(then).call(x2, resolve, reject);
        synchronous = false;
        if (promise && result === errorObj2) {
          promise._rejectCallback(result.e, true, true);
          promise = null;
        }
        function resolve(value) {
          if (!promise)
            return;
          promise._resolveCallback(value);
          promise = null;
        }
        __name(resolve, "resolve");
        function reject(reason) {
          if (!promise)
            return;
          promise._rejectCallback(reason, synchronous, true);
          promise = null;
        }
        __name(reject, "reject");
        return ret2;
      }
      __name(doThenable, "doThenable");
      return tryConvertToPromise;
    };
  }
});

// node_modules/bluebird/js/release/promise_array.js
var require_promise_array = __commonJS({
  "node_modules/bluebird/js/release/promise_array.js"(exports2, module2) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection, Proxyable) {
      var util = require_util();
      var isArray = util.isArray;
      function toResolutionValue(val) {
        switch (val) {
          case -2:
            return [];
          case -3:
            return {};
        }
      }
      __name(toResolutionValue, "toResolutionValue");
      function PromiseArray(values) {
        var promise = this._promise = new Promise2(INTERNAL);
        if (values instanceof Promise2) {
          promise._propagateFrom(values, 3);
        }
        promise._setOnCancel(this);
        this._values = values;
        this._length = 0;
        this._totalResolved = 0;
        this._init(void 0, -2);
      }
      __name(PromiseArray, "PromiseArray");
      util.inherits(PromiseArray, Proxyable);
      PromiseArray.prototype.length = function() {
        return this._length;
      };
      PromiseArray.prototype.promise = function() {
        return this._promise;
      };
      PromiseArray.prototype._init = /* @__PURE__ */ __name(function init(_2, resolveValueIfEmpty) {
        var values = tryConvertToPromise(this._values, this._promise);
        if (values instanceof Promise2) {
          values = values._target();
          var bitField = values._bitField;
          ;
          this._values = values;
          if ((bitField & 50397184) === 0) {
            this._promise._setAsyncGuaranteed();
            return values._then(
              init,
              this._reject,
              void 0,
              this,
              resolveValueIfEmpty
            );
          } else if ((bitField & 33554432) !== 0) {
            values = values._value();
          } else if ((bitField & 16777216) !== 0) {
            return this._reject(values._reason());
          } else {
            return this._cancel();
          }
        }
        values = util.asArray(values);
        if (values === null) {
          var err = apiRejection(
            "expecting an array or an iterable object but got " + util.classString(values)
          ).reason();
          this._promise._rejectCallback(err, false);
          return;
        }
        if (values.length === 0) {
          if (resolveValueIfEmpty === -5) {
            this._resolveEmptyArray();
          } else {
            this._resolve(toResolutionValue(resolveValueIfEmpty));
          }
          return;
        }
        this._iterate(values);
      }, "init");
      PromiseArray.prototype._iterate = function(values) {
        var len = this.getActualLength(values.length);
        this._length = len;
        this._values = this.shouldCopyValues() ? new Array(len) : this._values;
        var result = this._promise;
        var isResolved = false;
        var bitField = null;
        for (var i2 = 0; i2 < len; ++i2) {
          var maybePromise = tryConvertToPromise(values[i2], result);
          if (maybePromise instanceof Promise2) {
            maybePromise = maybePromise._target();
            bitField = maybePromise._bitField;
          } else {
            bitField = null;
          }
          if (isResolved) {
            if (bitField !== null) {
              maybePromise.suppressUnhandledRejections();
            }
          } else if (bitField !== null) {
            if ((bitField & 50397184) === 0) {
              maybePromise._proxy(this, i2);
              this._values[i2] = maybePromise;
            } else if ((bitField & 33554432) !== 0) {
              isResolved = this._promiseFulfilled(maybePromise._value(), i2);
            } else if ((bitField & 16777216) !== 0) {
              isResolved = this._promiseRejected(maybePromise._reason(), i2);
            } else {
              isResolved = this._promiseCancelled(i2);
            }
          } else {
            isResolved = this._promiseFulfilled(maybePromise, i2);
          }
        }
        if (!isResolved)
          result._setAsyncGuaranteed();
      };
      PromiseArray.prototype._isResolved = function() {
        return this._values === null;
      };
      PromiseArray.prototype._resolve = function(value) {
        this._values = null;
        this._promise._fulfill(value);
      };
      PromiseArray.prototype._cancel = function() {
        if (this._isResolved() || !this._promise._isCancellable())
          return;
        this._values = null;
        this._promise._cancel();
      };
      PromiseArray.prototype._reject = function(reason) {
        this._values = null;
        this._promise._rejectCallback(reason, false);
      };
      PromiseArray.prototype._promiseFulfilled = function(value, index) {
        this._values[index] = value;
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= this._length) {
          this._resolve(this._values);
          return true;
        }
        return false;
      };
      PromiseArray.prototype._promiseCancelled = function() {
        this._cancel();
        return true;
      };
      PromiseArray.prototype._promiseRejected = function(reason) {
        this._totalResolved++;
        this._reject(reason);
        return true;
      };
      PromiseArray.prototype._resultCancelled = function() {
        if (this._isResolved())
          return;
        var values = this._values;
        this._cancel();
        if (values instanceof Promise2) {
          values.cancel();
        } else {
          for (var i2 = 0; i2 < values.length; ++i2) {
            if (values[i2] instanceof Promise2) {
              values[i2].cancel();
            }
          }
        }
      };
      PromiseArray.prototype.shouldCopyValues = function() {
        return true;
      };
      PromiseArray.prototype.getActualLength = function(len) {
        return len;
      };
      return PromiseArray;
    };
  }
});

// node_modules/bluebird/js/release/context.js
var require_context = __commonJS({
  "node_modules/bluebird/js/release/context.js"(exports2, module2) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = function(Promise2) {
      var longStackTraces = false;
      var contextStack = [];
      Promise2.prototype._promiseCreated = function() {
      };
      Promise2.prototype._pushContext = function() {
      };
      Promise2.prototype._popContext = function() {
        return null;
      };
      Promise2._peekContext = Promise2.prototype._peekContext = function() {
      };
      function Context() {
        this._trace = new Context.CapturedTrace(peekContext());
      }
      __name(Context, "Context");
      Context.prototype._pushContext = function() {
        if (this._trace !== void 0) {
          this._trace._promiseCreated = null;
          contextStack.push(this._trace);
        }
      };
      Context.prototype._popContext = function() {
        if (this._trace !== void 0) {
          var trace3 = contextStack.pop();
          var ret2 = trace3._promiseCreated;
          trace3._promiseCreated = null;
          return ret2;
        }
        return null;
      };
      function createContext() {
        if (longStackTraces)
          return new Context();
      }
      __name(createContext, "createContext");
      function peekContext() {
        var lastIndex = contextStack.length - 1;
        if (lastIndex >= 0) {
          return contextStack[lastIndex];
        }
        return void 0;
      }
      __name(peekContext, "peekContext");
      Context.CapturedTrace = null;
      Context.create = createContext;
      Context.deactivateLongStackTraces = function() {
      };
      Context.activateLongStackTraces = function() {
        var Promise_pushContext = Promise2.prototype._pushContext;
        var Promise_popContext = Promise2.prototype._popContext;
        var Promise_PeekContext = Promise2._peekContext;
        var Promise_peekContext = Promise2.prototype._peekContext;
        var Promise_promiseCreated = Promise2.prototype._promiseCreated;
        Context.deactivateLongStackTraces = function() {
          Promise2.prototype._pushContext = Promise_pushContext;
          Promise2.prototype._popContext = Promise_popContext;
          Promise2._peekContext = Promise_PeekContext;
          Promise2.prototype._peekContext = Promise_peekContext;
          Promise2.prototype._promiseCreated = Promise_promiseCreated;
          longStackTraces = false;
        };
        longStackTraces = true;
        Promise2.prototype._pushContext = Context.prototype._pushContext;
        Promise2.prototype._popContext = Context.prototype._popContext;
        Promise2._peekContext = Promise2.prototype._peekContext = peekContext;
        Promise2.prototype._promiseCreated = function() {
          var ctx = this._peekContext();
          if (ctx && ctx._promiseCreated == null)
            ctx._promiseCreated = this;
        };
      };
      return Context;
    };
  }
});

// node_modules/bluebird/js/release/debuggability.js
var require_debuggability = __commonJS({
  "node_modules/bluebird/js/release/debuggability.js"(exports2, module2) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = function(Promise2, Context) {
      var getDomain = Promise2._getDomain;
      var async = Promise2._async;
      var Warning = require_errors().Warning;
      var util = require_util();
      var canAttachTrace2 = util.canAttachTrace;
      var unhandledRejectionHandled;
      var possiblyUnhandledRejection;
      var bluebirdFramePattern = /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/;
      var nodeFramePattern = /\((?:timers\.js):\d+:\d+\)/;
      var parseLinePattern = /[\/<\(](.+?):(\d+):(\d+)\)?\s*$/;
      var stackFramePattern = null;
      var formatStack = null;
      var indentStackFrames = false;
      var printWarning;
      var debugging = !!(util.env("BLUEBIRD_DEBUG") != 0 && (util.env("BLUEBIRD_DEBUG") || util.env("NODE_ENV") === "development"));
      var warnings = !!(util.env("BLUEBIRD_WARNINGS") != 0 && (debugging || util.env("BLUEBIRD_WARNINGS")));
      var longStackTraces = !!(util.env("BLUEBIRD_LONG_STACK_TRACES") != 0 && (debugging || util.env("BLUEBIRD_LONG_STACK_TRACES")));
      var wForgottenReturn = util.env("BLUEBIRD_W_FORGOTTEN_RETURN") != 0 && (warnings || !!util.env("BLUEBIRD_W_FORGOTTEN_RETURN"));
      Promise2.prototype.suppressUnhandledRejections = function() {
        var target = this._target();
        target._bitField = target._bitField & ~1048576 | 524288;
      };
      Promise2.prototype._ensurePossibleRejectionHandled = function() {
        if ((this._bitField & 524288) !== 0)
          return;
        this._setRejectionIsUnhandled();
        async.invokeLater(this._notifyUnhandledRejection, this, void 0);
      };
      Promise2.prototype._notifyUnhandledRejectionIsHandled = function() {
        fireRejectionEvent(
          "rejectionHandled",
          unhandledRejectionHandled,
          void 0,
          this
        );
      };
      Promise2.prototype._setReturnedNonUndefined = function() {
        this._bitField = this._bitField | 268435456;
      };
      Promise2.prototype._returnedNonUndefined = function() {
        return (this._bitField & 268435456) !== 0;
      };
      Promise2.prototype._notifyUnhandledRejection = function() {
        if (this._isRejectionUnhandled()) {
          var reason = this._settledValue();
          this._setUnhandledRejectionIsNotified();
          fireRejectionEvent(
            "unhandledRejection",
            possiblyUnhandledRejection,
            reason,
            this
          );
        }
      };
      Promise2.prototype._setUnhandledRejectionIsNotified = function() {
        this._bitField = this._bitField | 262144;
      };
      Promise2.prototype._unsetUnhandledRejectionIsNotified = function() {
        this._bitField = this._bitField & ~262144;
      };
      Promise2.prototype._isUnhandledRejectionNotified = function() {
        return (this._bitField & 262144) > 0;
      };
      Promise2.prototype._setRejectionIsUnhandled = function() {
        this._bitField = this._bitField | 1048576;
      };
      Promise2.prototype._unsetRejectionIsUnhandled = function() {
        this._bitField = this._bitField & ~1048576;
        if (this._isUnhandledRejectionNotified()) {
          this._unsetUnhandledRejectionIsNotified();
          this._notifyUnhandledRejectionIsHandled();
        }
      };
      Promise2.prototype._isRejectionUnhandled = function() {
        return (this._bitField & 1048576) > 0;
      };
      Promise2.prototype._warn = function(message, shouldUseOwnTrace, promise) {
        return warn4(message, shouldUseOwnTrace, promise || this);
      };
      Promise2.onPossiblyUnhandledRejection = function(fn2) {
        var domain2 = getDomain();
        possiblyUnhandledRejection = typeof fn2 === "function" ? domain2 === null ? fn2 : util.domainBind(domain2, fn2) : void 0;
      };
      Promise2.onUnhandledRejectionHandled = function(fn2) {
        var domain2 = getDomain();
        unhandledRejectionHandled = typeof fn2 === "function" ? domain2 === null ? fn2 : util.domainBind(domain2, fn2) : void 0;
      };
      var disableLongStackTraces = /* @__PURE__ */ __name(function() {
      }, "disableLongStackTraces");
      Promise2.longStackTraces = function() {
        if (async.haveItemsQueued() && !config2.longStackTraces) {
          throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");
        }
        if (!config2.longStackTraces && longStackTracesIsSupported()) {
          var Promise_captureStackTrace = Promise2.prototype._captureStackTrace;
          var Promise_attachExtraTrace = Promise2.prototype._attachExtraTrace;
          config2.longStackTraces = true;
          disableLongStackTraces = /* @__PURE__ */ __name(function() {
            if (async.haveItemsQueued() && !config2.longStackTraces) {
              throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");
            }
            Promise2.prototype._captureStackTrace = Promise_captureStackTrace;
            Promise2.prototype._attachExtraTrace = Promise_attachExtraTrace;
            Context.deactivateLongStackTraces();
            async.enableTrampoline();
            config2.longStackTraces = false;
          }, "disableLongStackTraces");
          Promise2.prototype._captureStackTrace = longStackTracesCaptureStackTrace;
          Promise2.prototype._attachExtraTrace = longStackTracesAttachExtraTrace;
          Context.activateLongStackTraces();
          async.disableTrampolineIfNecessary();
        }
      };
      Promise2.hasLongStackTraces = function() {
        return config2.longStackTraces && longStackTracesIsSupported();
      };
      var fireDomEvent = function() {
        try {
          if (typeof CustomEvent === "function") {
            var event = new CustomEvent("CustomEvent");
            util.global.dispatchEvent(event);
            return function(name, event2) {
              var domEvent = new CustomEvent(name.toLowerCase(), {
                detail: event2,
                cancelable: true
              });
              return !util.global.dispatchEvent(domEvent);
            };
          } else if (typeof Event === "function") {
            var event = new Event("CustomEvent");
            util.global.dispatchEvent(event);
            return function(name, event2) {
              var domEvent = new Event(name.toLowerCase(), {
                cancelable: true
              });
              domEvent.detail = event2;
              return !util.global.dispatchEvent(domEvent);
            };
          } else {
            var event = document.createEvent("CustomEvent");
            event.initCustomEvent("testingtheevent", false, true, {});
            util.global.dispatchEvent(event);
            return function(name, event2) {
              var domEvent = document.createEvent("CustomEvent");
              domEvent.initCustomEvent(
                name.toLowerCase(),
                false,
                true,
                event2
              );
              return !util.global.dispatchEvent(domEvent);
            };
          }
        } catch (e2) {
        }
        return function() {
          return false;
        };
      }();
      var fireGlobalEvent = function() {
        if (util.isNode) {
          return function() {
            return process.emit.apply(process, arguments);
          };
        } else {
          if (!util.global) {
            return function() {
              return false;
            };
          }
          return function(name) {
            var methodName = "on" + name.toLowerCase();
            var method = util.global[methodName];
            if (!method)
              return false;
            method.apply(util.global, [].slice.call(arguments, 1));
            return true;
          };
        }
      }();
      function generatePromiseLifecycleEventObject(name, promise) {
        return { promise };
      }
      __name(generatePromiseLifecycleEventObject, "generatePromiseLifecycleEventObject");
      var eventToObjectGenerator = {
        promiseCreated: generatePromiseLifecycleEventObject,
        promiseFulfilled: generatePromiseLifecycleEventObject,
        promiseRejected: generatePromiseLifecycleEventObject,
        promiseResolved: generatePromiseLifecycleEventObject,
        promiseCancelled: generatePromiseLifecycleEventObject,
        promiseChained: function(name, promise, child) {
          return { promise, child };
        },
        warning: function(name, warning) {
          return { warning };
        },
        unhandledRejection: function(name, reason, promise) {
          return { reason, promise };
        },
        rejectionHandled: generatePromiseLifecycleEventObject
      };
      var activeFireEvent = /* @__PURE__ */ __name(function(name) {
        var globalEventFired = false;
        try {
          globalEventFired = fireGlobalEvent.apply(null, arguments);
        } catch (e2) {
          async.throwLater(e2);
          globalEventFired = true;
        }
        var domEventFired = false;
        try {
          domEventFired = fireDomEvent(
            name,
            eventToObjectGenerator[name].apply(null, arguments)
          );
        } catch (e2) {
          async.throwLater(e2);
          domEventFired = true;
        }
        return domEventFired || globalEventFired;
      }, "activeFireEvent");
      Promise2.config = function(opts) {
        opts = Object(opts);
        if ("longStackTraces" in opts) {
          if (opts.longStackTraces) {
            Promise2.longStackTraces();
          } else if (!opts.longStackTraces && Promise2.hasLongStackTraces()) {
            disableLongStackTraces();
          }
        }
        if ("warnings" in opts) {
          var warningsOption = opts.warnings;
          config2.warnings = !!warningsOption;
          wForgottenReturn = config2.warnings;
          if (util.isObject(warningsOption)) {
            if ("wForgottenReturn" in warningsOption) {
              wForgottenReturn = !!warningsOption.wForgottenReturn;
            }
          }
        }
        if ("cancellation" in opts && opts.cancellation && !config2.cancellation) {
          if (async.haveItemsQueued()) {
            throw new Error(
              "cannot enable cancellation after promises are in use"
            );
          }
          Promise2.prototype._clearCancellationData = cancellationClearCancellationData;
          Promise2.prototype._propagateFrom = cancellationPropagateFrom;
          Promise2.prototype._onCancel = cancellationOnCancel;
          Promise2.prototype._setOnCancel = cancellationSetOnCancel;
          Promise2.prototype._attachCancellationCallback = cancellationAttachCancellationCallback;
          Promise2.prototype._execute = cancellationExecute;
          propagateFromFunction = cancellationPropagateFrom;
          config2.cancellation = true;
        }
        if ("monitoring" in opts) {
          if (opts.monitoring && !config2.monitoring) {
            config2.monitoring = true;
            Promise2.prototype._fireEvent = activeFireEvent;
          } else if (!opts.monitoring && config2.monitoring) {
            config2.monitoring = false;
            Promise2.prototype._fireEvent = defaultFireEvent;
          }
        }
        return Promise2;
      };
      function defaultFireEvent() {
        return false;
      }
      __name(defaultFireEvent, "defaultFireEvent");
      Promise2.prototype._fireEvent = defaultFireEvent;
      Promise2.prototype._execute = function(executor, resolve, reject) {
        try {
          executor(resolve, reject);
        } catch (e2) {
          return e2;
        }
      };
      Promise2.prototype._onCancel = function() {
      };
      Promise2.prototype._setOnCancel = function(handler) {
        ;
      };
      Promise2.prototype._attachCancellationCallback = function(onCancel) {
        ;
      };
      Promise2.prototype._captureStackTrace = function() {
      };
      Promise2.prototype._attachExtraTrace = function() {
      };
      Promise2.prototype._clearCancellationData = function() {
      };
      Promise2.prototype._propagateFrom = function(parent, flags) {
        ;
        ;
      };
      function cancellationExecute(executor, resolve, reject) {
        var promise = this;
        try {
          executor(resolve, reject, function(onCancel) {
            if (typeof onCancel !== "function") {
              throw new TypeError("onCancel must be a function, got: " + util.toString(onCancel));
            }
            promise._attachCancellationCallback(onCancel);
          });
        } catch (e2) {
          return e2;
        }
      }
      __name(cancellationExecute, "cancellationExecute");
      function cancellationAttachCancellationCallback(onCancel) {
        if (!this._isCancellable())
          return this;
        var previousOnCancel = this._onCancel();
        if (previousOnCancel !== void 0) {
          if (util.isArray(previousOnCancel)) {
            previousOnCancel.push(onCancel);
          } else {
            this._setOnCancel([previousOnCancel, onCancel]);
          }
        } else {
          this._setOnCancel(onCancel);
        }
      }
      __name(cancellationAttachCancellationCallback, "cancellationAttachCancellationCallback");
      function cancellationOnCancel() {
        return this._onCancelField;
      }
      __name(cancellationOnCancel, "cancellationOnCancel");
      function cancellationSetOnCancel(onCancel) {
        this._onCancelField = onCancel;
      }
      __name(cancellationSetOnCancel, "cancellationSetOnCancel");
      function cancellationClearCancellationData() {
        this._cancellationParent = void 0;
        this._onCancelField = void 0;
      }
      __name(cancellationClearCancellationData, "cancellationClearCancellationData");
      function cancellationPropagateFrom(parent, flags) {
        if ((flags & 1) !== 0) {
          this._cancellationParent = parent;
          var branchesRemainingToCancel = parent._branchesRemainingToCancel;
          if (branchesRemainingToCancel === void 0) {
            branchesRemainingToCancel = 0;
          }
          parent._branchesRemainingToCancel = branchesRemainingToCancel + 1;
        }
        if ((flags & 2) !== 0 && parent._isBound()) {
          this._setBoundTo(parent._boundTo);
        }
      }
      __name(cancellationPropagateFrom, "cancellationPropagateFrom");
      function bindingPropagateFrom(parent, flags) {
        if ((flags & 2) !== 0 && parent._isBound()) {
          this._setBoundTo(parent._boundTo);
        }
      }
      __name(bindingPropagateFrom, "bindingPropagateFrom");
      var propagateFromFunction = bindingPropagateFrom;
      function boundValueFunction() {
        var ret2 = this._boundTo;
        if (ret2 !== void 0) {
          if (ret2 instanceof Promise2) {
            if (ret2.isFulfilled()) {
              return ret2.value();
            } else {
              return void 0;
            }
          }
        }
        return ret2;
      }
      __name(boundValueFunction, "boundValueFunction");
      function longStackTracesCaptureStackTrace() {
        this._trace = new CapturedTrace(this._peekContext());
      }
      __name(longStackTracesCaptureStackTrace, "longStackTracesCaptureStackTrace");
      function longStackTracesAttachExtraTrace(error3, ignoreSelf) {
        if (canAttachTrace2(error3)) {
          var trace3 = this._trace;
          if (trace3 !== void 0) {
            if (ignoreSelf)
              trace3 = trace3._parent;
          }
          if (trace3 !== void 0) {
            trace3.attachExtraTrace(error3);
          } else if (!error3.__stackCleaned__) {
            var parsed = parseStackAndMessage(error3);
            util.notEnumerableProp(
              error3,
              "stack",
              parsed.message + "\n" + parsed.stack.join("\n")
            );
            util.notEnumerableProp(error3, "__stackCleaned__", true);
          }
        }
      }
      __name(longStackTracesAttachExtraTrace, "longStackTracesAttachExtraTrace");
      function checkForgottenReturns(returnValue, promiseCreated, name, promise, parent) {
        if (returnValue === void 0 && promiseCreated !== null && wForgottenReturn) {
          if (parent !== void 0 && parent._returnedNonUndefined())
            return;
          if ((promise._bitField & 65535) === 0)
            return;
          if (name)
            name = name + " ";
          var handlerLine = "";
          var creatorLine = "";
          if (promiseCreated._trace) {
            var traceLines = promiseCreated._trace.stack.split("\n");
            var stack = cleanStack(traceLines);
            for (var i2 = stack.length - 1; i2 >= 0; --i2) {
              var line = stack[i2];
              if (!nodeFramePattern.test(line)) {
                var lineMatches = line.match(parseLinePattern);
                if (lineMatches) {
                  handlerLine = "at " + lineMatches[1] + ":" + lineMatches[2] + ":" + lineMatches[3] + " ";
                }
                break;
              }
            }
            if (stack.length > 0) {
              var firstUserLine = stack[0];
              for (var i2 = 0; i2 < traceLines.length; ++i2) {
                if (traceLines[i2] === firstUserLine) {
                  if (i2 > 0) {
                    creatorLine = "\n" + traceLines[i2 - 1];
                  }
                  break;
                }
              }
            }
          }
          var msg = "a promise was created in a " + name + "handler " + handlerLine + "but was not returned from it, see http://goo.gl/rRqMUw" + creatorLine;
          promise._warn(msg, true, promiseCreated);
        }
      }
      __name(checkForgottenReturns, "checkForgottenReturns");
      function deprecated(name, replacement) {
        var message = name + " is deprecated and will be removed in a future version.";
        if (replacement)
          message += " Use " + replacement + " instead.";
        return warn4(message);
      }
      __name(deprecated, "deprecated");
      function warn4(message, shouldUseOwnTrace, promise) {
        if (!config2.warnings)
          return;
        var warning = new Warning(message);
        var ctx;
        if (shouldUseOwnTrace) {
          promise._attachExtraTrace(warning);
        } else if (config2.longStackTraces && (ctx = Promise2._peekContext())) {
          ctx.attachExtraTrace(warning);
        } else {
          var parsed = parseStackAndMessage(warning);
          warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
        }
        if (!activeFireEvent("warning", warning)) {
          formatAndLogError(warning, "", true);
        }
      }
      __name(warn4, "warn");
      function reconstructStack(message, stacks) {
        for (var i2 = 0; i2 < stacks.length - 1; ++i2) {
          stacks[i2].push("From previous event:");
          stacks[i2] = stacks[i2].join("\n");
        }
        if (i2 < stacks.length) {
          stacks[i2] = stacks[i2].join("\n");
        }
        return message + "\n" + stacks.join("\n");
      }
      __name(reconstructStack, "reconstructStack");
      function removeDuplicateOrEmptyJumps(stacks) {
        for (var i2 = 0; i2 < stacks.length; ++i2) {
          if (stacks[i2].length === 0 || i2 + 1 < stacks.length && stacks[i2][0] === stacks[i2 + 1][0]) {
            stacks.splice(i2, 1);
            i2--;
          }
        }
      }
      __name(removeDuplicateOrEmptyJumps, "removeDuplicateOrEmptyJumps");
      function removeCommonRoots(stacks) {
        var current = stacks[0];
        for (var i2 = 1; i2 < stacks.length; ++i2) {
          var prev = stacks[i2];
          var currentLastIndex = current.length - 1;
          var currentLastLine = current[currentLastIndex];
          var commonRootMeetPoint = -1;
          for (var j2 = prev.length - 1; j2 >= 0; --j2) {
            if (prev[j2] === currentLastLine) {
              commonRootMeetPoint = j2;
              break;
            }
          }
          for (var j2 = commonRootMeetPoint; j2 >= 0; --j2) {
            var line = prev[j2];
            if (current[currentLastIndex] === line) {
              current.pop();
              currentLastIndex--;
            } else {
              break;
            }
          }
          current = prev;
        }
      }
      __name(removeCommonRoots, "removeCommonRoots");
      function cleanStack(stack) {
        var ret2 = [];
        for (var i2 = 0; i2 < stack.length; ++i2) {
          var line = stack[i2];
          var isTraceLine = "    (No stack trace)" === line || stackFramePattern.test(line);
          var isInternalFrame = isTraceLine && shouldIgnore(line);
          if (isTraceLine && !isInternalFrame) {
            if (indentStackFrames && line.charAt(0) !== " ") {
              line = "    " + line;
            }
            ret2.push(line);
          }
        }
        return ret2;
      }
      __name(cleanStack, "cleanStack");
      function stackFramesAsArray(error3) {
        var stack = error3.stack.replace(/\s+$/g, "").split("\n");
        for (var i2 = 0; i2 < stack.length; ++i2) {
          var line = stack[i2];
          if ("    (No stack trace)" === line || stackFramePattern.test(line)) {
            break;
          }
        }
        if (i2 > 0 && error3.name != "SyntaxError") {
          stack = stack.slice(i2);
        }
        return stack;
      }
      __name(stackFramesAsArray, "stackFramesAsArray");
      function parseStackAndMessage(error3) {
        var stack = error3.stack;
        var message = error3.toString();
        stack = typeof stack === "string" && stack.length > 0 ? stackFramesAsArray(error3) : ["    (No stack trace)"];
        return {
          message,
          stack: error3.name == "SyntaxError" ? stack : cleanStack(stack)
        };
      }
      __name(parseStackAndMessage, "parseStackAndMessage");
      function formatAndLogError(error3, title2, isSoft) {
        if (typeof console !== "undefined") {
          var message;
          if (util.isObject(error3)) {
            var stack = error3.stack;
            message = title2 + formatStack(stack, error3);
          } else {
            message = title2 + String(error3);
          }
          if (typeof printWarning === "function") {
            printWarning(message, isSoft);
          } else if (typeof console.log === "function" || typeof console.log === "object") {
            console.log(message);
          }
        }
      }
      __name(formatAndLogError, "formatAndLogError");
      function fireRejectionEvent(name, localHandler, reason, promise) {
        var localEventFired = false;
        try {
          if (typeof localHandler === "function") {
            localEventFired = true;
            if (name === "rejectionHandled") {
              localHandler(promise);
            } else {
              localHandler(reason, promise);
            }
          }
        } catch (e2) {
          async.throwLater(e2);
        }
        if (name === "unhandledRejection") {
          if (!activeFireEvent(name, reason, promise) && !localEventFired) {
            formatAndLogError(reason, "Unhandled rejection ");
          }
        } else {
          activeFireEvent(name, promise);
        }
      }
      __name(fireRejectionEvent, "fireRejectionEvent");
      function formatNonError(obj2) {
        var str;
        if (typeof obj2 === "function") {
          str = "[function " + (obj2.name || "anonymous") + "]";
        } else {
          str = obj2 && typeof obj2.toString === "function" ? obj2.toString() : util.toString(obj2);
          var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
          if (ruselessToString.test(str)) {
            try {
              var newStr = JSON.stringify(obj2);
              str = newStr;
            } catch (e2) {
            }
          }
          if (str.length === 0) {
            str = "(empty array)";
          }
        }
        return "(<" + snip(str) + ">, no stack trace)";
      }
      __name(formatNonError, "formatNonError");
      function snip(str) {
        var maxChars = 41;
        if (str.length < maxChars) {
          return str;
        }
        return str.substr(0, maxChars - 3) + "...";
      }
      __name(snip, "snip");
      function longStackTracesIsSupported() {
        return typeof captureStackTrace === "function";
      }
      __name(longStackTracesIsSupported, "longStackTracesIsSupported");
      var shouldIgnore = /* @__PURE__ */ __name(function() {
        return false;
      }, "shouldIgnore");
      var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
      function parseLineInfo(line) {
        var matches = line.match(parseLineInfoRegex);
        if (matches) {
          return {
            fileName: matches[1],
            line: parseInt(matches[2], 10)
          };
        }
      }
      __name(parseLineInfo, "parseLineInfo");
      function setBounds(firstLineError, lastLineError) {
        if (!longStackTracesIsSupported())
          return;
        var firstStackLines = firstLineError.stack.split("\n");
        var lastStackLines = lastLineError.stack.split("\n");
        var firstIndex = -1;
        var lastIndex = -1;
        var firstFileName;
        var lastFileName;
        for (var i2 = 0; i2 < firstStackLines.length; ++i2) {
          var result = parseLineInfo(firstStackLines[i2]);
          if (result) {
            firstFileName = result.fileName;
            firstIndex = result.line;
            break;
          }
        }
        for (var i2 = 0; i2 < lastStackLines.length; ++i2) {
          var result = parseLineInfo(lastStackLines[i2]);
          if (result) {
            lastFileName = result.fileName;
            lastIndex = result.line;
            break;
          }
        }
        if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName || firstFileName !== lastFileName || firstIndex >= lastIndex) {
          return;
        }
        shouldIgnore = /* @__PURE__ */ __name(function(line) {
          if (bluebirdFramePattern.test(line))
            return true;
          var info4 = parseLineInfo(line);
          if (info4) {
            if (info4.fileName === firstFileName && (firstIndex <= info4.line && info4.line <= lastIndex)) {
              return true;
            }
          }
          return false;
        }, "shouldIgnore");
      }
      __name(setBounds, "setBounds");
      function CapturedTrace(parent) {
        this._parent = parent;
        this._promisesCreated = 0;
        var length = this._length = 1 + (parent === void 0 ? 0 : parent._length);
        captureStackTrace(this, CapturedTrace);
        if (length > 32)
          this.uncycle();
      }
      __name(CapturedTrace, "CapturedTrace");
      util.inherits(CapturedTrace, Error);
      Context.CapturedTrace = CapturedTrace;
      CapturedTrace.prototype.uncycle = function() {
        var length = this._length;
        if (length < 2)
          return;
        var nodes = [];
        var stackToIndex = {};
        for (var i2 = 0, node = this; node !== void 0; ++i2) {
          nodes.push(node);
          node = node._parent;
        }
        length = this._length = i2;
        for (var i2 = length - 1; i2 >= 0; --i2) {
          var stack = nodes[i2].stack;
          if (stackToIndex[stack] === void 0) {
            stackToIndex[stack] = i2;
          }
        }
        for (var i2 = 0; i2 < length; ++i2) {
          var currentStack = nodes[i2].stack;
          var index = stackToIndex[currentStack];
          if (index !== void 0 && index !== i2) {
            if (index > 0) {
              nodes[index - 1]._parent = void 0;
              nodes[index - 1]._length = 1;
            }
            nodes[i2]._parent = void 0;
            nodes[i2]._length = 1;
            var cycleEdgeNode = i2 > 0 ? nodes[i2 - 1] : this;
            if (index < length - 1) {
              cycleEdgeNode._parent = nodes[index + 1];
              cycleEdgeNode._parent.uncycle();
              cycleEdgeNode._length = cycleEdgeNode._parent._length + 1;
            } else {
              cycleEdgeNode._parent = void 0;
              cycleEdgeNode._length = 1;
            }
            var currentChildLength = cycleEdgeNode._length + 1;
            for (var j2 = i2 - 2; j2 >= 0; --j2) {
              nodes[j2]._length = currentChildLength;
              currentChildLength++;
            }
            return;
          }
        }
      };
      CapturedTrace.prototype.attachExtraTrace = function(error3) {
        if (error3.__stackCleaned__)
          return;
        this.uncycle();
        var parsed = parseStackAndMessage(error3);
        var message = parsed.message;
        var stacks = [parsed.stack];
        var trace3 = this;
        while (trace3 !== void 0) {
          stacks.push(cleanStack(trace3.stack.split("\n")));
          trace3 = trace3._parent;
        }
        removeCommonRoots(stacks);
        removeDuplicateOrEmptyJumps(stacks);
        util.notEnumerableProp(error3, "stack", reconstructStack(message, stacks));
        util.notEnumerableProp(error3, "__stackCleaned__", true);
      };
      var captureStackTrace = (/* @__PURE__ */ __name(function stackDetection() {
        var v8stackFramePattern = /^\s*at\s*/;
        var v8stackFormatter = /* @__PURE__ */ __name(function(stack, error3) {
          if (typeof stack === "string")
            return stack;
          if (error3.name !== void 0 && error3.message !== void 0) {
            return error3.toString();
          }
          return formatNonError(error3);
        }, "v8stackFormatter");
        if (typeof Error.stackTraceLimit === "number" && typeof Error.captureStackTrace === "function") {
          Error.stackTraceLimit += 6;
          stackFramePattern = v8stackFramePattern;
          formatStack = v8stackFormatter;
          var captureStackTrace2 = Error.captureStackTrace;
          shouldIgnore = /* @__PURE__ */ __name(function(line) {
            return bluebirdFramePattern.test(line);
          }, "shouldIgnore");
          return function(receiver, ignoreUntil) {
            Error.stackTraceLimit += 6;
            captureStackTrace2(receiver, ignoreUntil);
            Error.stackTraceLimit -= 6;
          };
        }
        var err = new Error();
        if (typeof err.stack === "string" && err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
          stackFramePattern = /@/;
          formatStack = v8stackFormatter;
          indentStackFrames = true;
          return /* @__PURE__ */ __name(function captureStackTrace3(o2) {
            o2.stack = new Error().stack;
          }, "captureStackTrace");
        }
        var hasStackAfterThrow;
        try {
          throw new Error();
        } catch (e2) {
          hasStackAfterThrow = "stack" in e2;
        }
        if (!("stack" in err) && hasStackAfterThrow && typeof Error.stackTraceLimit === "number") {
          stackFramePattern = v8stackFramePattern;
          formatStack = v8stackFormatter;
          return /* @__PURE__ */ __name(function captureStackTrace3(o2) {
            Error.stackTraceLimit += 6;
            try {
              throw new Error();
            } catch (e2) {
              o2.stack = e2.stack;
            }
            Error.stackTraceLimit -= 6;
          }, "captureStackTrace");
        }
        formatStack = /* @__PURE__ */ __name(function(stack, error3) {
          if (typeof stack === "string")
            return stack;
          if ((typeof error3 === "object" || typeof error3 === "function") && error3.name !== void 0 && error3.message !== void 0) {
            return error3.toString();
          }
          return formatNonError(error3);
        }, "formatStack");
        return null;
      }, "stackDetection"))([]);
      if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
        printWarning = /* @__PURE__ */ __name(function(message) {
          console.warn(message);
        }, "printWarning");
        if (util.isNode && process.stderr.isTTY) {
          printWarning = /* @__PURE__ */ __name(function(message, isSoft) {
            var color = isSoft ? "\x1B[33m" : "\x1B[31m";
            console.warn(color + message + "\x1B[0m\n");
          }, "printWarning");
        } else if (!util.isNode && typeof new Error().stack === "string") {
          printWarning = /* @__PURE__ */ __name(function(message, isSoft) {
            console.warn(
              "%c" + message,
              isSoft ? "color: darkorange" : "color: red"
            );
          }, "printWarning");
        }
      }
      var config2 = {
        warnings,
        longStackTraces: false,
        cancellation: false,
        monitoring: false
      };
      if (longStackTraces)
        Promise2.longStackTraces();
      return {
        longStackTraces: function() {
          return config2.longStackTraces;
        },
        warnings: function() {
          return config2.warnings;
        },
        cancellation: function() {
          return config2.cancellation;
        },
        monitoring: function() {
          return config2.monitoring;
        },
        propagateFromFunction: function() {
          return propagateFromFunction;
        },
        boundValueFunction: function() {
          return boundValueFunction;
        },
        checkForgottenReturns,
        setBounds,
        warn: warn4,
        deprecated,
        CapturedTrace,
        fireDomEvent,
        fireGlobalEvent
      };
    };
  }
});

// node_modules/bluebird/js/release/finally.js
var require_finally = __commonJS({
  "node_modules/bluebird/js/release/finally.js"(exports2, module2) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = function(Promise2, tryConvertToPromise) {
      var util = require_util();
      var CancellationError = Promise2.CancellationError;
      var errorObj2 = util.errorObj;
      function PassThroughHandlerContext(promise, type, handler) {
        this.promise = promise;
        this.type = type;
        this.handler = handler;
        this.called = false;
        this.cancelPromise = null;
      }
      __name(PassThroughHandlerContext, "PassThroughHandlerContext");
      PassThroughHandlerContext.prototype.isFinallyHandler = function() {
        return this.type === 0;
      };
      function FinallyHandlerCancelReaction(finallyHandler2) {
        this.finallyHandler = finallyHandler2;
      }
      __name(FinallyHandlerCancelReaction, "FinallyHandlerCancelReaction");
      FinallyHandlerCancelReaction.prototype._resultCancelled = function() {
        checkCancel(this.finallyHandler);
      };
      function checkCancel(ctx, reason) {
        if (ctx.cancelPromise != null) {
          if (arguments.length > 1) {
            ctx.cancelPromise._reject(reason);
          } else {
            ctx.cancelPromise._cancel();
          }
          ctx.cancelPromise = null;
          return true;
        }
        return false;
      }
      __name(checkCancel, "checkCancel");
      function succeed() {
        return finallyHandler.call(this, this.promise._target()._settledValue());
      }
      __name(succeed, "succeed");
      function fail(reason) {
        if (checkCancel(this, reason))
          return;
        errorObj2.e = reason;
        return errorObj2;
      }
      __name(fail, "fail");
      function finallyHandler(reasonOrValue) {
        var promise = this.promise;
        var handler = this.handler;
        if (!this.called) {
          this.called = true;
          var ret2 = this.isFinallyHandler() ? handler.call(promise._boundValue()) : handler.call(promise._boundValue(), reasonOrValue);
          if (ret2 !== void 0) {
            promise._setReturnedNonUndefined();
            var maybePromise = tryConvertToPromise(ret2, promise);
            if (maybePromise instanceof Promise2) {
              if (this.cancelPromise != null) {
                if (maybePromise._isCancelled()) {
                  var reason = new CancellationError("late cancellation observer");
                  promise._attachExtraTrace(reason);
                  errorObj2.e = reason;
                  return errorObj2;
                } else if (maybePromise.isPending()) {
                  maybePromise._attachCancellationCallback(
                    new FinallyHandlerCancelReaction(this)
                  );
                }
              }
              return maybePromise._then(
                succeed,
                fail,
                void 0,
                this,
                void 0
              );
            }
          }
        }
        if (promise.isRejected()) {
          checkCancel(this);
          errorObj2.e = reasonOrValue;
          return errorObj2;
        } else {
          checkCancel(this);
          return reasonOrValue;
        }
      }
      __name(finallyHandler, "finallyHandler");
      Promise2.prototype._passThrough = function(handler, type, success, fail2) {
        if (typeof handler !== "function")
          return this.then();
        return this._then(
          success,
          fail2,
          void 0,
          new PassThroughHandlerContext(this, type, handler),
          void 0
        );
      };
      Promise2.prototype.lastly = Promise2.prototype["finally"] = function(handler) {
        return this._passThrough(
          handler,
          0,
          finallyHandler,
          finallyHandler
        );
      };
      Promise2.prototype.tap = function(handler) {
        return this._passThrough(handler, 1, finallyHandler);
      };
      return PassThroughHandlerContext;
    };
  }
});

// node_modules/bluebird/js/release/catch_filter.js
var require_catch_filter = __commonJS({
  "node_modules/bluebird/js/release/catch_filter.js"(exports2, module2) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = function(NEXT_FILTER) {
      var util = require_util();
      var getKeys = require_es5().keys;
      var tryCatch2 = util.tryCatch;
      var errorObj2 = util.errorObj;
      function catchFilter(instances, cb, promise) {
        return function(e2) {
          var boundTo = promise._boundValue();
          predicateLoop:
            for (var i2 = 0; i2 < instances.length; ++i2) {
              var item = instances[i2];
              if (item === Error || item != null && item.prototype instanceof Error) {
                if (e2 instanceof item) {
                  return tryCatch2(cb).call(boundTo, e2);
                }
              } else if (typeof item === "function") {
                var matchesPredicate = tryCatch2(item).call(boundTo, e2);
                if (matchesPredicate === errorObj2) {
                  return matchesPredicate;
                } else if (matchesPredicate) {
                  return tryCatch2(cb).call(boundTo, e2);
                }
              } else if (util.isObject(e2)) {
                var keys = getKeys(item);
                for (var j2 = 0; j2 < keys.length; ++j2) {
                  var key = keys[j2];
                  if (item[key] != e2[key]) {
                    continue predicateLoop;
                  }
                }
                return tryCatch2(cb).call(boundTo, e2);
              }
            }
          return NEXT_FILTER;
        };
      }
      __name(catchFilter, "catchFilter");
      return catchFilter;
    };
  }
});

// node_modules/bluebird/js/release/nodeback.js
var require_nodeback = __commonJS({
  "node_modules/bluebird/js/release/nodeback.js"(exports2, module2) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var util = require_util();
    var maybeWrapAsError2 = util.maybeWrapAsError;
    var errors = require_errors();
    var OperationalError = errors.OperationalError;
    var es52 = require_es5();
    function isUntypedError(obj2) {
      return obj2 instanceof Error && es52.getPrototypeOf(obj2) === Error.prototype;
    }
    __name(isUntypedError, "isUntypedError");
    var rErrorKey = /^(?:name|message|stack|cause)$/;
    function wrapAsOperationalError(obj2) {
      var ret2;
      if (isUntypedError(obj2)) {
        ret2 = new OperationalError(obj2);
        ret2.name = obj2.name;
        ret2.message = obj2.message;
        ret2.stack = obj2.stack;
        var keys = es52.keys(obj2);
        for (var i2 = 0; i2 < keys.length; ++i2) {
          var key = keys[i2];
          if (!rErrorKey.test(key)) {
            ret2[key] = obj2[key];
          }
        }
        return ret2;
      }
      util.markAsOriginatingFromRejection(obj2);
      return obj2;
    }
    __name(wrapAsOperationalError, "wrapAsOperationalError");
    function nodebackForPromise(promise, multiArgs) {
      return function(err, value) {
        if (promise === null)
          return;
        if (err) {
          var wrapped = wrapAsOperationalError(maybeWrapAsError2(err));
          promise._attachExtraTrace(wrapped);
          promise._reject(wrapped);
        } else if (!multiArgs) {
          promise._fulfill(value);
        } else {
          var $_len = arguments.length;
          var args = new Array(Math.max($_len - 1, 0));
          for (var $_i = 1; $_i < $_len; ++$_i) {
            args[$_i - 1] = arguments[$_i];
          }
          ;
          promise._fulfill(args);
        }
        promise = null;
      };
    }
    __name(nodebackForPromise, "nodebackForPromise");
    module2.exports = nodebackForPromise;
  }
});

// node_modules/bluebird/js/release/method.js
var require_method = __commonJS({
  "node_modules/bluebird/js/release/method.js"(exports2, module2) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection, debug3) {
      var util = require_util();
      var tryCatch2 = util.tryCatch;
      Promise2.method = function(fn2) {
        if (typeof fn2 !== "function") {
          throw new Promise2.TypeError("expecting a function but got " + util.classString(fn2));
        }
        return function() {
          var ret2 = new Promise2(INTERNAL);
          ret2._captureStackTrace();
          ret2._pushContext();
          var value = tryCatch2(fn2).apply(this, arguments);
          var promiseCreated = ret2._popContext();
          debug3.checkForgottenReturns(
            value,
            promiseCreated,
            "Promise.method",
            ret2
          );
          ret2._resolveFromSyncValue(value);
          return ret2;
        };
      };
      Promise2.attempt = Promise2["try"] = function(fn2) {
        if (typeof fn2 !== "function") {
          return apiRejection("expecting a function but got " + util.classString(fn2));
        }
        var ret2 = new Promise2(INTERNAL);
        ret2._captureStackTrace();
        ret2._pushContext();
        var value;
        if (arguments.length > 1) {
          debug3.deprecated("calling Promise.try with more than 1 argument");
          var arg = arguments[1];
          var ctx = arguments[2];
          value = util.isArray(arg) ? tryCatch2(fn2).apply(ctx, arg) : tryCatch2(fn2).call(ctx, arg);
        } else {
          value = tryCatch2(fn2)();
        }
        var promiseCreated = ret2._popContext();
        debug3.checkForgottenReturns(
          value,
          promiseCreated,
          "Promise.try",
          ret2
        );
        ret2._resolveFromSyncValue(value);
        return ret2;
      };
      Promise2.prototype._resolveFromSyncValue = function(value) {
        if (value === util.errorObj) {
          this._rejectCallback(value.e, false);
        } else {
          this._resolveCallback(value, true);
        }
      };
    };
  }
});

// node_modules/bluebird/js/release/bind.js
var require_bind = __commonJS({
  "node_modules/bluebird/js/release/bind.js"(exports2, module2) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, debug3) {
      var calledBind = false;
      var rejectThis = /* @__PURE__ */ __name(function(_2, e2) {
        this._reject(e2);
      }, "rejectThis");
      var targetRejected = /* @__PURE__ */ __name(function(e2, context2) {
        context2.promiseRejectionQueued = true;
        context2.bindingPromise._then(rejectThis, rejectThis, null, this, e2);
      }, "targetRejected");
      var bindingResolved = /* @__PURE__ */ __name(function(thisArg, context2) {
        if ((this._bitField & 50397184) === 0) {
          this._resolveCallback(context2.target);
        }
      }, "bindingResolved");
      var bindingRejected = /* @__PURE__ */ __name(function(e2, context2) {
        if (!context2.promiseRejectionQueued)
          this._reject(e2);
      }, "bindingRejected");
      Promise2.prototype.bind = function(thisArg) {
        if (!calledBind) {
          calledBind = true;
          Promise2.prototype._propagateFrom = debug3.propagateFromFunction();
          Promise2.prototype._boundValue = debug3.boundValueFunction();
        }
        var maybePromise = tryConvertToPromise(thisArg);
        var ret2 = new Promise2(INTERNAL);
        ret2._propagateFrom(this, 1);
        var target = this._target();
        ret2._setBoundTo(maybePromise);
        if (maybePromise instanceof Promise2) {
          var context2 = {
            promiseRejectionQueued: false,
            promise: ret2,
            target,
            bindingPromise: maybePromise
          };
          target._then(INTERNAL, targetRejected, void 0, ret2, context2);
          maybePromise._then(
            bindingResolved,
            bindingRejected,
            void 0,
            ret2,
            context2
          );
          ret2._setOnCancel(maybePromise);
        } else {
          ret2._resolveCallback(target);
        }
        return ret2;
      };
      Promise2.prototype._setBoundTo = function(obj2) {
        if (obj2 !== void 0) {
          this._bitField = this._bitField | 2097152;
          this._boundTo = obj2;
        } else {
          this._bitField = this._bitField & ~2097152;
        }
      };
      Promise2.prototype._isBound = function() {
        return (this._bitField & 2097152) === 2097152;
      };
      Promise2.bind = function(thisArg, value) {
        return Promise2.resolve(value).bind(thisArg);
      };
    };
  }
});

// node_modules/bluebird/js/release/cancel.js
var require_cancel = __commonJS({
  "node_modules/bluebird/js/release/cancel.js"(exports2, module2) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = function(Promise2, PromiseArray, apiRejection, debug3) {
      var util = require_util();
      var tryCatch2 = util.tryCatch;
      var errorObj2 = util.errorObj;
      var async = Promise2._async;
      Promise2.prototype["break"] = Promise2.prototype.cancel = function() {
        if (!debug3.cancellation())
          return this._warn("cancellation is disabled");
        var promise = this;
        var child = promise;
        while (promise._isCancellable()) {
          if (!promise._cancelBy(child)) {
            if (child._isFollowing()) {
              child._followee().cancel();
            } else {
              child._cancelBranched();
            }
            break;
          }
          var parent = promise._cancellationParent;
          if (parent == null || !parent._isCancellable()) {
            if (promise._isFollowing()) {
              promise._followee().cancel();
            } else {
              promise._cancelBranched();
            }
            break;
          } else {
            if (promise._isFollowing())
              promise._followee().cancel();
            promise._setWillBeCancelled();
            child = promise;
            promise = parent;
          }
        }
      };
      Promise2.prototype._branchHasCancelled = function() {
        this._branchesRemainingToCancel--;
      };
      Promise2.prototype._enoughBranchesHaveCancelled = function() {
        return this._branchesRemainingToCancel === void 0 || this._branchesRemainingToCancel <= 0;
      };
      Promise2.prototype._cancelBy = function(canceller) {
        if (canceller === this) {
          this._branchesRemainingToCancel = 0;
          this._invokeOnCancel();
          return true;
        } else {
          this._branchHasCancelled();
          if (this._enoughBranchesHaveCancelled()) {
            this._invokeOnCancel();
            return true;
          }
        }
        return false;
      };
      Promise2.prototype._cancelBranched = function() {
        if (this._enoughBranchesHaveCancelled()) {
          this._cancel();
        }
      };
      Promise2.prototype._cancel = function() {
        if (!this._isCancellable())
          return;
        this._setCancelled();
        async.invoke(this._cancelPromises, this, void 0);
      };
      Promise2.prototype._cancelPromises = function() {
        if (this._length() > 0)
          this._settlePromises();
      };
      Promise2.prototype._unsetOnCancel = function() {
        this._onCancelField = void 0;
      };
      Promise2.prototype._isCancellable = function() {
        return this.isPending() && !this._isCancelled();
      };
      Promise2.prototype.isCancellable = function() {
        return this.isPending() && !this.isCancelled();
      };
      Promise2.prototype._doInvokeOnCancel = function(onCancelCallback, internalOnly) {
        if (util.isArray(onCancelCallback)) {
          for (var i2 = 0; i2 < onCancelCallback.length; ++i2) {
            this._doInvokeOnCancel(onCancelCallback[i2], internalOnly);
          }
        } else if (onCancelCallback !== void 0) {
          if (typeof onCancelCallback === "function") {
            if (!internalOnly) {
              var e2 = tryCatch2(onCancelCallback).call(this._boundValue());
              if (e2 === errorObj2) {
                this._attachExtraTrace(e2.e);
                async.throwLater(e2.e);
              }
            }
          } else {
            onCancelCallback._resultCancelled(this);
          }
        }
      };
      Promise2.prototype._invokeOnCancel = function() {
        var onCancelCallback = this._onCancel();
        this._unsetOnCancel();
        async.invoke(this._doInvokeOnCancel, this, onCancelCallback);
      };
      Promise2.prototype._invokeInternalOnCancel = function() {
        if (this._isCancellable()) {
          this._doInvokeOnCancel(this._onCancel(), true);
          this._unsetOnCancel();
        }
      };
      Promise2.prototype._resultCancelled = function() {
        this.cancel();
      };
    };
  }
});

// node_modules/bluebird/js/release/direct_resolve.js
var require_direct_resolve = __commonJS({
  "node_modules/bluebird/js/release/direct_resolve.js"(exports2, module2) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = function(Promise2) {
      function returner() {
        return this.value;
      }
      __name(returner, "returner");
      function thrower2() {
        throw this.reason;
      }
      __name(thrower2, "thrower");
      Promise2.prototype["return"] = Promise2.prototype.thenReturn = function(value) {
        if (value instanceof Promise2)
          value.suppressUnhandledRejections();
        return this._then(
          returner,
          void 0,
          void 0,
          { value },
          void 0
        );
      };
      Promise2.prototype["throw"] = Promise2.prototype.thenThrow = function(reason) {
        return this._then(
          thrower2,
          void 0,
          void 0,
          { reason },
          void 0
        );
      };
      Promise2.prototype.catchThrow = function(reason) {
        if (arguments.length <= 1) {
          return this._then(
            void 0,
            thrower2,
            void 0,
            { reason },
            void 0
          );
        } else {
          var _reason = arguments[1];
          var handler = /* @__PURE__ */ __name(function() {
            throw _reason;
          }, "handler");
          return this.caught(reason, handler);
        }
      };
      Promise2.prototype.catchReturn = function(value) {
        if (arguments.length <= 1) {
          if (value instanceof Promise2)
            value.suppressUnhandledRejections();
          return this._then(
            void 0,
            returner,
            void 0,
            { value },
            void 0
          );
        } else {
          var _value = arguments[1];
          if (_value instanceof Promise2)
            _value.suppressUnhandledRejections();
          var handler = /* @__PURE__ */ __name(function() {
            return _value;
          }, "handler");
          return this.caught(value, handler);
        }
      };
    };
  }
});

// node_modules/bluebird/js/release/synchronous_inspection.js
var require_synchronous_inspection = __commonJS({
  "node_modules/bluebird/js/release/synchronous_inspection.js"(exports2, module2) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = function(Promise2) {
      function PromiseInspection(promise) {
        if (promise !== void 0) {
          promise = promise._target();
          this._bitField = promise._bitField;
          this._settledValueField = promise._isFateSealed() ? promise._settledValue() : void 0;
        } else {
          this._bitField = 0;
          this._settledValueField = void 0;
        }
      }
      __name(PromiseInspection, "PromiseInspection");
      PromiseInspection.prototype._settledValue = function() {
        return this._settledValueField;
      };
      var value = PromiseInspection.prototype.value = function() {
        if (!this.isFulfilled()) {
          throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n");
        }
        return this._settledValue();
      };
      var reason = PromiseInspection.prototype.error = PromiseInspection.prototype.reason = function() {
        if (!this.isRejected()) {
          throw new TypeError("cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n");
        }
        return this._settledValue();
      };
      var isFulfilled = PromiseInspection.prototype.isFulfilled = function() {
        return (this._bitField & 33554432) !== 0;
      };
      var isRejected = PromiseInspection.prototype.isRejected = function() {
        return (this._bitField & 16777216) !== 0;
      };
      var isPending = PromiseInspection.prototype.isPending = function() {
        return (this._bitField & 50397184) === 0;
      };
      var isResolved = PromiseInspection.prototype.isResolved = function() {
        return (this._bitField & 50331648) !== 0;
      };
      PromiseInspection.prototype.isCancelled = function() {
        return (this._bitField & 8454144) !== 0;
      };
      Promise2.prototype.__isCancelled = function() {
        return (this._bitField & 65536) === 65536;
      };
      Promise2.prototype._isCancelled = function() {
        return this._target().__isCancelled();
      };
      Promise2.prototype.isCancelled = function() {
        return (this._target()._bitField & 8454144) !== 0;
      };
      Promise2.prototype.isPending = function() {
        return isPending.call(this._target());
      };
      Promise2.prototype.isRejected = function() {
        return isRejected.call(this._target());
      };
      Promise2.prototype.isFulfilled = function() {
        return isFulfilled.call(this._target());
      };
      Promise2.prototype.isResolved = function() {
        return isResolved.call(this._target());
      };
      Promise2.prototype.value = function() {
        return value.call(this._target());
      };
      Promise2.prototype.reason = function() {
        var target = this._target();
        target._unsetRejectionIsUnhandled();
        return reason.call(target);
      };
      Promise2.prototype._value = function() {
        return this._settledValue();
      };
      Promise2.prototype._reason = function() {
        this._unsetRejectionIsUnhandled();
        return this._settledValue();
      };
      Promise2.PromiseInspection = PromiseInspection;
    };
  }
});

// node_modules/bluebird/js/release/join.js
var require_join = __commonJS({
  "node_modules/bluebird/js/release/join.js"(exports2, module2) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = function(Promise2, PromiseArray, tryConvertToPromise, INTERNAL, async, getDomain) {
      var util = require_util();
      var canEvaluate2 = util.canEvaluate;
      var tryCatch2 = util.tryCatch;
      var errorObj2 = util.errorObj;
      var reject;
      if (true) {
        if (canEvaluate2) {
          var thenCallback = /* @__PURE__ */ __name(function(i3) {
            return new Function("value", "holder", "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ".replace(/Index/g, i3));
          }, "thenCallback");
          var promiseSetter = /* @__PURE__ */ __name(function(i3) {
            return new Function("promise", "holder", "                           \n            'use strict';                                                    \n            holder.pIndex = promise;                                         \n            ".replace(/Index/g, i3));
          }, "promiseSetter");
          var generateHolderClass = /* @__PURE__ */ __name(function(total) {
            var props = new Array(total);
            for (var i3 = 0; i3 < props.length; ++i3) {
              props[i3] = "this.p" + (i3 + 1);
            }
            var assignment = props.join(" = ") + " = null;";
            var cancellationCode = "var promise;\n" + props.map(function(prop) {
              return "                                                         \n                promise = " + prop + ";                                      \n                if (promise instanceof Promise) {                            \n                    promise.cancel();                                        \n                }                                                            \n            ";
            }).join("\n");
            var passedArguments = props.join(", ");
            var name = "Holder$" + total;
            var code = "return function(tryCatch, errorObj, Promise, async) {    \n            'use strict';                                                    \n            function [TheName](fn) {                                         \n                [TheProperties]                                              \n                this.fn = fn;                                                \n                this.asyncNeeded = true;                                     \n                this.now = 0;                                                \n            }                                                                \n                                                                             \n            [TheName].prototype._callFunction = function(promise) {          \n                promise._pushContext();                                      \n                var ret = tryCatch(this.fn)([ThePassedArguments]);           \n                promise._popContext();                                       \n                if (ret === errorObj) {                                      \n                    promise._rejectCallback(ret.e, false);                   \n                } else {                                                     \n                    promise._resolveCallback(ret);                           \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype.checkFulfillment = function(promise) {       \n                var now = ++this.now;                                        \n                if (now === [TheTotal]) {                                    \n                    if (this.asyncNeeded) {                                  \n                        async.invoke(this._callFunction, this, promise);     \n                    } else {                                                 \n                        this._callFunction(promise);                         \n                    }                                                        \n                                                                             \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype._resultCancelled = function() {              \n                [CancellationCode]                                           \n            };                                                               \n                                                                             \n            return [TheName];                                                \n        }(tryCatch, errorObj, Promise, async);                               \n        ";
            code = code.replace(/\[TheName\]/g, name).replace(/\[TheTotal\]/g, total).replace(/\[ThePassedArguments\]/g, passedArguments).replace(/\[TheProperties\]/g, assignment).replace(/\[CancellationCode\]/g, cancellationCode);
            return new Function("tryCatch", "errorObj", "Promise", "async", code)(tryCatch2, errorObj2, Promise2, async);
          }, "generateHolderClass");
          var holderClasses = [];
          var thenCallbacks = [];
          var promiseSetters = [];
          for (var i2 = 0; i2 < 8; ++i2) {
            holderClasses.push(generateHolderClass(i2 + 1));
            thenCallbacks.push(thenCallback(i2 + 1));
            promiseSetters.push(promiseSetter(i2 + 1));
          }
          reject = /* @__PURE__ */ __name(function(reason) {
            this._reject(reason);
          }, "reject");
        }
      }
      Promise2.join = function() {
        var last = arguments.length - 1;
        var fn2;
        if (last > 0 && typeof arguments[last] === "function") {
          fn2 = arguments[last];
          if (true) {
            if (last <= 8 && canEvaluate2) {
              var ret2 = new Promise2(INTERNAL);
              ret2._captureStackTrace();
              var HolderClass = holderClasses[last - 1];
              var holder = new HolderClass(fn2);
              var callbacks = thenCallbacks;
              for (var i3 = 0; i3 < last; ++i3) {
                var maybePromise = tryConvertToPromise(arguments[i3], ret2);
                if (maybePromise instanceof Promise2) {
                  maybePromise = maybePromise._target();
                  var bitField = maybePromise._bitField;
                  ;
                  if ((bitField & 50397184) === 0) {
                    maybePromise._then(
                      callbacks[i3],
                      reject,
                      void 0,
                      ret2,
                      holder
                    );
                    promiseSetters[i3](maybePromise, holder);
                    holder.asyncNeeded = false;
                  } else if ((bitField & 33554432) !== 0) {
                    callbacks[i3].call(
                      ret2,
                      maybePromise._value(),
                      holder
                    );
                  } else if ((bitField & 16777216) !== 0) {
                    ret2._reject(maybePromise._reason());
                  } else {
                    ret2._cancel();
                  }
                } else {
                  callbacks[i3].call(ret2, maybePromise, holder);
                }
              }
              if (!ret2._isFateSealed()) {
                if (holder.asyncNeeded) {
                  var domain2 = getDomain();
                  if (domain2 !== null) {
                    holder.fn = util.domainBind(domain2, holder.fn);
                  }
                }
                ret2._setAsyncGuaranteed();
                ret2._setOnCancel(holder);
              }
              return ret2;
            }
          }
        }
        var $_len = arguments.length;
        var args = new Array($_len);
        for (var $_i = 0; $_i < $_len; ++$_i) {
          args[$_i] = arguments[$_i];
        }
        ;
        if (fn2)
          args.pop();
        var ret2 = new PromiseArray(args).promise();
        return fn2 !== void 0 ? ret2.spread(fn2) : ret2;
      };
    };
  }
});

// node_modules/bluebird/js/release/map.js
var require_map = __commonJS({
  "node_modules/bluebird/js/release/map.js"(exports2, module2) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = function(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug3) {
      var getDomain = Promise2._getDomain;
      var util = require_util();
      var tryCatch2 = util.tryCatch;
      var errorObj2 = util.errorObj;
      var async = Promise2._async;
      function MappingPromiseArray(promises, fn2, limit, _filter) {
        this.constructor$(promises);
        this._promise._captureStackTrace();
        var domain2 = getDomain();
        this._callback = domain2 === null ? fn2 : util.domainBind(domain2, fn2);
        this._preservedValues = _filter === INTERNAL ? new Array(this.length()) : null;
        this._limit = limit;
        this._inFlight = 0;
        this._queue = [];
        async.invoke(this._asyncInit, this, void 0);
      }
      __name(MappingPromiseArray, "MappingPromiseArray");
      util.inherits(MappingPromiseArray, PromiseArray);
      MappingPromiseArray.prototype._asyncInit = function() {
        this._init$(void 0, -2);
      };
      MappingPromiseArray.prototype._init = function() {
      };
      MappingPromiseArray.prototype._promiseFulfilled = function(value, index) {
        var values = this._values;
        var length = this.length();
        var preservedValues = this._preservedValues;
        var limit = this._limit;
        if (index < 0) {
          index = index * -1 - 1;
          values[index] = value;
          if (limit >= 1) {
            this._inFlight--;
            this._drainQueue();
            if (this._isResolved())
              return true;
          }
        } else {
          if (limit >= 1 && this._inFlight >= limit) {
            values[index] = value;
            this._queue.push(index);
            return false;
          }
          if (preservedValues !== null)
            preservedValues[index] = value;
          var promise = this._promise;
          var callback = this._callback;
          var receiver = promise._boundValue();
          promise._pushContext();
          var ret2 = tryCatch2(callback).call(receiver, value, index, length);
          var promiseCreated = promise._popContext();
          debug3.checkForgottenReturns(
            ret2,
            promiseCreated,
            preservedValues !== null ? "Promise.filter" : "Promise.map",
            promise
          );
          if (ret2 === errorObj2) {
            this._reject(ret2.e);
            return true;
          }
          var maybePromise = tryConvertToPromise(ret2, this._promise);
          if (maybePromise instanceof Promise2) {
            maybePromise = maybePromise._target();
            var bitField = maybePromise._bitField;
            ;
            if ((bitField & 50397184) === 0) {
              if (limit >= 1)
                this._inFlight++;
              values[index] = maybePromise;
              maybePromise._proxy(this, (index + 1) * -1);
              return false;
            } else if ((bitField & 33554432) !== 0) {
              ret2 = maybePromise._value();
            } else if ((bitField & 16777216) !== 0) {
              this._reject(maybePromise._reason());
              return true;
            } else {
              this._cancel();
              return true;
            }
          }
          values[index] = ret2;
        }
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= length) {
          if (preservedValues !== null) {
            this._filter(values, preservedValues);
          } else {
            this._resolve(values);
          }
          return true;
        }
        return false;
      };
      MappingPromiseArray.prototype._drainQueue = function() {
        var queue = this._queue;
        var limit = this._limit;
        var values = this._values;
        while (queue.length > 0 && this._inFlight < limit) {
          if (this._isResolved())
            return;
          var index = queue.pop();
          this._promiseFulfilled(values[index], index);
        }
      };
      MappingPromiseArray.prototype._filter = function(booleans, values) {
        var len = values.length;
        var ret2 = new Array(len);
        var j2 = 0;
        for (var i2 = 0; i2 < len; ++i2) {
          if (booleans[i2])
            ret2[j2++] = values[i2];
        }
        ret2.length = j2;
        this._resolve(ret2);
      };
      MappingPromiseArray.prototype.preservedValues = function() {
        return this._preservedValues;
      };
      function map(promises, fn2, options, _filter) {
        if (typeof fn2 !== "function") {
          return apiRejection("expecting a function but got " + util.classString(fn2));
        }
        var limit = 0;
        if (options !== void 0) {
          if (typeof options === "object" && options !== null) {
            if (typeof options.concurrency !== "number") {
              return Promise2.reject(
                new TypeError("'concurrency' must be a number but it is " + util.classString(options.concurrency))
              );
            }
            limit = options.concurrency;
          } else {
            return Promise2.reject(new TypeError(
              "options argument must be an object but it is " + util.classString(options)
            ));
          }
        }
        limit = typeof limit === "number" && isFinite(limit) && limit >= 1 ? limit : 0;
        return new MappingPromiseArray(promises, fn2, limit, _filter).promise();
      }
      __name(map, "map");
      Promise2.prototype.map = function(fn2, options) {
        return map(this, fn2, options, null);
      };
      Promise2.map = function(promises, fn2, options, _filter) {
        return map(promises, fn2, options, _filter);
      };
    };
  }
});

// node_modules/bluebird/js/release/call_get.js
var require_call_get = __commonJS({
  "node_modules/bluebird/js/release/call_get.js"(exports2, module2) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var cr2 = Object.create;
    if (cr2) {
      callerCache = cr2(null);
      getterCache = cr2(null);
      callerCache[" size"] = getterCache[" size"] = 0;
    }
    var callerCache;
    var getterCache;
    module2.exports = function(Promise2) {
      var util = require_util();
      var canEvaluate2 = util.canEvaluate;
      var isIdentifier2 = util.isIdentifier;
      var getMethodCaller;
      var getGetter;
      if (true) {
        var makeMethodCaller = /* @__PURE__ */ __name(function(methodName) {
          return new Function("ensureMethod", "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ".replace(/methodName/g, methodName))(ensureMethod);
        }, "makeMethodCaller");
        var makeGetter = /* @__PURE__ */ __name(function(propertyName) {
          return new Function("obj", "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ".replace("propertyName", propertyName));
        }, "makeGetter");
        var getCompiled = /* @__PURE__ */ __name(function(name, compiler, cache) {
          var ret2 = cache[name];
          if (typeof ret2 !== "function") {
            if (!isIdentifier2(name)) {
              return null;
            }
            ret2 = compiler(name);
            cache[name] = ret2;
            cache[" size"]++;
            if (cache[" size"] > 512) {
              var keys = Object.keys(cache);
              for (var i2 = 0; i2 < 256; ++i2)
                delete cache[keys[i2]];
              cache[" size"] = keys.length - 256;
            }
          }
          return ret2;
        }, "getCompiled");
        getMethodCaller = /* @__PURE__ */ __name(function(name) {
          return getCompiled(name, makeMethodCaller, callerCache);
        }, "getMethodCaller");
        getGetter = /* @__PURE__ */ __name(function(name) {
          return getCompiled(name, makeGetter, getterCache);
        }, "getGetter");
      }
      function ensureMethod(obj2, methodName) {
        var fn2;
        if (obj2 != null)
          fn2 = obj2[methodName];
        if (typeof fn2 !== "function") {
          var message = "Object " + util.classString(obj2) + " has no method '" + util.toString(methodName) + "'";
          throw new Promise2.TypeError(message);
        }
        return fn2;
      }
      __name(ensureMethod, "ensureMethod");
      function caller(obj2) {
        var methodName = this.pop();
        var fn2 = ensureMethod(obj2, methodName);
        return fn2.apply(obj2, this);
      }
      __name(caller, "caller");
      Promise2.prototype.call = function(methodName) {
        var $_len = arguments.length;
        var args = new Array(Math.max($_len - 1, 0));
        for (var $_i = 1; $_i < $_len; ++$_i) {
          args[$_i - 1] = arguments[$_i];
        }
        ;
        if (true) {
          if (canEvaluate2) {
            var maybeCaller = getMethodCaller(methodName);
            if (maybeCaller !== null) {
              return this._then(
                maybeCaller,
                void 0,
                void 0,
                args,
                void 0
              );
            }
          }
        }
        args.push(methodName);
        return this._then(caller, void 0, void 0, args, void 0);
      };
      function namedGetter(obj2) {
        return obj2[this];
      }
      __name(namedGetter, "namedGetter");
      function indexedGetter(obj2) {
        var index = +this;
        if (index < 0)
          index = Math.max(0, index + obj2.length);
        return obj2[index];
      }
      __name(indexedGetter, "indexedGetter");
      Promise2.prototype.get = function(propertyName) {
        var isIndex = typeof propertyName === "number";
        var getter;
        if (!isIndex) {
          if (canEvaluate2) {
            var maybeGetter = getGetter(propertyName);
            getter = maybeGetter !== null ? maybeGetter : namedGetter;
          } else {
            getter = namedGetter;
          }
        } else {
          getter = indexedGetter;
        }
        return this._then(getter, void 0, void 0, propertyName, void 0);
      };
    };
  }
});

// node_modules/bluebird/js/release/using.js
var require_using = __commonJS({
  "node_modules/bluebird/js/release/using.js"(exports2, module2) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = function(Promise2, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug3) {
      var util = require_util();
      var TypeError2 = require_errors().TypeError;
      var inherits2 = require_util().inherits;
      var errorObj2 = util.errorObj;
      var tryCatch2 = util.tryCatch;
      var NULL = {};
      function thrower2(e2) {
        setTimeout(function() {
          throw e2;
        }, 0);
      }
      __name(thrower2, "thrower");
      function castPreservingDisposable(thenable) {
        var maybePromise = tryConvertToPromise(thenable);
        if (maybePromise !== thenable && typeof thenable._isDisposable === "function" && typeof thenable._getDisposer === "function" && thenable._isDisposable()) {
          maybePromise._setDisposable(thenable._getDisposer());
        }
        return maybePromise;
      }
      __name(castPreservingDisposable, "castPreservingDisposable");
      function dispose(resources, inspection) {
        var i2 = 0;
        var len = resources.length;
        var ret2 = new Promise2(INTERNAL);
        function iterator() {
          if (i2 >= len)
            return ret2._fulfill();
          var maybePromise = castPreservingDisposable(resources[i2++]);
          if (maybePromise instanceof Promise2 && maybePromise._isDisposable()) {
            try {
              maybePromise = tryConvertToPromise(
                maybePromise._getDisposer().tryDispose(inspection),
                resources.promise
              );
            } catch (e2) {
              return thrower2(e2);
            }
            if (maybePromise instanceof Promise2) {
              return maybePromise._then(
                iterator,
                thrower2,
                null,
                null,
                null
              );
            }
          }
          iterator();
        }
        __name(iterator, "iterator");
        iterator();
        return ret2;
      }
      __name(dispose, "dispose");
      function Disposer(data, promise, context2) {
        this._data = data;
        this._promise = promise;
        this._context = context2;
      }
      __name(Disposer, "Disposer");
      Disposer.prototype.data = function() {
        return this._data;
      };
      Disposer.prototype.promise = function() {
        return this._promise;
      };
      Disposer.prototype.resource = function() {
        if (this.promise().isFulfilled()) {
          return this.promise().value();
        }
        return NULL;
      };
      Disposer.prototype.tryDispose = function(inspection) {
        var resource = this.resource();
        var context2 = this._context;
        if (context2 !== void 0)
          context2._pushContext();
        var ret2 = resource !== NULL ? this.doDispose(resource, inspection) : null;
        if (context2 !== void 0)
          context2._popContext();
        this._promise._unsetDisposable();
        this._data = null;
        return ret2;
      };
      Disposer.isDisposer = function(d2) {
        return d2 != null && typeof d2.resource === "function" && typeof d2.tryDispose === "function";
      };
      function FunctionDisposer(fn2, promise, context2) {
        this.constructor$(fn2, promise, context2);
      }
      __name(FunctionDisposer, "FunctionDisposer");
      inherits2(FunctionDisposer, Disposer);
      FunctionDisposer.prototype.doDispose = function(resource, inspection) {
        var fn2 = this.data();
        return fn2.call(resource, resource, inspection);
      };
      function maybeUnwrapDisposer(value) {
        if (Disposer.isDisposer(value)) {
          this.resources[this.index]._setDisposable(value);
          return value.promise();
        }
        return value;
      }
      __name(maybeUnwrapDisposer, "maybeUnwrapDisposer");
      function ResourceList(length) {
        this.length = length;
        this.promise = null;
        this[length - 1] = null;
      }
      __name(ResourceList, "ResourceList");
      ResourceList.prototype._resultCancelled = function() {
        var len = this.length;
        for (var i2 = 0; i2 < len; ++i2) {
          var item = this[i2];
          if (item instanceof Promise2) {
            item.cancel();
          }
        }
      };
      Promise2.using = function() {
        var len = arguments.length;
        if (len < 2)
          return apiRejection(
            "you must pass at least 2 arguments to Promise.using"
          );
        var fn2 = arguments[len - 1];
        if (typeof fn2 !== "function") {
          return apiRejection("expecting a function but got " + util.classString(fn2));
        }
        var input;
        var spreadArgs = true;
        if (len === 2 && Array.isArray(arguments[0])) {
          input = arguments[0];
          len = input.length;
          spreadArgs = false;
        } else {
          input = arguments;
          len--;
        }
        var resources = new ResourceList(len);
        for (var i2 = 0; i2 < len; ++i2) {
          var resource = input[i2];
          if (Disposer.isDisposer(resource)) {
            var disposer = resource;
            resource = resource.promise();
            resource._setDisposable(disposer);
          } else {
            var maybePromise = tryConvertToPromise(resource);
            if (maybePromise instanceof Promise2) {
              resource = maybePromise._then(maybeUnwrapDisposer, null, null, {
                resources,
                index: i2
              }, void 0);
            }
          }
          resources[i2] = resource;
        }
        var reflectedResources = new Array(resources.length);
        for (var i2 = 0; i2 < reflectedResources.length; ++i2) {
          reflectedResources[i2] = Promise2.resolve(resources[i2]).reflect();
        }
        var resultPromise = Promise2.all(reflectedResources).then(function(inspections) {
          for (var i3 = 0; i3 < inspections.length; ++i3) {
            var inspection = inspections[i3];
            if (inspection.isRejected()) {
              errorObj2.e = inspection.error();
              return errorObj2;
            } else if (!inspection.isFulfilled()) {
              resultPromise.cancel();
              return;
            }
            inspections[i3] = inspection.value();
          }
          promise._pushContext();
          fn2 = tryCatch2(fn2);
          var ret2 = spreadArgs ? fn2.apply(void 0, inspections) : fn2(inspections);
          var promiseCreated = promise._popContext();
          debug3.checkForgottenReturns(
            ret2,
            promiseCreated,
            "Promise.using",
            promise
          );
          return ret2;
        });
        var promise = resultPromise.lastly(function() {
          var inspection = new Promise2.PromiseInspection(resultPromise);
          return dispose(resources, inspection);
        });
        resources.promise = promise;
        promise._setOnCancel(resources);
        return promise;
      };
      Promise2.prototype._setDisposable = function(disposer) {
        this._bitField = this._bitField | 131072;
        this._disposer = disposer;
      };
      Promise2.prototype._isDisposable = function() {
        return (this._bitField & 131072) > 0;
      };
      Promise2.prototype._getDisposer = function() {
        return this._disposer;
      };
      Promise2.prototype._unsetDisposable = function() {
        this._bitField = this._bitField & ~131072;
        this._disposer = void 0;
      };
      Promise2.prototype.disposer = function(fn2) {
        if (typeof fn2 === "function") {
          return new FunctionDisposer(fn2, this, createContext());
        }
        throw new TypeError2();
      };
    };
  }
});

// node_modules/bluebird/js/release/timers.js
var require_timers = __commonJS({
  "node_modules/bluebird/js/release/timers.js"(exports2, module2) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = function(Promise2, INTERNAL, debug3) {
      var util = require_util();
      var TimeoutError = Promise2.TimeoutError;
      function HandleWrapper(handle) {
        this.handle = handle;
      }
      __name(HandleWrapper, "HandleWrapper");
      HandleWrapper.prototype._resultCancelled = function() {
        clearTimeout(this.handle);
      };
      var afterValue = /* @__PURE__ */ __name(function(value) {
        return delay(+this).thenReturn(value);
      }, "afterValue");
      var delay = Promise2.delay = function(ms2, value) {
        var ret2;
        var handle;
        if (value !== void 0) {
          ret2 = Promise2.resolve(value)._then(afterValue, null, null, ms2, void 0);
          if (debug3.cancellation() && value instanceof Promise2) {
            ret2._setOnCancel(value);
          }
        } else {
          ret2 = new Promise2(INTERNAL);
          handle = setTimeout(function() {
            ret2._fulfill();
          }, +ms2);
          if (debug3.cancellation()) {
            ret2._setOnCancel(new HandleWrapper(handle));
          }
          ret2._captureStackTrace();
        }
        ret2._setAsyncGuaranteed();
        return ret2;
      };
      Promise2.prototype.delay = function(ms2) {
        return delay(ms2, this);
      };
      var afterTimeout = /* @__PURE__ */ __name(function(promise, message, parent) {
        var err;
        if (typeof message !== "string") {
          if (message instanceof Error) {
            err = message;
          } else {
            err = new TimeoutError("operation timed out");
          }
        } else {
          err = new TimeoutError(message);
        }
        util.markAsOriginatingFromRejection(err);
        promise._attachExtraTrace(err);
        promise._reject(err);
        if (parent != null) {
          parent.cancel();
        }
      }, "afterTimeout");
      function successClear(value) {
        clearTimeout(this.handle);
        return value;
      }
      __name(successClear, "successClear");
      function failureClear(reason) {
        clearTimeout(this.handle);
        throw reason;
      }
      __name(failureClear, "failureClear");
      Promise2.prototype.timeout = function(ms2, message) {
        ms2 = +ms2;
        var ret2, parent;
        var handleWrapper = new HandleWrapper(setTimeout(/* @__PURE__ */ __name(function timeoutTimeout() {
          if (ret2.isPending()) {
            afterTimeout(ret2, message, parent);
          }
        }, "timeoutTimeout"), ms2));
        if (debug3.cancellation()) {
          parent = this.then();
          ret2 = parent._then(
            successClear,
            failureClear,
            void 0,
            handleWrapper,
            void 0
          );
          ret2._setOnCancel(handleWrapper);
        } else {
          ret2 = this._then(
            successClear,
            failureClear,
            void 0,
            handleWrapper,
            void 0
          );
        }
        return ret2;
      };
    };
  }
});

// node_modules/bluebird/js/release/generators.js
var require_generators = __commonJS({
  "node_modules/bluebird/js/release/generators.js"(exports2, module2) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = function(Promise2, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug3) {
      var errors = require_errors();
      var TypeError2 = errors.TypeError;
      var util = require_util();
      var errorObj2 = util.errorObj;
      var tryCatch2 = util.tryCatch;
      var yieldHandlers = [];
      function promiseFromYieldHandler(value, yieldHandlers2, traceParent) {
        for (var i2 = 0; i2 < yieldHandlers2.length; ++i2) {
          traceParent._pushContext();
          var result = tryCatch2(yieldHandlers2[i2])(value);
          traceParent._popContext();
          if (result === errorObj2) {
            traceParent._pushContext();
            var ret2 = Promise2.reject(errorObj2.e);
            traceParent._popContext();
            return ret2;
          }
          var maybePromise = tryConvertToPromise(result, traceParent);
          if (maybePromise instanceof Promise2)
            return maybePromise;
        }
        return null;
      }
      __name(promiseFromYieldHandler, "promiseFromYieldHandler");
      function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
        if (debug3.cancellation()) {
          var internal = new Promise2(INTERNAL);
          var _finallyPromise = this._finallyPromise = new Promise2(INTERNAL);
          this._promise = internal.lastly(function() {
            return _finallyPromise;
          });
          internal._captureStackTrace();
          internal._setOnCancel(this);
        } else {
          var promise = this._promise = new Promise2(INTERNAL);
          promise._captureStackTrace();
        }
        this._stack = stack;
        this._generatorFunction = generatorFunction;
        this._receiver = receiver;
        this._generator = void 0;
        this._yieldHandlers = typeof yieldHandler === "function" ? [yieldHandler].concat(yieldHandlers) : yieldHandlers;
        this._yieldedPromise = null;
        this._cancellationPhase = false;
      }
      __name(PromiseSpawn, "PromiseSpawn");
      util.inherits(PromiseSpawn, Proxyable);
      PromiseSpawn.prototype._isResolved = function() {
        return this._promise === null;
      };
      PromiseSpawn.prototype._cleanup = function() {
        this._promise = this._generator = null;
        if (debug3.cancellation() && this._finallyPromise !== null) {
          this._finallyPromise._fulfill();
          this._finallyPromise = null;
        }
      };
      PromiseSpawn.prototype._promiseCancelled = function() {
        if (this._isResolved())
          return;
        var implementsReturn = typeof this._generator["return"] !== "undefined";
        var result;
        if (!implementsReturn) {
          var reason = new Promise2.CancellationError(
            "generator .return() sentinel"
          );
          Promise2.coroutine.returnSentinel = reason;
          this._promise._attachExtraTrace(reason);
          this._promise._pushContext();
          result = tryCatch2(this._generator["throw"]).call(
            this._generator,
            reason
          );
          this._promise._popContext();
        } else {
          this._promise._pushContext();
          result = tryCatch2(this._generator["return"]).call(
            this._generator,
            void 0
          );
          this._promise._popContext();
        }
        this._cancellationPhase = true;
        this._yieldedPromise = null;
        this._continue(result);
      };
      PromiseSpawn.prototype._promiseFulfilled = function(value) {
        this._yieldedPromise = null;
        this._promise._pushContext();
        var result = tryCatch2(this._generator.next).call(this._generator, value);
        this._promise._popContext();
        this._continue(result);
      };
      PromiseSpawn.prototype._promiseRejected = function(reason) {
        this._yieldedPromise = null;
        this._promise._attachExtraTrace(reason);
        this._promise._pushContext();
        var result = tryCatch2(this._generator["throw"]).call(this._generator, reason);
        this._promise._popContext();
        this._continue(result);
      };
      PromiseSpawn.prototype._resultCancelled = function() {
        if (this._yieldedPromise instanceof Promise2) {
          var promise = this._yieldedPromise;
          this._yieldedPromise = null;
          promise.cancel();
        }
      };
      PromiseSpawn.prototype.promise = function() {
        return this._promise;
      };
      PromiseSpawn.prototype._run = function() {
        this._generator = this._generatorFunction.call(this._receiver);
        this._receiver = this._generatorFunction = void 0;
        this._promiseFulfilled(void 0);
      };
      PromiseSpawn.prototype._continue = function(result) {
        var promise = this._promise;
        if (result === errorObj2) {
          this._cleanup();
          if (this._cancellationPhase) {
            return promise.cancel();
          } else {
            return promise._rejectCallback(result.e, false);
          }
        }
        var value = result.value;
        if (result.done === true) {
          this._cleanup();
          if (this._cancellationPhase) {
            return promise.cancel();
          } else {
            return promise._resolveCallback(value);
          }
        } else {
          var maybePromise = tryConvertToPromise(value, this._promise);
          if (!(maybePromise instanceof Promise2)) {
            maybePromise = promiseFromYieldHandler(
              maybePromise,
              this._yieldHandlers,
              this._promise
            );
            if (maybePromise === null) {
              this._promiseRejected(
                new TypeError2(
                  "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n".replace("%s", value) + "From coroutine:\n" + this._stack.split("\n").slice(1, -7).join("\n")
                )
              );
              return;
            }
          }
          maybePromise = maybePromise._target();
          var bitField = maybePromise._bitField;
          ;
          if ((bitField & 50397184) === 0) {
            this._yieldedPromise = maybePromise;
            maybePromise._proxy(this, null);
          } else if ((bitField & 33554432) !== 0) {
            Promise2._async.invoke(
              this._promiseFulfilled,
              this,
              maybePromise._value()
            );
          } else if ((bitField & 16777216) !== 0) {
            Promise2._async.invoke(
              this._promiseRejected,
              this,
              maybePromise._reason()
            );
          } else {
            this._promiseCancelled();
          }
        }
      };
      Promise2.coroutine = function(generatorFunction, options) {
        if (typeof generatorFunction !== "function") {
          throw new TypeError2("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");
        }
        var yieldHandler = Object(options).yieldHandler;
        var PromiseSpawn$ = PromiseSpawn;
        var stack = new Error().stack;
        return function() {
          var generator = generatorFunction.apply(this, arguments);
          var spawn = new PromiseSpawn$(
            void 0,
            void 0,
            yieldHandler,
            stack
          );
          var ret2 = spawn.promise();
          spawn._generator = generator;
          spawn._promiseFulfilled(void 0);
          return ret2;
        };
      };
      Promise2.coroutine.addYieldHandler = function(fn2) {
        if (typeof fn2 !== "function") {
          throw new TypeError2("expecting a function but got " + util.classString(fn2));
        }
        yieldHandlers.push(fn2);
      };
      Promise2.spawn = function(generatorFunction) {
        debug3.deprecated("Promise.spawn()", "Promise.coroutine()");
        if (typeof generatorFunction !== "function") {
          return apiRejection("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");
        }
        var spawn = new PromiseSpawn(generatorFunction, this);
        var ret2 = spawn.promise();
        spawn._run(Promise2.spawn);
        return ret2;
      };
    };
  }
});

// node_modules/bluebird/js/release/nodeify.js
var require_nodeify = __commonJS({
  "node_modules/bluebird/js/release/nodeify.js"(exports2, module2) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = function(Promise2) {
      var util = require_util();
      var async = Promise2._async;
      var tryCatch2 = util.tryCatch;
      var errorObj2 = util.errorObj;
      function spreadAdapter(val, nodeback) {
        var promise = this;
        if (!util.isArray(val))
          return successAdapter.call(promise, val, nodeback);
        var ret2 = tryCatch2(nodeback).apply(promise._boundValue(), [null].concat(val));
        if (ret2 === errorObj2) {
          async.throwLater(ret2.e);
        }
      }
      __name(spreadAdapter, "spreadAdapter");
      function successAdapter(val, nodeback) {
        var promise = this;
        var receiver = promise._boundValue();
        var ret2 = val === void 0 ? tryCatch2(nodeback).call(receiver, null) : tryCatch2(nodeback).call(receiver, null, val);
        if (ret2 === errorObj2) {
          async.throwLater(ret2.e);
        }
      }
      __name(successAdapter, "successAdapter");
      function errorAdapter(reason, nodeback) {
        var promise = this;
        if (!reason) {
          var newReason = new Error(reason + "");
          newReason.cause = reason;
          reason = newReason;
        }
        var ret2 = tryCatch2(nodeback).call(promise._boundValue(), reason);
        if (ret2 === errorObj2) {
          async.throwLater(ret2.e);
        }
      }
      __name(errorAdapter, "errorAdapter");
      Promise2.prototype.asCallback = Promise2.prototype.nodeify = function(nodeback, options) {
        if (typeof nodeback == "function") {
          var adapter = successAdapter;
          if (options !== void 0 && Object(options).spread) {
            adapter = spreadAdapter;
          }
          this._then(
            adapter,
            errorAdapter,
            void 0,
            this,
            nodeback
          );
        }
        return this;
      };
    };
  }
});

// node_modules/bluebird/js/release/promisify.js
var require_promisify = __commonJS({
  "node_modules/bluebird/js/release/promisify.js"(exports2, module2) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = function(Promise2, INTERNAL) {
      var THIS = {};
      var util = require_util();
      var nodebackForPromise = require_nodeback();
      var withAppended2 = util.withAppended;
      var maybeWrapAsError2 = util.maybeWrapAsError;
      var canEvaluate2 = util.canEvaluate;
      var TypeError2 = require_errors().TypeError;
      var defaultSuffix = "Async";
      var defaultPromisified = { __isPromisified__: true };
      var noCopyProps = [
        "arity",
        "length",
        "name",
        "arguments",
        "caller",
        "callee",
        "prototype",
        "__isPromisified__"
      ];
      var noCopyPropsPattern = new RegExp("^(?:" + noCopyProps.join("|") + ")$");
      var defaultFilter = /* @__PURE__ */ __name(function(name) {
        return util.isIdentifier(name) && name.charAt(0) !== "_" && name !== "constructor";
      }, "defaultFilter");
      function propsFilter(key) {
        return !noCopyPropsPattern.test(key);
      }
      __name(propsFilter, "propsFilter");
      function isPromisified(fn2) {
        try {
          return fn2.__isPromisified__ === true;
        } catch (e2) {
          return false;
        }
      }
      __name(isPromisified, "isPromisified");
      function hasPromisified(obj2, key, suffix) {
        var val = util.getDataPropertyOrDefault(
          obj2,
          key + suffix,
          defaultPromisified
        );
        return val ? isPromisified(val) : false;
      }
      __name(hasPromisified, "hasPromisified");
      function checkValid(ret2, suffix, suffixRegexp) {
        for (var i2 = 0; i2 < ret2.length; i2 += 2) {
          var key = ret2[i2];
          if (suffixRegexp.test(key)) {
            var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
            for (var j2 = 0; j2 < ret2.length; j2 += 2) {
              if (ret2[j2] === keyWithoutAsyncSuffix) {
                throw new TypeError2("Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n".replace("%s", suffix));
              }
            }
          }
        }
      }
      __name(checkValid, "checkValid");
      function promisifiableMethods(obj2, suffix, suffixRegexp, filter) {
        var keys = util.inheritedDataKeys(obj2);
        var ret2 = [];
        for (var i2 = 0; i2 < keys.length; ++i2) {
          var key = keys[i2];
          var value = obj2[key];
          var passesDefaultFilter = filter === defaultFilter ? true : defaultFilter(key, value, obj2);
          if (typeof value === "function" && !isPromisified(value) && !hasPromisified(obj2, key, suffix) && filter(key, value, obj2, passesDefaultFilter)) {
            ret2.push(key, value);
          }
        }
        checkValid(ret2, suffix, suffixRegexp);
        return ret2;
      }
      __name(promisifiableMethods, "promisifiableMethods");
      var escapeIdentRegex = /* @__PURE__ */ __name(function(str) {
        return str.replace(/([$])/, "\\$");
      }, "escapeIdentRegex");
      var makeNodePromisifiedEval;
      if (true) {
        var switchCaseArgumentOrder = /* @__PURE__ */ __name(function(likelyArgumentCount) {
          var ret2 = [likelyArgumentCount];
          var min = Math.max(0, likelyArgumentCount - 1 - 3);
          for (var i2 = likelyArgumentCount - 1; i2 >= min; --i2) {
            ret2.push(i2);
          }
          for (var i2 = likelyArgumentCount + 1; i2 <= 3; ++i2) {
            ret2.push(i2);
          }
          return ret2;
        }, "switchCaseArgumentOrder");
        var argumentSequence = /* @__PURE__ */ __name(function(argumentCount) {
          return util.filledRange(argumentCount, "_arg", "");
        }, "argumentSequence");
        var parameterDeclaration = /* @__PURE__ */ __name(function(parameterCount2) {
          return util.filledRange(
            Math.max(parameterCount2, 3),
            "_arg",
            ""
          );
        }, "parameterDeclaration");
        var parameterCount = /* @__PURE__ */ __name(function(fn2) {
          if (typeof fn2.length === "number") {
            return Math.max(Math.min(fn2.length, 1023 + 1), 0);
          }
          return 0;
        }, "parameterCount");
        makeNodePromisifiedEval = /* @__PURE__ */ __name(function(callback, receiver, originalName, fn2, _2, multiArgs) {
          var newParameterCount = Math.max(0, parameterCount(fn2) - 1);
          var argumentOrder = switchCaseArgumentOrder(newParameterCount);
          var shouldProxyThis = typeof callback === "string" || receiver === THIS;
          function generateCallForArgumentCount(count3) {
            var args = argumentSequence(count3).join(", ");
            var comma = count3 > 0 ? ", " : "";
            var ret2;
            if (shouldProxyThis) {
              ret2 = "ret = callback.call(this, {{args}}, nodeback); break;\n";
            } else {
              ret2 = receiver === void 0 ? "ret = callback({{args}}, nodeback); break;\n" : "ret = callback.call(receiver, {{args}}, nodeback); break;\n";
            }
            return ret2.replace("{{args}}", args).replace(", ", comma);
          }
          __name(generateCallForArgumentCount, "generateCallForArgumentCount");
          function generateArgumentSwitchCase() {
            var ret2 = "";
            for (var i2 = 0; i2 < argumentOrder.length; ++i2) {
              ret2 += "case " + argumentOrder[i2] + ":" + generateCallForArgumentCount(argumentOrder[i2]);
            }
            ret2 += "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ".replace("[CodeForCall]", shouldProxyThis ? "ret = callback.apply(this, args);\n" : "ret = callback.apply(receiver, args);\n");
            return ret2;
          }
          __name(generateArgumentSwitchCase, "generateArgumentSwitchCase");
          var getFunctionCode = typeof callback === "string" ? "this != null ? this['" + callback + "'] : fn" : "fn";
          var body = "'use strict';                                                \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise, " + multiArgs + ");   \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n    ".replace("[CodeForSwitchCase]", generateArgumentSwitchCase()).replace("[GetFunctionCode]", getFunctionCode);
          body = body.replace("Parameters", parameterDeclaration(newParameterCount));
          return new Function(
            "Promise",
            "fn",
            "receiver",
            "withAppended",
            "maybeWrapAsError",
            "nodebackForPromise",
            "tryCatch",
            "errorObj",
            "notEnumerableProp",
            "INTERNAL",
            body
          )(
            Promise2,
            fn2,
            receiver,
            withAppended2,
            maybeWrapAsError2,
            nodebackForPromise,
            util.tryCatch,
            util.errorObj,
            util.notEnumerableProp,
            INTERNAL
          );
        }, "makeNodePromisifiedEval");
      }
      function makeNodePromisifiedClosure(callback, receiver, _2, fn2, __2, multiArgs) {
        var defaultThis = function() {
          return this;
        }();
        var method = callback;
        if (typeof method === "string") {
          callback = fn2;
        }
        function promisified() {
          var _receiver = receiver;
          if (receiver === THIS)
            _receiver = this;
          var promise = new Promise2(INTERNAL);
          promise._captureStackTrace();
          var cb = typeof method === "string" && this !== defaultThis ? this[method] : callback;
          var fn3 = nodebackForPromise(promise, multiArgs);
          try {
            cb.apply(_receiver, withAppended2(arguments, fn3));
          } catch (e2) {
            promise._rejectCallback(maybeWrapAsError2(e2), true, true);
          }
          if (!promise._isFateSealed())
            promise._setAsyncGuaranteed();
          return promise;
        }
        __name(promisified, "promisified");
        util.notEnumerableProp(promisified, "__isPromisified__", true);
        return promisified;
      }
      __name(makeNodePromisifiedClosure, "makeNodePromisifiedClosure");
      var makeNodePromisified = canEvaluate2 ? makeNodePromisifiedEval : makeNodePromisifiedClosure;
      function promisifyAll(obj2, suffix, filter, promisifier, multiArgs) {
        var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
        var methods = promisifiableMethods(obj2, suffix, suffixRegexp, filter);
        for (var i2 = 0, len = methods.length; i2 < len; i2 += 2) {
          var key = methods[i2];
          var fn2 = methods[i2 + 1];
          var promisifiedKey = key + suffix;
          if (promisifier === makeNodePromisified) {
            obj2[promisifiedKey] = makeNodePromisified(key, THIS, key, fn2, suffix, multiArgs);
          } else {
            var promisified = promisifier(fn2, function() {
              return makeNodePromisified(
                key,
                THIS,
                key,
                fn2,
                suffix,
                multiArgs
              );
            });
            util.notEnumerableProp(promisified, "__isPromisified__", true);
            obj2[promisifiedKey] = promisified;
          }
        }
        util.toFastProperties(obj2);
        return obj2;
      }
      __name(promisifyAll, "promisifyAll");
      function promisify(callback, receiver, multiArgs) {
        return makeNodePromisified(
          callback,
          receiver,
          void 0,
          callback,
          null,
          multiArgs
        );
      }
      __name(promisify, "promisify");
      Promise2.promisify = function(fn2, options) {
        if (typeof fn2 !== "function") {
          throw new TypeError2("expecting a function but got " + util.classString(fn2));
        }
        if (isPromisified(fn2)) {
          return fn2;
        }
        options = Object(options);
        var receiver = options.context === void 0 ? THIS : options.context;
        var multiArgs = !!options.multiArgs;
        var ret2 = promisify(fn2, receiver, multiArgs);
        util.copyDescriptors(fn2, ret2, propsFilter);
        return ret2;
      };
      Promise2.promisifyAll = function(target, options) {
        if (typeof target !== "function" && typeof target !== "object") {
          throw new TypeError2("the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n");
        }
        options = Object(options);
        var multiArgs = !!options.multiArgs;
        var suffix = options.suffix;
        if (typeof suffix !== "string")
          suffix = defaultSuffix;
        var filter = options.filter;
        if (typeof filter !== "function")
          filter = defaultFilter;
        var promisifier = options.promisifier;
        if (typeof promisifier !== "function")
          promisifier = makeNodePromisified;
        if (!util.isIdentifier(suffix)) {
          throw new RangeError("suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n");
        }
        var keys = util.inheritedDataKeys(target);
        for (var i2 = 0; i2 < keys.length; ++i2) {
          var value = target[keys[i2]];
          if (keys[i2] !== "constructor" && util.isClass(value)) {
            promisifyAll(
              value.prototype,
              suffix,
              filter,
              promisifier,
              multiArgs
            );
            promisifyAll(value, suffix, filter, promisifier, multiArgs);
          }
        }
        return promisifyAll(target, suffix, filter, promisifier, multiArgs);
      };
    };
  }
});

// node_modules/bluebird/js/release/props.js
var require_props = __commonJS({
  "node_modules/bluebird/js/release/props.js"(exports2, module2) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = function(Promise2, PromiseArray, tryConvertToPromise, apiRejection) {
      var util = require_util();
      var isObject2 = util.isObject;
      var es52 = require_es5();
      var Es6Map;
      if (typeof Map === "function")
        Es6Map = Map;
      var mapToEntries = function() {
        var index = 0;
        var size = 0;
        function extractEntry(value, key) {
          this[index] = value;
          this[index + size] = key;
          index++;
        }
        __name(extractEntry, "extractEntry");
        return /* @__PURE__ */ __name(function mapToEntries2(map) {
          size = map.size;
          index = 0;
          var ret2 = new Array(map.size * 2);
          map.forEach(extractEntry, ret2);
          return ret2;
        }, "mapToEntries");
      }();
      var entriesToMap = /* @__PURE__ */ __name(function(entries) {
        var ret2 = new Es6Map();
        var length = entries.length / 2 | 0;
        for (var i2 = 0; i2 < length; ++i2) {
          var key = entries[length + i2];
          var value = entries[i2];
          ret2.set(key, value);
        }
        return ret2;
      }, "entriesToMap");
      function PropertiesPromiseArray(obj2) {
        var isMap = false;
        var entries;
        if (Es6Map !== void 0 && obj2 instanceof Es6Map) {
          entries = mapToEntries(obj2);
          isMap = true;
        } else {
          var keys = es52.keys(obj2);
          var len = keys.length;
          entries = new Array(len * 2);
          for (var i2 = 0; i2 < len; ++i2) {
            var key = keys[i2];
            entries[i2] = obj2[key];
            entries[i2 + len] = key;
          }
        }
        this.constructor$(entries);
        this._isMap = isMap;
        this._init$(void 0, -3);
      }
      __name(PropertiesPromiseArray, "PropertiesPromiseArray");
      util.inherits(PropertiesPromiseArray, PromiseArray);
      PropertiesPromiseArray.prototype._init = function() {
      };
      PropertiesPromiseArray.prototype._promiseFulfilled = function(value, index) {
        this._values[index] = value;
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= this._length) {
          var val;
          if (this._isMap) {
            val = entriesToMap(this._values);
          } else {
            val = {};
            var keyOffset = this.length();
            for (var i2 = 0, len = this.length(); i2 < len; ++i2) {
              val[this._values[i2 + keyOffset]] = this._values[i2];
            }
          }
          this._resolve(val);
          return true;
        }
        return false;
      };
      PropertiesPromiseArray.prototype.shouldCopyValues = function() {
        return false;
      };
      PropertiesPromiseArray.prototype.getActualLength = function(len) {
        return len >> 1;
      };
      function props(promises) {
        var ret2;
        var castValue = tryConvertToPromise(promises);
        if (!isObject2(castValue)) {
          return apiRejection("cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n");
        } else if (castValue instanceof Promise2) {
          ret2 = castValue._then(
            Promise2.props,
            void 0,
            void 0,
            void 0,
            void 0
          );
        } else {
          ret2 = new PropertiesPromiseArray(castValue).promise();
        }
        if (castValue instanceof Promise2) {
          ret2._propagateFrom(castValue, 2);
        }
        return ret2;
      }
      __name(props, "props");
      Promise2.prototype.props = function() {
        return props(this);
      };
      Promise2.props = function(promises) {
        return props(promises);
      };
    };
  }
});

// node_modules/bluebird/js/release/race.js
var require_race = __commonJS({
  "node_modules/bluebird/js/release/race.js"(exports2, module2) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection) {
      var util = require_util();
      var raceLater = /* @__PURE__ */ __name(function(promise) {
        return promise.then(function(array) {
          return race(array, promise);
        });
      }, "raceLater");
      function race(promises, parent) {
        var maybePromise = tryConvertToPromise(promises);
        if (maybePromise instanceof Promise2) {
          return raceLater(maybePromise);
        } else {
          promises = util.asArray(promises);
          if (promises === null)
            return apiRejection("expecting an array or an iterable object but got " + util.classString(promises));
        }
        var ret2 = new Promise2(INTERNAL);
        if (parent !== void 0) {
          ret2._propagateFrom(parent, 3);
        }
        var fulfill = ret2._fulfill;
        var reject = ret2._reject;
        for (var i2 = 0, len = promises.length; i2 < len; ++i2) {
          var val = promises[i2];
          if (val === void 0 && !(i2 in promises)) {
            continue;
          }
          Promise2.cast(val)._then(fulfill, reject, void 0, ret2, null);
        }
        return ret2;
      }
      __name(race, "race");
      Promise2.race = function(promises) {
        return race(promises, void 0);
      };
      Promise2.prototype.race = function() {
        return race(this, void 0);
      };
    };
  }
});

// node_modules/bluebird/js/release/reduce.js
var require_reduce = __commonJS({
  "node_modules/bluebird/js/release/reduce.js"(exports2, module2) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = function(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug3) {
      var getDomain = Promise2._getDomain;
      var util = require_util();
      var tryCatch2 = util.tryCatch;
      function ReductionPromiseArray(promises, fn2, initialValue, _each) {
        this.constructor$(promises);
        var domain2 = getDomain();
        this._fn = domain2 === null ? fn2 : util.domainBind(domain2, fn2);
        if (initialValue !== void 0) {
          initialValue = Promise2.resolve(initialValue);
          initialValue._attachCancellationCallback(this);
        }
        this._initialValue = initialValue;
        this._currentCancellable = null;
        if (_each === INTERNAL) {
          this._eachValues = Array(this._length);
        } else if (_each === 0) {
          this._eachValues = null;
        } else {
          this._eachValues = void 0;
        }
        this._promise._captureStackTrace();
        this._init$(void 0, -5);
      }
      __name(ReductionPromiseArray, "ReductionPromiseArray");
      util.inherits(ReductionPromiseArray, PromiseArray);
      ReductionPromiseArray.prototype._gotAccum = function(accum) {
        if (this._eachValues !== void 0 && this._eachValues !== null && accum !== INTERNAL) {
          this._eachValues.push(accum);
        }
      };
      ReductionPromiseArray.prototype._eachComplete = function(value) {
        if (this._eachValues !== null) {
          this._eachValues.push(value);
        }
        return this._eachValues;
      };
      ReductionPromiseArray.prototype._init = function() {
      };
      ReductionPromiseArray.prototype._resolveEmptyArray = function() {
        this._resolve(this._eachValues !== void 0 ? this._eachValues : this._initialValue);
      };
      ReductionPromiseArray.prototype.shouldCopyValues = function() {
        return false;
      };
      ReductionPromiseArray.prototype._resolve = function(value) {
        this._promise._resolveCallback(value);
        this._values = null;
      };
      ReductionPromiseArray.prototype._resultCancelled = function(sender) {
        if (sender === this._initialValue)
          return this._cancel();
        if (this._isResolved())
          return;
        this._resultCancelled$();
        if (this._currentCancellable instanceof Promise2) {
          this._currentCancellable.cancel();
        }
        if (this._initialValue instanceof Promise2) {
          this._initialValue.cancel();
        }
      };
      ReductionPromiseArray.prototype._iterate = function(values) {
        this._values = values;
        var value;
        var i2;
        var length = values.length;
        if (this._initialValue !== void 0) {
          value = this._initialValue;
          i2 = 0;
        } else {
          value = Promise2.resolve(values[0]);
          i2 = 1;
        }
        this._currentCancellable = value;
        if (!value.isRejected()) {
          for (; i2 < length; ++i2) {
            var ctx = {
              accum: null,
              value: values[i2],
              index: i2,
              length,
              array: this
            };
            value = value._then(gotAccum, void 0, void 0, ctx, void 0);
          }
        }
        if (this._eachValues !== void 0) {
          value = value._then(this._eachComplete, void 0, void 0, this, void 0);
        }
        value._then(completed, completed, void 0, value, this);
      };
      Promise2.prototype.reduce = function(fn2, initialValue) {
        return reduce(this, fn2, initialValue, null);
      };
      Promise2.reduce = function(promises, fn2, initialValue, _each) {
        return reduce(promises, fn2, initialValue, _each);
      };
      function completed(valueOrReason, array) {
        if (this.isFulfilled()) {
          array._resolve(valueOrReason);
        } else {
          array._reject(valueOrReason);
        }
      }
      __name(completed, "completed");
      function reduce(promises, fn2, initialValue, _each) {
        if (typeof fn2 !== "function") {
          return apiRejection("expecting a function but got " + util.classString(fn2));
        }
        var array = new ReductionPromiseArray(promises, fn2, initialValue, _each);
        return array.promise();
      }
      __name(reduce, "reduce");
      function gotAccum(accum) {
        this.accum = accum;
        this.array._gotAccum(accum);
        var value = tryConvertToPromise(this.value, this.array._promise);
        if (value instanceof Promise2) {
          this.array._currentCancellable = value;
          return value._then(gotValue, void 0, void 0, this, void 0);
        } else {
          return gotValue.call(this, value);
        }
      }
      __name(gotAccum, "gotAccum");
      function gotValue(value) {
        var array = this.array;
        var promise = array._promise;
        var fn2 = tryCatch2(array._fn);
        promise._pushContext();
        var ret2;
        if (array._eachValues !== void 0) {
          ret2 = fn2.call(promise._boundValue(), value, this.index, this.length);
        } else {
          ret2 = fn2.call(
            promise._boundValue(),
            this.accum,
            value,
            this.index,
            this.length
          );
        }
        if (ret2 instanceof Promise2) {
          array._currentCancellable = ret2;
        }
        var promiseCreated = promise._popContext();
        debug3.checkForgottenReturns(
          ret2,
          promiseCreated,
          array._eachValues !== void 0 ? "Promise.each" : "Promise.reduce",
          promise
        );
        return ret2;
      }
      __name(gotValue, "gotValue");
    };
  }
});

// node_modules/bluebird/js/release/settle.js
var require_settle = __commonJS({
  "node_modules/bluebird/js/release/settle.js"(exports2, module2) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = function(Promise2, PromiseArray, debug3) {
      var PromiseInspection = Promise2.PromiseInspection;
      var util = require_util();
      function SettledPromiseArray(values) {
        this.constructor$(values);
      }
      __name(SettledPromiseArray, "SettledPromiseArray");
      util.inherits(SettledPromiseArray, PromiseArray);
      SettledPromiseArray.prototype._promiseResolved = function(index, inspection) {
        this._values[index] = inspection;
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= this._length) {
          this._resolve(this._values);
          return true;
        }
        return false;
      };
      SettledPromiseArray.prototype._promiseFulfilled = function(value, index) {
        var ret2 = new PromiseInspection();
        ret2._bitField = 33554432;
        ret2._settledValueField = value;
        return this._promiseResolved(index, ret2);
      };
      SettledPromiseArray.prototype._promiseRejected = function(reason, index) {
        var ret2 = new PromiseInspection();
        ret2._bitField = 16777216;
        ret2._settledValueField = reason;
        return this._promiseResolved(index, ret2);
      };
      Promise2.settle = function(promises) {
        debug3.deprecated(".settle()", ".reflect()");
        return new SettledPromiseArray(promises).promise();
      };
      Promise2.prototype.settle = function() {
        return Promise2.settle(this);
      };
    };
  }
});

// node_modules/bluebird/js/release/some.js
var require_some = __commonJS({
  "node_modules/bluebird/js/release/some.js"(exports2, module2) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = function(Promise2, PromiseArray, apiRejection) {
      var util = require_util();
      var RangeError2 = require_errors().RangeError;
      var AggregateError = require_errors().AggregateError;
      var isArray = util.isArray;
      var CANCELLATION = {};
      function SomePromiseArray(values) {
        this.constructor$(values);
        this._howMany = 0;
        this._unwrap = false;
        this._initialized = false;
      }
      __name(SomePromiseArray, "SomePromiseArray");
      util.inherits(SomePromiseArray, PromiseArray);
      SomePromiseArray.prototype._init = function() {
        if (!this._initialized) {
          return;
        }
        if (this._howMany === 0) {
          this._resolve([]);
          return;
        }
        this._init$(void 0, -5);
        var isArrayResolved = isArray(this._values);
        if (!this._isResolved() && isArrayResolved && this._howMany > this._canPossiblyFulfill()) {
          this._reject(this._getRangeError(this.length()));
        }
      };
      SomePromiseArray.prototype.init = function() {
        this._initialized = true;
        this._init();
      };
      SomePromiseArray.prototype.setUnwrap = function() {
        this._unwrap = true;
      };
      SomePromiseArray.prototype.howMany = function() {
        return this._howMany;
      };
      SomePromiseArray.prototype.setHowMany = function(count3) {
        this._howMany = count3;
      };
      SomePromiseArray.prototype._promiseFulfilled = function(value) {
        this._addFulfilled(value);
        if (this._fulfilled() === this.howMany()) {
          this._values.length = this.howMany();
          if (this.howMany() === 1 && this._unwrap) {
            this._resolve(this._values[0]);
          } else {
            this._resolve(this._values);
          }
          return true;
        }
        return false;
      };
      SomePromiseArray.prototype._promiseRejected = function(reason) {
        this._addRejected(reason);
        return this._checkOutcome();
      };
      SomePromiseArray.prototype._promiseCancelled = function() {
        if (this._values instanceof Promise2 || this._values == null) {
          return this._cancel();
        }
        this._addRejected(CANCELLATION);
        return this._checkOutcome();
      };
      SomePromiseArray.prototype._checkOutcome = function() {
        if (this.howMany() > this._canPossiblyFulfill()) {
          var e2 = new AggregateError();
          for (var i2 = this.length(); i2 < this._values.length; ++i2) {
            if (this._values[i2] !== CANCELLATION) {
              e2.push(this._values[i2]);
            }
          }
          if (e2.length > 0) {
            this._reject(e2);
          } else {
            this._cancel();
          }
          return true;
        }
        return false;
      };
      SomePromiseArray.prototype._fulfilled = function() {
        return this._totalResolved;
      };
      SomePromiseArray.prototype._rejected = function() {
        return this._values.length - this.length();
      };
      SomePromiseArray.prototype._addRejected = function(reason) {
        this._values.push(reason);
      };
      SomePromiseArray.prototype._addFulfilled = function(value) {
        this._values[this._totalResolved++] = value;
      };
      SomePromiseArray.prototype._canPossiblyFulfill = function() {
        return this.length() - this._rejected();
      };
      SomePromiseArray.prototype._getRangeError = function(count3) {
        var message = "Input array must contain at least " + this._howMany + " items but contains only " + count3 + " items";
        return new RangeError2(message);
      };
      SomePromiseArray.prototype._resolveEmptyArray = function() {
        this._reject(this._getRangeError(0));
      };
      function some(promises, howMany) {
        if ((howMany | 0) !== howMany || howMany < 0) {
          return apiRejection("expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n");
        }
        var ret2 = new SomePromiseArray(promises);
        var promise = ret2.promise();
        ret2.setHowMany(howMany);
        ret2.init();
        return promise;
      }
      __name(some, "some");
      Promise2.some = function(promises, howMany) {
        return some(promises, howMany);
      };
      Promise2.prototype.some = function(howMany) {
        return some(this, howMany);
      };
      Promise2._SomePromiseArray = SomePromiseArray;
    };
  }
});

// node_modules/bluebird/js/release/filter.js
var require_filter = __commonJS({
  "node_modules/bluebird/js/release/filter.js"(exports2, module2) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = function(Promise2, INTERNAL) {
      var PromiseMap = Promise2.map;
      Promise2.prototype.filter = function(fn2, options) {
        return PromiseMap(this, fn2, options, INTERNAL);
      };
      Promise2.filter = function(promises, fn2, options) {
        return PromiseMap(promises, fn2, options, INTERNAL);
      };
    };
  }
});

// node_modules/bluebird/js/release/each.js
var require_each = __commonJS({
  "node_modules/bluebird/js/release/each.js"(exports2, module2) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = function(Promise2, INTERNAL) {
      var PromiseReduce = Promise2.reduce;
      var PromiseAll = Promise2.all;
      function promiseAllThis() {
        return PromiseAll(this);
      }
      __name(promiseAllThis, "promiseAllThis");
      function PromiseMapSeries(promises, fn2) {
        return PromiseReduce(promises, fn2, INTERNAL, INTERNAL);
      }
      __name(PromiseMapSeries, "PromiseMapSeries");
      Promise2.prototype.each = function(fn2) {
        return PromiseReduce(this, fn2, INTERNAL, 0)._then(promiseAllThis, void 0, void 0, this, void 0);
      };
      Promise2.prototype.mapSeries = function(fn2) {
        return PromiseReduce(this, fn2, INTERNAL, INTERNAL);
      };
      Promise2.each = function(promises, fn2) {
        return PromiseReduce(promises, fn2, INTERNAL, 0)._then(promiseAllThis, void 0, void 0, promises, void 0);
      };
      Promise2.mapSeries = PromiseMapSeries;
    };
  }
});

// node_modules/bluebird/js/release/any.js
var require_any = __commonJS({
  "node_modules/bluebird/js/release/any.js"(exports2, module2) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = function(Promise2) {
      var SomePromiseArray = Promise2._SomePromiseArray;
      function any(promises) {
        var ret2 = new SomePromiseArray(promises);
        var promise = ret2.promise();
        ret2.setHowMany(1);
        ret2.setUnwrap();
        ret2.init();
        return promise;
      }
      __name(any, "any");
      Promise2.any = function(promises) {
        return any(promises);
      };
      Promise2.prototype.any = function() {
        return any(this);
      };
    };
  }
});

// node_modules/bluebird/js/release/promise.js
var require_promise = __commonJS({
  "node_modules/bluebird/js/release/promise.js"(exports2, module2) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = function() {
      var makeSelfResolutionError = /* @__PURE__ */ __name(function() {
        return new TypeError2("circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n");
      }, "makeSelfResolutionError");
      var reflectHandler = /* @__PURE__ */ __name(function() {
        return new Promise2.PromiseInspection(this._target());
      }, "reflectHandler");
      var apiRejection = /* @__PURE__ */ __name(function(msg) {
        return Promise2.reject(new TypeError2(msg));
      }, "apiRejection");
      function Proxyable() {
      }
      __name(Proxyable, "Proxyable");
      var UNDEFINED_BINDING = {};
      var util = require_util();
      var getDomain;
      if (util.isNode) {
        getDomain = /* @__PURE__ */ __name(function() {
          var ret2 = process.domain;
          if (ret2 === void 0)
            ret2 = null;
          return ret2;
        }, "getDomain");
      } else {
        getDomain = /* @__PURE__ */ __name(function() {
          return null;
        }, "getDomain");
      }
      util.notEnumerableProp(Promise2, "_getDomain", getDomain);
      var es52 = require_es5();
      var Async = require_async();
      var async = new Async();
      es52.defineProperty(Promise2, "_async", { value: async });
      var errors = require_errors();
      var TypeError2 = Promise2.TypeError = errors.TypeError;
      Promise2.RangeError = errors.RangeError;
      var CancellationError = Promise2.CancellationError = errors.CancellationError;
      Promise2.TimeoutError = errors.TimeoutError;
      Promise2.OperationalError = errors.OperationalError;
      Promise2.RejectionError = errors.OperationalError;
      Promise2.AggregateError = errors.AggregateError;
      var INTERNAL = /* @__PURE__ */ __name(function() {
      }, "INTERNAL");
      var APPLY = {};
      var NEXT_FILTER = {};
      var tryConvertToPromise = require_thenables()(Promise2, INTERNAL);
      var PromiseArray = require_promise_array()(
        Promise2,
        INTERNAL,
        tryConvertToPromise,
        apiRejection,
        Proxyable
      );
      var Context = require_context()(Promise2);
      var createContext = Context.create;
      var debug3 = require_debuggability()(Promise2, Context);
      var CapturedTrace = debug3.CapturedTrace;
      var PassThroughHandlerContext = require_finally()(Promise2, tryConvertToPromise);
      var catchFilter = require_catch_filter()(NEXT_FILTER);
      var nodebackForPromise = require_nodeback();
      var errorObj2 = util.errorObj;
      var tryCatch2 = util.tryCatch;
      function check(self2, executor) {
        if (typeof executor !== "function") {
          throw new TypeError2("expecting a function but got " + util.classString(executor));
        }
        if (self2.constructor !== Promise2) {
          throw new TypeError2("the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n");
        }
      }
      __name(check, "check");
      function Promise2(executor) {
        this._bitField = 0;
        this._fulfillmentHandler0 = void 0;
        this._rejectionHandler0 = void 0;
        this._promise0 = void 0;
        this._receiver0 = void 0;
        if (executor !== INTERNAL) {
          check(this, executor);
          this._resolveFromExecutor(executor);
        }
        this._promiseCreated();
        this._fireEvent("promiseCreated", this);
      }
      __name(Promise2, "Promise");
      Promise2.prototype.toString = function() {
        return "[object Promise]";
      };
      Promise2.prototype.caught = Promise2.prototype["catch"] = function(fn2) {
        var len = arguments.length;
        if (len > 1) {
          var catchInstances = new Array(len - 1), j2 = 0, i2;
          for (i2 = 0; i2 < len - 1; ++i2) {
            var item = arguments[i2];
            if (util.isObject(item)) {
              catchInstances[j2++] = item;
            } else {
              return apiRejection("expecting an object but got A catch statement predicate " + util.classString(item));
            }
          }
          catchInstances.length = j2;
          fn2 = arguments[i2];
          return this.then(void 0, catchFilter(catchInstances, fn2, this));
        }
        return this.then(void 0, fn2);
      };
      Promise2.prototype.reflect = function() {
        return this._then(
          reflectHandler,
          reflectHandler,
          void 0,
          this,
          void 0
        );
      };
      Promise2.prototype.then = function(didFulfill, didReject) {
        if (debug3.warnings() && arguments.length > 0 && typeof didFulfill !== "function" && typeof didReject !== "function") {
          var msg = ".then() only accepts functions but was passed: " + util.classString(didFulfill);
          if (arguments.length > 1) {
            msg += ", " + util.classString(didReject);
          }
          this._warn(msg);
        }
        return this._then(didFulfill, didReject, void 0, void 0, void 0);
      };
      Promise2.prototype.done = function(didFulfill, didReject) {
        var promise = this._then(didFulfill, didReject, void 0, void 0, void 0);
        promise._setIsFinal();
      };
      Promise2.prototype.spread = function(fn2) {
        if (typeof fn2 !== "function") {
          return apiRejection("expecting a function but got " + util.classString(fn2));
        }
        return this.all()._then(fn2, void 0, void 0, APPLY, void 0);
      };
      Promise2.prototype.toJSON = function() {
        var ret2 = {
          isFulfilled: false,
          isRejected: false,
          fulfillmentValue: void 0,
          rejectionReason: void 0
        };
        if (this.isFulfilled()) {
          ret2.fulfillmentValue = this.value();
          ret2.isFulfilled = true;
        } else if (this.isRejected()) {
          ret2.rejectionReason = this.reason();
          ret2.isRejected = true;
        }
        return ret2;
      };
      Promise2.prototype.all = function() {
        if (arguments.length > 0) {
          this._warn(".all() was passed arguments but it does not take any");
        }
        return new PromiseArray(this).promise();
      };
      Promise2.prototype.error = function(fn2) {
        return this.caught(util.originatesFromRejection, fn2);
      };
      Promise2.getNewLibraryCopy = module2.exports;
      Promise2.is = function(val) {
        return val instanceof Promise2;
      };
      Promise2.fromNode = Promise2.fromCallback = function(fn2) {
        var ret2 = new Promise2(INTERNAL);
        ret2._captureStackTrace();
        var multiArgs = arguments.length > 1 ? !!Object(arguments[1]).multiArgs : false;
        var result = tryCatch2(fn2)(nodebackForPromise(ret2, multiArgs));
        if (result === errorObj2) {
          ret2._rejectCallback(result.e, true);
        }
        if (!ret2._isFateSealed())
          ret2._setAsyncGuaranteed();
        return ret2;
      };
      Promise2.all = function(promises) {
        return new PromiseArray(promises).promise();
      };
      Promise2.cast = function(obj2) {
        var ret2 = tryConvertToPromise(obj2);
        if (!(ret2 instanceof Promise2)) {
          ret2 = new Promise2(INTERNAL);
          ret2._captureStackTrace();
          ret2._setFulfilled();
          ret2._rejectionHandler0 = obj2;
        }
        return ret2;
      };
      Promise2.resolve = Promise2.fulfilled = Promise2.cast;
      Promise2.reject = Promise2.rejected = function(reason) {
        var ret2 = new Promise2(INTERNAL);
        ret2._captureStackTrace();
        ret2._rejectCallback(reason, true);
        return ret2;
      };
      Promise2.setScheduler = function(fn2) {
        if (typeof fn2 !== "function") {
          throw new TypeError2("expecting a function but got " + util.classString(fn2));
        }
        return async.setScheduler(fn2);
      };
      Promise2.prototype._then = function(didFulfill, didReject, _2, receiver, internalData) {
        var haveInternalData = internalData !== void 0;
        var promise = haveInternalData ? internalData : new Promise2(INTERNAL);
        var target = this._target();
        var bitField = target._bitField;
        if (!haveInternalData) {
          promise._propagateFrom(this, 3);
          promise._captureStackTrace();
          if (receiver === void 0 && (this._bitField & 2097152) !== 0) {
            if (!((bitField & 50397184) === 0)) {
              receiver = this._boundValue();
            } else {
              receiver = target === this ? void 0 : this._boundTo;
            }
          }
          this._fireEvent("promiseChained", this, promise);
        }
        var domain2 = getDomain();
        if (!((bitField & 50397184) === 0)) {
          var handler, value, settler = target._settlePromiseCtx;
          if ((bitField & 33554432) !== 0) {
            value = target._rejectionHandler0;
            handler = didFulfill;
          } else if ((bitField & 16777216) !== 0) {
            value = target._fulfillmentHandler0;
            handler = didReject;
            target._unsetRejectionIsUnhandled();
          } else {
            settler = target._settlePromiseLateCancellationObserver;
            value = new CancellationError("late cancellation observer");
            target._attachExtraTrace(value);
            handler = didReject;
          }
          async.invoke(settler, target, {
            handler: domain2 === null ? handler : typeof handler === "function" && util.domainBind(domain2, handler),
            promise,
            receiver,
            value
          });
        } else {
          target._addCallbacks(didFulfill, didReject, promise, receiver, domain2);
        }
        return promise;
      };
      Promise2.prototype._length = function() {
        return this._bitField & 65535;
      };
      Promise2.prototype._isFateSealed = function() {
        return (this._bitField & 117506048) !== 0;
      };
      Promise2.prototype._isFollowing = function() {
        return (this._bitField & 67108864) === 67108864;
      };
      Promise2.prototype._setLength = function(len) {
        this._bitField = this._bitField & -65536 | len & 65535;
      };
      Promise2.prototype._setFulfilled = function() {
        this._bitField = this._bitField | 33554432;
        this._fireEvent("promiseFulfilled", this);
      };
      Promise2.prototype._setRejected = function() {
        this._bitField = this._bitField | 16777216;
        this._fireEvent("promiseRejected", this);
      };
      Promise2.prototype._setFollowing = function() {
        this._bitField = this._bitField | 67108864;
        this._fireEvent("promiseResolved", this);
      };
      Promise2.prototype._setIsFinal = function() {
        this._bitField = this._bitField | 4194304;
      };
      Promise2.prototype._isFinal = function() {
        return (this._bitField & 4194304) > 0;
      };
      Promise2.prototype._unsetCancelled = function() {
        this._bitField = this._bitField & ~65536;
      };
      Promise2.prototype._setCancelled = function() {
        this._bitField = this._bitField | 65536;
        this._fireEvent("promiseCancelled", this);
      };
      Promise2.prototype._setWillBeCancelled = function() {
        this._bitField = this._bitField | 8388608;
      };
      Promise2.prototype._setAsyncGuaranteed = function() {
        if (async.hasCustomScheduler())
          return;
        this._bitField = this._bitField | 134217728;
      };
      Promise2.prototype._receiverAt = function(index) {
        var ret2 = index === 0 ? this._receiver0 : this[index * 4 - 4 + 3];
        if (ret2 === UNDEFINED_BINDING) {
          return void 0;
        } else if (ret2 === void 0 && this._isBound()) {
          return this._boundValue();
        }
        return ret2;
      };
      Promise2.prototype._promiseAt = function(index) {
        return this[index * 4 - 4 + 2];
      };
      Promise2.prototype._fulfillmentHandlerAt = function(index) {
        return this[index * 4 - 4 + 0];
      };
      Promise2.prototype._rejectionHandlerAt = function(index) {
        return this[index * 4 - 4 + 1];
      };
      Promise2.prototype._boundValue = function() {
      };
      Promise2.prototype._migrateCallback0 = function(follower) {
        var bitField = follower._bitField;
        var fulfill = follower._fulfillmentHandler0;
        var reject = follower._rejectionHandler0;
        var promise = follower._promise0;
        var receiver = follower._receiverAt(0);
        if (receiver === void 0)
          receiver = UNDEFINED_BINDING;
        this._addCallbacks(fulfill, reject, promise, receiver, null);
      };
      Promise2.prototype._migrateCallbackAt = function(follower, index) {
        var fulfill = follower._fulfillmentHandlerAt(index);
        var reject = follower._rejectionHandlerAt(index);
        var promise = follower._promiseAt(index);
        var receiver = follower._receiverAt(index);
        if (receiver === void 0)
          receiver = UNDEFINED_BINDING;
        this._addCallbacks(fulfill, reject, promise, receiver, null);
      };
      Promise2.prototype._addCallbacks = function(fulfill, reject, promise, receiver, domain2) {
        var index = this._length();
        if (index >= 65535 - 4) {
          index = 0;
          this._setLength(0);
        }
        if (index === 0) {
          this._promise0 = promise;
          this._receiver0 = receiver;
          if (typeof fulfill === "function") {
            this._fulfillmentHandler0 = domain2 === null ? fulfill : util.domainBind(domain2, fulfill);
          }
          if (typeof reject === "function") {
            this._rejectionHandler0 = domain2 === null ? reject : util.domainBind(domain2, reject);
          }
        } else {
          var base = index * 4 - 4;
          this[base + 2] = promise;
          this[base + 3] = receiver;
          if (typeof fulfill === "function") {
            this[base + 0] = domain2 === null ? fulfill : util.domainBind(domain2, fulfill);
          }
          if (typeof reject === "function") {
            this[base + 1] = domain2 === null ? reject : util.domainBind(domain2, reject);
          }
        }
        this._setLength(index + 1);
        return index;
      };
      Promise2.prototype._proxy = function(proxyable, arg) {
        this._addCallbacks(void 0, void 0, arg, proxyable, null);
      };
      Promise2.prototype._resolveCallback = function(value, shouldBind) {
        if ((this._bitField & 117506048) !== 0)
          return;
        if (value === this)
          return this._rejectCallback(makeSelfResolutionError(), false);
        var maybePromise = tryConvertToPromise(value, this);
        if (!(maybePromise instanceof Promise2))
          return this._fulfill(value);
        if (shouldBind)
          this._propagateFrom(maybePromise, 2);
        var promise = maybePromise._target();
        if (promise === this) {
          this._reject(makeSelfResolutionError());
          return;
        }
        var bitField = promise._bitField;
        if ((bitField & 50397184) === 0) {
          var len = this._length();
          if (len > 0)
            promise._migrateCallback0(this);
          for (var i2 = 1; i2 < len; ++i2) {
            promise._migrateCallbackAt(this, i2);
          }
          this._setFollowing();
          this._setLength(0);
          this._setFollowee(promise);
        } else if ((bitField & 33554432) !== 0) {
          this._fulfill(promise._value());
        } else if ((bitField & 16777216) !== 0) {
          this._reject(promise._reason());
        } else {
          var reason = new CancellationError("late cancellation observer");
          promise._attachExtraTrace(reason);
          this._reject(reason);
        }
      };
      Promise2.prototype._rejectCallback = function(reason, synchronous, ignoreNonErrorWarnings) {
        var trace3 = util.ensureErrorObject(reason);
        var hasStack = trace3 === reason;
        if (!hasStack && !ignoreNonErrorWarnings && debug3.warnings()) {
          var message = "a promise was rejected with a non-error: " + util.classString(reason);
          this._warn(message, true);
        }
        this._attachExtraTrace(trace3, synchronous ? hasStack : false);
        this._reject(reason);
      };
      Promise2.prototype._resolveFromExecutor = function(executor) {
        var promise = this;
        this._captureStackTrace();
        this._pushContext();
        var synchronous = true;
        var r2 = this._execute(executor, function(value) {
          promise._resolveCallback(value);
        }, function(reason) {
          promise._rejectCallback(reason, synchronous);
        });
        synchronous = false;
        this._popContext();
        if (r2 !== void 0) {
          promise._rejectCallback(r2, true);
        }
      };
      Promise2.prototype._settlePromiseFromHandler = function(handler, receiver, value, promise) {
        var bitField = promise._bitField;
        if ((bitField & 65536) !== 0)
          return;
        promise._pushContext();
        var x2;
        if (receiver === APPLY) {
          if (!value || typeof value.length !== "number") {
            x2 = errorObj2;
            x2.e = new TypeError2("cannot .spread() a non-array: " + util.classString(value));
          } else {
            x2 = tryCatch2(handler).apply(this._boundValue(), value);
          }
        } else {
          x2 = tryCatch2(handler).call(receiver, value);
        }
        var promiseCreated = promise._popContext();
        bitField = promise._bitField;
        if ((bitField & 65536) !== 0)
          return;
        if (x2 === NEXT_FILTER) {
          promise._reject(value);
        } else if (x2 === errorObj2) {
          promise._rejectCallback(x2.e, false);
        } else {
          debug3.checkForgottenReturns(x2, promiseCreated, "", promise, this);
          promise._resolveCallback(x2);
        }
      };
      Promise2.prototype._target = function() {
        var ret2 = this;
        while (ret2._isFollowing())
          ret2 = ret2._followee();
        return ret2;
      };
      Promise2.prototype._followee = function() {
        return this._rejectionHandler0;
      };
      Promise2.prototype._setFollowee = function(promise) {
        this._rejectionHandler0 = promise;
      };
      Promise2.prototype._settlePromise = function(promise, handler, receiver, value) {
        var isPromise = promise instanceof Promise2;
        var bitField = this._bitField;
        var asyncGuaranteed = (bitField & 134217728) !== 0;
        if ((bitField & 65536) !== 0) {
          if (isPromise)
            promise._invokeInternalOnCancel();
          if (receiver instanceof PassThroughHandlerContext && receiver.isFinallyHandler()) {
            receiver.cancelPromise = promise;
            if (tryCatch2(handler).call(receiver, value) === errorObj2) {
              promise._reject(errorObj2.e);
            }
          } else if (handler === reflectHandler) {
            promise._fulfill(reflectHandler.call(receiver));
          } else if (receiver instanceof Proxyable) {
            receiver._promiseCancelled(promise);
          } else if (isPromise || promise instanceof PromiseArray) {
            promise._cancel();
          } else {
            receiver.cancel();
          }
        } else if (typeof handler === "function") {
          if (!isPromise) {
            handler.call(receiver, value, promise);
          } else {
            if (asyncGuaranteed)
              promise._setAsyncGuaranteed();
            this._settlePromiseFromHandler(handler, receiver, value, promise);
          }
        } else if (receiver instanceof Proxyable) {
          if (!receiver._isResolved()) {
            if ((bitField & 33554432) !== 0) {
              receiver._promiseFulfilled(value, promise);
            } else {
              receiver._promiseRejected(value, promise);
            }
          }
        } else if (isPromise) {
          if (asyncGuaranteed)
            promise._setAsyncGuaranteed();
          if ((bitField & 33554432) !== 0) {
            promise._fulfill(value);
          } else {
            promise._reject(value);
          }
        }
      };
      Promise2.prototype._settlePromiseLateCancellationObserver = function(ctx) {
        var handler = ctx.handler;
        var promise = ctx.promise;
        var receiver = ctx.receiver;
        var value = ctx.value;
        if (typeof handler === "function") {
          if (!(promise instanceof Promise2)) {
            handler.call(receiver, value, promise);
          } else {
            this._settlePromiseFromHandler(handler, receiver, value, promise);
          }
        } else if (promise instanceof Promise2) {
          promise._reject(value);
        }
      };
      Promise2.prototype._settlePromiseCtx = function(ctx) {
        this._settlePromise(ctx.promise, ctx.handler, ctx.receiver, ctx.value);
      };
      Promise2.prototype._settlePromise0 = function(handler, value, bitField) {
        var promise = this._promise0;
        var receiver = this._receiverAt(0);
        this._promise0 = void 0;
        this._receiver0 = void 0;
        this._settlePromise(promise, handler, receiver, value);
      };
      Promise2.prototype._clearCallbackDataAtIndex = function(index) {
        var base = index * 4 - 4;
        this[base + 2] = this[base + 3] = this[base + 0] = this[base + 1] = void 0;
      };
      Promise2.prototype._fulfill = function(value) {
        var bitField = this._bitField;
        if ((bitField & 117506048) >>> 16)
          return;
        if (value === this) {
          var err = makeSelfResolutionError();
          this._attachExtraTrace(err);
          return this._reject(err);
        }
        this._setFulfilled();
        this._rejectionHandler0 = value;
        if ((bitField & 65535) > 0) {
          if ((bitField & 134217728) !== 0) {
            this._settlePromises();
          } else {
            async.settlePromises(this);
          }
        }
      };
      Promise2.prototype._reject = function(reason) {
        var bitField = this._bitField;
        if ((bitField & 117506048) >>> 16)
          return;
        this._setRejected();
        this._fulfillmentHandler0 = reason;
        if (this._isFinal()) {
          return async.fatalError(reason, util.isNode);
        }
        if ((bitField & 65535) > 0) {
          async.settlePromises(this);
        } else {
          this._ensurePossibleRejectionHandled();
        }
      };
      Promise2.prototype._fulfillPromises = function(len, value) {
        for (var i2 = 1; i2 < len; i2++) {
          var handler = this._fulfillmentHandlerAt(i2);
          var promise = this._promiseAt(i2);
          var receiver = this._receiverAt(i2);
          this._clearCallbackDataAtIndex(i2);
          this._settlePromise(promise, handler, receiver, value);
        }
      };
      Promise2.prototype._rejectPromises = function(len, reason) {
        for (var i2 = 1; i2 < len; i2++) {
          var handler = this._rejectionHandlerAt(i2);
          var promise = this._promiseAt(i2);
          var receiver = this._receiverAt(i2);
          this._clearCallbackDataAtIndex(i2);
          this._settlePromise(promise, handler, receiver, reason);
        }
      };
      Promise2.prototype._settlePromises = function() {
        var bitField = this._bitField;
        var len = bitField & 65535;
        if (len > 0) {
          if ((bitField & 16842752) !== 0) {
            var reason = this._fulfillmentHandler0;
            this._settlePromise0(this._rejectionHandler0, reason, bitField);
            this._rejectPromises(len, reason);
          } else {
            var value = this._rejectionHandler0;
            this._settlePromise0(this._fulfillmentHandler0, value, bitField);
            this._fulfillPromises(len, value);
          }
          this._setLength(0);
        }
        this._clearCancellationData();
      };
      Promise2.prototype._settledValue = function() {
        var bitField = this._bitField;
        if ((bitField & 33554432) !== 0) {
          return this._rejectionHandler0;
        } else if ((bitField & 16777216) !== 0) {
          return this._fulfillmentHandler0;
        }
      };
      function deferResolve(v2) {
        this.promise._resolveCallback(v2);
      }
      __name(deferResolve, "deferResolve");
      function deferReject(v2) {
        this.promise._rejectCallback(v2, false);
      }
      __name(deferReject, "deferReject");
      Promise2.defer = Promise2.pending = function() {
        debug3.deprecated("Promise.defer", "new Promise");
        var promise = new Promise2(INTERNAL);
        return {
          promise,
          resolve: deferResolve,
          reject: deferReject
        };
      };
      util.notEnumerableProp(
        Promise2,
        "_makeSelfResolutionError",
        makeSelfResolutionError
      );
      require_method()(
        Promise2,
        INTERNAL,
        tryConvertToPromise,
        apiRejection,
        debug3
      );
      require_bind()(Promise2, INTERNAL, tryConvertToPromise, debug3);
      require_cancel()(Promise2, PromiseArray, apiRejection, debug3);
      require_direct_resolve()(Promise2);
      require_synchronous_inspection()(Promise2);
      require_join()(
        Promise2,
        PromiseArray,
        tryConvertToPromise,
        INTERNAL,
        async,
        getDomain
      );
      Promise2.Promise = Promise2;
      Promise2.version = "3.4.7";
      require_map()(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug3);
      require_call_get()(Promise2);
      require_using()(Promise2, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug3);
      require_timers()(Promise2, INTERNAL, debug3);
      require_generators()(Promise2, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug3);
      require_nodeify()(Promise2);
      require_promisify()(Promise2, INTERNAL);
      require_props()(Promise2, PromiseArray, tryConvertToPromise, apiRejection);
      require_race()(Promise2, INTERNAL, tryConvertToPromise, apiRejection);
      require_reduce()(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug3);
      require_settle()(Promise2, PromiseArray, debug3);
      require_some()(Promise2, PromiseArray, apiRejection);
      require_filter()(Promise2, INTERNAL);
      require_each()(Promise2, INTERNAL);
      require_any()(Promise2);
      util.toFastProperties(Promise2);
      util.toFastProperties(Promise2.prototype);
      function fillTypes(value) {
        var p2 = new Promise2(INTERNAL);
        p2._fulfillmentHandler0 = value;
        p2._rejectionHandler0 = value;
        p2._promise0 = value;
        p2._receiver0 = value;
      }
      __name(fillTypes, "fillTypes");
      fillTypes({ a: 1 });
      fillTypes({ b: 2 });
      fillTypes({ c: 3 });
      fillTypes(1);
      fillTypes(function() {
      });
      fillTypes(void 0);
      fillTypes(false);
      fillTypes(new Promise2(INTERNAL));
      debug3.setBounds(Async.firstLineError, util.lastLineError);
      return Promise2;
    };
  }
});

// node_modules/mammoth/lib/promises.js
var require_promises = __commonJS({
  "node_modules/mammoth/lib/promises.js"(exports2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var _2 = require_underscore_umd();
    var bluebird = require_promise()();
    exports2.defer = defer;
    exports2.when = bluebird.resolve;
    exports2.resolve = bluebird.resolve;
    exports2.all = bluebird.all;
    exports2.props = bluebird.props;
    exports2.reject = bluebird.reject;
    exports2.promisify = bluebird.promisify;
    exports2.mapSeries = bluebird.mapSeries;
    exports2.attempt = bluebird.attempt;
    exports2.nfcall = function(func) {
      var args = Array.prototype.slice.call(arguments, 1);
      var promisedFunc = bluebird.promisify(func);
      return promisedFunc.apply(null, args);
    };
    bluebird.prototype.fail = bluebird.prototype.caught;
    bluebird.prototype.also = function(func) {
      return this.then(function(value) {
        var returnValue = _2.extend({}, value, func(value));
        return bluebird.props(returnValue);
      });
    };
    function defer() {
      var resolve;
      var reject;
      var promise = new bluebird.Promise(function(resolveArg, rejectArg) {
        resolve = resolveArg;
        reject = rejectArg;
      });
      return {
        resolve,
        reject,
        promise
      };
    }
    __name(defer, "defer");
  }
});

// node_modules/mammoth/lib/documents.js
var require_documents = __commonJS({
  "node_modules/mammoth/lib/documents.js"(exports2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var _2 = require_underscore_umd();
    var types = exports2.types = {
      document: "document",
      paragraph: "paragraph",
      run: "run",
      text: "text",
      tab: "tab",
      checkbox: "checkbox",
      hyperlink: "hyperlink",
      noteReference: "noteReference",
      image: "image",
      note: "note",
      commentReference: "commentReference",
      comment: "comment",
      table: "table",
      tableRow: "tableRow",
      tableCell: "tableCell",
      "break": "break",
      bookmarkStart: "bookmarkStart"
    };
    function Document(children, options) {
      options = options || {};
      return {
        type: types.document,
        children,
        notes: options.notes || new Notes({}),
        comments: options.comments || []
      };
    }
    __name(Document, "Document");
    function Paragraph(children, properties) {
      properties = properties || {};
      var indent = properties.indent || {};
      return {
        type: types.paragraph,
        children,
        styleId: properties.styleId || null,
        styleName: properties.styleName || null,
        numbering: properties.numbering || null,
        alignment: properties.alignment || null,
        indent: {
          start: indent.start || null,
          end: indent.end || null,
          firstLine: indent.firstLine || null,
          hanging: indent.hanging || null
        }
      };
    }
    __name(Paragraph, "Paragraph");
    function Run(children, properties) {
      properties = properties || {};
      return {
        type: types.run,
        children,
        styleId: properties.styleId || null,
        styleName: properties.styleName || null,
        isBold: !!properties.isBold,
        isUnderline: !!properties.isUnderline,
        isItalic: !!properties.isItalic,
        isStrikethrough: !!properties.isStrikethrough,
        isAllCaps: !!properties.isAllCaps,
        isSmallCaps: !!properties.isSmallCaps,
        verticalAlignment: properties.verticalAlignment || verticalAlignment.baseline,
        font: properties.font || null,
        fontSize: properties.fontSize || null,
        highlight: properties.highlight || null
      };
    }
    __name(Run, "Run");
    var verticalAlignment = {
      baseline: "baseline",
      superscript: "superscript",
      subscript: "subscript"
    };
    function Text2(value) {
      return {
        type: types.text,
        value
      };
    }
    __name(Text2, "Text");
    function Tab() {
      return {
        type: types.tab
      };
    }
    __name(Tab, "Tab");
    function Checkbox(options) {
      return {
        type: types.checkbox,
        checked: options.checked
      };
    }
    __name(Checkbox, "Checkbox");
    function Hyperlink(children, options) {
      return {
        type: types.hyperlink,
        children,
        href: options.href,
        anchor: options.anchor,
        targetFrame: options.targetFrame
      };
    }
    __name(Hyperlink, "Hyperlink");
    function NoteReference(options) {
      return {
        type: types.noteReference,
        noteType: options.noteType,
        noteId: options.noteId
      };
    }
    __name(NoteReference, "NoteReference");
    function Notes(notes) {
      this._notes = _2.indexBy(notes, function(note) {
        return noteKey(note.noteType, note.noteId);
      });
    }
    __name(Notes, "Notes");
    Notes.prototype.resolve = function(reference) {
      return this.findNoteByKey(noteKey(reference.noteType, reference.noteId));
    };
    Notes.prototype.findNoteByKey = function(key) {
      return this._notes[key] || null;
    };
    function Note(options) {
      return {
        type: types.note,
        noteType: options.noteType,
        noteId: options.noteId,
        body: options.body
      };
    }
    __name(Note, "Note");
    function commentReference(options) {
      return {
        type: types.commentReference,
        commentId: options.commentId
      };
    }
    __name(commentReference, "commentReference");
    function comment(options) {
      return {
        type: types.comment,
        commentId: options.commentId,
        body: options.body,
        authorName: options.authorName,
        authorInitials: options.authorInitials
      };
    }
    __name(comment, "comment");
    function noteKey(noteType, id) {
      return noteType + "-" + id;
    }
    __name(noteKey, "noteKey");
    function Image2(options) {
      return {
        type: types.image,
        // `read` is retained for backwards compatibility, but other read
        // methods should be preferred.
        read: function(encoding) {
          if (encoding) {
            return options.readImage(encoding);
          } else {
            return options.readImage().then(function(arrayBuffer) {
              return Buffer.from(arrayBuffer);
            });
          }
        },
        readAsArrayBuffer: function() {
          return options.readImage();
        },
        readAsBase64String: function() {
          return options.readImage("base64");
        },
        readAsBuffer: function() {
          return options.readImage().then(function(arrayBuffer) {
            return Buffer.from(arrayBuffer);
          });
        },
        altText: options.altText,
        contentType: options.contentType
      };
    }
    __name(Image2, "Image");
    function Table(children, properties) {
      properties = properties || {};
      return {
        type: types.table,
        children,
        styleId: properties.styleId || null,
        styleName: properties.styleName || null
      };
    }
    __name(Table, "Table");
    function TableRow(children, options) {
      options = options || {};
      return {
        type: types.tableRow,
        children,
        isHeader: options.isHeader || false
      };
    }
    __name(TableRow, "TableRow");
    function TableCell(children, options) {
      options = options || {};
      return {
        type: types.tableCell,
        children,
        colSpan: options.colSpan == null ? 1 : options.colSpan,
        rowSpan: options.rowSpan == null ? 1 : options.rowSpan
      };
    }
    __name(TableCell, "TableCell");
    function Break2(breakType) {
      return {
        type: types["break"],
        breakType
      };
    }
    __name(Break2, "Break");
    function BookmarkStart(options) {
      return {
        type: types.bookmarkStart,
        name: options.name
      };
    }
    __name(BookmarkStart, "BookmarkStart");
    exports2.document = exports2.Document = Document;
    exports2.paragraph = exports2.Paragraph = Paragraph;
    exports2.run = exports2.Run = Run;
    exports2.text = exports2.Text = Text2;
    exports2.tab = exports2.Tab = Tab;
    exports2.checkbox = exports2.Checkbox = Checkbox;
    exports2.Hyperlink = Hyperlink;
    exports2.noteReference = exports2.NoteReference = NoteReference;
    exports2.Notes = Notes;
    exports2.Note = Note;
    exports2.commentReference = commentReference;
    exports2.comment = comment;
    exports2.Image = Image2;
    exports2.Table = Table;
    exports2.TableRow = TableRow;
    exports2.TableCell = TableCell;
    exports2.lineBreak = Break2("line");
    exports2.pageBreak = Break2("page");
    exports2.columnBreak = Break2("column");
    exports2.BookmarkStart = BookmarkStart;
    exports2.verticalAlignment = verticalAlignment;
  }
});

// node_modules/mammoth/lib/results.js
var require_results = __commonJS({
  "node_modules/mammoth/lib/results.js"(exports2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var _2 = require_underscore_umd();
    exports2.Result = Result;
    exports2.success = success;
    exports2.warning = warning;
    exports2.error = error3;
    function Result(value, messages) {
      this.value = value;
      this.messages = messages || [];
    }
    __name(Result, "Result");
    Result.prototype.map = function(func) {
      return new Result(func(this.value), this.messages);
    };
    Result.prototype.flatMap = function(func) {
      var funcResult = func(this.value);
      return new Result(funcResult.value, combineMessages([this, funcResult]));
    };
    Result.prototype.flatMapThen = function(func) {
      var that = this;
      return func(this.value).then(function(otherResult) {
        return new Result(otherResult.value, combineMessages([that, otherResult]));
      });
    };
    Result.combine = function(results) {
      var values = _2.flatten(_2.pluck(results, "value"));
      var messages = combineMessages(results);
      return new Result(values, messages);
    };
    function success(value) {
      return new Result(value, []);
    }
    __name(success, "success");
    function warning(message) {
      return {
        type: "warning",
        message
      };
    }
    __name(warning, "warning");
    function error3(exception) {
      return {
        type: "error",
        message: exception.message,
        error: exception
      };
    }
    __name(error3, "error");
    function combineMessages(results) {
      var messages = [];
      _2.flatten(_2.pluck(results, "messages"), true).forEach(function(message) {
        if (!containsMessage(messages, message)) {
          messages.push(message);
        }
      });
      return messages;
    }
    __name(combineMessages, "combineMessages");
    function containsMessage(messages, message) {
      return _2.find(messages, isSameMessage.bind(null, message)) !== void 0;
    }
    __name(containsMessage, "containsMessage");
    function isSameMessage(first, second) {
      return first.type === second.type && first.message === second.message;
    }
    __name(isSameMessage, "isSameMessage");
  }
});

// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports2) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    exports2.byteLength = byteLength;
    exports2.toByteArray = toByteArray;
    exports2.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i2 = 0, len = code.length; i2 < len; ++i2) {
      lookup[i2] = code[i2];
      revLookup[code.charCodeAt(i2)] = i2;
    }
    var i2;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    __name(getLens, "getLens");
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    __name(byteLength, "byteLength");
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    __name(_byteLength, "_byteLength");
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i3;
      for (i3 = 0; i3 < len2; i3 += 4) {
        tmp = revLookup[b64.charCodeAt(i3)] << 18 | revLookup[b64.charCodeAt(i3 + 1)] << 12 | revLookup[b64.charCodeAt(i3 + 2)] << 6 | revLookup[b64.charCodeAt(i3 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i3)] << 2 | revLookup[b64.charCodeAt(i3 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i3)] << 10 | revLookup[b64.charCodeAt(i3 + 1)] << 4 | revLookup[b64.charCodeAt(i3 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    __name(toByteArray, "toByteArray");
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    __name(tripletToBase64, "tripletToBase64");
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i3 = start; i3 < end; i3 += 3) {
        tmp = (uint8[i3] << 16 & 16711680) + (uint8[i3 + 1] << 8 & 65280) + (uint8[i3 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    __name(encodeChunk, "encodeChunk");
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i3 = 0, len22 = len2 - extraBytes; i3 < len22; i3 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i3, i3 + maxChunkLength > len22 ? len22 : i3 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
    __name(fromByteArray, "fromByteArray");
  }
});

// node_modules/jszip/dist/jszip.min.js
var require_jszip_min = __commonJS({
  "node_modules/jszip/dist/jszip.min.js"(exports2, module2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    !function(e2) {
      if ("object" == typeof exports2 && "undefined" != typeof module2)
        module2.exports = e2();
      else if ("function" == typeof define && define.amd)
        define([], e2);
      else {
        ("undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this).JSZip = e2();
      }
    }(function() {
      return (/* @__PURE__ */ __name(function s2(a2, o2, h2) {
        function u2(r2, e3) {
          if (!o2[r2]) {
            if (!a2[r2]) {
              var t2 = "function" == typeof __require && __require;
              if (!e3 && t2)
                return t2(r2, true);
              if (l3)
                return l3(r2, true);
              var n2 = new Error("Cannot find module '" + r2 + "'");
              throw n2.code = "MODULE_NOT_FOUND", n2;
            }
            var i2 = o2[r2] = { exports: {} };
            a2[r2][0].call(i2.exports, function(e4) {
              var t3 = a2[r2][1][e4];
              return u2(t3 || e4);
            }, i2, i2.exports, s2, a2, o2, h2);
          }
          return o2[r2].exports;
        }
        __name(u2, "u");
        for (var l3 = "function" == typeof __require && __require, e2 = 0; e2 < h2.length; e2++)
          u2(h2[e2]);
        return u2;
      }, "s"))({ 1: [function(e2, t2, r2) {
        "use strict";
        var d2 = e2("./utils"), c2 = e2("./support"), p2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        r2.encode = function(e3) {
          for (var t3, r3, n2, i2, s2, a2, o2, h2 = [], u2 = 0, l3 = e3.length, f2 = l3, c3 = "string" !== d2.getTypeOf(e3); u2 < e3.length; )
            f2 = l3 - u2, n2 = c3 ? (t3 = e3[u2++], r3 = u2 < l3 ? e3[u2++] : 0, u2 < l3 ? e3[u2++] : 0) : (t3 = e3.charCodeAt(u2++), r3 = u2 < l3 ? e3.charCodeAt(u2++) : 0, u2 < l3 ? e3.charCodeAt(u2++) : 0), i2 = t3 >> 2, s2 = (3 & t3) << 4 | r3 >> 4, a2 = 1 < f2 ? (15 & r3) << 2 | n2 >> 6 : 64, o2 = 2 < f2 ? 63 & n2 : 64, h2.push(p2.charAt(i2) + p2.charAt(s2) + p2.charAt(a2) + p2.charAt(o2));
          return h2.join("");
        }, r2.decode = function(e3) {
          var t3, r3, n2, i2, s2, a2, o2 = 0, h2 = 0, u2 = "data:";
          if (e3.substr(0, u2.length) === u2)
            throw new Error("Invalid base64 input, it looks like a data url.");
          var l3, f2 = 3 * (e3 = e3.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
          if (e3.charAt(e3.length - 1) === p2.charAt(64) && f2--, e3.charAt(e3.length - 2) === p2.charAt(64) && f2--, f2 % 1 != 0)
            throw new Error("Invalid base64 input, bad content length.");
          for (l3 = c2.uint8array ? new Uint8Array(0 | f2) : new Array(0 | f2); o2 < e3.length; )
            t3 = p2.indexOf(e3.charAt(o2++)) << 2 | (i2 = p2.indexOf(e3.charAt(o2++))) >> 4, r3 = (15 & i2) << 4 | (s2 = p2.indexOf(e3.charAt(o2++))) >> 2, n2 = (3 & s2) << 6 | (a2 = p2.indexOf(e3.charAt(o2++))), l3[h2++] = t3, 64 !== s2 && (l3[h2++] = r3), 64 !== a2 && (l3[h2++] = n2);
          return l3;
        };
      }, { "./support": 30, "./utils": 32 }], 2: [function(e2, t2, r2) {
        "use strict";
        var n2 = e2("./external"), i2 = e2("./stream/DataWorker"), s2 = e2("./stream/Crc32Probe"), a2 = e2("./stream/DataLengthProbe");
        function o2(e3, t3, r3, n3, i3) {
          this.compressedSize = e3, this.uncompressedSize = t3, this.crc32 = r3, this.compression = n3, this.compressedContent = i3;
        }
        __name(o2, "o");
        o2.prototype = { getContentWorker: function() {
          var e3 = new i2(n2.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a2("data_length")), t3 = this;
          return e3.on("end", function() {
            if (this.streamInfo.data_length !== t3.uncompressedSize)
              throw new Error("Bug : uncompressed data size mismatch");
          }), e3;
        }, getCompressedWorker: function() {
          return new i2(n2.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
        } }, o2.createWorkerFrom = function(e3, t3, r3) {
          return e3.pipe(new s2()).pipe(new a2("uncompressedSize")).pipe(t3.compressWorker(r3)).pipe(new a2("compressedSize")).withStreamInfo("compression", t3);
        }, t2.exports = o2;
      }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(e2, t2, r2) {
        "use strict";
        var n2 = e2("./stream/GenericWorker");
        r2.STORE = { magic: "\0\0", compressWorker: function() {
          return new n2("STORE compression");
        }, uncompressWorker: function() {
          return new n2("STORE decompression");
        } }, r2.DEFLATE = e2("./flate");
      }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(e2, t2, r2) {
        "use strict";
        var n2 = e2("./utils");
        var o2 = function() {
          for (var e3, t3 = [], r3 = 0; r3 < 256; r3++) {
            e3 = r3;
            for (var n3 = 0; n3 < 8; n3++)
              e3 = 1 & e3 ? 3988292384 ^ e3 >>> 1 : e3 >>> 1;
            t3[r3] = e3;
          }
          return t3;
        }();
        t2.exports = function(e3, t3) {
          return void 0 !== e3 && e3.length ? "string" !== n2.getTypeOf(e3) ? function(e4, t4, r3, n3) {
            var i2 = o2, s2 = n3 + r3;
            e4 ^= -1;
            for (var a2 = n3; a2 < s2; a2++)
              e4 = e4 >>> 8 ^ i2[255 & (e4 ^ t4[a2])];
            return -1 ^ e4;
          }(0 | t3, e3, e3.length, 0) : function(e4, t4, r3, n3) {
            var i2 = o2, s2 = n3 + r3;
            e4 ^= -1;
            for (var a2 = n3; a2 < s2; a2++)
              e4 = e4 >>> 8 ^ i2[255 & (e4 ^ t4.charCodeAt(a2))];
            return -1 ^ e4;
          }(0 | t3, e3, e3.length, 0) : 0;
        };
      }, { "./utils": 32 }], 5: [function(e2, t2, r2) {
        "use strict";
        r2.base64 = false, r2.binary = false, r2.dir = false, r2.createFolders = true, r2.date = null, r2.compression = null, r2.compressionOptions = null, r2.comment = null, r2.unixPermissions = null, r2.dosPermissions = null;
      }, {}], 6: [function(e2, t2, r2) {
        "use strict";
        var n2 = null;
        n2 = "undefined" != typeof Promise ? Promise : e2("lie"), t2.exports = { Promise: n2 };
      }, { lie: 37 }], 7: [function(e2, t2, r2) {
        "use strict";
        var n2 = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Uint32Array, i2 = e2("pako"), s2 = e2("./utils"), a2 = e2("./stream/GenericWorker"), o2 = n2 ? "uint8array" : "array";
        function h2(e3, t3) {
          a2.call(this, "FlateWorker/" + e3), this._pako = null, this._pakoAction = e3, this._pakoOptions = t3, this.meta = {};
        }
        __name(h2, "h");
        r2.magic = "\b\0", s2.inherits(h2, a2), h2.prototype.processChunk = function(e3) {
          this.meta = e3.meta, null === this._pako && this._createPako(), this._pako.push(s2.transformTo(o2, e3.data), false);
        }, h2.prototype.flush = function() {
          a2.prototype.flush.call(this), null === this._pako && this._createPako(), this._pako.push([], true);
        }, h2.prototype.cleanUp = function() {
          a2.prototype.cleanUp.call(this), this._pako = null;
        }, h2.prototype._createPako = function() {
          this._pako = new i2[this._pakoAction]({ raw: true, level: this._pakoOptions.level || -1 });
          var t3 = this;
          this._pako.onData = function(e3) {
            t3.push({ data: e3, meta: t3.meta });
          };
        }, r2.compressWorker = function(e3) {
          return new h2("Deflate", e3);
        }, r2.uncompressWorker = function() {
          return new h2("Inflate", {});
        };
      }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(e2, t2, r2) {
        "use strict";
        function A2(e3, t3) {
          var r3, n3 = "";
          for (r3 = 0; r3 < t3; r3++)
            n3 += String.fromCharCode(255 & e3), e3 >>>= 8;
          return n3;
        }
        __name(A2, "A");
        function n2(e3, t3, r3, n3, i3, s3) {
          var a2, o2, h2 = e3.file, u2 = e3.compression, l3 = s3 !== O2.utf8encode, f2 = I2.transformTo("string", s3(h2.name)), c2 = I2.transformTo("string", O2.utf8encode(h2.name)), d2 = h2.comment, p2 = I2.transformTo("string", s3(d2)), m2 = I2.transformTo("string", O2.utf8encode(d2)), _2 = c2.length !== h2.name.length, g2 = m2.length !== d2.length, b2 = "", v2 = "", y2 = "", w2 = h2.dir, k2 = h2.date, x2 = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
          t3 && !r3 || (x2.crc32 = e3.crc32, x2.compressedSize = e3.compressedSize, x2.uncompressedSize = e3.uncompressedSize);
          var S2 = 0;
          t3 && (S2 |= 8), l3 || !_2 && !g2 || (S2 |= 2048);
          var z2 = 0, C2 = 0;
          w2 && (z2 |= 16), "UNIX" === i3 ? (C2 = 798, z2 |= function(e4, t4) {
            var r4 = e4;
            return e4 || (r4 = t4 ? 16893 : 33204), (65535 & r4) << 16;
          }(h2.unixPermissions, w2)) : (C2 = 20, z2 |= function(e4) {
            return 63 & (e4 || 0);
          }(h2.dosPermissions)), a2 = k2.getUTCHours(), a2 <<= 6, a2 |= k2.getUTCMinutes(), a2 <<= 5, a2 |= k2.getUTCSeconds() / 2, o2 = k2.getUTCFullYear() - 1980, o2 <<= 4, o2 |= k2.getUTCMonth() + 1, o2 <<= 5, o2 |= k2.getUTCDate(), _2 && (v2 = A2(1, 1) + A2(B2(f2), 4) + c2, b2 += "up" + A2(v2.length, 2) + v2), g2 && (y2 = A2(1, 1) + A2(B2(p2), 4) + m2, b2 += "uc" + A2(y2.length, 2) + y2);
          var E2 = "";
          return E2 += "\n\0", E2 += A2(S2, 2), E2 += u2.magic, E2 += A2(a2, 2), E2 += A2(o2, 2), E2 += A2(x2.crc32, 4), E2 += A2(x2.compressedSize, 4), E2 += A2(x2.uncompressedSize, 4), E2 += A2(f2.length, 2), E2 += A2(b2.length, 2), { fileRecord: R2.LOCAL_FILE_HEADER + E2 + f2 + b2, dirRecord: R2.CENTRAL_FILE_HEADER + A2(C2, 2) + E2 + A2(p2.length, 2) + "\0\0\0\0" + A2(z2, 4) + A2(n3, 4) + f2 + b2 + p2 };
        }
        __name(n2, "n");
        var I2 = e2("../utils"), i2 = e2("../stream/GenericWorker"), O2 = e2("../utf8"), B2 = e2("../crc32"), R2 = e2("../signature");
        function s2(e3, t3, r3, n3) {
          i2.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = t3, this.zipPlatform = r3, this.encodeFileName = n3, this.streamFiles = e3, this.accumulate = false, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
        }
        __name(s2, "s");
        I2.inherits(s2, i2), s2.prototype.push = function(e3) {
          var t3 = e3.meta.percent || 0, r3 = this.entriesCount, n3 = this._sources.length;
          this.accumulate ? this.contentBuffer.push(e3) : (this.bytesWritten += e3.data.length, i2.prototype.push.call(this, { data: e3.data, meta: { currentFile: this.currentFile, percent: r3 ? (t3 + 100 * (r3 - n3 - 1)) / r3 : 100 } }));
        }, s2.prototype.openedSource = function(e3) {
          this.currentSourceOffset = this.bytesWritten, this.currentFile = e3.file.name;
          var t3 = this.streamFiles && !e3.file.dir;
          if (t3) {
            var r3 = n2(e3, t3, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
            this.push({ data: r3.fileRecord, meta: { percent: 0 } });
          } else
            this.accumulate = true;
        }, s2.prototype.closedSource = function(e3) {
          this.accumulate = false;
          var t3 = this.streamFiles && !e3.file.dir, r3 = n2(e3, t3, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          if (this.dirRecords.push(r3.dirRecord), t3)
            this.push({ data: function(e4) {
              return R2.DATA_DESCRIPTOR + A2(e4.crc32, 4) + A2(e4.compressedSize, 4) + A2(e4.uncompressedSize, 4);
            }(e3), meta: { percent: 100 } });
          else
            for (this.push({ data: r3.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; )
              this.push(this.contentBuffer.shift());
          this.currentFile = null;
        }, s2.prototype.flush = function() {
          for (var e3 = this.bytesWritten, t3 = 0; t3 < this.dirRecords.length; t3++)
            this.push({ data: this.dirRecords[t3], meta: { percent: 100 } });
          var r3 = this.bytesWritten - e3, n3 = function(e4, t4, r4, n4, i3) {
            var s3 = I2.transformTo("string", i3(n4));
            return R2.CENTRAL_DIRECTORY_END + "\0\0\0\0" + A2(e4, 2) + A2(e4, 2) + A2(t4, 4) + A2(r4, 4) + A2(s3.length, 2) + s3;
          }(this.dirRecords.length, r3, e3, this.zipComment, this.encodeFileName);
          this.push({ data: n3, meta: { percent: 100 } });
        }, s2.prototype.prepareNextSource = function() {
          this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
        }, s2.prototype.registerPrevious = function(e3) {
          this._sources.push(e3);
          var t3 = this;
          return e3.on("data", function(e4) {
            t3.processChunk(e4);
          }), e3.on("end", function() {
            t3.closedSource(t3.previous.streamInfo), t3._sources.length ? t3.prepareNextSource() : t3.end();
          }), e3.on("error", function(e4) {
            t3.error(e4);
          }), this;
        }, s2.prototype.resume = function() {
          return !!i2.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), true) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), true));
        }, s2.prototype.error = function(e3) {
          var t3 = this._sources;
          if (!i2.prototype.error.call(this, e3))
            return false;
          for (var r3 = 0; r3 < t3.length; r3++)
            try {
              t3[r3].error(e3);
            } catch (e4) {
            }
          return true;
        }, s2.prototype.lock = function() {
          i2.prototype.lock.call(this);
          for (var e3 = this._sources, t3 = 0; t3 < e3.length; t3++)
            e3[t3].lock();
        }, t2.exports = s2;
      }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(e2, t2, r2) {
        "use strict";
        var u2 = e2("../compressions"), n2 = e2("./ZipFileWorker");
        r2.generateWorker = function(e3, a2, t3) {
          var o2 = new n2(a2.streamFiles, t3, a2.platform, a2.encodeFileName), h2 = 0;
          try {
            e3.forEach(function(e4, t4) {
              h2++;
              var r3 = function(e5, t5) {
                var r4 = e5 || t5, n4 = u2[r4];
                if (!n4)
                  throw new Error(r4 + " is not a valid compression method !");
                return n4;
              }(t4.options.compression, a2.compression), n3 = t4.options.compressionOptions || a2.compressionOptions || {}, i2 = t4.dir, s2 = t4.date;
              t4._compressWorker(r3, n3).withStreamInfo("file", { name: e4, dir: i2, date: s2, comment: t4.comment || "", unixPermissions: t4.unixPermissions, dosPermissions: t4.dosPermissions }).pipe(o2);
            }), o2.entriesCount = h2;
          } catch (e4) {
            o2.error(e4);
          }
          return o2;
        };
      }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(e2, t2, r2) {
        "use strict";
        function n2() {
          if (!(this instanceof n2))
            return new n2();
          if (arguments.length)
            throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
          this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
            var e3 = new n2();
            for (var t3 in this)
              "function" != typeof this[t3] && (e3[t3] = this[t3]);
            return e3;
          };
        }
        __name(n2, "n");
        (n2.prototype = e2("./object")).loadAsync = e2("./load"), n2.support = e2("./support"), n2.defaults = e2("./defaults"), n2.version = "3.10.1", n2.loadAsync = function(e3, t3) {
          return new n2().loadAsync(e3, t3);
        }, n2.external = e2("./external"), t2.exports = n2;
      }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(e2, t2, r2) {
        "use strict";
        var u2 = e2("./utils"), i2 = e2("./external"), n2 = e2("./utf8"), s2 = e2("./zipEntries"), a2 = e2("./stream/Crc32Probe"), l3 = e2("./nodejsUtils");
        function f2(n3) {
          return new i2.Promise(function(e3, t3) {
            var r3 = n3.decompressed.getContentWorker().pipe(new a2());
            r3.on("error", function(e4) {
              t3(e4);
            }).on("end", function() {
              r3.streamInfo.crc32 !== n3.decompressed.crc32 ? t3(new Error("Corrupted zip : CRC32 mismatch")) : e3();
            }).resume();
          });
        }
        __name(f2, "f");
        t2.exports = function(e3, o2) {
          var h2 = this;
          return o2 = u2.extend(o2 || {}, { base64: false, checkCRC32: false, optimizedBinaryString: false, createFolders: false, decodeFileName: n2.utf8decode }), l3.isNode && l3.isStream(e3) ? i2.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : u2.prepareContent("the loaded zip file", e3, true, o2.optimizedBinaryString, o2.base64).then(function(e4) {
            var t3 = new s2(o2);
            return t3.load(e4), t3;
          }).then(function(e4) {
            var t3 = [i2.Promise.resolve(e4)], r3 = e4.files;
            if (o2.checkCRC32)
              for (var n3 = 0; n3 < r3.length; n3++)
                t3.push(f2(r3[n3]));
            return i2.Promise.all(t3);
          }).then(function(e4) {
            for (var t3 = e4.shift(), r3 = t3.files, n3 = 0; n3 < r3.length; n3++) {
              var i3 = r3[n3], s3 = i3.fileNameStr, a3 = u2.resolve(i3.fileNameStr);
              h2.file(a3, i3.decompressed, { binary: true, optimizedBinaryString: true, date: i3.date, dir: i3.dir, comment: i3.fileCommentStr.length ? i3.fileCommentStr : null, unixPermissions: i3.unixPermissions, dosPermissions: i3.dosPermissions, createFolders: o2.createFolders }), i3.dir || (h2.file(a3).unsafeOriginalName = s3);
            }
            return t3.zipComment.length && (h2.comment = t3.zipComment), h2;
          });
        };
      }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(e2, t2, r2) {
        "use strict";
        var n2 = e2("../utils"), i2 = e2("../stream/GenericWorker");
        function s2(e3, t3) {
          i2.call(this, "Nodejs stream input adapter for " + e3), this._upstreamEnded = false, this._bindStream(t3);
        }
        __name(s2, "s");
        n2.inherits(s2, i2), s2.prototype._bindStream = function(e3) {
          var t3 = this;
          (this._stream = e3).pause(), e3.on("data", function(e4) {
            t3.push({ data: e4, meta: { percent: 0 } });
          }).on("error", function(e4) {
            t3.isPaused ? this.generatedError = e4 : t3.error(e4);
          }).on("end", function() {
            t3.isPaused ? t3._upstreamEnded = true : t3.end();
          });
        }, s2.prototype.pause = function() {
          return !!i2.prototype.pause.call(this) && (this._stream.pause(), true);
        }, s2.prototype.resume = function() {
          return !!i2.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), true);
        }, t2.exports = s2;
      }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(e2, t2, r2) {
        "use strict";
        var i2 = e2("readable-stream").Readable;
        function n2(e3, t3, r3) {
          i2.call(this, t3), this._helper = e3;
          var n3 = this;
          e3.on("data", function(e4, t4) {
            n3.push(e4) || n3._helper.pause(), r3 && r3(t4);
          }).on("error", function(e4) {
            n3.emit("error", e4);
          }).on("end", function() {
            n3.push(null);
          });
        }
        __name(n2, "n");
        e2("../utils").inherits(n2, i2), n2.prototype._read = function() {
          this._helper.resume();
        }, t2.exports = n2;
      }, { "../utils": 32, "readable-stream": 16 }], 14: [function(e2, t2, r2) {
        "use strict";
        t2.exports = { isNode: "undefined" != typeof Buffer, newBufferFrom: function(e3, t3) {
          if (Buffer.from && Buffer.from !== Uint8Array.from)
            return Buffer.from(e3, t3);
          if ("number" == typeof e3)
            throw new Error('The "data" argument must not be a number');
          return new Buffer(e3, t3);
        }, allocBuffer: function(e3) {
          if (Buffer.alloc)
            return Buffer.alloc(e3);
          var t3 = new Buffer(e3);
          return t3.fill(0), t3;
        }, isBuffer: function(e3) {
          return Buffer.isBuffer(e3);
        }, isStream: function(e3) {
          return e3 && "function" == typeof e3.on && "function" == typeof e3.pause && "function" == typeof e3.resume;
        } };
      }, {}], 15: [function(e2, t2, r2) {
        "use strict";
        function s2(e3, t3, r3) {
          var n3, i3 = u2.getTypeOf(t3), s3 = u2.extend(r3 || {}, f2);
          s3.date = s3.date || /* @__PURE__ */ new Date(), null !== s3.compression && (s3.compression = s3.compression.toUpperCase()), "string" == typeof s3.unixPermissions && (s3.unixPermissions = parseInt(s3.unixPermissions, 8)), s3.unixPermissions && 16384 & s3.unixPermissions && (s3.dir = true), s3.dosPermissions && 16 & s3.dosPermissions && (s3.dir = true), s3.dir && (e3 = g2(e3)), s3.createFolders && (n3 = _2(e3)) && b2.call(this, n3, true);
          var a3 = "string" === i3 && false === s3.binary && false === s3.base64;
          r3 && void 0 !== r3.binary || (s3.binary = !a3), (t3 instanceof c2 && 0 === t3.uncompressedSize || s3.dir || !t3 || 0 === t3.length) && (s3.base64 = false, s3.binary = true, t3 = "", s3.compression = "STORE", i3 = "string");
          var o3 = null;
          o3 = t3 instanceof c2 || t3 instanceof l3 ? t3 : p2.isNode && p2.isStream(t3) ? new m2(e3, t3) : u2.prepareContent(e3, t3, s3.binary, s3.optimizedBinaryString, s3.base64);
          var h3 = new d2(e3, o3, s3);
          this.files[e3] = h3;
        }
        __name(s2, "s");
        var i2 = e2("./utf8"), u2 = e2("./utils"), l3 = e2("./stream/GenericWorker"), a2 = e2("./stream/StreamHelper"), f2 = e2("./defaults"), c2 = e2("./compressedObject"), d2 = e2("./zipObject"), o2 = e2("./generate"), p2 = e2("./nodejsUtils"), m2 = e2("./nodejs/NodejsStreamInputAdapter"), _2 = /* @__PURE__ */ __name(function(e3) {
          "/" === e3.slice(-1) && (e3 = e3.substring(0, e3.length - 1));
          var t3 = e3.lastIndexOf("/");
          return 0 < t3 ? e3.substring(0, t3) : "";
        }, "_"), g2 = /* @__PURE__ */ __name(function(e3) {
          return "/" !== e3.slice(-1) && (e3 += "/"), e3;
        }, "g"), b2 = /* @__PURE__ */ __name(function(e3, t3) {
          return t3 = void 0 !== t3 ? t3 : f2.createFolders, e3 = g2(e3), this.files[e3] || s2.call(this, e3, null, { dir: true, createFolders: t3 }), this.files[e3];
        }, "b");
        function h2(e3) {
          return "[object RegExp]" === Object.prototype.toString.call(e3);
        }
        __name(h2, "h");
        var n2 = { load: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, forEach: function(e3) {
          var t3, r3, n3;
          for (t3 in this.files)
            n3 = this.files[t3], (r3 = t3.slice(this.root.length, t3.length)) && t3.slice(0, this.root.length) === this.root && e3(r3, n3);
        }, filter: function(r3) {
          var n3 = [];
          return this.forEach(function(e3, t3) {
            r3(e3, t3) && n3.push(t3);
          }), n3;
        }, file: function(e3, t3, r3) {
          if (1 !== arguments.length)
            return e3 = this.root + e3, s2.call(this, e3, t3, r3), this;
          if (h2(e3)) {
            var n3 = e3;
            return this.filter(function(e4, t4) {
              return !t4.dir && n3.test(e4);
            });
          }
          var i3 = this.files[this.root + e3];
          return i3 && !i3.dir ? i3 : null;
        }, folder: function(r3) {
          if (!r3)
            return this;
          if (h2(r3))
            return this.filter(function(e4, t4) {
              return t4.dir && r3.test(e4);
            });
          var e3 = this.root + r3, t3 = b2.call(this, e3), n3 = this.clone();
          return n3.root = t3.name, n3;
        }, remove: function(r3) {
          r3 = this.root + r3;
          var e3 = this.files[r3];
          if (e3 || ("/" !== r3.slice(-1) && (r3 += "/"), e3 = this.files[r3]), e3 && !e3.dir)
            delete this.files[r3];
          else
            for (var t3 = this.filter(function(e4, t4) {
              return t4.name.slice(0, r3.length) === r3;
            }), n3 = 0; n3 < t3.length; n3++)
              delete this.files[t3[n3].name];
          return this;
        }, generate: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, generateInternalStream: function(e3) {
          var t3, r3 = {};
          try {
            if ((r3 = u2.extend(e3 || {}, { streamFiles: false, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: i2.utf8encode })).type = r3.type.toLowerCase(), r3.compression = r3.compression.toUpperCase(), "binarystring" === r3.type && (r3.type = "string"), !r3.type)
              throw new Error("No output type specified.");
            u2.checkSupport(r3.type), "darwin" !== r3.platform && "freebsd" !== r3.platform && "linux" !== r3.platform && "sunos" !== r3.platform || (r3.platform = "UNIX"), "win32" === r3.platform && (r3.platform = "DOS");
            var n3 = r3.comment || this.comment || "";
            t3 = o2.generateWorker(this, r3, n3);
          } catch (e4) {
            (t3 = new l3("error")).error(e4);
          }
          return new a2(t3, r3.type || "string", r3.mimeType);
        }, generateAsync: function(e3, t3) {
          return this.generateInternalStream(e3).accumulate(t3);
        }, generateNodeStream: function(e3, t3) {
          return (e3 = e3 || {}).type || (e3.type = "nodebuffer"), this.generateInternalStream(e3).toNodejsStream(t3);
        } };
        t2.exports = n2;
      }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(e2, t2, r2) {
        "use strict";
        t2.exports = e2("stream");
      }, { stream: void 0 }], 17: [function(e2, t2, r2) {
        "use strict";
        var n2 = e2("./DataReader");
        function i2(e3) {
          n2.call(this, e3);
          for (var t3 = 0; t3 < this.data.length; t3++)
            e3[t3] = 255 & e3[t3];
        }
        __name(i2, "i");
        e2("../utils").inherits(i2, n2), i2.prototype.byteAt = function(e3) {
          return this.data[this.zero + e3];
        }, i2.prototype.lastIndexOfSignature = function(e3) {
          for (var t3 = e3.charCodeAt(0), r3 = e3.charCodeAt(1), n3 = e3.charCodeAt(2), i3 = e3.charCodeAt(3), s2 = this.length - 4; 0 <= s2; --s2)
            if (this.data[s2] === t3 && this.data[s2 + 1] === r3 && this.data[s2 + 2] === n3 && this.data[s2 + 3] === i3)
              return s2 - this.zero;
          return -1;
        }, i2.prototype.readAndCheckSignature = function(e3) {
          var t3 = e3.charCodeAt(0), r3 = e3.charCodeAt(1), n3 = e3.charCodeAt(2), i3 = e3.charCodeAt(3), s2 = this.readData(4);
          return t3 === s2[0] && r3 === s2[1] && n3 === s2[2] && i3 === s2[3];
        }, i2.prototype.readData = function(e3) {
          if (this.checkOffset(e3), 0 === e3)
            return [];
          var t3 = this.data.slice(this.zero + this.index, this.zero + this.index + e3);
          return this.index += e3, t3;
        }, t2.exports = i2;
      }, { "../utils": 32, "./DataReader": 18 }], 18: [function(e2, t2, r2) {
        "use strict";
        var n2 = e2("../utils");
        function i2(e3) {
          this.data = e3, this.length = e3.length, this.index = 0, this.zero = 0;
        }
        __name(i2, "i");
        i2.prototype = { checkOffset: function(e3) {
          this.checkIndex(this.index + e3);
        }, checkIndex: function(e3) {
          if (this.length < this.zero + e3 || e3 < 0)
            throw new Error("End of data reached (data length = " + this.length + ", asked index = " + e3 + "). Corrupted zip ?");
        }, setIndex: function(e3) {
          this.checkIndex(e3), this.index = e3;
        }, skip: function(e3) {
          this.setIndex(this.index + e3);
        }, byteAt: function() {
        }, readInt: function(e3) {
          var t3, r3 = 0;
          for (this.checkOffset(e3), t3 = this.index + e3 - 1; t3 >= this.index; t3--)
            r3 = (r3 << 8) + this.byteAt(t3);
          return this.index += e3, r3;
        }, readString: function(e3) {
          return n2.transformTo("string", this.readData(e3));
        }, readData: function() {
        }, lastIndexOfSignature: function() {
        }, readAndCheckSignature: function() {
        }, readDate: function() {
          var e3 = this.readInt(4);
          return new Date(Date.UTC(1980 + (e3 >> 25 & 127), (e3 >> 21 & 15) - 1, e3 >> 16 & 31, e3 >> 11 & 31, e3 >> 5 & 63, (31 & e3) << 1));
        } }, t2.exports = i2;
      }, { "../utils": 32 }], 19: [function(e2, t2, r2) {
        "use strict";
        var n2 = e2("./Uint8ArrayReader");
        function i2(e3) {
          n2.call(this, e3);
        }
        __name(i2, "i");
        e2("../utils").inherits(i2, n2), i2.prototype.readData = function(e3) {
          this.checkOffset(e3);
          var t3 = this.data.slice(this.zero + this.index, this.zero + this.index + e3);
          return this.index += e3, t3;
        }, t2.exports = i2;
      }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(e2, t2, r2) {
        "use strict";
        var n2 = e2("./DataReader");
        function i2(e3) {
          n2.call(this, e3);
        }
        __name(i2, "i");
        e2("../utils").inherits(i2, n2), i2.prototype.byteAt = function(e3) {
          return this.data.charCodeAt(this.zero + e3);
        }, i2.prototype.lastIndexOfSignature = function(e3) {
          return this.data.lastIndexOf(e3) - this.zero;
        }, i2.prototype.readAndCheckSignature = function(e3) {
          return e3 === this.readData(4);
        }, i2.prototype.readData = function(e3) {
          this.checkOffset(e3);
          var t3 = this.data.slice(this.zero + this.index, this.zero + this.index + e3);
          return this.index += e3, t3;
        }, t2.exports = i2;
      }, { "../utils": 32, "./DataReader": 18 }], 21: [function(e2, t2, r2) {
        "use strict";
        var n2 = e2("./ArrayReader");
        function i2(e3) {
          n2.call(this, e3);
        }
        __name(i2, "i");
        e2("../utils").inherits(i2, n2), i2.prototype.readData = function(e3) {
          if (this.checkOffset(e3), 0 === e3)
            return new Uint8Array(0);
          var t3 = this.data.subarray(this.zero + this.index, this.zero + this.index + e3);
          return this.index += e3, t3;
        }, t2.exports = i2;
      }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(e2, t2, r2) {
        "use strict";
        var n2 = e2("../utils"), i2 = e2("../support"), s2 = e2("./ArrayReader"), a2 = e2("./StringReader"), o2 = e2("./NodeBufferReader"), h2 = e2("./Uint8ArrayReader");
        t2.exports = function(e3) {
          var t3 = n2.getTypeOf(e3);
          return n2.checkSupport(t3), "string" !== t3 || i2.uint8array ? "nodebuffer" === t3 ? new o2(e3) : i2.uint8array ? new h2(n2.transformTo("uint8array", e3)) : new s2(n2.transformTo("array", e3)) : new a2(e3);
        };
      }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(e2, t2, r2) {
        "use strict";
        r2.LOCAL_FILE_HEADER = "PK", r2.CENTRAL_FILE_HEADER = "PK", r2.CENTRAL_DIRECTORY_END = "PK", r2.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", r2.ZIP64_CENTRAL_DIRECTORY_END = "PK", r2.DATA_DESCRIPTOR = "PK\x07\b";
      }, {}], 24: [function(e2, t2, r2) {
        "use strict";
        var n2 = e2("./GenericWorker"), i2 = e2("../utils");
        function s2(e3) {
          n2.call(this, "ConvertWorker to " + e3), this.destType = e3;
        }
        __name(s2, "s");
        i2.inherits(s2, n2), s2.prototype.processChunk = function(e3) {
          this.push({ data: i2.transformTo(this.destType, e3.data), meta: e3.meta });
        }, t2.exports = s2;
      }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(e2, t2, r2) {
        "use strict";
        var n2 = e2("./GenericWorker"), i2 = e2("../crc32");
        function s2() {
          n2.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
        }
        __name(s2, "s");
        e2("../utils").inherits(s2, n2), s2.prototype.processChunk = function(e3) {
          this.streamInfo.crc32 = i2(e3.data, this.streamInfo.crc32 || 0), this.push(e3);
        }, t2.exports = s2;
      }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(e2, t2, r2) {
        "use strict";
        var n2 = e2("../utils"), i2 = e2("./GenericWorker");
        function s2(e3) {
          i2.call(this, "DataLengthProbe for " + e3), this.propName = e3, this.withStreamInfo(e3, 0);
        }
        __name(s2, "s");
        n2.inherits(s2, i2), s2.prototype.processChunk = function(e3) {
          if (e3) {
            var t3 = this.streamInfo[this.propName] || 0;
            this.streamInfo[this.propName] = t3 + e3.data.length;
          }
          i2.prototype.processChunk.call(this, e3);
        }, t2.exports = s2;
      }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(e2, t2, r2) {
        "use strict";
        var n2 = e2("../utils"), i2 = e2("./GenericWorker");
        function s2(e3) {
          i2.call(this, "DataWorker");
          var t3 = this;
          this.dataIsReady = false, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = false, e3.then(function(e4) {
            t3.dataIsReady = true, t3.data = e4, t3.max = e4 && e4.length || 0, t3.type = n2.getTypeOf(e4), t3.isPaused || t3._tickAndRepeat();
          }, function(e4) {
            t3.error(e4);
          });
        }
        __name(s2, "s");
        n2.inherits(s2, i2), s2.prototype.cleanUp = function() {
          i2.prototype.cleanUp.call(this), this.data = null;
        }, s2.prototype.resume = function() {
          return !!i2.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = true, n2.delay(this._tickAndRepeat, [], this)), true);
        }, s2.prototype._tickAndRepeat = function() {
          this._tickScheduled = false, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (n2.delay(this._tickAndRepeat, [], this), this._tickScheduled = true));
        }, s2.prototype._tick = function() {
          if (this.isPaused || this.isFinished)
            return false;
          var e3 = null, t3 = Math.min(this.max, this.index + 16384);
          if (this.index >= this.max)
            return this.end();
          switch (this.type) {
            case "string":
              e3 = this.data.substring(this.index, t3);
              break;
            case "uint8array":
              e3 = this.data.subarray(this.index, t3);
              break;
            case "array":
            case "nodebuffer":
              e3 = this.data.slice(this.index, t3);
          }
          return this.index = t3, this.push({ data: e3, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
        }, t2.exports = s2;
      }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(e2, t2, r2) {
        "use strict";
        function n2(e3) {
          this.name = e3 || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = true, this.isFinished = false, this.isLocked = false, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
        }
        __name(n2, "n");
        n2.prototype = { push: function(e3) {
          this.emit("data", e3);
        }, end: function() {
          if (this.isFinished)
            return false;
          this.flush();
          try {
            this.emit("end"), this.cleanUp(), this.isFinished = true;
          } catch (e3) {
            this.emit("error", e3);
          }
          return true;
        }, error: function(e3) {
          return !this.isFinished && (this.isPaused ? this.generatedError = e3 : (this.isFinished = true, this.emit("error", e3), this.previous && this.previous.error(e3), this.cleanUp()), true);
        }, on: function(e3, t3) {
          return this._listeners[e3].push(t3), this;
        }, cleanUp: function() {
          this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
        }, emit: function(e3, t3) {
          if (this._listeners[e3])
            for (var r3 = 0; r3 < this._listeners[e3].length; r3++)
              this._listeners[e3][r3].call(this, t3);
        }, pipe: function(e3) {
          return e3.registerPrevious(this);
        }, registerPrevious: function(e3) {
          if (this.isLocked)
            throw new Error("The stream '" + this + "' has already been used.");
          this.streamInfo = e3.streamInfo, this.mergeStreamInfo(), this.previous = e3;
          var t3 = this;
          return e3.on("data", function(e4) {
            t3.processChunk(e4);
          }), e3.on("end", function() {
            t3.end();
          }), e3.on("error", function(e4) {
            t3.error(e4);
          }), this;
        }, pause: function() {
          return !this.isPaused && !this.isFinished && (this.isPaused = true, this.previous && this.previous.pause(), true);
        }, resume: function() {
          if (!this.isPaused || this.isFinished)
            return false;
          var e3 = this.isPaused = false;
          return this.generatedError && (this.error(this.generatedError), e3 = true), this.previous && this.previous.resume(), !e3;
        }, flush: function() {
        }, processChunk: function(e3) {
          this.push(e3);
        }, withStreamInfo: function(e3, t3) {
          return this.extraStreamInfo[e3] = t3, this.mergeStreamInfo(), this;
        }, mergeStreamInfo: function() {
          for (var e3 in this.extraStreamInfo)
            Object.prototype.hasOwnProperty.call(this.extraStreamInfo, e3) && (this.streamInfo[e3] = this.extraStreamInfo[e3]);
        }, lock: function() {
          if (this.isLocked)
            throw new Error("The stream '" + this + "' has already been used.");
          this.isLocked = true, this.previous && this.previous.lock();
        }, toString: function() {
          var e3 = "Worker " + this.name;
          return this.previous ? this.previous + " -> " + e3 : e3;
        } }, t2.exports = n2;
      }, {}], 29: [function(e2, t2, r2) {
        "use strict";
        var h2 = e2("../utils"), i2 = e2("./ConvertWorker"), s2 = e2("./GenericWorker"), u2 = e2("../base64"), n2 = e2("../support"), a2 = e2("../external"), o2 = null;
        if (n2.nodestream)
          try {
            o2 = e2("../nodejs/NodejsStreamOutputAdapter");
          } catch (e3) {
          }
        function l3(e3, o3) {
          return new a2.Promise(function(t3, r3) {
            var n3 = [], i3 = e3._internalType, s3 = e3._outputType, a3 = e3._mimeType;
            e3.on("data", function(e4, t4) {
              n3.push(e4), o3 && o3(t4);
            }).on("error", function(e4) {
              n3 = [], r3(e4);
            }).on("end", function() {
              try {
                var e4 = function(e5, t4, r4) {
                  switch (e5) {
                    case "blob":
                      return h2.newBlob(h2.transformTo("arraybuffer", t4), r4);
                    case "base64":
                      return u2.encode(t4);
                    default:
                      return h2.transformTo(e5, t4);
                  }
                }(s3, function(e5, t4) {
                  var r4, n4 = 0, i4 = null, s4 = 0;
                  for (r4 = 0; r4 < t4.length; r4++)
                    s4 += t4[r4].length;
                  switch (e5) {
                    case "string":
                      return t4.join("");
                    case "array":
                      return Array.prototype.concat.apply([], t4);
                    case "uint8array":
                      for (i4 = new Uint8Array(s4), r4 = 0; r4 < t4.length; r4++)
                        i4.set(t4[r4], n4), n4 += t4[r4].length;
                      return i4;
                    case "nodebuffer":
                      return Buffer.concat(t4);
                    default:
                      throw new Error("concat : unsupported type '" + e5 + "'");
                  }
                }(i3, n3), a3);
                t3(e4);
              } catch (e5) {
                r3(e5);
              }
              n3 = [];
            }).resume();
          });
        }
        __name(l3, "l");
        function f2(e3, t3, r3) {
          var n3 = t3;
          switch (t3) {
            case "blob":
            case "arraybuffer":
              n3 = "uint8array";
              break;
            case "base64":
              n3 = "string";
          }
          try {
            this._internalType = n3, this._outputType = t3, this._mimeType = r3, h2.checkSupport(n3), this._worker = e3.pipe(new i2(n3)), e3.lock();
          } catch (e4) {
            this._worker = new s2("error"), this._worker.error(e4);
          }
        }
        __name(f2, "f");
        f2.prototype = { accumulate: function(e3) {
          return l3(this, e3);
        }, on: function(e3, t3) {
          var r3 = this;
          return "data" === e3 ? this._worker.on(e3, function(e4) {
            t3.call(r3, e4.data, e4.meta);
          }) : this._worker.on(e3, function() {
            h2.delay(t3, arguments, r3);
          }), this;
        }, resume: function() {
          return h2.delay(this._worker.resume, [], this._worker), this;
        }, pause: function() {
          return this._worker.pause(), this;
        }, toNodejsStream: function(e3) {
          if (h2.checkSupport("nodestream"), "nodebuffer" !== this._outputType)
            throw new Error(this._outputType + " is not supported by this method");
          return new o2(this, { objectMode: "nodebuffer" !== this._outputType }, e3);
        } }, t2.exports = f2;
      }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(e2, t2, r2) {
        "use strict";
        if (r2.base64 = true, r2.array = true, r2.string = true, r2.arraybuffer = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array, r2.nodebuffer = "undefined" != typeof Buffer, r2.uint8array = "undefined" != typeof Uint8Array, "undefined" == typeof ArrayBuffer)
          r2.blob = false;
        else {
          var n2 = new ArrayBuffer(0);
          try {
            r2.blob = 0 === new Blob([n2], { type: "application/zip" }).size;
          } catch (e3) {
            try {
              var i2 = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
              i2.append(n2), r2.blob = 0 === i2.getBlob("application/zip").size;
            } catch (e4) {
              r2.blob = false;
            }
          }
        }
        try {
          r2.nodestream = !!e2("readable-stream").Readable;
        } catch (e3) {
          r2.nodestream = false;
        }
      }, { "readable-stream": 16 }], 31: [function(e2, t2, s2) {
        "use strict";
        for (var o2 = e2("./utils"), h2 = e2("./support"), r2 = e2("./nodejsUtils"), n2 = e2("./stream/GenericWorker"), u2 = new Array(256), i2 = 0; i2 < 256; i2++)
          u2[i2] = 252 <= i2 ? 6 : 248 <= i2 ? 5 : 240 <= i2 ? 4 : 224 <= i2 ? 3 : 192 <= i2 ? 2 : 1;
        u2[254] = u2[254] = 1;
        function a2() {
          n2.call(this, "utf-8 decode"), this.leftOver = null;
        }
        __name(a2, "a");
        function l3() {
          n2.call(this, "utf-8 encode");
        }
        __name(l3, "l");
        s2.utf8encode = function(e3) {
          return h2.nodebuffer ? r2.newBufferFrom(e3, "utf-8") : function(e4) {
            var t3, r3, n3, i3, s3, a3 = e4.length, o3 = 0;
            for (i3 = 0; i3 < a3; i3++)
              55296 == (64512 & (r3 = e4.charCodeAt(i3))) && i3 + 1 < a3 && 56320 == (64512 & (n3 = e4.charCodeAt(i3 + 1))) && (r3 = 65536 + (r3 - 55296 << 10) + (n3 - 56320), i3++), o3 += r3 < 128 ? 1 : r3 < 2048 ? 2 : r3 < 65536 ? 3 : 4;
            for (t3 = h2.uint8array ? new Uint8Array(o3) : new Array(o3), i3 = s3 = 0; s3 < o3; i3++)
              55296 == (64512 & (r3 = e4.charCodeAt(i3))) && i3 + 1 < a3 && 56320 == (64512 & (n3 = e4.charCodeAt(i3 + 1))) && (r3 = 65536 + (r3 - 55296 << 10) + (n3 - 56320), i3++), r3 < 128 ? t3[s3++] = r3 : (r3 < 2048 ? t3[s3++] = 192 | r3 >>> 6 : (r3 < 65536 ? t3[s3++] = 224 | r3 >>> 12 : (t3[s3++] = 240 | r3 >>> 18, t3[s3++] = 128 | r3 >>> 12 & 63), t3[s3++] = 128 | r3 >>> 6 & 63), t3[s3++] = 128 | 63 & r3);
            return t3;
          }(e3);
        }, s2.utf8decode = function(e3) {
          return h2.nodebuffer ? o2.transformTo("nodebuffer", e3).toString("utf-8") : function(e4) {
            var t3, r3, n3, i3, s3 = e4.length, a3 = new Array(2 * s3);
            for (t3 = r3 = 0; t3 < s3; )
              if ((n3 = e4[t3++]) < 128)
                a3[r3++] = n3;
              else if (4 < (i3 = u2[n3]))
                a3[r3++] = 65533, t3 += i3 - 1;
              else {
                for (n3 &= 2 === i3 ? 31 : 3 === i3 ? 15 : 7; 1 < i3 && t3 < s3; )
                  n3 = n3 << 6 | 63 & e4[t3++], i3--;
                1 < i3 ? a3[r3++] = 65533 : n3 < 65536 ? a3[r3++] = n3 : (n3 -= 65536, a3[r3++] = 55296 | n3 >> 10 & 1023, a3[r3++] = 56320 | 1023 & n3);
              }
            return a3.length !== r3 && (a3.subarray ? a3 = a3.subarray(0, r3) : a3.length = r3), o2.applyFromCharCode(a3);
          }(e3 = o2.transformTo(h2.uint8array ? "uint8array" : "array", e3));
        }, o2.inherits(a2, n2), a2.prototype.processChunk = function(e3) {
          var t3 = o2.transformTo(h2.uint8array ? "uint8array" : "array", e3.data);
          if (this.leftOver && this.leftOver.length) {
            if (h2.uint8array) {
              var r3 = t3;
              (t3 = new Uint8Array(r3.length + this.leftOver.length)).set(this.leftOver, 0), t3.set(r3, this.leftOver.length);
            } else
              t3 = this.leftOver.concat(t3);
            this.leftOver = null;
          }
          var n3 = function(e4, t4) {
            var r4;
            for ((t4 = t4 || e4.length) > e4.length && (t4 = e4.length), r4 = t4 - 1; 0 <= r4 && 128 == (192 & e4[r4]); )
              r4--;
            return r4 < 0 ? t4 : 0 === r4 ? t4 : r4 + u2[e4[r4]] > t4 ? r4 : t4;
          }(t3), i3 = t3;
          n3 !== t3.length && (h2.uint8array ? (i3 = t3.subarray(0, n3), this.leftOver = t3.subarray(n3, t3.length)) : (i3 = t3.slice(0, n3), this.leftOver = t3.slice(n3, t3.length))), this.push({ data: s2.utf8decode(i3), meta: e3.meta });
        }, a2.prototype.flush = function() {
          this.leftOver && this.leftOver.length && (this.push({ data: s2.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
        }, s2.Utf8DecodeWorker = a2, o2.inherits(l3, n2), l3.prototype.processChunk = function(e3) {
          this.push({ data: s2.utf8encode(e3.data), meta: e3.meta });
        }, s2.Utf8EncodeWorker = l3;
      }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(e2, t2, a2) {
        "use strict";
        var o2 = e2("./support"), h2 = e2("./base64"), r2 = e2("./nodejsUtils"), u2 = e2("./external");
        function n2(e3) {
          return e3;
        }
        __name(n2, "n");
        function l3(e3, t3) {
          for (var r3 = 0; r3 < e3.length; ++r3)
            t3[r3] = 255 & e3.charCodeAt(r3);
          return t3;
        }
        __name(l3, "l");
        e2("setimmediate"), a2.newBlob = function(t3, r3) {
          a2.checkSupport("blob");
          try {
            return new Blob([t3], { type: r3 });
          } catch (e3) {
            try {
              var n3 = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
              return n3.append(t3), n3.getBlob(r3);
            } catch (e4) {
              throw new Error("Bug : can't construct the Blob.");
            }
          }
        };
        var i2 = { stringifyByChunk: function(e3, t3, r3) {
          var n3 = [], i3 = 0, s3 = e3.length;
          if (s3 <= r3)
            return String.fromCharCode.apply(null, e3);
          for (; i3 < s3; )
            "array" === t3 || "nodebuffer" === t3 ? n3.push(String.fromCharCode.apply(null, e3.slice(i3, Math.min(i3 + r3, s3)))) : n3.push(String.fromCharCode.apply(null, e3.subarray(i3, Math.min(i3 + r3, s3)))), i3 += r3;
          return n3.join("");
        }, stringifyByChar: function(e3) {
          for (var t3 = "", r3 = 0; r3 < e3.length; r3++)
            t3 += String.fromCharCode(e3[r3]);
          return t3;
        }, applyCanBeUsed: { uint8array: function() {
          try {
            return o2.uint8array && 1 === String.fromCharCode.apply(null, new Uint8Array(1)).length;
          } catch (e3) {
            return false;
          }
        }(), nodebuffer: function() {
          try {
            return o2.nodebuffer && 1 === String.fromCharCode.apply(null, r2.allocBuffer(1)).length;
          } catch (e3) {
            return false;
          }
        }() } };
        function s2(e3) {
          var t3 = 65536, r3 = a2.getTypeOf(e3), n3 = true;
          if ("uint8array" === r3 ? n3 = i2.applyCanBeUsed.uint8array : "nodebuffer" === r3 && (n3 = i2.applyCanBeUsed.nodebuffer), n3)
            for (; 1 < t3; )
              try {
                return i2.stringifyByChunk(e3, r3, t3);
              } catch (e4) {
                t3 = Math.floor(t3 / 2);
              }
          return i2.stringifyByChar(e3);
        }
        __name(s2, "s");
        function f2(e3, t3) {
          for (var r3 = 0; r3 < e3.length; r3++)
            t3[r3] = e3[r3];
          return t3;
        }
        __name(f2, "f");
        a2.applyFromCharCode = s2;
        var c2 = {};
        c2.string = { string: n2, array: function(e3) {
          return l3(e3, new Array(e3.length));
        }, arraybuffer: function(e3) {
          return c2.string.uint8array(e3).buffer;
        }, uint8array: function(e3) {
          return l3(e3, new Uint8Array(e3.length));
        }, nodebuffer: function(e3) {
          return l3(e3, r2.allocBuffer(e3.length));
        } }, c2.array = { string: s2, array: n2, arraybuffer: function(e3) {
          return new Uint8Array(e3).buffer;
        }, uint8array: function(e3) {
          return new Uint8Array(e3);
        }, nodebuffer: function(e3) {
          return r2.newBufferFrom(e3);
        } }, c2.arraybuffer = { string: function(e3) {
          return s2(new Uint8Array(e3));
        }, array: function(e3) {
          return f2(new Uint8Array(e3), new Array(e3.byteLength));
        }, arraybuffer: n2, uint8array: function(e3) {
          return new Uint8Array(e3);
        }, nodebuffer: function(e3) {
          return r2.newBufferFrom(new Uint8Array(e3));
        } }, c2.uint8array = { string: s2, array: function(e3) {
          return f2(e3, new Array(e3.length));
        }, arraybuffer: function(e3) {
          return e3.buffer;
        }, uint8array: n2, nodebuffer: function(e3) {
          return r2.newBufferFrom(e3);
        } }, c2.nodebuffer = { string: s2, array: function(e3) {
          return f2(e3, new Array(e3.length));
        }, arraybuffer: function(e3) {
          return c2.nodebuffer.uint8array(e3).buffer;
        }, uint8array: function(e3) {
          return f2(e3, new Uint8Array(e3.length));
        }, nodebuffer: n2 }, a2.transformTo = function(e3, t3) {
          if (t3 = t3 || "", !e3)
            return t3;
          a2.checkSupport(e3);
          var r3 = a2.getTypeOf(t3);
          return c2[r3][e3](t3);
        }, a2.resolve = function(e3) {
          for (var t3 = e3.split("/"), r3 = [], n3 = 0; n3 < t3.length; n3++) {
            var i3 = t3[n3];
            "." === i3 || "" === i3 && 0 !== n3 && n3 !== t3.length - 1 || (".." === i3 ? r3.pop() : r3.push(i3));
          }
          return r3.join("/");
        }, a2.getTypeOf = function(e3) {
          return "string" == typeof e3 ? "string" : "[object Array]" === Object.prototype.toString.call(e3) ? "array" : o2.nodebuffer && r2.isBuffer(e3) ? "nodebuffer" : o2.uint8array && e3 instanceof Uint8Array ? "uint8array" : o2.arraybuffer && e3 instanceof ArrayBuffer ? "arraybuffer" : void 0;
        }, a2.checkSupport = function(e3) {
          if (!o2[e3.toLowerCase()])
            throw new Error(e3 + " is not supported by this platform");
        }, a2.MAX_VALUE_16BITS = 65535, a2.MAX_VALUE_32BITS = -1, a2.pretty = function(e3) {
          var t3, r3, n3 = "";
          for (r3 = 0; r3 < (e3 || "").length; r3++)
            n3 += "\\x" + ((t3 = e3.charCodeAt(r3)) < 16 ? "0" : "") + t3.toString(16).toUpperCase();
          return n3;
        }, a2.delay = function(e3, t3, r3) {
          setImmediate(function() {
            e3.apply(r3 || null, t3 || []);
          });
        }, a2.inherits = function(e3, t3) {
          function r3() {
          }
          __name(r3, "r");
          r3.prototype = t3.prototype, e3.prototype = new r3();
        }, a2.extend = function() {
          var e3, t3, r3 = {};
          for (e3 = 0; e3 < arguments.length; e3++)
            for (t3 in arguments[e3])
              Object.prototype.hasOwnProperty.call(arguments[e3], t3) && void 0 === r3[t3] && (r3[t3] = arguments[e3][t3]);
          return r3;
        }, a2.prepareContent = function(r3, e3, n3, i3, s3) {
          return u2.Promise.resolve(e3).then(function(n4) {
            return o2.blob && (n4 instanceof Blob || -1 !== ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(n4))) && "undefined" != typeof FileReader ? new u2.Promise(function(t3, r4) {
              var e4 = new FileReader();
              e4.onload = function(e5) {
                t3(e5.target.result);
              }, e4.onerror = function(e5) {
                r4(e5.target.error);
              }, e4.readAsArrayBuffer(n4);
            }) : n4;
          }).then(function(e4) {
            var t3 = a2.getTypeOf(e4);
            return t3 ? ("arraybuffer" === t3 ? e4 = a2.transformTo("uint8array", e4) : "string" === t3 && (s3 ? e4 = h2.decode(e4) : n3 && true !== i3 && (e4 = function(e5) {
              return l3(e5, o2.uint8array ? new Uint8Array(e5.length) : new Array(e5.length));
            }(e4))), e4) : u2.Promise.reject(new Error("Can't read the data of '" + r3 + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
          });
        };
      }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(e2, t2, r2) {
        "use strict";
        var n2 = e2("./reader/readerFor"), i2 = e2("./utils"), s2 = e2("./signature"), a2 = e2("./zipEntry"), o2 = e2("./support");
        function h2(e3) {
          this.files = [], this.loadOptions = e3;
        }
        __name(h2, "h");
        h2.prototype = { checkSignature: function(e3) {
          if (!this.reader.readAndCheckSignature(e3)) {
            this.reader.index -= 4;
            var t3 = this.reader.readString(4);
            throw new Error("Corrupted zip or bug: unexpected signature (" + i2.pretty(t3) + ", expected " + i2.pretty(e3) + ")");
          }
        }, isSignature: function(e3, t3) {
          var r3 = this.reader.index;
          this.reader.setIndex(e3);
          var n3 = this.reader.readString(4) === t3;
          return this.reader.setIndex(r3), n3;
        }, readBlockEndOfCentral: function() {
          this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
          var e3 = this.reader.readData(this.zipCommentLength), t3 = o2.uint8array ? "uint8array" : "array", r3 = i2.transformTo(t3, e3);
          this.zipComment = this.loadOptions.decodeFileName(r3);
        }, readBlockZip64EndOfCentral: function() {
          this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
          for (var e3, t3, r3, n3 = this.zip64EndOfCentralSize - 44; 0 < n3; )
            e3 = this.reader.readInt(2), t3 = this.reader.readInt(4), r3 = this.reader.readData(t3), this.zip64ExtensibleData[e3] = { id: e3, length: t3, value: r3 };
        }, readBlockZip64EndOfCentralLocator: function() {
          if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount)
            throw new Error("Multi-volumes zip are not supported");
        }, readLocalFiles: function() {
          var e3, t3;
          for (e3 = 0; e3 < this.files.length; e3++)
            t3 = this.files[e3], this.reader.setIndex(t3.localHeaderOffset), this.checkSignature(s2.LOCAL_FILE_HEADER), t3.readLocalPart(this.reader), t3.handleUTF8(), t3.processAttributes();
        }, readCentralDir: function() {
          var e3;
          for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(s2.CENTRAL_FILE_HEADER); )
            (e3 = new a2({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(e3);
          if (this.centralDirRecords !== this.files.length && 0 !== this.centralDirRecords && 0 === this.files.length)
            throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
        }, readEndOfCentral: function() {
          var e3 = this.reader.lastIndexOfSignature(s2.CENTRAL_DIRECTORY_END);
          if (e3 < 0)
            throw !this.isSignature(0, s2.LOCAL_FILE_HEADER) ? new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html") : new Error("Corrupted zip: can't find end of central directory");
          this.reader.setIndex(e3);
          var t3 = e3;
          if (this.checkSignature(s2.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === i2.MAX_VALUE_16BITS || this.diskWithCentralDirStart === i2.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === i2.MAX_VALUE_16BITS || this.centralDirRecords === i2.MAX_VALUE_16BITS || this.centralDirSize === i2.MAX_VALUE_32BITS || this.centralDirOffset === i2.MAX_VALUE_32BITS) {
            if (this.zip64 = true, (e3 = this.reader.lastIndexOfSignature(s2.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0)
              throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
            if (this.reader.setIndex(e3), this.checkSignature(s2.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, s2.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(s2.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0))
              throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(s2.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
          }
          var r3 = this.centralDirOffset + this.centralDirSize;
          this.zip64 && (r3 += 20, r3 += 12 + this.zip64EndOfCentralSize);
          var n3 = t3 - r3;
          if (0 < n3)
            this.isSignature(t3, s2.CENTRAL_FILE_HEADER) || (this.reader.zero = n3);
          else if (n3 < 0)
            throw new Error("Corrupted zip: missing " + Math.abs(n3) + " bytes.");
        }, prepareReader: function(e3) {
          this.reader = n2(e3);
        }, load: function(e3) {
          this.prepareReader(e3), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
        } }, t2.exports = h2;
      }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(e2, t2, r2) {
        "use strict";
        var n2 = e2("./reader/readerFor"), s2 = e2("./utils"), i2 = e2("./compressedObject"), a2 = e2("./crc32"), o2 = e2("./utf8"), h2 = e2("./compressions"), u2 = e2("./support");
        function l3(e3, t3) {
          this.options = e3, this.loadOptions = t3;
        }
        __name(l3, "l");
        l3.prototype = { isEncrypted: function() {
          return 1 == (1 & this.bitFlag);
        }, useUTF8: function() {
          return 2048 == (2048 & this.bitFlag);
        }, readLocalPart: function(e3) {
          var t3, r3;
          if (e3.skip(22), this.fileNameLength = e3.readInt(2), r3 = e3.readInt(2), this.fileName = e3.readData(this.fileNameLength), e3.skip(r3), -1 === this.compressedSize || -1 === this.uncompressedSize)
            throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
          if (null === (t3 = function(e4) {
            for (var t4 in h2)
              if (Object.prototype.hasOwnProperty.call(h2, t4) && h2[t4].magic === e4)
                return h2[t4];
            return null;
          }(this.compressionMethod)))
            throw new Error("Corrupted zip : compression " + s2.pretty(this.compressionMethod) + " unknown (inner file : " + s2.transformTo("string", this.fileName) + ")");
          this.decompressed = new i2(this.compressedSize, this.uncompressedSize, this.crc32, t3, e3.readData(this.compressedSize));
        }, readCentralPart: function(e3) {
          this.versionMadeBy = e3.readInt(2), e3.skip(2), this.bitFlag = e3.readInt(2), this.compressionMethod = e3.readString(2), this.date = e3.readDate(), this.crc32 = e3.readInt(4), this.compressedSize = e3.readInt(4), this.uncompressedSize = e3.readInt(4);
          var t3 = e3.readInt(2);
          if (this.extraFieldsLength = e3.readInt(2), this.fileCommentLength = e3.readInt(2), this.diskNumberStart = e3.readInt(2), this.internalFileAttributes = e3.readInt(2), this.externalFileAttributes = e3.readInt(4), this.localHeaderOffset = e3.readInt(4), this.isEncrypted())
            throw new Error("Encrypted zip are not supported");
          e3.skip(t3), this.readExtraFields(e3), this.parseZIP64ExtraField(e3), this.fileComment = e3.readData(this.fileCommentLength);
        }, processAttributes: function() {
          this.unixPermissions = null, this.dosPermissions = null;
          var e3 = this.versionMadeBy >> 8;
          this.dir = !!(16 & this.externalFileAttributes), 0 == e3 && (this.dosPermissions = 63 & this.externalFileAttributes), 3 == e3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || "/" !== this.fileNameStr.slice(-1) || (this.dir = true);
        }, parseZIP64ExtraField: function() {
          if (this.extraFields[1]) {
            var e3 = n2(this.extraFields[1].value);
            this.uncompressedSize === s2.MAX_VALUE_32BITS && (this.uncompressedSize = e3.readInt(8)), this.compressedSize === s2.MAX_VALUE_32BITS && (this.compressedSize = e3.readInt(8)), this.localHeaderOffset === s2.MAX_VALUE_32BITS && (this.localHeaderOffset = e3.readInt(8)), this.diskNumberStart === s2.MAX_VALUE_32BITS && (this.diskNumberStart = e3.readInt(4));
          }
        }, readExtraFields: function(e3) {
          var t3, r3, n3, i3 = e3.index + this.extraFieldsLength;
          for (this.extraFields || (this.extraFields = {}); e3.index + 4 < i3; )
            t3 = e3.readInt(2), r3 = e3.readInt(2), n3 = e3.readData(r3), this.extraFields[t3] = { id: t3, length: r3, value: n3 };
          e3.setIndex(i3);
        }, handleUTF8: function() {
          var e3 = u2.uint8array ? "uint8array" : "array";
          if (this.useUTF8())
            this.fileNameStr = o2.utf8decode(this.fileName), this.fileCommentStr = o2.utf8decode(this.fileComment);
          else {
            var t3 = this.findExtraFieldUnicodePath();
            if (null !== t3)
              this.fileNameStr = t3;
            else {
              var r3 = s2.transformTo(e3, this.fileName);
              this.fileNameStr = this.loadOptions.decodeFileName(r3);
            }
            var n3 = this.findExtraFieldUnicodeComment();
            if (null !== n3)
              this.fileCommentStr = n3;
            else {
              var i3 = s2.transformTo(e3, this.fileComment);
              this.fileCommentStr = this.loadOptions.decodeFileName(i3);
            }
          }
        }, findExtraFieldUnicodePath: function() {
          var e3 = this.extraFields[28789];
          if (e3) {
            var t3 = n2(e3.value);
            return 1 !== t3.readInt(1) ? null : a2(this.fileName) !== t3.readInt(4) ? null : o2.utf8decode(t3.readData(e3.length - 5));
          }
          return null;
        }, findExtraFieldUnicodeComment: function() {
          var e3 = this.extraFields[25461];
          if (e3) {
            var t3 = n2(e3.value);
            return 1 !== t3.readInt(1) ? null : a2(this.fileComment) !== t3.readInt(4) ? null : o2.utf8decode(t3.readData(e3.length - 5));
          }
          return null;
        } }, t2.exports = l3;
      }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(e2, t2, r2) {
        "use strict";
        function n2(e3, t3, r3) {
          this.name = e3, this.dir = r3.dir, this.date = r3.date, this.comment = r3.comment, this.unixPermissions = r3.unixPermissions, this.dosPermissions = r3.dosPermissions, this._data = t3, this._dataBinary = r3.binary, this.options = { compression: r3.compression, compressionOptions: r3.compressionOptions };
        }
        __name(n2, "n");
        var s2 = e2("./stream/StreamHelper"), i2 = e2("./stream/DataWorker"), a2 = e2("./utf8"), o2 = e2("./compressedObject"), h2 = e2("./stream/GenericWorker");
        n2.prototype = { internalStream: function(e3) {
          var t3 = null, r3 = "string";
          try {
            if (!e3)
              throw new Error("No output type specified.");
            var n3 = "string" === (r3 = e3.toLowerCase()) || "text" === r3;
            "binarystring" !== r3 && "text" !== r3 || (r3 = "string"), t3 = this._decompressWorker();
            var i3 = !this._dataBinary;
            i3 && !n3 && (t3 = t3.pipe(new a2.Utf8EncodeWorker())), !i3 && n3 && (t3 = t3.pipe(new a2.Utf8DecodeWorker()));
          } catch (e4) {
            (t3 = new h2("error")).error(e4);
          }
          return new s2(t3, r3, "");
        }, async: function(e3, t3) {
          return this.internalStream(e3).accumulate(t3);
        }, nodeStream: function(e3, t3) {
          return this.internalStream(e3 || "nodebuffer").toNodejsStream(t3);
        }, _compressWorker: function(e3, t3) {
          if (this._data instanceof o2 && this._data.compression.magic === e3.magic)
            return this._data.getCompressedWorker();
          var r3 = this._decompressWorker();
          return this._dataBinary || (r3 = r3.pipe(new a2.Utf8EncodeWorker())), o2.createWorkerFrom(r3, e3, t3);
        }, _decompressWorker: function() {
          return this._data instanceof o2 ? this._data.getContentWorker() : this._data instanceof h2 ? this._data : new i2(this._data);
        } };
        for (var u2 = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], l3 = function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, f2 = 0; f2 < u2.length; f2++)
          n2.prototype[u2[f2]] = l3;
        t2.exports = n2;
      }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(e2, l3, t2) {
        (function(t3) {
          "use strict";
          var r2, n2, e3 = t3.MutationObserver || t3.WebKitMutationObserver;
          if (e3) {
            var i2 = 0, s2 = new e3(u2), a2 = t3.document.createTextNode("");
            s2.observe(a2, { characterData: true }), r2 = /* @__PURE__ */ __name(function() {
              a2.data = i2 = ++i2 % 2;
            }, "r");
          } else if (t3.setImmediate || void 0 === t3.MessageChannel)
            r2 = "document" in t3 && "onreadystatechange" in t3.document.createElement("script") ? function() {
              var e4 = t3.document.createElement("script");
              e4.onreadystatechange = function() {
                u2(), e4.onreadystatechange = null, e4.parentNode.removeChild(e4), e4 = null;
              }, t3.document.documentElement.appendChild(e4);
            } : function() {
              setTimeout(u2, 0);
            };
          else {
            var o2 = new t3.MessageChannel();
            o2.port1.onmessage = u2, r2 = /* @__PURE__ */ __name(function() {
              o2.port2.postMessage(0);
            }, "r");
          }
          var h2 = [];
          function u2() {
            var e4, t4;
            n2 = true;
            for (var r3 = h2.length; r3; ) {
              for (t4 = h2, h2 = [], e4 = -1; ++e4 < r3; )
                t4[e4]();
              r3 = h2.length;
            }
            n2 = false;
          }
          __name(u2, "u");
          l3.exports = function(e4) {
            1 !== h2.push(e4) || n2 || r2();
          };
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, {}], 37: [function(e2, t2, r2) {
        "use strict";
        var i2 = e2("immediate");
        function u2() {
        }
        __name(u2, "u");
        var l3 = {}, s2 = ["REJECTED"], a2 = ["FULFILLED"], n2 = ["PENDING"];
        function o2(e3) {
          if ("function" != typeof e3)
            throw new TypeError("resolver must be a function");
          this.state = n2, this.queue = [], this.outcome = void 0, e3 !== u2 && d2(this, e3);
        }
        __name(o2, "o");
        function h2(e3, t3, r3) {
          this.promise = e3, "function" == typeof t3 && (this.onFulfilled = t3, this.callFulfilled = this.otherCallFulfilled), "function" == typeof r3 && (this.onRejected = r3, this.callRejected = this.otherCallRejected);
        }
        __name(h2, "h");
        function f2(t3, r3, n3) {
          i2(function() {
            var e3;
            try {
              e3 = r3(n3);
            } catch (e4) {
              return l3.reject(t3, e4);
            }
            e3 === t3 ? l3.reject(t3, new TypeError("Cannot resolve promise with itself")) : l3.resolve(t3, e3);
          });
        }
        __name(f2, "f");
        function c2(e3) {
          var t3 = e3 && e3.then;
          if (e3 && ("object" == typeof e3 || "function" == typeof e3) && "function" == typeof t3)
            return function() {
              t3.apply(e3, arguments);
            };
        }
        __name(c2, "c");
        function d2(t3, e3) {
          var r3 = false;
          function n3(e4) {
            r3 || (r3 = true, l3.reject(t3, e4));
          }
          __name(n3, "n");
          function i3(e4) {
            r3 || (r3 = true, l3.resolve(t3, e4));
          }
          __name(i3, "i");
          var s3 = p2(function() {
            e3(i3, n3);
          });
          "error" === s3.status && n3(s3.value);
        }
        __name(d2, "d");
        function p2(e3, t3) {
          var r3 = {};
          try {
            r3.value = e3(t3), r3.status = "success";
          } catch (e4) {
            r3.status = "error", r3.value = e4;
          }
          return r3;
        }
        __name(p2, "p");
        (t2.exports = o2).prototype.finally = function(t3) {
          if ("function" != typeof t3)
            return this;
          var r3 = this.constructor;
          return this.then(function(e3) {
            return r3.resolve(t3()).then(function() {
              return e3;
            });
          }, function(e3) {
            return r3.resolve(t3()).then(function() {
              throw e3;
            });
          });
        }, o2.prototype.catch = function(e3) {
          return this.then(null, e3);
        }, o2.prototype.then = function(e3, t3) {
          if ("function" != typeof e3 && this.state === a2 || "function" != typeof t3 && this.state === s2)
            return this;
          var r3 = new this.constructor(u2);
          this.state !== n2 ? f2(r3, this.state === a2 ? e3 : t3, this.outcome) : this.queue.push(new h2(r3, e3, t3));
          return r3;
        }, h2.prototype.callFulfilled = function(e3) {
          l3.resolve(this.promise, e3);
        }, h2.prototype.otherCallFulfilled = function(e3) {
          f2(this.promise, this.onFulfilled, e3);
        }, h2.prototype.callRejected = function(e3) {
          l3.reject(this.promise, e3);
        }, h2.prototype.otherCallRejected = function(e3) {
          f2(this.promise, this.onRejected, e3);
        }, l3.resolve = function(e3, t3) {
          var r3 = p2(c2, t3);
          if ("error" === r3.status)
            return l3.reject(e3, r3.value);
          var n3 = r3.value;
          if (n3)
            d2(e3, n3);
          else {
            e3.state = a2, e3.outcome = t3;
            for (var i3 = -1, s3 = e3.queue.length; ++i3 < s3; )
              e3.queue[i3].callFulfilled(t3);
          }
          return e3;
        }, l3.reject = function(e3, t3) {
          e3.state = s2, e3.outcome = t3;
          for (var r3 = -1, n3 = e3.queue.length; ++r3 < n3; )
            e3.queue[r3].callRejected(t3);
          return e3;
        }, o2.resolve = function(e3) {
          if (e3 instanceof this)
            return e3;
          return l3.resolve(new this(u2), e3);
        }, o2.reject = function(e3) {
          var t3 = new this(u2);
          return l3.reject(t3, e3);
        }, o2.all = function(e3) {
          var r3 = this;
          if ("[object Array]" !== Object.prototype.toString.call(e3))
            return this.reject(new TypeError("must be an array"));
          var n3 = e3.length, i3 = false;
          if (!n3)
            return this.resolve([]);
          var s3 = new Array(n3), a3 = 0, t3 = -1, o3 = new this(u2);
          for (; ++t3 < n3; )
            h3(e3[t3], t3);
          return o3;
          function h3(e4, t4) {
            r3.resolve(e4).then(function(e5) {
              s3[t4] = e5, ++a3 !== n3 || i3 || (i3 = true, l3.resolve(o3, s3));
            }, function(e5) {
              i3 || (i3 = true, l3.reject(o3, e5));
            });
          }
          __name(h3, "h");
        }, o2.race = function(e3) {
          var t3 = this;
          if ("[object Array]" !== Object.prototype.toString.call(e3))
            return this.reject(new TypeError("must be an array"));
          var r3 = e3.length, n3 = false;
          if (!r3)
            return this.resolve([]);
          var i3 = -1, s3 = new this(u2);
          for (; ++i3 < r3; )
            a3 = e3[i3], t3.resolve(a3).then(function(e4) {
              n3 || (n3 = true, l3.resolve(s3, e4));
            }, function(e4) {
              n3 || (n3 = true, l3.reject(s3, e4));
            });
          var a3;
          return s3;
        };
      }, { immediate: 36 }], 38: [function(e2, t2, r2) {
        "use strict";
        var n2 = {};
        (0, e2("./lib/utils/common").assign)(n2, e2("./lib/deflate"), e2("./lib/inflate"), e2("./lib/zlib/constants")), t2.exports = n2;
      }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(e2, t2, r2) {
        "use strict";
        var a2 = e2("./zlib/deflate"), o2 = e2("./utils/common"), h2 = e2("./utils/strings"), i2 = e2("./zlib/messages"), s2 = e2("./zlib/zstream"), u2 = Object.prototype.toString, l3 = 0, f2 = -1, c2 = 0, d2 = 8;
        function p2(e3) {
          if (!(this instanceof p2))
            return new p2(e3);
          this.options = o2.assign({ level: f2, method: d2, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: c2, to: "" }, e3 || {});
          var t3 = this.options;
          t3.raw && 0 < t3.windowBits ? t3.windowBits = -t3.windowBits : t3.gzip && 0 < t3.windowBits && t3.windowBits < 16 && (t3.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new s2(), this.strm.avail_out = 0;
          var r3 = a2.deflateInit2(this.strm, t3.level, t3.method, t3.windowBits, t3.memLevel, t3.strategy);
          if (r3 !== l3)
            throw new Error(i2[r3]);
          if (t3.header && a2.deflateSetHeader(this.strm, t3.header), t3.dictionary) {
            var n3;
            if (n3 = "string" == typeof t3.dictionary ? h2.string2buf(t3.dictionary) : "[object ArrayBuffer]" === u2.call(t3.dictionary) ? new Uint8Array(t3.dictionary) : t3.dictionary, (r3 = a2.deflateSetDictionary(this.strm, n3)) !== l3)
              throw new Error(i2[r3]);
            this._dict_set = true;
          }
        }
        __name(p2, "p");
        function n2(e3, t3) {
          var r3 = new p2(t3);
          if (r3.push(e3, true), r3.err)
            throw r3.msg || i2[r3.err];
          return r3.result;
        }
        __name(n2, "n");
        p2.prototype.push = function(e3, t3) {
          var r3, n3, i3 = this.strm, s3 = this.options.chunkSize;
          if (this.ended)
            return false;
          n3 = t3 === ~~t3 ? t3 : true === t3 ? 4 : 0, "string" == typeof e3 ? i3.input = h2.string2buf(e3) : "[object ArrayBuffer]" === u2.call(e3) ? i3.input = new Uint8Array(e3) : i3.input = e3, i3.next_in = 0, i3.avail_in = i3.input.length;
          do {
            if (0 === i3.avail_out && (i3.output = new o2.Buf8(s3), i3.next_out = 0, i3.avail_out = s3), 1 !== (r3 = a2.deflate(i3, n3)) && r3 !== l3)
              return this.onEnd(r3), !(this.ended = true);
            0 !== i3.avail_out && (0 !== i3.avail_in || 4 !== n3 && 2 !== n3) || ("string" === this.options.to ? this.onData(h2.buf2binstring(o2.shrinkBuf(i3.output, i3.next_out))) : this.onData(o2.shrinkBuf(i3.output, i3.next_out)));
          } while ((0 < i3.avail_in || 0 === i3.avail_out) && 1 !== r3);
          return 4 === n3 ? (r3 = a2.deflateEnd(this.strm), this.onEnd(r3), this.ended = true, r3 === l3) : 2 !== n3 || (this.onEnd(l3), !(i3.avail_out = 0));
        }, p2.prototype.onData = function(e3) {
          this.chunks.push(e3);
        }, p2.prototype.onEnd = function(e3) {
          e3 === l3 && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = o2.flattenChunks(this.chunks)), this.chunks = [], this.err = e3, this.msg = this.strm.msg;
        }, r2.Deflate = p2, r2.deflate = n2, r2.deflateRaw = function(e3, t3) {
          return (t3 = t3 || {}).raw = true, n2(e3, t3);
        }, r2.gzip = function(e3, t3) {
          return (t3 = t3 || {}).gzip = true, n2(e3, t3);
        };
      }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(e2, t2, r2) {
        "use strict";
        var c2 = e2("./zlib/inflate"), d2 = e2("./utils/common"), p2 = e2("./utils/strings"), m2 = e2("./zlib/constants"), n2 = e2("./zlib/messages"), i2 = e2("./zlib/zstream"), s2 = e2("./zlib/gzheader"), _2 = Object.prototype.toString;
        function a2(e3) {
          if (!(this instanceof a2))
            return new a2(e3);
          this.options = d2.assign({ chunkSize: 16384, windowBits: 0, to: "" }, e3 || {});
          var t3 = this.options;
          t3.raw && 0 <= t3.windowBits && t3.windowBits < 16 && (t3.windowBits = -t3.windowBits, 0 === t3.windowBits && (t3.windowBits = -15)), !(0 <= t3.windowBits && t3.windowBits < 16) || e3 && e3.windowBits || (t3.windowBits += 32), 15 < t3.windowBits && t3.windowBits < 48 && 0 == (15 & t3.windowBits) && (t3.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new i2(), this.strm.avail_out = 0;
          var r3 = c2.inflateInit2(this.strm, t3.windowBits);
          if (r3 !== m2.Z_OK)
            throw new Error(n2[r3]);
          this.header = new s2(), c2.inflateGetHeader(this.strm, this.header);
        }
        __name(a2, "a");
        function o2(e3, t3) {
          var r3 = new a2(t3);
          if (r3.push(e3, true), r3.err)
            throw r3.msg || n2[r3.err];
          return r3.result;
        }
        __name(o2, "o");
        a2.prototype.push = function(e3, t3) {
          var r3, n3, i3, s3, a3, o3, h2 = this.strm, u2 = this.options.chunkSize, l3 = this.options.dictionary, f2 = false;
          if (this.ended)
            return false;
          n3 = t3 === ~~t3 ? t3 : true === t3 ? m2.Z_FINISH : m2.Z_NO_FLUSH, "string" == typeof e3 ? h2.input = p2.binstring2buf(e3) : "[object ArrayBuffer]" === _2.call(e3) ? h2.input = new Uint8Array(e3) : h2.input = e3, h2.next_in = 0, h2.avail_in = h2.input.length;
          do {
            if (0 === h2.avail_out && (h2.output = new d2.Buf8(u2), h2.next_out = 0, h2.avail_out = u2), (r3 = c2.inflate(h2, m2.Z_NO_FLUSH)) === m2.Z_NEED_DICT && l3 && (o3 = "string" == typeof l3 ? p2.string2buf(l3) : "[object ArrayBuffer]" === _2.call(l3) ? new Uint8Array(l3) : l3, r3 = c2.inflateSetDictionary(this.strm, o3)), r3 === m2.Z_BUF_ERROR && true === f2 && (r3 = m2.Z_OK, f2 = false), r3 !== m2.Z_STREAM_END && r3 !== m2.Z_OK)
              return this.onEnd(r3), !(this.ended = true);
            h2.next_out && (0 !== h2.avail_out && r3 !== m2.Z_STREAM_END && (0 !== h2.avail_in || n3 !== m2.Z_FINISH && n3 !== m2.Z_SYNC_FLUSH) || ("string" === this.options.to ? (i3 = p2.utf8border(h2.output, h2.next_out), s3 = h2.next_out - i3, a3 = p2.buf2string(h2.output, i3), h2.next_out = s3, h2.avail_out = u2 - s3, s3 && d2.arraySet(h2.output, h2.output, i3, s3, 0), this.onData(a3)) : this.onData(d2.shrinkBuf(h2.output, h2.next_out)))), 0 === h2.avail_in && 0 === h2.avail_out && (f2 = true);
          } while ((0 < h2.avail_in || 0 === h2.avail_out) && r3 !== m2.Z_STREAM_END);
          return r3 === m2.Z_STREAM_END && (n3 = m2.Z_FINISH), n3 === m2.Z_FINISH ? (r3 = c2.inflateEnd(this.strm), this.onEnd(r3), this.ended = true, r3 === m2.Z_OK) : n3 !== m2.Z_SYNC_FLUSH || (this.onEnd(m2.Z_OK), !(h2.avail_out = 0));
        }, a2.prototype.onData = function(e3) {
          this.chunks.push(e3);
        }, a2.prototype.onEnd = function(e3) {
          e3 === m2.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = d2.flattenChunks(this.chunks)), this.chunks = [], this.err = e3, this.msg = this.strm.msg;
        }, r2.Inflate = a2, r2.inflate = o2, r2.inflateRaw = function(e3, t3) {
          return (t3 = t3 || {}).raw = true, o2(e3, t3);
        }, r2.ungzip = o2;
      }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(e2, t2, r2) {
        "use strict";
        var n2 = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
        r2.assign = function(e3) {
          for (var t3 = Array.prototype.slice.call(arguments, 1); t3.length; ) {
            var r3 = t3.shift();
            if (r3) {
              if ("object" != typeof r3)
                throw new TypeError(r3 + "must be non-object");
              for (var n3 in r3)
                r3.hasOwnProperty(n3) && (e3[n3] = r3[n3]);
            }
          }
          return e3;
        }, r2.shrinkBuf = function(e3, t3) {
          return e3.length === t3 ? e3 : e3.subarray ? e3.subarray(0, t3) : (e3.length = t3, e3);
        };
        var i2 = { arraySet: function(e3, t3, r3, n3, i3) {
          if (t3.subarray && e3.subarray)
            e3.set(t3.subarray(r3, r3 + n3), i3);
          else
            for (var s3 = 0; s3 < n3; s3++)
              e3[i3 + s3] = t3[r3 + s3];
        }, flattenChunks: function(e3) {
          var t3, r3, n3, i3, s3, a2;
          for (t3 = n3 = 0, r3 = e3.length; t3 < r3; t3++)
            n3 += e3[t3].length;
          for (a2 = new Uint8Array(n3), t3 = i3 = 0, r3 = e3.length; t3 < r3; t3++)
            s3 = e3[t3], a2.set(s3, i3), i3 += s3.length;
          return a2;
        } }, s2 = { arraySet: function(e3, t3, r3, n3, i3) {
          for (var s3 = 0; s3 < n3; s3++)
            e3[i3 + s3] = t3[r3 + s3];
        }, flattenChunks: function(e3) {
          return [].concat.apply([], e3);
        } };
        r2.setTyped = function(e3) {
          e3 ? (r2.Buf8 = Uint8Array, r2.Buf16 = Uint16Array, r2.Buf32 = Int32Array, r2.assign(r2, i2)) : (r2.Buf8 = Array, r2.Buf16 = Array, r2.Buf32 = Array, r2.assign(r2, s2));
        }, r2.setTyped(n2);
      }, {}], 42: [function(e2, t2, r2) {
        "use strict";
        var h2 = e2("./common"), i2 = true, s2 = true;
        try {
          String.fromCharCode.apply(null, [0]);
        } catch (e3) {
          i2 = false;
        }
        try {
          String.fromCharCode.apply(null, new Uint8Array(1));
        } catch (e3) {
          s2 = false;
        }
        for (var u2 = new h2.Buf8(256), n2 = 0; n2 < 256; n2++)
          u2[n2] = 252 <= n2 ? 6 : 248 <= n2 ? 5 : 240 <= n2 ? 4 : 224 <= n2 ? 3 : 192 <= n2 ? 2 : 1;
        function l3(e3, t3) {
          if (t3 < 65537 && (e3.subarray && s2 || !e3.subarray && i2))
            return String.fromCharCode.apply(null, h2.shrinkBuf(e3, t3));
          for (var r3 = "", n3 = 0; n3 < t3; n3++)
            r3 += String.fromCharCode(e3[n3]);
          return r3;
        }
        __name(l3, "l");
        u2[254] = u2[254] = 1, r2.string2buf = function(e3) {
          var t3, r3, n3, i3, s3, a2 = e3.length, o2 = 0;
          for (i3 = 0; i3 < a2; i3++)
            55296 == (64512 & (r3 = e3.charCodeAt(i3))) && i3 + 1 < a2 && 56320 == (64512 & (n3 = e3.charCodeAt(i3 + 1))) && (r3 = 65536 + (r3 - 55296 << 10) + (n3 - 56320), i3++), o2 += r3 < 128 ? 1 : r3 < 2048 ? 2 : r3 < 65536 ? 3 : 4;
          for (t3 = new h2.Buf8(o2), i3 = s3 = 0; s3 < o2; i3++)
            55296 == (64512 & (r3 = e3.charCodeAt(i3))) && i3 + 1 < a2 && 56320 == (64512 & (n3 = e3.charCodeAt(i3 + 1))) && (r3 = 65536 + (r3 - 55296 << 10) + (n3 - 56320), i3++), r3 < 128 ? t3[s3++] = r3 : (r3 < 2048 ? t3[s3++] = 192 | r3 >>> 6 : (r3 < 65536 ? t3[s3++] = 224 | r3 >>> 12 : (t3[s3++] = 240 | r3 >>> 18, t3[s3++] = 128 | r3 >>> 12 & 63), t3[s3++] = 128 | r3 >>> 6 & 63), t3[s3++] = 128 | 63 & r3);
          return t3;
        }, r2.buf2binstring = function(e3) {
          return l3(e3, e3.length);
        }, r2.binstring2buf = function(e3) {
          for (var t3 = new h2.Buf8(e3.length), r3 = 0, n3 = t3.length; r3 < n3; r3++)
            t3[r3] = e3.charCodeAt(r3);
          return t3;
        }, r2.buf2string = function(e3, t3) {
          var r3, n3, i3, s3, a2 = t3 || e3.length, o2 = new Array(2 * a2);
          for (r3 = n3 = 0; r3 < a2; )
            if ((i3 = e3[r3++]) < 128)
              o2[n3++] = i3;
            else if (4 < (s3 = u2[i3]))
              o2[n3++] = 65533, r3 += s3 - 1;
            else {
              for (i3 &= 2 === s3 ? 31 : 3 === s3 ? 15 : 7; 1 < s3 && r3 < a2; )
                i3 = i3 << 6 | 63 & e3[r3++], s3--;
              1 < s3 ? o2[n3++] = 65533 : i3 < 65536 ? o2[n3++] = i3 : (i3 -= 65536, o2[n3++] = 55296 | i3 >> 10 & 1023, o2[n3++] = 56320 | 1023 & i3);
            }
          return l3(o2, n3);
        }, r2.utf8border = function(e3, t3) {
          var r3;
          for ((t3 = t3 || e3.length) > e3.length && (t3 = e3.length), r3 = t3 - 1; 0 <= r3 && 128 == (192 & e3[r3]); )
            r3--;
          return r3 < 0 ? t3 : 0 === r3 ? t3 : r3 + u2[e3[r3]] > t3 ? r3 : t3;
        };
      }, { "./common": 41 }], 43: [function(e2, t2, r2) {
        "use strict";
        t2.exports = function(e3, t3, r3, n2) {
          for (var i2 = 65535 & e3 | 0, s2 = e3 >>> 16 & 65535 | 0, a2 = 0; 0 !== r3; ) {
            for (r3 -= a2 = 2e3 < r3 ? 2e3 : r3; s2 = s2 + (i2 = i2 + t3[n2++] | 0) | 0, --a2; )
              ;
            i2 %= 65521, s2 %= 65521;
          }
          return i2 | s2 << 16 | 0;
        };
      }, {}], 44: [function(e2, t2, r2) {
        "use strict";
        t2.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
      }, {}], 45: [function(e2, t2, r2) {
        "use strict";
        var o2 = function() {
          for (var e3, t3 = [], r3 = 0; r3 < 256; r3++) {
            e3 = r3;
            for (var n2 = 0; n2 < 8; n2++)
              e3 = 1 & e3 ? 3988292384 ^ e3 >>> 1 : e3 >>> 1;
            t3[r3] = e3;
          }
          return t3;
        }();
        t2.exports = function(e3, t3, r3, n2) {
          var i2 = o2, s2 = n2 + r3;
          e3 ^= -1;
          for (var a2 = n2; a2 < s2; a2++)
            e3 = e3 >>> 8 ^ i2[255 & (e3 ^ t3[a2])];
          return -1 ^ e3;
        };
      }, {}], 46: [function(e2, t2, r2) {
        "use strict";
        var h2, c2 = e2("../utils/common"), u2 = e2("./trees"), d2 = e2("./adler32"), p2 = e2("./crc32"), n2 = e2("./messages"), l3 = 0, f2 = 4, m2 = 0, _2 = -2, g2 = -1, b2 = 4, i2 = 2, v2 = 8, y2 = 9, s2 = 286, a2 = 30, o2 = 19, w2 = 2 * s2 + 1, k2 = 15, x2 = 3, S2 = 258, z2 = S2 + x2 + 1, C2 = 42, E2 = 113, A2 = 1, I2 = 2, O2 = 3, B2 = 4;
        function R2(e3, t3) {
          return e3.msg = n2[t3], t3;
        }
        __name(R2, "R");
        function T2(e3) {
          return (e3 << 1) - (4 < e3 ? 9 : 0);
        }
        __name(T2, "T");
        function D2(e3) {
          for (var t3 = e3.length; 0 <= --t3; )
            e3[t3] = 0;
        }
        __name(D2, "D");
        function F2(e3) {
          var t3 = e3.state, r3 = t3.pending;
          r3 > e3.avail_out && (r3 = e3.avail_out), 0 !== r3 && (c2.arraySet(e3.output, t3.pending_buf, t3.pending_out, r3, e3.next_out), e3.next_out += r3, t3.pending_out += r3, e3.total_out += r3, e3.avail_out -= r3, t3.pending -= r3, 0 === t3.pending && (t3.pending_out = 0));
        }
        __name(F2, "F");
        function N2(e3, t3) {
          u2._tr_flush_block(e3, 0 <= e3.block_start ? e3.block_start : -1, e3.strstart - e3.block_start, t3), e3.block_start = e3.strstart, F2(e3.strm);
        }
        __name(N2, "N");
        function U2(e3, t3) {
          e3.pending_buf[e3.pending++] = t3;
        }
        __name(U2, "U");
        function P2(e3, t3) {
          e3.pending_buf[e3.pending++] = t3 >>> 8 & 255, e3.pending_buf[e3.pending++] = 255 & t3;
        }
        __name(P2, "P");
        function L2(e3, t3) {
          var r3, n3, i3 = e3.max_chain_length, s3 = e3.strstart, a3 = e3.prev_length, o3 = e3.nice_match, h3 = e3.strstart > e3.w_size - z2 ? e3.strstart - (e3.w_size - z2) : 0, u3 = e3.window, l4 = e3.w_mask, f3 = e3.prev, c3 = e3.strstart + S2, d3 = u3[s3 + a3 - 1], p3 = u3[s3 + a3];
          e3.prev_length >= e3.good_match && (i3 >>= 2), o3 > e3.lookahead && (o3 = e3.lookahead);
          do {
            if (u3[(r3 = t3) + a3] === p3 && u3[r3 + a3 - 1] === d3 && u3[r3] === u3[s3] && u3[++r3] === u3[s3 + 1]) {
              s3 += 2, r3++;
              do {
              } while (u3[++s3] === u3[++r3] && u3[++s3] === u3[++r3] && u3[++s3] === u3[++r3] && u3[++s3] === u3[++r3] && u3[++s3] === u3[++r3] && u3[++s3] === u3[++r3] && u3[++s3] === u3[++r3] && u3[++s3] === u3[++r3] && s3 < c3);
              if (n3 = S2 - (c3 - s3), s3 = c3 - S2, a3 < n3) {
                if (e3.match_start = t3, o3 <= (a3 = n3))
                  break;
                d3 = u3[s3 + a3 - 1], p3 = u3[s3 + a3];
              }
            }
          } while ((t3 = f3[t3 & l4]) > h3 && 0 != --i3);
          return a3 <= e3.lookahead ? a3 : e3.lookahead;
        }
        __name(L2, "L");
        function j2(e3) {
          var t3, r3, n3, i3, s3, a3, o3, h3, u3, l4, f3 = e3.w_size;
          do {
            if (i3 = e3.window_size - e3.lookahead - e3.strstart, e3.strstart >= f3 + (f3 - z2)) {
              for (c2.arraySet(e3.window, e3.window, f3, f3, 0), e3.match_start -= f3, e3.strstart -= f3, e3.block_start -= f3, t3 = r3 = e3.hash_size; n3 = e3.head[--t3], e3.head[t3] = f3 <= n3 ? n3 - f3 : 0, --r3; )
                ;
              for (t3 = r3 = f3; n3 = e3.prev[--t3], e3.prev[t3] = f3 <= n3 ? n3 - f3 : 0, --r3; )
                ;
              i3 += f3;
            }
            if (0 === e3.strm.avail_in)
              break;
            if (a3 = e3.strm, o3 = e3.window, h3 = e3.strstart + e3.lookahead, u3 = i3, l4 = void 0, l4 = a3.avail_in, u3 < l4 && (l4 = u3), r3 = 0 === l4 ? 0 : (a3.avail_in -= l4, c2.arraySet(o3, a3.input, a3.next_in, l4, h3), 1 === a3.state.wrap ? a3.adler = d2(a3.adler, o3, l4, h3) : 2 === a3.state.wrap && (a3.adler = p2(a3.adler, o3, l4, h3)), a3.next_in += l4, a3.total_in += l4, l4), e3.lookahead += r3, e3.lookahead + e3.insert >= x2)
              for (s3 = e3.strstart - e3.insert, e3.ins_h = e3.window[s3], e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[s3 + 1]) & e3.hash_mask; e3.insert && (e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[s3 + x2 - 1]) & e3.hash_mask, e3.prev[s3 & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = s3, s3++, e3.insert--, !(e3.lookahead + e3.insert < x2)); )
                ;
          } while (e3.lookahead < z2 && 0 !== e3.strm.avail_in);
        }
        __name(j2, "j");
        function Z2(e3, t3) {
          for (var r3, n3; ; ) {
            if (e3.lookahead < z2) {
              if (j2(e3), e3.lookahead < z2 && t3 === l3)
                return A2;
              if (0 === e3.lookahead)
                break;
            }
            if (r3 = 0, e3.lookahead >= x2 && (e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[e3.strstart + x2 - 1]) & e3.hash_mask, r3 = e3.prev[e3.strstart & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = e3.strstart), 0 !== r3 && e3.strstart - r3 <= e3.w_size - z2 && (e3.match_length = L2(e3, r3)), e3.match_length >= x2)
              if (n3 = u2._tr_tally(e3, e3.strstart - e3.match_start, e3.match_length - x2), e3.lookahead -= e3.match_length, e3.match_length <= e3.max_lazy_match && e3.lookahead >= x2) {
                for (e3.match_length--; e3.strstart++, e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[e3.strstart + x2 - 1]) & e3.hash_mask, r3 = e3.prev[e3.strstart & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = e3.strstart, 0 != --e3.match_length; )
                  ;
                e3.strstart++;
              } else
                e3.strstart += e3.match_length, e3.match_length = 0, e3.ins_h = e3.window[e3.strstart], e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[e3.strstart + 1]) & e3.hash_mask;
            else
              n3 = u2._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++;
            if (n3 && (N2(e3, false), 0 === e3.strm.avail_out))
              return A2;
          }
          return e3.insert = e3.strstart < x2 - 1 ? e3.strstart : x2 - 1, t3 === f2 ? (N2(e3, true), 0 === e3.strm.avail_out ? O2 : B2) : e3.last_lit && (N2(e3, false), 0 === e3.strm.avail_out) ? A2 : I2;
        }
        __name(Z2, "Z");
        function W2(e3, t3) {
          for (var r3, n3, i3; ; ) {
            if (e3.lookahead < z2) {
              if (j2(e3), e3.lookahead < z2 && t3 === l3)
                return A2;
              if (0 === e3.lookahead)
                break;
            }
            if (r3 = 0, e3.lookahead >= x2 && (e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[e3.strstart + x2 - 1]) & e3.hash_mask, r3 = e3.prev[e3.strstart & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = e3.strstart), e3.prev_length = e3.match_length, e3.prev_match = e3.match_start, e3.match_length = x2 - 1, 0 !== r3 && e3.prev_length < e3.max_lazy_match && e3.strstart - r3 <= e3.w_size - z2 && (e3.match_length = L2(e3, r3), e3.match_length <= 5 && (1 === e3.strategy || e3.match_length === x2 && 4096 < e3.strstart - e3.match_start) && (e3.match_length = x2 - 1)), e3.prev_length >= x2 && e3.match_length <= e3.prev_length) {
              for (i3 = e3.strstart + e3.lookahead - x2, n3 = u2._tr_tally(e3, e3.strstart - 1 - e3.prev_match, e3.prev_length - x2), e3.lookahead -= e3.prev_length - 1, e3.prev_length -= 2; ++e3.strstart <= i3 && (e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[e3.strstart + x2 - 1]) & e3.hash_mask, r3 = e3.prev[e3.strstart & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = e3.strstart), 0 != --e3.prev_length; )
                ;
              if (e3.match_available = 0, e3.match_length = x2 - 1, e3.strstart++, n3 && (N2(e3, false), 0 === e3.strm.avail_out))
                return A2;
            } else if (e3.match_available) {
              if ((n3 = u2._tr_tally(e3, 0, e3.window[e3.strstart - 1])) && N2(e3, false), e3.strstart++, e3.lookahead--, 0 === e3.strm.avail_out)
                return A2;
            } else
              e3.match_available = 1, e3.strstart++, e3.lookahead--;
          }
          return e3.match_available && (n3 = u2._tr_tally(e3, 0, e3.window[e3.strstart - 1]), e3.match_available = 0), e3.insert = e3.strstart < x2 - 1 ? e3.strstart : x2 - 1, t3 === f2 ? (N2(e3, true), 0 === e3.strm.avail_out ? O2 : B2) : e3.last_lit && (N2(e3, false), 0 === e3.strm.avail_out) ? A2 : I2;
        }
        __name(W2, "W");
        function M2(e3, t3, r3, n3, i3) {
          this.good_length = e3, this.max_lazy = t3, this.nice_length = r3, this.max_chain = n3, this.func = i3;
        }
        __name(M2, "M");
        function H2() {
          this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = v2, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new c2.Buf16(2 * w2), this.dyn_dtree = new c2.Buf16(2 * (2 * a2 + 1)), this.bl_tree = new c2.Buf16(2 * (2 * o2 + 1)), D2(this.dyn_ltree), D2(this.dyn_dtree), D2(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new c2.Buf16(k2 + 1), this.heap = new c2.Buf16(2 * s2 + 1), D2(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new c2.Buf16(2 * s2 + 1), D2(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
        }
        __name(H2, "H");
        function G2(e3) {
          var t3;
          return e3 && e3.state ? (e3.total_in = e3.total_out = 0, e3.data_type = i2, (t3 = e3.state).pending = 0, t3.pending_out = 0, t3.wrap < 0 && (t3.wrap = -t3.wrap), t3.status = t3.wrap ? C2 : E2, e3.adler = 2 === t3.wrap ? 0 : 1, t3.last_flush = l3, u2._tr_init(t3), m2) : R2(e3, _2);
        }
        __name(G2, "G");
        function K2(e3) {
          var t3 = G2(e3);
          return t3 === m2 && function(e4) {
            e4.window_size = 2 * e4.w_size, D2(e4.head), e4.max_lazy_match = h2[e4.level].max_lazy, e4.good_match = h2[e4.level].good_length, e4.nice_match = h2[e4.level].nice_length, e4.max_chain_length = h2[e4.level].max_chain, e4.strstart = 0, e4.block_start = 0, e4.lookahead = 0, e4.insert = 0, e4.match_length = e4.prev_length = x2 - 1, e4.match_available = 0, e4.ins_h = 0;
          }(e3.state), t3;
        }
        __name(K2, "K");
        function Y2(e3, t3, r3, n3, i3, s3) {
          if (!e3)
            return _2;
          var a3 = 1;
          if (t3 === g2 && (t3 = 6), n3 < 0 ? (a3 = 0, n3 = -n3) : 15 < n3 && (a3 = 2, n3 -= 16), i3 < 1 || y2 < i3 || r3 !== v2 || n3 < 8 || 15 < n3 || t3 < 0 || 9 < t3 || s3 < 0 || b2 < s3)
            return R2(e3, _2);
          8 === n3 && (n3 = 9);
          var o3 = new H2();
          return (e3.state = o3).strm = e3, o3.wrap = a3, o3.gzhead = null, o3.w_bits = n3, o3.w_size = 1 << o3.w_bits, o3.w_mask = o3.w_size - 1, o3.hash_bits = i3 + 7, o3.hash_size = 1 << o3.hash_bits, o3.hash_mask = o3.hash_size - 1, o3.hash_shift = ~~((o3.hash_bits + x2 - 1) / x2), o3.window = new c2.Buf8(2 * o3.w_size), o3.head = new c2.Buf16(o3.hash_size), o3.prev = new c2.Buf16(o3.w_size), o3.lit_bufsize = 1 << i3 + 6, o3.pending_buf_size = 4 * o3.lit_bufsize, o3.pending_buf = new c2.Buf8(o3.pending_buf_size), o3.d_buf = 1 * o3.lit_bufsize, o3.l_buf = 3 * o3.lit_bufsize, o3.level = t3, o3.strategy = s3, o3.method = r3, K2(e3);
        }
        __name(Y2, "Y");
        h2 = [new M2(0, 0, 0, 0, function(e3, t3) {
          var r3 = 65535;
          for (r3 > e3.pending_buf_size - 5 && (r3 = e3.pending_buf_size - 5); ; ) {
            if (e3.lookahead <= 1) {
              if (j2(e3), 0 === e3.lookahead && t3 === l3)
                return A2;
              if (0 === e3.lookahead)
                break;
            }
            e3.strstart += e3.lookahead, e3.lookahead = 0;
            var n3 = e3.block_start + r3;
            if ((0 === e3.strstart || e3.strstart >= n3) && (e3.lookahead = e3.strstart - n3, e3.strstart = n3, N2(e3, false), 0 === e3.strm.avail_out))
              return A2;
            if (e3.strstart - e3.block_start >= e3.w_size - z2 && (N2(e3, false), 0 === e3.strm.avail_out))
              return A2;
          }
          return e3.insert = 0, t3 === f2 ? (N2(e3, true), 0 === e3.strm.avail_out ? O2 : B2) : (e3.strstart > e3.block_start && (N2(e3, false), e3.strm.avail_out), A2);
        }), new M2(4, 4, 8, 4, Z2), new M2(4, 5, 16, 8, Z2), new M2(4, 6, 32, 32, Z2), new M2(4, 4, 16, 16, W2), new M2(8, 16, 32, 32, W2), new M2(8, 16, 128, 128, W2), new M2(8, 32, 128, 256, W2), new M2(32, 128, 258, 1024, W2), new M2(32, 258, 258, 4096, W2)], r2.deflateInit = function(e3, t3) {
          return Y2(e3, t3, v2, 15, 8, 0);
        }, r2.deflateInit2 = Y2, r2.deflateReset = K2, r2.deflateResetKeep = G2, r2.deflateSetHeader = function(e3, t3) {
          return e3 && e3.state ? 2 !== e3.state.wrap ? _2 : (e3.state.gzhead = t3, m2) : _2;
        }, r2.deflate = function(e3, t3) {
          var r3, n3, i3, s3;
          if (!e3 || !e3.state || 5 < t3 || t3 < 0)
            return e3 ? R2(e3, _2) : _2;
          if (n3 = e3.state, !e3.output || !e3.input && 0 !== e3.avail_in || 666 === n3.status && t3 !== f2)
            return R2(e3, 0 === e3.avail_out ? -5 : _2);
          if (n3.strm = e3, r3 = n3.last_flush, n3.last_flush = t3, n3.status === C2)
            if (2 === n3.wrap)
              e3.adler = 0, U2(n3, 31), U2(n3, 139), U2(n3, 8), n3.gzhead ? (U2(n3, (n3.gzhead.text ? 1 : 0) + (n3.gzhead.hcrc ? 2 : 0) + (n3.gzhead.extra ? 4 : 0) + (n3.gzhead.name ? 8 : 0) + (n3.gzhead.comment ? 16 : 0)), U2(n3, 255 & n3.gzhead.time), U2(n3, n3.gzhead.time >> 8 & 255), U2(n3, n3.gzhead.time >> 16 & 255), U2(n3, n3.gzhead.time >> 24 & 255), U2(n3, 9 === n3.level ? 2 : 2 <= n3.strategy || n3.level < 2 ? 4 : 0), U2(n3, 255 & n3.gzhead.os), n3.gzhead.extra && n3.gzhead.extra.length && (U2(n3, 255 & n3.gzhead.extra.length), U2(n3, n3.gzhead.extra.length >> 8 & 255)), n3.gzhead.hcrc && (e3.adler = p2(e3.adler, n3.pending_buf, n3.pending, 0)), n3.gzindex = 0, n3.status = 69) : (U2(n3, 0), U2(n3, 0), U2(n3, 0), U2(n3, 0), U2(n3, 0), U2(n3, 9 === n3.level ? 2 : 2 <= n3.strategy || n3.level < 2 ? 4 : 0), U2(n3, 3), n3.status = E2);
            else {
              var a3 = v2 + (n3.w_bits - 8 << 4) << 8;
              a3 |= (2 <= n3.strategy || n3.level < 2 ? 0 : n3.level < 6 ? 1 : 6 === n3.level ? 2 : 3) << 6, 0 !== n3.strstart && (a3 |= 32), a3 += 31 - a3 % 31, n3.status = E2, P2(n3, a3), 0 !== n3.strstart && (P2(n3, e3.adler >>> 16), P2(n3, 65535 & e3.adler)), e3.adler = 1;
            }
          if (69 === n3.status)
            if (n3.gzhead.extra) {
              for (i3 = n3.pending; n3.gzindex < (65535 & n3.gzhead.extra.length) && (n3.pending !== n3.pending_buf_size || (n3.gzhead.hcrc && n3.pending > i3 && (e3.adler = p2(e3.adler, n3.pending_buf, n3.pending - i3, i3)), F2(e3), i3 = n3.pending, n3.pending !== n3.pending_buf_size)); )
                U2(n3, 255 & n3.gzhead.extra[n3.gzindex]), n3.gzindex++;
              n3.gzhead.hcrc && n3.pending > i3 && (e3.adler = p2(e3.adler, n3.pending_buf, n3.pending - i3, i3)), n3.gzindex === n3.gzhead.extra.length && (n3.gzindex = 0, n3.status = 73);
            } else
              n3.status = 73;
          if (73 === n3.status)
            if (n3.gzhead.name) {
              i3 = n3.pending;
              do {
                if (n3.pending === n3.pending_buf_size && (n3.gzhead.hcrc && n3.pending > i3 && (e3.adler = p2(e3.adler, n3.pending_buf, n3.pending - i3, i3)), F2(e3), i3 = n3.pending, n3.pending === n3.pending_buf_size)) {
                  s3 = 1;
                  break;
                }
                s3 = n3.gzindex < n3.gzhead.name.length ? 255 & n3.gzhead.name.charCodeAt(n3.gzindex++) : 0, U2(n3, s3);
              } while (0 !== s3);
              n3.gzhead.hcrc && n3.pending > i3 && (e3.adler = p2(e3.adler, n3.pending_buf, n3.pending - i3, i3)), 0 === s3 && (n3.gzindex = 0, n3.status = 91);
            } else
              n3.status = 91;
          if (91 === n3.status)
            if (n3.gzhead.comment) {
              i3 = n3.pending;
              do {
                if (n3.pending === n3.pending_buf_size && (n3.gzhead.hcrc && n3.pending > i3 && (e3.adler = p2(e3.adler, n3.pending_buf, n3.pending - i3, i3)), F2(e3), i3 = n3.pending, n3.pending === n3.pending_buf_size)) {
                  s3 = 1;
                  break;
                }
                s3 = n3.gzindex < n3.gzhead.comment.length ? 255 & n3.gzhead.comment.charCodeAt(n3.gzindex++) : 0, U2(n3, s3);
              } while (0 !== s3);
              n3.gzhead.hcrc && n3.pending > i3 && (e3.adler = p2(e3.adler, n3.pending_buf, n3.pending - i3, i3)), 0 === s3 && (n3.status = 103);
            } else
              n3.status = 103;
          if (103 === n3.status && (n3.gzhead.hcrc ? (n3.pending + 2 > n3.pending_buf_size && F2(e3), n3.pending + 2 <= n3.pending_buf_size && (U2(n3, 255 & e3.adler), U2(n3, e3.adler >> 8 & 255), e3.adler = 0, n3.status = E2)) : n3.status = E2), 0 !== n3.pending) {
            if (F2(e3), 0 === e3.avail_out)
              return n3.last_flush = -1, m2;
          } else if (0 === e3.avail_in && T2(t3) <= T2(r3) && t3 !== f2)
            return R2(e3, -5);
          if (666 === n3.status && 0 !== e3.avail_in)
            return R2(e3, -5);
          if (0 !== e3.avail_in || 0 !== n3.lookahead || t3 !== l3 && 666 !== n3.status) {
            var o3 = 2 === n3.strategy ? function(e4, t4) {
              for (var r4; ; ) {
                if (0 === e4.lookahead && (j2(e4), 0 === e4.lookahead)) {
                  if (t4 === l3)
                    return A2;
                  break;
                }
                if (e4.match_length = 0, r4 = u2._tr_tally(e4, 0, e4.window[e4.strstart]), e4.lookahead--, e4.strstart++, r4 && (N2(e4, false), 0 === e4.strm.avail_out))
                  return A2;
              }
              return e4.insert = 0, t4 === f2 ? (N2(e4, true), 0 === e4.strm.avail_out ? O2 : B2) : e4.last_lit && (N2(e4, false), 0 === e4.strm.avail_out) ? A2 : I2;
            }(n3, t3) : 3 === n3.strategy ? function(e4, t4) {
              for (var r4, n4, i4, s4, a4 = e4.window; ; ) {
                if (e4.lookahead <= S2) {
                  if (j2(e4), e4.lookahead <= S2 && t4 === l3)
                    return A2;
                  if (0 === e4.lookahead)
                    break;
                }
                if (e4.match_length = 0, e4.lookahead >= x2 && 0 < e4.strstart && (n4 = a4[i4 = e4.strstart - 1]) === a4[++i4] && n4 === a4[++i4] && n4 === a4[++i4]) {
                  s4 = e4.strstart + S2;
                  do {
                  } while (n4 === a4[++i4] && n4 === a4[++i4] && n4 === a4[++i4] && n4 === a4[++i4] && n4 === a4[++i4] && n4 === a4[++i4] && n4 === a4[++i4] && n4 === a4[++i4] && i4 < s4);
                  e4.match_length = S2 - (s4 - i4), e4.match_length > e4.lookahead && (e4.match_length = e4.lookahead);
                }
                if (e4.match_length >= x2 ? (r4 = u2._tr_tally(e4, 1, e4.match_length - x2), e4.lookahead -= e4.match_length, e4.strstart += e4.match_length, e4.match_length = 0) : (r4 = u2._tr_tally(e4, 0, e4.window[e4.strstart]), e4.lookahead--, e4.strstart++), r4 && (N2(e4, false), 0 === e4.strm.avail_out))
                  return A2;
              }
              return e4.insert = 0, t4 === f2 ? (N2(e4, true), 0 === e4.strm.avail_out ? O2 : B2) : e4.last_lit && (N2(e4, false), 0 === e4.strm.avail_out) ? A2 : I2;
            }(n3, t3) : h2[n3.level].func(n3, t3);
            if (o3 !== O2 && o3 !== B2 || (n3.status = 666), o3 === A2 || o3 === O2)
              return 0 === e3.avail_out && (n3.last_flush = -1), m2;
            if (o3 === I2 && (1 === t3 ? u2._tr_align(n3) : 5 !== t3 && (u2._tr_stored_block(n3, 0, 0, false), 3 === t3 && (D2(n3.head), 0 === n3.lookahead && (n3.strstart = 0, n3.block_start = 0, n3.insert = 0))), F2(e3), 0 === e3.avail_out))
              return n3.last_flush = -1, m2;
          }
          return t3 !== f2 ? m2 : n3.wrap <= 0 ? 1 : (2 === n3.wrap ? (U2(n3, 255 & e3.adler), U2(n3, e3.adler >> 8 & 255), U2(n3, e3.adler >> 16 & 255), U2(n3, e3.adler >> 24 & 255), U2(n3, 255 & e3.total_in), U2(n3, e3.total_in >> 8 & 255), U2(n3, e3.total_in >> 16 & 255), U2(n3, e3.total_in >> 24 & 255)) : (P2(n3, e3.adler >>> 16), P2(n3, 65535 & e3.adler)), F2(e3), 0 < n3.wrap && (n3.wrap = -n3.wrap), 0 !== n3.pending ? m2 : 1);
        }, r2.deflateEnd = function(e3) {
          var t3;
          return e3 && e3.state ? (t3 = e3.state.status) !== C2 && 69 !== t3 && 73 !== t3 && 91 !== t3 && 103 !== t3 && t3 !== E2 && 666 !== t3 ? R2(e3, _2) : (e3.state = null, t3 === E2 ? R2(e3, -3) : m2) : _2;
        }, r2.deflateSetDictionary = function(e3, t3) {
          var r3, n3, i3, s3, a3, o3, h3, u3, l4 = t3.length;
          if (!e3 || !e3.state)
            return _2;
          if (2 === (s3 = (r3 = e3.state).wrap) || 1 === s3 && r3.status !== C2 || r3.lookahead)
            return _2;
          for (1 === s3 && (e3.adler = d2(e3.adler, t3, l4, 0)), r3.wrap = 0, l4 >= r3.w_size && (0 === s3 && (D2(r3.head), r3.strstart = 0, r3.block_start = 0, r3.insert = 0), u3 = new c2.Buf8(r3.w_size), c2.arraySet(u3, t3, l4 - r3.w_size, r3.w_size, 0), t3 = u3, l4 = r3.w_size), a3 = e3.avail_in, o3 = e3.next_in, h3 = e3.input, e3.avail_in = l4, e3.next_in = 0, e3.input = t3, j2(r3); r3.lookahead >= x2; ) {
            for (n3 = r3.strstart, i3 = r3.lookahead - (x2 - 1); r3.ins_h = (r3.ins_h << r3.hash_shift ^ r3.window[n3 + x2 - 1]) & r3.hash_mask, r3.prev[n3 & r3.w_mask] = r3.head[r3.ins_h], r3.head[r3.ins_h] = n3, n3++, --i3; )
              ;
            r3.strstart = n3, r3.lookahead = x2 - 1, j2(r3);
          }
          return r3.strstart += r3.lookahead, r3.block_start = r3.strstart, r3.insert = r3.lookahead, r3.lookahead = 0, r3.match_length = r3.prev_length = x2 - 1, r3.match_available = 0, e3.next_in = o3, e3.input = h3, e3.avail_in = a3, r3.wrap = s3, m2;
        }, r2.deflateInfo = "pako deflate (from Nodeca project)";
      }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(e2, t2, r2) {
        "use strict";
        t2.exports = function() {
          this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
        };
      }, {}], 48: [function(e2, t2, r2) {
        "use strict";
        t2.exports = function(e3, t3) {
          var r3, n2, i2, s2, a2, o2, h2, u2, l3, f2, c2, d2, p2, m2, _2, g2, b2, v2, y2, w2, k2, x2, S2, z2, C2;
          r3 = e3.state, n2 = e3.next_in, z2 = e3.input, i2 = n2 + (e3.avail_in - 5), s2 = e3.next_out, C2 = e3.output, a2 = s2 - (t3 - e3.avail_out), o2 = s2 + (e3.avail_out - 257), h2 = r3.dmax, u2 = r3.wsize, l3 = r3.whave, f2 = r3.wnext, c2 = r3.window, d2 = r3.hold, p2 = r3.bits, m2 = r3.lencode, _2 = r3.distcode, g2 = (1 << r3.lenbits) - 1, b2 = (1 << r3.distbits) - 1;
          e:
            do {
              p2 < 15 && (d2 += z2[n2++] << p2, p2 += 8, d2 += z2[n2++] << p2, p2 += 8), v2 = m2[d2 & g2];
              t:
                for (; ; ) {
                  if (d2 >>>= y2 = v2 >>> 24, p2 -= y2, 0 === (y2 = v2 >>> 16 & 255))
                    C2[s2++] = 65535 & v2;
                  else {
                    if (!(16 & y2)) {
                      if (0 == (64 & y2)) {
                        v2 = m2[(65535 & v2) + (d2 & (1 << y2) - 1)];
                        continue t;
                      }
                      if (32 & y2) {
                        r3.mode = 12;
                        break e;
                      }
                      e3.msg = "invalid literal/length code", r3.mode = 30;
                      break e;
                    }
                    w2 = 65535 & v2, (y2 &= 15) && (p2 < y2 && (d2 += z2[n2++] << p2, p2 += 8), w2 += d2 & (1 << y2) - 1, d2 >>>= y2, p2 -= y2), p2 < 15 && (d2 += z2[n2++] << p2, p2 += 8, d2 += z2[n2++] << p2, p2 += 8), v2 = _2[d2 & b2];
                    r:
                      for (; ; ) {
                        if (d2 >>>= y2 = v2 >>> 24, p2 -= y2, !(16 & (y2 = v2 >>> 16 & 255))) {
                          if (0 == (64 & y2)) {
                            v2 = _2[(65535 & v2) + (d2 & (1 << y2) - 1)];
                            continue r;
                          }
                          e3.msg = "invalid distance code", r3.mode = 30;
                          break e;
                        }
                        if (k2 = 65535 & v2, p2 < (y2 &= 15) && (d2 += z2[n2++] << p2, (p2 += 8) < y2 && (d2 += z2[n2++] << p2, p2 += 8)), h2 < (k2 += d2 & (1 << y2) - 1)) {
                          e3.msg = "invalid distance too far back", r3.mode = 30;
                          break e;
                        }
                        if (d2 >>>= y2, p2 -= y2, (y2 = s2 - a2) < k2) {
                          if (l3 < (y2 = k2 - y2) && r3.sane) {
                            e3.msg = "invalid distance too far back", r3.mode = 30;
                            break e;
                          }
                          if (S2 = c2, (x2 = 0) === f2) {
                            if (x2 += u2 - y2, y2 < w2) {
                              for (w2 -= y2; C2[s2++] = c2[x2++], --y2; )
                                ;
                              x2 = s2 - k2, S2 = C2;
                            }
                          } else if (f2 < y2) {
                            if (x2 += u2 + f2 - y2, (y2 -= f2) < w2) {
                              for (w2 -= y2; C2[s2++] = c2[x2++], --y2; )
                                ;
                              if (x2 = 0, f2 < w2) {
                                for (w2 -= y2 = f2; C2[s2++] = c2[x2++], --y2; )
                                  ;
                                x2 = s2 - k2, S2 = C2;
                              }
                            }
                          } else if (x2 += f2 - y2, y2 < w2) {
                            for (w2 -= y2; C2[s2++] = c2[x2++], --y2; )
                              ;
                            x2 = s2 - k2, S2 = C2;
                          }
                          for (; 2 < w2; )
                            C2[s2++] = S2[x2++], C2[s2++] = S2[x2++], C2[s2++] = S2[x2++], w2 -= 3;
                          w2 && (C2[s2++] = S2[x2++], 1 < w2 && (C2[s2++] = S2[x2++]));
                        } else {
                          for (x2 = s2 - k2; C2[s2++] = C2[x2++], C2[s2++] = C2[x2++], C2[s2++] = C2[x2++], 2 < (w2 -= 3); )
                            ;
                          w2 && (C2[s2++] = C2[x2++], 1 < w2 && (C2[s2++] = C2[x2++]));
                        }
                        break;
                      }
                  }
                  break;
                }
            } while (n2 < i2 && s2 < o2);
          n2 -= w2 = p2 >> 3, d2 &= (1 << (p2 -= w2 << 3)) - 1, e3.next_in = n2, e3.next_out = s2, e3.avail_in = n2 < i2 ? i2 - n2 + 5 : 5 - (n2 - i2), e3.avail_out = s2 < o2 ? o2 - s2 + 257 : 257 - (s2 - o2), r3.hold = d2, r3.bits = p2;
        };
      }, {}], 49: [function(e2, t2, r2) {
        "use strict";
        var I2 = e2("../utils/common"), O2 = e2("./adler32"), B2 = e2("./crc32"), R2 = e2("./inffast"), T2 = e2("./inftrees"), D2 = 1, F2 = 2, N2 = 0, U2 = -2, P2 = 1, n2 = 852, i2 = 592;
        function L2(e3) {
          return (e3 >>> 24 & 255) + (e3 >>> 8 & 65280) + ((65280 & e3) << 8) + ((255 & e3) << 24);
        }
        __name(L2, "L");
        function s2() {
          this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new I2.Buf16(320), this.work = new I2.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
        }
        __name(s2, "s");
        function a2(e3) {
          var t3;
          return e3 && e3.state ? (t3 = e3.state, e3.total_in = e3.total_out = t3.total = 0, e3.msg = "", t3.wrap && (e3.adler = 1 & t3.wrap), t3.mode = P2, t3.last = 0, t3.havedict = 0, t3.dmax = 32768, t3.head = null, t3.hold = 0, t3.bits = 0, t3.lencode = t3.lendyn = new I2.Buf32(n2), t3.distcode = t3.distdyn = new I2.Buf32(i2), t3.sane = 1, t3.back = -1, N2) : U2;
        }
        __name(a2, "a");
        function o2(e3) {
          var t3;
          return e3 && e3.state ? ((t3 = e3.state).wsize = 0, t3.whave = 0, t3.wnext = 0, a2(e3)) : U2;
        }
        __name(o2, "o");
        function h2(e3, t3) {
          var r3, n3;
          return e3 && e3.state ? (n3 = e3.state, t3 < 0 ? (r3 = 0, t3 = -t3) : (r3 = 1 + (t3 >> 4), t3 < 48 && (t3 &= 15)), t3 && (t3 < 8 || 15 < t3) ? U2 : (null !== n3.window && n3.wbits !== t3 && (n3.window = null), n3.wrap = r3, n3.wbits = t3, o2(e3))) : U2;
        }
        __name(h2, "h");
        function u2(e3, t3) {
          var r3, n3;
          return e3 ? (n3 = new s2(), (e3.state = n3).window = null, (r3 = h2(e3, t3)) !== N2 && (e3.state = null), r3) : U2;
        }
        __name(u2, "u");
        var l3, f2, c2 = true;
        function j2(e3) {
          if (c2) {
            var t3;
            for (l3 = new I2.Buf32(512), f2 = new I2.Buf32(32), t3 = 0; t3 < 144; )
              e3.lens[t3++] = 8;
            for (; t3 < 256; )
              e3.lens[t3++] = 9;
            for (; t3 < 280; )
              e3.lens[t3++] = 7;
            for (; t3 < 288; )
              e3.lens[t3++] = 8;
            for (T2(D2, e3.lens, 0, 288, l3, 0, e3.work, { bits: 9 }), t3 = 0; t3 < 32; )
              e3.lens[t3++] = 5;
            T2(F2, e3.lens, 0, 32, f2, 0, e3.work, { bits: 5 }), c2 = false;
          }
          e3.lencode = l3, e3.lenbits = 9, e3.distcode = f2, e3.distbits = 5;
        }
        __name(j2, "j");
        function Z2(e3, t3, r3, n3) {
          var i3, s3 = e3.state;
          return null === s3.window && (s3.wsize = 1 << s3.wbits, s3.wnext = 0, s3.whave = 0, s3.window = new I2.Buf8(s3.wsize)), n3 >= s3.wsize ? (I2.arraySet(s3.window, t3, r3 - s3.wsize, s3.wsize, 0), s3.wnext = 0, s3.whave = s3.wsize) : (n3 < (i3 = s3.wsize - s3.wnext) && (i3 = n3), I2.arraySet(s3.window, t3, r3 - n3, i3, s3.wnext), (n3 -= i3) ? (I2.arraySet(s3.window, t3, r3 - n3, n3, 0), s3.wnext = n3, s3.whave = s3.wsize) : (s3.wnext += i3, s3.wnext === s3.wsize && (s3.wnext = 0), s3.whave < s3.wsize && (s3.whave += i3))), 0;
        }
        __name(Z2, "Z");
        r2.inflateReset = o2, r2.inflateReset2 = h2, r2.inflateResetKeep = a2, r2.inflateInit = function(e3) {
          return u2(e3, 15);
        }, r2.inflateInit2 = u2, r2.inflate = function(e3, t3) {
          var r3, n3, i3, s3, a3, o3, h3, u3, l4, f3, c3, d2, p2, m2, _2, g2, b2, v2, y2, w2, k2, x2, S2, z2, C2 = 0, E2 = new I2.Buf8(4), A2 = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
          if (!e3 || !e3.state || !e3.output || !e3.input && 0 !== e3.avail_in)
            return U2;
          12 === (r3 = e3.state).mode && (r3.mode = 13), a3 = e3.next_out, i3 = e3.output, h3 = e3.avail_out, s3 = e3.next_in, n3 = e3.input, o3 = e3.avail_in, u3 = r3.hold, l4 = r3.bits, f3 = o3, c3 = h3, x2 = N2;
          e:
            for (; ; )
              switch (r3.mode) {
                case P2:
                  if (0 === r3.wrap) {
                    r3.mode = 13;
                    break;
                  }
                  for (; l4 < 16; ) {
                    if (0 === o3)
                      break e;
                    o3--, u3 += n3[s3++] << l4, l4 += 8;
                  }
                  if (2 & r3.wrap && 35615 === u3) {
                    E2[r3.check = 0] = 255 & u3, E2[1] = u3 >>> 8 & 255, r3.check = B2(r3.check, E2, 2, 0), l4 = u3 = 0, r3.mode = 2;
                    break;
                  }
                  if (r3.flags = 0, r3.head && (r3.head.done = false), !(1 & r3.wrap) || (((255 & u3) << 8) + (u3 >> 8)) % 31) {
                    e3.msg = "incorrect header check", r3.mode = 30;
                    break;
                  }
                  if (8 != (15 & u3)) {
                    e3.msg = "unknown compression method", r3.mode = 30;
                    break;
                  }
                  if (l4 -= 4, k2 = 8 + (15 & (u3 >>>= 4)), 0 === r3.wbits)
                    r3.wbits = k2;
                  else if (k2 > r3.wbits) {
                    e3.msg = "invalid window size", r3.mode = 30;
                    break;
                  }
                  r3.dmax = 1 << k2, e3.adler = r3.check = 1, r3.mode = 512 & u3 ? 10 : 12, l4 = u3 = 0;
                  break;
                case 2:
                  for (; l4 < 16; ) {
                    if (0 === o3)
                      break e;
                    o3--, u3 += n3[s3++] << l4, l4 += 8;
                  }
                  if (r3.flags = u3, 8 != (255 & r3.flags)) {
                    e3.msg = "unknown compression method", r3.mode = 30;
                    break;
                  }
                  if (57344 & r3.flags) {
                    e3.msg = "unknown header flags set", r3.mode = 30;
                    break;
                  }
                  r3.head && (r3.head.text = u3 >> 8 & 1), 512 & r3.flags && (E2[0] = 255 & u3, E2[1] = u3 >>> 8 & 255, r3.check = B2(r3.check, E2, 2, 0)), l4 = u3 = 0, r3.mode = 3;
                case 3:
                  for (; l4 < 32; ) {
                    if (0 === o3)
                      break e;
                    o3--, u3 += n3[s3++] << l4, l4 += 8;
                  }
                  r3.head && (r3.head.time = u3), 512 & r3.flags && (E2[0] = 255 & u3, E2[1] = u3 >>> 8 & 255, E2[2] = u3 >>> 16 & 255, E2[3] = u3 >>> 24 & 255, r3.check = B2(r3.check, E2, 4, 0)), l4 = u3 = 0, r3.mode = 4;
                case 4:
                  for (; l4 < 16; ) {
                    if (0 === o3)
                      break e;
                    o3--, u3 += n3[s3++] << l4, l4 += 8;
                  }
                  r3.head && (r3.head.xflags = 255 & u3, r3.head.os = u3 >> 8), 512 & r3.flags && (E2[0] = 255 & u3, E2[1] = u3 >>> 8 & 255, r3.check = B2(r3.check, E2, 2, 0)), l4 = u3 = 0, r3.mode = 5;
                case 5:
                  if (1024 & r3.flags) {
                    for (; l4 < 16; ) {
                      if (0 === o3)
                        break e;
                      o3--, u3 += n3[s3++] << l4, l4 += 8;
                    }
                    r3.length = u3, r3.head && (r3.head.extra_len = u3), 512 & r3.flags && (E2[0] = 255 & u3, E2[1] = u3 >>> 8 & 255, r3.check = B2(r3.check, E2, 2, 0)), l4 = u3 = 0;
                  } else
                    r3.head && (r3.head.extra = null);
                  r3.mode = 6;
                case 6:
                  if (1024 & r3.flags && (o3 < (d2 = r3.length) && (d2 = o3), d2 && (r3.head && (k2 = r3.head.extra_len - r3.length, r3.head.extra || (r3.head.extra = new Array(r3.head.extra_len)), I2.arraySet(r3.head.extra, n3, s3, d2, k2)), 512 & r3.flags && (r3.check = B2(r3.check, n3, d2, s3)), o3 -= d2, s3 += d2, r3.length -= d2), r3.length))
                    break e;
                  r3.length = 0, r3.mode = 7;
                case 7:
                  if (2048 & r3.flags) {
                    if (0 === o3)
                      break e;
                    for (d2 = 0; k2 = n3[s3 + d2++], r3.head && k2 && r3.length < 65536 && (r3.head.name += String.fromCharCode(k2)), k2 && d2 < o3; )
                      ;
                    if (512 & r3.flags && (r3.check = B2(r3.check, n3, d2, s3)), o3 -= d2, s3 += d2, k2)
                      break e;
                  } else
                    r3.head && (r3.head.name = null);
                  r3.length = 0, r3.mode = 8;
                case 8:
                  if (4096 & r3.flags) {
                    if (0 === o3)
                      break e;
                    for (d2 = 0; k2 = n3[s3 + d2++], r3.head && k2 && r3.length < 65536 && (r3.head.comment += String.fromCharCode(k2)), k2 && d2 < o3; )
                      ;
                    if (512 & r3.flags && (r3.check = B2(r3.check, n3, d2, s3)), o3 -= d2, s3 += d2, k2)
                      break e;
                  } else
                    r3.head && (r3.head.comment = null);
                  r3.mode = 9;
                case 9:
                  if (512 & r3.flags) {
                    for (; l4 < 16; ) {
                      if (0 === o3)
                        break e;
                      o3--, u3 += n3[s3++] << l4, l4 += 8;
                    }
                    if (u3 !== (65535 & r3.check)) {
                      e3.msg = "header crc mismatch", r3.mode = 30;
                      break;
                    }
                    l4 = u3 = 0;
                  }
                  r3.head && (r3.head.hcrc = r3.flags >> 9 & 1, r3.head.done = true), e3.adler = r3.check = 0, r3.mode = 12;
                  break;
                case 10:
                  for (; l4 < 32; ) {
                    if (0 === o3)
                      break e;
                    o3--, u3 += n3[s3++] << l4, l4 += 8;
                  }
                  e3.adler = r3.check = L2(u3), l4 = u3 = 0, r3.mode = 11;
                case 11:
                  if (0 === r3.havedict)
                    return e3.next_out = a3, e3.avail_out = h3, e3.next_in = s3, e3.avail_in = o3, r3.hold = u3, r3.bits = l4, 2;
                  e3.adler = r3.check = 1, r3.mode = 12;
                case 12:
                  if (5 === t3 || 6 === t3)
                    break e;
                case 13:
                  if (r3.last) {
                    u3 >>>= 7 & l4, l4 -= 7 & l4, r3.mode = 27;
                    break;
                  }
                  for (; l4 < 3; ) {
                    if (0 === o3)
                      break e;
                    o3--, u3 += n3[s3++] << l4, l4 += 8;
                  }
                  switch (r3.last = 1 & u3, l4 -= 1, 3 & (u3 >>>= 1)) {
                    case 0:
                      r3.mode = 14;
                      break;
                    case 1:
                      if (j2(r3), r3.mode = 20, 6 !== t3)
                        break;
                      u3 >>>= 2, l4 -= 2;
                      break e;
                    case 2:
                      r3.mode = 17;
                      break;
                    case 3:
                      e3.msg = "invalid block type", r3.mode = 30;
                  }
                  u3 >>>= 2, l4 -= 2;
                  break;
                case 14:
                  for (u3 >>>= 7 & l4, l4 -= 7 & l4; l4 < 32; ) {
                    if (0 === o3)
                      break e;
                    o3--, u3 += n3[s3++] << l4, l4 += 8;
                  }
                  if ((65535 & u3) != (u3 >>> 16 ^ 65535)) {
                    e3.msg = "invalid stored block lengths", r3.mode = 30;
                    break;
                  }
                  if (r3.length = 65535 & u3, l4 = u3 = 0, r3.mode = 15, 6 === t3)
                    break e;
                case 15:
                  r3.mode = 16;
                case 16:
                  if (d2 = r3.length) {
                    if (o3 < d2 && (d2 = o3), h3 < d2 && (d2 = h3), 0 === d2)
                      break e;
                    I2.arraySet(i3, n3, s3, d2, a3), o3 -= d2, s3 += d2, h3 -= d2, a3 += d2, r3.length -= d2;
                    break;
                  }
                  r3.mode = 12;
                  break;
                case 17:
                  for (; l4 < 14; ) {
                    if (0 === o3)
                      break e;
                    o3--, u3 += n3[s3++] << l4, l4 += 8;
                  }
                  if (r3.nlen = 257 + (31 & u3), u3 >>>= 5, l4 -= 5, r3.ndist = 1 + (31 & u3), u3 >>>= 5, l4 -= 5, r3.ncode = 4 + (15 & u3), u3 >>>= 4, l4 -= 4, 286 < r3.nlen || 30 < r3.ndist) {
                    e3.msg = "too many length or distance symbols", r3.mode = 30;
                    break;
                  }
                  r3.have = 0, r3.mode = 18;
                case 18:
                  for (; r3.have < r3.ncode; ) {
                    for (; l4 < 3; ) {
                      if (0 === o3)
                        break e;
                      o3--, u3 += n3[s3++] << l4, l4 += 8;
                    }
                    r3.lens[A2[r3.have++]] = 7 & u3, u3 >>>= 3, l4 -= 3;
                  }
                  for (; r3.have < 19; )
                    r3.lens[A2[r3.have++]] = 0;
                  if (r3.lencode = r3.lendyn, r3.lenbits = 7, S2 = { bits: r3.lenbits }, x2 = T2(0, r3.lens, 0, 19, r3.lencode, 0, r3.work, S2), r3.lenbits = S2.bits, x2) {
                    e3.msg = "invalid code lengths set", r3.mode = 30;
                    break;
                  }
                  r3.have = 0, r3.mode = 19;
                case 19:
                  for (; r3.have < r3.nlen + r3.ndist; ) {
                    for (; g2 = (C2 = r3.lencode[u3 & (1 << r3.lenbits) - 1]) >>> 16 & 255, b2 = 65535 & C2, !((_2 = C2 >>> 24) <= l4); ) {
                      if (0 === o3)
                        break e;
                      o3--, u3 += n3[s3++] << l4, l4 += 8;
                    }
                    if (b2 < 16)
                      u3 >>>= _2, l4 -= _2, r3.lens[r3.have++] = b2;
                    else {
                      if (16 === b2) {
                        for (z2 = _2 + 2; l4 < z2; ) {
                          if (0 === o3)
                            break e;
                          o3--, u3 += n3[s3++] << l4, l4 += 8;
                        }
                        if (u3 >>>= _2, l4 -= _2, 0 === r3.have) {
                          e3.msg = "invalid bit length repeat", r3.mode = 30;
                          break;
                        }
                        k2 = r3.lens[r3.have - 1], d2 = 3 + (3 & u3), u3 >>>= 2, l4 -= 2;
                      } else if (17 === b2) {
                        for (z2 = _2 + 3; l4 < z2; ) {
                          if (0 === o3)
                            break e;
                          o3--, u3 += n3[s3++] << l4, l4 += 8;
                        }
                        l4 -= _2, k2 = 0, d2 = 3 + (7 & (u3 >>>= _2)), u3 >>>= 3, l4 -= 3;
                      } else {
                        for (z2 = _2 + 7; l4 < z2; ) {
                          if (0 === o3)
                            break e;
                          o3--, u3 += n3[s3++] << l4, l4 += 8;
                        }
                        l4 -= _2, k2 = 0, d2 = 11 + (127 & (u3 >>>= _2)), u3 >>>= 7, l4 -= 7;
                      }
                      if (r3.have + d2 > r3.nlen + r3.ndist) {
                        e3.msg = "invalid bit length repeat", r3.mode = 30;
                        break;
                      }
                      for (; d2--; )
                        r3.lens[r3.have++] = k2;
                    }
                  }
                  if (30 === r3.mode)
                    break;
                  if (0 === r3.lens[256]) {
                    e3.msg = "invalid code -- missing end-of-block", r3.mode = 30;
                    break;
                  }
                  if (r3.lenbits = 9, S2 = { bits: r3.lenbits }, x2 = T2(D2, r3.lens, 0, r3.nlen, r3.lencode, 0, r3.work, S2), r3.lenbits = S2.bits, x2) {
                    e3.msg = "invalid literal/lengths set", r3.mode = 30;
                    break;
                  }
                  if (r3.distbits = 6, r3.distcode = r3.distdyn, S2 = { bits: r3.distbits }, x2 = T2(F2, r3.lens, r3.nlen, r3.ndist, r3.distcode, 0, r3.work, S2), r3.distbits = S2.bits, x2) {
                    e3.msg = "invalid distances set", r3.mode = 30;
                    break;
                  }
                  if (r3.mode = 20, 6 === t3)
                    break e;
                case 20:
                  r3.mode = 21;
                case 21:
                  if (6 <= o3 && 258 <= h3) {
                    e3.next_out = a3, e3.avail_out = h3, e3.next_in = s3, e3.avail_in = o3, r3.hold = u3, r3.bits = l4, R2(e3, c3), a3 = e3.next_out, i3 = e3.output, h3 = e3.avail_out, s3 = e3.next_in, n3 = e3.input, o3 = e3.avail_in, u3 = r3.hold, l4 = r3.bits, 12 === r3.mode && (r3.back = -1);
                    break;
                  }
                  for (r3.back = 0; g2 = (C2 = r3.lencode[u3 & (1 << r3.lenbits) - 1]) >>> 16 & 255, b2 = 65535 & C2, !((_2 = C2 >>> 24) <= l4); ) {
                    if (0 === o3)
                      break e;
                    o3--, u3 += n3[s3++] << l4, l4 += 8;
                  }
                  if (g2 && 0 == (240 & g2)) {
                    for (v2 = _2, y2 = g2, w2 = b2; g2 = (C2 = r3.lencode[w2 + ((u3 & (1 << v2 + y2) - 1) >> v2)]) >>> 16 & 255, b2 = 65535 & C2, !(v2 + (_2 = C2 >>> 24) <= l4); ) {
                      if (0 === o3)
                        break e;
                      o3--, u3 += n3[s3++] << l4, l4 += 8;
                    }
                    u3 >>>= v2, l4 -= v2, r3.back += v2;
                  }
                  if (u3 >>>= _2, l4 -= _2, r3.back += _2, r3.length = b2, 0 === g2) {
                    r3.mode = 26;
                    break;
                  }
                  if (32 & g2) {
                    r3.back = -1, r3.mode = 12;
                    break;
                  }
                  if (64 & g2) {
                    e3.msg = "invalid literal/length code", r3.mode = 30;
                    break;
                  }
                  r3.extra = 15 & g2, r3.mode = 22;
                case 22:
                  if (r3.extra) {
                    for (z2 = r3.extra; l4 < z2; ) {
                      if (0 === o3)
                        break e;
                      o3--, u3 += n3[s3++] << l4, l4 += 8;
                    }
                    r3.length += u3 & (1 << r3.extra) - 1, u3 >>>= r3.extra, l4 -= r3.extra, r3.back += r3.extra;
                  }
                  r3.was = r3.length, r3.mode = 23;
                case 23:
                  for (; g2 = (C2 = r3.distcode[u3 & (1 << r3.distbits) - 1]) >>> 16 & 255, b2 = 65535 & C2, !((_2 = C2 >>> 24) <= l4); ) {
                    if (0 === o3)
                      break e;
                    o3--, u3 += n3[s3++] << l4, l4 += 8;
                  }
                  if (0 == (240 & g2)) {
                    for (v2 = _2, y2 = g2, w2 = b2; g2 = (C2 = r3.distcode[w2 + ((u3 & (1 << v2 + y2) - 1) >> v2)]) >>> 16 & 255, b2 = 65535 & C2, !(v2 + (_2 = C2 >>> 24) <= l4); ) {
                      if (0 === o3)
                        break e;
                      o3--, u3 += n3[s3++] << l4, l4 += 8;
                    }
                    u3 >>>= v2, l4 -= v2, r3.back += v2;
                  }
                  if (u3 >>>= _2, l4 -= _2, r3.back += _2, 64 & g2) {
                    e3.msg = "invalid distance code", r3.mode = 30;
                    break;
                  }
                  r3.offset = b2, r3.extra = 15 & g2, r3.mode = 24;
                case 24:
                  if (r3.extra) {
                    for (z2 = r3.extra; l4 < z2; ) {
                      if (0 === o3)
                        break e;
                      o3--, u3 += n3[s3++] << l4, l4 += 8;
                    }
                    r3.offset += u3 & (1 << r3.extra) - 1, u3 >>>= r3.extra, l4 -= r3.extra, r3.back += r3.extra;
                  }
                  if (r3.offset > r3.dmax) {
                    e3.msg = "invalid distance too far back", r3.mode = 30;
                    break;
                  }
                  r3.mode = 25;
                case 25:
                  if (0 === h3)
                    break e;
                  if (d2 = c3 - h3, r3.offset > d2) {
                    if ((d2 = r3.offset - d2) > r3.whave && r3.sane) {
                      e3.msg = "invalid distance too far back", r3.mode = 30;
                      break;
                    }
                    p2 = d2 > r3.wnext ? (d2 -= r3.wnext, r3.wsize - d2) : r3.wnext - d2, d2 > r3.length && (d2 = r3.length), m2 = r3.window;
                  } else
                    m2 = i3, p2 = a3 - r3.offset, d2 = r3.length;
                  for (h3 < d2 && (d2 = h3), h3 -= d2, r3.length -= d2; i3[a3++] = m2[p2++], --d2; )
                    ;
                  0 === r3.length && (r3.mode = 21);
                  break;
                case 26:
                  if (0 === h3)
                    break e;
                  i3[a3++] = r3.length, h3--, r3.mode = 21;
                  break;
                case 27:
                  if (r3.wrap) {
                    for (; l4 < 32; ) {
                      if (0 === o3)
                        break e;
                      o3--, u3 |= n3[s3++] << l4, l4 += 8;
                    }
                    if (c3 -= h3, e3.total_out += c3, r3.total += c3, c3 && (e3.adler = r3.check = r3.flags ? B2(r3.check, i3, c3, a3 - c3) : O2(r3.check, i3, c3, a3 - c3)), c3 = h3, (r3.flags ? u3 : L2(u3)) !== r3.check) {
                      e3.msg = "incorrect data check", r3.mode = 30;
                      break;
                    }
                    l4 = u3 = 0;
                  }
                  r3.mode = 28;
                case 28:
                  if (r3.wrap && r3.flags) {
                    for (; l4 < 32; ) {
                      if (0 === o3)
                        break e;
                      o3--, u3 += n3[s3++] << l4, l4 += 8;
                    }
                    if (u3 !== (4294967295 & r3.total)) {
                      e3.msg = "incorrect length check", r3.mode = 30;
                      break;
                    }
                    l4 = u3 = 0;
                  }
                  r3.mode = 29;
                case 29:
                  x2 = 1;
                  break e;
                case 30:
                  x2 = -3;
                  break e;
                case 31:
                  return -4;
                case 32:
                default:
                  return U2;
              }
          return e3.next_out = a3, e3.avail_out = h3, e3.next_in = s3, e3.avail_in = o3, r3.hold = u3, r3.bits = l4, (r3.wsize || c3 !== e3.avail_out && r3.mode < 30 && (r3.mode < 27 || 4 !== t3)) && Z2(e3, e3.output, e3.next_out, c3 - e3.avail_out) ? (r3.mode = 31, -4) : (f3 -= e3.avail_in, c3 -= e3.avail_out, e3.total_in += f3, e3.total_out += c3, r3.total += c3, r3.wrap && c3 && (e3.adler = r3.check = r3.flags ? B2(r3.check, i3, c3, e3.next_out - c3) : O2(r3.check, i3, c3, e3.next_out - c3)), e3.data_type = r3.bits + (r3.last ? 64 : 0) + (12 === r3.mode ? 128 : 0) + (20 === r3.mode || 15 === r3.mode ? 256 : 0), (0 == f3 && 0 === c3 || 4 === t3) && x2 === N2 && (x2 = -5), x2);
        }, r2.inflateEnd = function(e3) {
          if (!e3 || !e3.state)
            return U2;
          var t3 = e3.state;
          return t3.window && (t3.window = null), e3.state = null, N2;
        }, r2.inflateGetHeader = function(e3, t3) {
          var r3;
          return e3 && e3.state ? 0 == (2 & (r3 = e3.state).wrap) ? U2 : ((r3.head = t3).done = false, N2) : U2;
        }, r2.inflateSetDictionary = function(e3, t3) {
          var r3, n3 = t3.length;
          return e3 && e3.state ? 0 !== (r3 = e3.state).wrap && 11 !== r3.mode ? U2 : 11 === r3.mode && O2(1, t3, n3, 0) !== r3.check ? -3 : Z2(e3, t3, n3, n3) ? (r3.mode = 31, -4) : (r3.havedict = 1, N2) : U2;
        }, r2.inflateInfo = "pako inflate (from Nodeca project)";
      }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(e2, t2, r2) {
        "use strict";
        var D2 = e2("../utils/common"), F2 = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], N2 = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], U2 = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], P2 = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
        t2.exports = function(e3, t3, r3, n2, i2, s2, a2, o2) {
          var h2, u2, l3, f2, c2, d2, p2, m2, _2, g2 = o2.bits, b2 = 0, v2 = 0, y2 = 0, w2 = 0, k2 = 0, x2 = 0, S2 = 0, z2 = 0, C2 = 0, E2 = 0, A2 = null, I2 = 0, O2 = new D2.Buf16(16), B2 = new D2.Buf16(16), R2 = null, T2 = 0;
          for (b2 = 0; b2 <= 15; b2++)
            O2[b2] = 0;
          for (v2 = 0; v2 < n2; v2++)
            O2[t3[r3 + v2]]++;
          for (k2 = g2, w2 = 15; 1 <= w2 && 0 === O2[w2]; w2--)
            ;
          if (w2 < k2 && (k2 = w2), 0 === w2)
            return i2[s2++] = 20971520, i2[s2++] = 20971520, o2.bits = 1, 0;
          for (y2 = 1; y2 < w2 && 0 === O2[y2]; y2++)
            ;
          for (k2 < y2 && (k2 = y2), b2 = z2 = 1; b2 <= 15; b2++)
            if (z2 <<= 1, (z2 -= O2[b2]) < 0)
              return -1;
          if (0 < z2 && (0 === e3 || 1 !== w2))
            return -1;
          for (B2[1] = 0, b2 = 1; b2 < 15; b2++)
            B2[b2 + 1] = B2[b2] + O2[b2];
          for (v2 = 0; v2 < n2; v2++)
            0 !== t3[r3 + v2] && (a2[B2[t3[r3 + v2]]++] = v2);
          if (d2 = 0 === e3 ? (A2 = R2 = a2, 19) : 1 === e3 ? (A2 = F2, I2 -= 257, R2 = N2, T2 -= 257, 256) : (A2 = U2, R2 = P2, -1), b2 = y2, c2 = s2, S2 = v2 = E2 = 0, l3 = -1, f2 = (C2 = 1 << (x2 = k2)) - 1, 1 === e3 && 852 < C2 || 2 === e3 && 592 < C2)
            return 1;
          for (; ; ) {
            for (p2 = b2 - S2, _2 = a2[v2] < d2 ? (m2 = 0, a2[v2]) : a2[v2] > d2 ? (m2 = R2[T2 + a2[v2]], A2[I2 + a2[v2]]) : (m2 = 96, 0), h2 = 1 << b2 - S2, y2 = u2 = 1 << x2; i2[c2 + (E2 >> S2) + (u2 -= h2)] = p2 << 24 | m2 << 16 | _2 | 0, 0 !== u2; )
              ;
            for (h2 = 1 << b2 - 1; E2 & h2; )
              h2 >>= 1;
            if (0 !== h2 ? (E2 &= h2 - 1, E2 += h2) : E2 = 0, v2++, 0 == --O2[b2]) {
              if (b2 === w2)
                break;
              b2 = t3[r3 + a2[v2]];
            }
            if (k2 < b2 && (E2 & f2) !== l3) {
              for (0 === S2 && (S2 = k2), c2 += y2, z2 = 1 << (x2 = b2 - S2); x2 + S2 < w2 && !((z2 -= O2[x2 + S2]) <= 0); )
                x2++, z2 <<= 1;
              if (C2 += 1 << x2, 1 === e3 && 852 < C2 || 2 === e3 && 592 < C2)
                return 1;
              i2[l3 = E2 & f2] = k2 << 24 | x2 << 16 | c2 - s2 | 0;
            }
          }
          return 0 !== E2 && (i2[c2 + E2] = b2 - S2 << 24 | 64 << 16 | 0), o2.bits = k2, 0;
        };
      }, { "../utils/common": 41 }], 51: [function(e2, t2, r2) {
        "use strict";
        t2.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
      }, {}], 52: [function(e2, t2, r2) {
        "use strict";
        var i2 = e2("../utils/common"), o2 = 0, h2 = 1;
        function n2(e3) {
          for (var t3 = e3.length; 0 <= --t3; )
            e3[t3] = 0;
        }
        __name(n2, "n");
        var s2 = 0, a2 = 29, u2 = 256, l3 = u2 + 1 + a2, f2 = 30, c2 = 19, _2 = 2 * l3 + 1, g2 = 15, d2 = 16, p2 = 7, m2 = 256, b2 = 16, v2 = 17, y2 = 18, w2 = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], k2 = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], x2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], S2 = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], z2 = new Array(2 * (l3 + 2));
        n2(z2);
        var C2 = new Array(2 * f2);
        n2(C2);
        var E2 = new Array(512);
        n2(E2);
        var A2 = new Array(256);
        n2(A2);
        var I2 = new Array(a2);
        n2(I2);
        var O2, B2, R2, T2 = new Array(f2);
        function D2(e3, t3, r3, n3, i3) {
          this.static_tree = e3, this.extra_bits = t3, this.extra_base = r3, this.elems = n3, this.max_length = i3, this.has_stree = e3 && e3.length;
        }
        __name(D2, "D");
        function F2(e3, t3) {
          this.dyn_tree = e3, this.max_code = 0, this.stat_desc = t3;
        }
        __name(F2, "F");
        function N2(e3) {
          return e3 < 256 ? E2[e3] : E2[256 + (e3 >>> 7)];
        }
        __name(N2, "N");
        function U2(e3, t3) {
          e3.pending_buf[e3.pending++] = 255 & t3, e3.pending_buf[e3.pending++] = t3 >>> 8 & 255;
        }
        __name(U2, "U");
        function P2(e3, t3, r3) {
          e3.bi_valid > d2 - r3 ? (e3.bi_buf |= t3 << e3.bi_valid & 65535, U2(e3, e3.bi_buf), e3.bi_buf = t3 >> d2 - e3.bi_valid, e3.bi_valid += r3 - d2) : (e3.bi_buf |= t3 << e3.bi_valid & 65535, e3.bi_valid += r3);
        }
        __name(P2, "P");
        function L2(e3, t3, r3) {
          P2(e3, r3[2 * t3], r3[2 * t3 + 1]);
        }
        __name(L2, "L");
        function j2(e3, t3) {
          for (var r3 = 0; r3 |= 1 & e3, e3 >>>= 1, r3 <<= 1, 0 < --t3; )
            ;
          return r3 >>> 1;
        }
        __name(j2, "j");
        function Z2(e3, t3, r3) {
          var n3, i3, s3 = new Array(g2 + 1), a3 = 0;
          for (n3 = 1; n3 <= g2; n3++)
            s3[n3] = a3 = a3 + r3[n3 - 1] << 1;
          for (i3 = 0; i3 <= t3; i3++) {
            var o3 = e3[2 * i3 + 1];
            0 !== o3 && (e3[2 * i3] = j2(s3[o3]++, o3));
          }
        }
        __name(Z2, "Z");
        function W2(e3) {
          var t3;
          for (t3 = 0; t3 < l3; t3++)
            e3.dyn_ltree[2 * t3] = 0;
          for (t3 = 0; t3 < f2; t3++)
            e3.dyn_dtree[2 * t3] = 0;
          for (t3 = 0; t3 < c2; t3++)
            e3.bl_tree[2 * t3] = 0;
          e3.dyn_ltree[2 * m2] = 1, e3.opt_len = e3.static_len = 0, e3.last_lit = e3.matches = 0;
        }
        __name(W2, "W");
        function M2(e3) {
          8 < e3.bi_valid ? U2(e3, e3.bi_buf) : 0 < e3.bi_valid && (e3.pending_buf[e3.pending++] = e3.bi_buf), e3.bi_buf = 0, e3.bi_valid = 0;
        }
        __name(M2, "M");
        function H2(e3, t3, r3, n3) {
          var i3 = 2 * t3, s3 = 2 * r3;
          return e3[i3] < e3[s3] || e3[i3] === e3[s3] && n3[t3] <= n3[r3];
        }
        __name(H2, "H");
        function G2(e3, t3, r3) {
          for (var n3 = e3.heap[r3], i3 = r3 << 1; i3 <= e3.heap_len && (i3 < e3.heap_len && H2(t3, e3.heap[i3 + 1], e3.heap[i3], e3.depth) && i3++, !H2(t3, n3, e3.heap[i3], e3.depth)); )
            e3.heap[r3] = e3.heap[i3], r3 = i3, i3 <<= 1;
          e3.heap[r3] = n3;
        }
        __name(G2, "G");
        function K2(e3, t3, r3) {
          var n3, i3, s3, a3, o3 = 0;
          if (0 !== e3.last_lit)
            for (; n3 = e3.pending_buf[e3.d_buf + 2 * o3] << 8 | e3.pending_buf[e3.d_buf + 2 * o3 + 1], i3 = e3.pending_buf[e3.l_buf + o3], o3++, 0 === n3 ? L2(e3, i3, t3) : (L2(e3, (s3 = A2[i3]) + u2 + 1, t3), 0 !== (a3 = w2[s3]) && P2(e3, i3 -= I2[s3], a3), L2(e3, s3 = N2(--n3), r3), 0 !== (a3 = k2[s3]) && P2(e3, n3 -= T2[s3], a3)), o3 < e3.last_lit; )
              ;
          L2(e3, m2, t3);
        }
        __name(K2, "K");
        function Y2(e3, t3) {
          var r3, n3, i3, s3 = t3.dyn_tree, a3 = t3.stat_desc.static_tree, o3 = t3.stat_desc.has_stree, h3 = t3.stat_desc.elems, u3 = -1;
          for (e3.heap_len = 0, e3.heap_max = _2, r3 = 0; r3 < h3; r3++)
            0 !== s3[2 * r3] ? (e3.heap[++e3.heap_len] = u3 = r3, e3.depth[r3] = 0) : s3[2 * r3 + 1] = 0;
          for (; e3.heap_len < 2; )
            s3[2 * (i3 = e3.heap[++e3.heap_len] = u3 < 2 ? ++u3 : 0)] = 1, e3.depth[i3] = 0, e3.opt_len--, o3 && (e3.static_len -= a3[2 * i3 + 1]);
          for (t3.max_code = u3, r3 = e3.heap_len >> 1; 1 <= r3; r3--)
            G2(e3, s3, r3);
          for (i3 = h3; r3 = e3.heap[1], e3.heap[1] = e3.heap[e3.heap_len--], G2(e3, s3, 1), n3 = e3.heap[1], e3.heap[--e3.heap_max] = r3, e3.heap[--e3.heap_max] = n3, s3[2 * i3] = s3[2 * r3] + s3[2 * n3], e3.depth[i3] = (e3.depth[r3] >= e3.depth[n3] ? e3.depth[r3] : e3.depth[n3]) + 1, s3[2 * r3 + 1] = s3[2 * n3 + 1] = i3, e3.heap[1] = i3++, G2(e3, s3, 1), 2 <= e3.heap_len; )
            ;
          e3.heap[--e3.heap_max] = e3.heap[1], function(e4, t4) {
            var r4, n4, i4, s4, a4, o4, h4 = t4.dyn_tree, u4 = t4.max_code, l4 = t4.stat_desc.static_tree, f3 = t4.stat_desc.has_stree, c3 = t4.stat_desc.extra_bits, d3 = t4.stat_desc.extra_base, p3 = t4.stat_desc.max_length, m3 = 0;
            for (s4 = 0; s4 <= g2; s4++)
              e4.bl_count[s4] = 0;
            for (h4[2 * e4.heap[e4.heap_max] + 1] = 0, r4 = e4.heap_max + 1; r4 < _2; r4++)
              p3 < (s4 = h4[2 * h4[2 * (n4 = e4.heap[r4]) + 1] + 1] + 1) && (s4 = p3, m3++), h4[2 * n4 + 1] = s4, u4 < n4 || (e4.bl_count[s4]++, a4 = 0, d3 <= n4 && (a4 = c3[n4 - d3]), o4 = h4[2 * n4], e4.opt_len += o4 * (s4 + a4), f3 && (e4.static_len += o4 * (l4[2 * n4 + 1] + a4)));
            if (0 !== m3) {
              do {
                for (s4 = p3 - 1; 0 === e4.bl_count[s4]; )
                  s4--;
                e4.bl_count[s4]--, e4.bl_count[s4 + 1] += 2, e4.bl_count[p3]--, m3 -= 2;
              } while (0 < m3);
              for (s4 = p3; 0 !== s4; s4--)
                for (n4 = e4.bl_count[s4]; 0 !== n4; )
                  u4 < (i4 = e4.heap[--r4]) || (h4[2 * i4 + 1] !== s4 && (e4.opt_len += (s4 - h4[2 * i4 + 1]) * h4[2 * i4], h4[2 * i4 + 1] = s4), n4--);
            }
          }(e3, t3), Z2(s3, u3, e3.bl_count);
        }
        __name(Y2, "Y");
        function X2(e3, t3, r3) {
          var n3, i3, s3 = -1, a3 = t3[1], o3 = 0, h3 = 7, u3 = 4;
          for (0 === a3 && (h3 = 138, u3 = 3), t3[2 * (r3 + 1) + 1] = 65535, n3 = 0; n3 <= r3; n3++)
            i3 = a3, a3 = t3[2 * (n3 + 1) + 1], ++o3 < h3 && i3 === a3 || (o3 < u3 ? e3.bl_tree[2 * i3] += o3 : 0 !== i3 ? (i3 !== s3 && e3.bl_tree[2 * i3]++, e3.bl_tree[2 * b2]++) : o3 <= 10 ? e3.bl_tree[2 * v2]++ : e3.bl_tree[2 * y2]++, s3 = i3, u3 = (o3 = 0) === a3 ? (h3 = 138, 3) : i3 === a3 ? (h3 = 6, 3) : (h3 = 7, 4));
        }
        __name(X2, "X");
        function V2(e3, t3, r3) {
          var n3, i3, s3 = -1, a3 = t3[1], o3 = 0, h3 = 7, u3 = 4;
          for (0 === a3 && (h3 = 138, u3 = 3), n3 = 0; n3 <= r3; n3++)
            if (i3 = a3, a3 = t3[2 * (n3 + 1) + 1], !(++o3 < h3 && i3 === a3)) {
              if (o3 < u3)
                for (; L2(e3, i3, e3.bl_tree), 0 != --o3; )
                  ;
              else
                0 !== i3 ? (i3 !== s3 && (L2(e3, i3, e3.bl_tree), o3--), L2(e3, b2, e3.bl_tree), P2(e3, o3 - 3, 2)) : o3 <= 10 ? (L2(e3, v2, e3.bl_tree), P2(e3, o3 - 3, 3)) : (L2(e3, y2, e3.bl_tree), P2(e3, o3 - 11, 7));
              s3 = i3, u3 = (o3 = 0) === a3 ? (h3 = 138, 3) : i3 === a3 ? (h3 = 6, 3) : (h3 = 7, 4);
            }
        }
        __name(V2, "V");
        n2(T2);
        var q2 = false;
        function J2(e3, t3, r3, n3) {
          P2(e3, (s2 << 1) + (n3 ? 1 : 0), 3), function(e4, t4, r4, n4) {
            M2(e4), n4 && (U2(e4, r4), U2(e4, ~r4)), i2.arraySet(e4.pending_buf, e4.window, t4, r4, e4.pending), e4.pending += r4;
          }(e3, t3, r3, true);
        }
        __name(J2, "J");
        r2._tr_init = function(e3) {
          q2 || (function() {
            var e4, t3, r3, n3, i3, s3 = new Array(g2 + 1);
            for (n3 = r3 = 0; n3 < a2 - 1; n3++)
              for (I2[n3] = r3, e4 = 0; e4 < 1 << w2[n3]; e4++)
                A2[r3++] = n3;
            for (A2[r3 - 1] = n3, n3 = i3 = 0; n3 < 16; n3++)
              for (T2[n3] = i3, e4 = 0; e4 < 1 << k2[n3]; e4++)
                E2[i3++] = n3;
            for (i3 >>= 7; n3 < f2; n3++)
              for (T2[n3] = i3 << 7, e4 = 0; e4 < 1 << k2[n3] - 7; e4++)
                E2[256 + i3++] = n3;
            for (t3 = 0; t3 <= g2; t3++)
              s3[t3] = 0;
            for (e4 = 0; e4 <= 143; )
              z2[2 * e4 + 1] = 8, e4++, s3[8]++;
            for (; e4 <= 255; )
              z2[2 * e4 + 1] = 9, e4++, s3[9]++;
            for (; e4 <= 279; )
              z2[2 * e4 + 1] = 7, e4++, s3[7]++;
            for (; e4 <= 287; )
              z2[2 * e4 + 1] = 8, e4++, s3[8]++;
            for (Z2(z2, l3 + 1, s3), e4 = 0; e4 < f2; e4++)
              C2[2 * e4 + 1] = 5, C2[2 * e4] = j2(e4, 5);
            O2 = new D2(z2, w2, u2 + 1, l3, g2), B2 = new D2(C2, k2, 0, f2, g2), R2 = new D2(new Array(0), x2, 0, c2, p2);
          }(), q2 = true), e3.l_desc = new F2(e3.dyn_ltree, O2), e3.d_desc = new F2(e3.dyn_dtree, B2), e3.bl_desc = new F2(e3.bl_tree, R2), e3.bi_buf = 0, e3.bi_valid = 0, W2(e3);
        }, r2._tr_stored_block = J2, r2._tr_flush_block = function(e3, t3, r3, n3) {
          var i3, s3, a3 = 0;
          0 < e3.level ? (2 === e3.strm.data_type && (e3.strm.data_type = function(e4) {
            var t4, r4 = 4093624447;
            for (t4 = 0; t4 <= 31; t4++, r4 >>>= 1)
              if (1 & r4 && 0 !== e4.dyn_ltree[2 * t4])
                return o2;
            if (0 !== e4.dyn_ltree[18] || 0 !== e4.dyn_ltree[20] || 0 !== e4.dyn_ltree[26])
              return h2;
            for (t4 = 32; t4 < u2; t4++)
              if (0 !== e4.dyn_ltree[2 * t4])
                return h2;
            return o2;
          }(e3)), Y2(e3, e3.l_desc), Y2(e3, e3.d_desc), a3 = function(e4) {
            var t4;
            for (X2(e4, e4.dyn_ltree, e4.l_desc.max_code), X2(e4, e4.dyn_dtree, e4.d_desc.max_code), Y2(e4, e4.bl_desc), t4 = c2 - 1; 3 <= t4 && 0 === e4.bl_tree[2 * S2[t4] + 1]; t4--)
              ;
            return e4.opt_len += 3 * (t4 + 1) + 5 + 5 + 4, t4;
          }(e3), i3 = e3.opt_len + 3 + 7 >>> 3, (s3 = e3.static_len + 3 + 7 >>> 3) <= i3 && (i3 = s3)) : i3 = s3 = r3 + 5, r3 + 4 <= i3 && -1 !== t3 ? J2(e3, t3, r3, n3) : 4 === e3.strategy || s3 === i3 ? (P2(e3, 2 + (n3 ? 1 : 0), 3), K2(e3, z2, C2)) : (P2(e3, 4 + (n3 ? 1 : 0), 3), function(e4, t4, r4, n4) {
            var i4;
            for (P2(e4, t4 - 257, 5), P2(e4, r4 - 1, 5), P2(e4, n4 - 4, 4), i4 = 0; i4 < n4; i4++)
              P2(e4, e4.bl_tree[2 * S2[i4] + 1], 3);
            V2(e4, e4.dyn_ltree, t4 - 1), V2(e4, e4.dyn_dtree, r4 - 1);
          }(e3, e3.l_desc.max_code + 1, e3.d_desc.max_code + 1, a3 + 1), K2(e3, e3.dyn_ltree, e3.dyn_dtree)), W2(e3), n3 && M2(e3);
        }, r2._tr_tally = function(e3, t3, r3) {
          return e3.pending_buf[e3.d_buf + 2 * e3.last_lit] = t3 >>> 8 & 255, e3.pending_buf[e3.d_buf + 2 * e3.last_lit + 1] = 255 & t3, e3.pending_buf[e3.l_buf + e3.last_lit] = 255 & r3, e3.last_lit++, 0 === t3 ? e3.dyn_ltree[2 * r3]++ : (e3.matches++, t3--, e3.dyn_ltree[2 * (A2[r3] + u2 + 1)]++, e3.dyn_dtree[2 * N2(t3)]++), e3.last_lit === e3.lit_bufsize - 1;
        }, r2._tr_align = function(e3) {
          P2(e3, 2, 3), L2(e3, m2, z2), function(e4) {
            16 === e4.bi_valid ? (U2(e4, e4.bi_buf), e4.bi_buf = 0, e4.bi_valid = 0) : 8 <= e4.bi_valid && (e4.pending_buf[e4.pending++] = 255 & e4.bi_buf, e4.bi_buf >>= 8, e4.bi_valid -= 8);
          }(e3);
        };
      }, { "../utils/common": 41 }], 53: [function(e2, t2, r2) {
        "use strict";
        t2.exports = function() {
          this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
        };
      }, {}], 54: [function(e2, t2, r2) {
        (function(e3) {
          !function(r3, n2) {
            "use strict";
            if (!r3.setImmediate) {
              var i2, s2, t3, a2, o2 = 1, h2 = {}, u2 = false, l3 = r3.document, e4 = Object.getPrototypeOf && Object.getPrototypeOf(r3);
              e4 = e4 && e4.setTimeout ? e4 : r3, i2 = "[object process]" === {}.toString.call(r3.process) ? function(e5) {
                process.nextTick(function() {
                  c2(e5);
                });
              } : function() {
                if (r3.postMessage && !r3.importScripts) {
                  var e5 = true, t4 = r3.onmessage;
                  return r3.onmessage = function() {
                    e5 = false;
                  }, r3.postMessage("", "*"), r3.onmessage = t4, e5;
                }
              }() ? (a2 = "setImmediate$" + Math.random() + "$", r3.addEventListener ? r3.addEventListener("message", d2, false) : r3.attachEvent("onmessage", d2), function(e5) {
                r3.postMessage(a2 + e5, "*");
              }) : r3.MessageChannel ? ((t3 = new MessageChannel()).port1.onmessage = function(e5) {
                c2(e5.data);
              }, function(e5) {
                t3.port2.postMessage(e5);
              }) : l3 && "onreadystatechange" in l3.createElement("script") ? (s2 = l3.documentElement, function(e5) {
                var t4 = l3.createElement("script");
                t4.onreadystatechange = function() {
                  c2(e5), t4.onreadystatechange = null, s2.removeChild(t4), t4 = null;
                }, s2.appendChild(t4);
              }) : function(e5) {
                setTimeout(c2, 0, e5);
              }, e4.setImmediate = function(e5) {
                "function" != typeof e5 && (e5 = new Function("" + e5));
                for (var t4 = new Array(arguments.length - 1), r4 = 0; r4 < t4.length; r4++)
                  t4[r4] = arguments[r4 + 1];
                var n3 = { callback: e5, args: t4 };
                return h2[o2] = n3, i2(o2), o2++;
              }, e4.clearImmediate = f2;
            }
            function f2(e5) {
              delete h2[e5];
            }
            __name(f2, "f");
            function c2(e5) {
              if (u2)
                setTimeout(c2, 0, e5);
              else {
                var t4 = h2[e5];
                if (t4) {
                  u2 = true;
                  try {
                    !function(e6) {
                      var t5 = e6.callback, r4 = e6.args;
                      switch (r4.length) {
                        case 0:
                          t5();
                          break;
                        case 1:
                          t5(r4[0]);
                          break;
                        case 2:
                          t5(r4[0], r4[1]);
                          break;
                        case 3:
                          t5(r4[0], r4[1], r4[2]);
                          break;
                        default:
                          t5.apply(n2, r4);
                      }
                    }(t4);
                  } finally {
                    f2(e5), u2 = false;
                  }
                }
              }
            }
            __name(c2, "c");
            function d2(e5) {
              e5.source === r3 && "string" == typeof e5.data && 0 === e5.data.indexOf(a2) && c2(+e5.data.slice(a2.length));
            }
            __name(d2, "d");
          }("undefined" == typeof self ? void 0 === e3 ? this : e3 : self);
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, {}] }, {}, [10])(10);
    });
  }
});

// node_modules/mammoth/lib/zipfile.js
var require_zipfile = __commonJS({
  "node_modules/mammoth/lib/zipfile.js"(exports2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var base64js = require_base64_js();
    var JSZip = require_jszip_min();
    exports2.openArrayBuffer = openArrayBuffer;
    exports2.splitPath = splitPath;
    exports2.joinPath = joinPath;
    function openArrayBuffer(arrayBuffer) {
      return JSZip.loadAsync(arrayBuffer).then(function(zipFile) {
        function exists(name) {
          return zipFile.file(name) !== null;
        }
        __name(exists, "exists");
        function read(name, encoding) {
          return zipFile.file(name).async("uint8array").then(function(array) {
            if (encoding === "base64") {
              return base64js.fromByteArray(array);
            } else if (encoding) {
              var decoder = new TextDecoder(encoding);
              return decoder.decode(array);
            } else {
              return array;
            }
          });
        }
        __name(read, "read");
        function write(name, contents) {
          zipFile.file(name, contents);
        }
        __name(write, "write");
        function toArrayBuffer() {
          return zipFile.generateAsync({ type: "arraybuffer" });
        }
        __name(toArrayBuffer, "toArrayBuffer");
        return {
          exists,
          read,
          write,
          toArrayBuffer
        };
      });
    }
    __name(openArrayBuffer, "openArrayBuffer");
    function splitPath(path) {
      var lastIndex = path.lastIndexOf("/");
      if (lastIndex === -1) {
        return { dirname: "", basename: path };
      } else {
        return {
          dirname: path.substring(0, lastIndex),
          basename: path.substring(lastIndex + 1)
        };
      }
    }
    __name(splitPath, "splitPath");
    function joinPath() {
      var nonEmptyPaths = Array.prototype.filter.call(arguments, function(path) {
        return path;
      });
      var relevantPaths = [];
      nonEmptyPaths.forEach(function(path) {
        if (/^\//.test(path)) {
          relevantPaths = [path];
        } else {
          relevantPaths.push(path);
        }
      });
      return relevantPaths.join("/");
    }
    __name(joinPath, "joinPath");
  }
});

// node_modules/mammoth/lib/xml/nodes.js
var require_nodes = __commonJS({
  "node_modules/mammoth/lib/xml/nodes.js"(exports2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var _2 = require_underscore_umd();
    exports2.Element = Element;
    exports2.element = function(name, attributes, children) {
      return new Element(name, attributes, children);
    };
    exports2.text = function(value) {
      return {
        type: "text",
        value
      };
    };
    var emptyElement = exports2.emptyElement = {
      first: function() {
        return null;
      },
      firstOrEmpty: function() {
        return emptyElement;
      },
      attributes: {},
      children: []
    };
    function Element(name, attributes, children) {
      this.type = "element";
      this.name = name;
      this.attributes = attributes || {};
      this.children = children || [];
    }
    __name(Element, "Element");
    Element.prototype.first = function(name) {
      return _2.find(this.children, function(child) {
        return child.name === name;
      });
    };
    Element.prototype.firstOrEmpty = function(name) {
      return this.first(name) || emptyElement;
    };
    Element.prototype.getElementsByTagName = function(name) {
      var elements = _2.filter(this.children, function(child) {
        return child.name === name;
      });
      return toElementList(elements);
    };
    Element.prototype.text = function() {
      if (this.children.length === 0) {
        return "";
      } else if (this.children.length !== 1 || this.children[0].type !== "text") {
        throw new Error("Not implemented");
      }
      return this.children[0].value;
    };
    var elementListPrototype = {
      getElementsByTagName: function(name) {
        return toElementList(_2.flatten(this.map(function(element) {
          return element.getElementsByTagName(name);
        }, true)));
      }
    };
    function toElementList(array) {
      return _2.extend(array, elementListPrototype);
    }
    __name(toElementList, "toElementList");
  }
});

// node_modules/@xmldom/xmldom/lib/conventions.js
var require_conventions = __commonJS({
  "node_modules/@xmldom/xmldom/lib/conventions.js"(exports2) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function find2(list, predicate, ac2) {
      if (ac2 === void 0) {
        ac2 = Array.prototype;
      }
      if (list && typeof ac2.find === "function") {
        return ac2.find.call(list, predicate);
      }
      for (var i2 = 0; i2 < list.length; i2++) {
        if (Object.prototype.hasOwnProperty.call(list, i2)) {
          var item = list[i2];
          if (predicate.call(void 0, item, i2, list)) {
            return item;
          }
        }
      }
    }
    __name(find2, "find");
    function freeze(object, oc2) {
      if (oc2 === void 0) {
        oc2 = Object;
      }
      return oc2 && typeof oc2.freeze === "function" ? oc2.freeze(object) : object;
    }
    __name(freeze, "freeze");
    function assign(target, source) {
      if (target === null || typeof target !== "object") {
        throw new TypeError("target is not an object");
      }
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
      return target;
    }
    __name(assign, "assign");
    var MIME_TYPE = freeze({
      /**
       * `text/html`, the only mime type that triggers treating an XML document as HTML.
       *
       * @see DOMParser.SupportedType.isHTML
       * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
       * @see https://en.wikipedia.org/wiki/HTML Wikipedia
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
       * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring WHATWG HTML Spec
       */
      HTML: "text/html",
      /**
       * Helper method to check a mime type if it indicates an HTML document
       *
       * @param {string} [value]
       * @returns {boolean}
       *
       * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
       * @see https://en.wikipedia.org/wiki/HTML Wikipedia
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
       * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring 	 */
      isHTML: function(value) {
        return value === MIME_TYPE.HTML;
      },
      /**
       * `application/xml`, the standard mime type for XML documents.
       *
       * @see https://www.iana.org/assignments/media-types/application/xml IANA MimeType registration
       * @see https://tools.ietf.org/html/rfc7303#section-9.1 RFC 7303
       * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
       */
      XML_APPLICATION: "application/xml",
      /**
       * `text/html`, an alias for `application/xml`.
       *
       * @see https://tools.ietf.org/html/rfc7303#section-9.2 RFC 7303
       * @see https://www.iana.org/assignments/media-types/text/xml IANA MimeType registration
       * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
       */
      XML_TEXT: "text/xml",
      /**
       * `application/xhtml+xml`, indicates an XML document that has the default HTML namespace,
       * but is parsed as an XML document.
       *
       * @see https://www.iana.org/assignments/media-types/application/xhtml+xml IANA MimeType registration
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument WHATWG DOM Spec
       * @see https://en.wikipedia.org/wiki/XHTML Wikipedia
       */
      XML_XHTML_APPLICATION: "application/xhtml+xml",
      /**
       * `image/svg+xml`,
       *
       * @see https://www.iana.org/assignments/media-types/image/svg+xml IANA MimeType registration
       * @see https://www.w3.org/TR/SVG11/ W3C SVG 1.1
       * @see https://en.wikipedia.org/wiki/Scalable_Vector_Graphics Wikipedia
       */
      XML_SVG_IMAGE: "image/svg+xml"
    });
    var NAMESPACE = freeze({
      /**
       * The XHTML namespace.
       *
       * @see http://www.w3.org/1999/xhtml
       */
      HTML: "http://www.w3.org/1999/xhtml",
      /**
       * Checks if `uri` equals `NAMESPACE.HTML`.
       *
       * @param {string} [uri]
       *
       * @see NAMESPACE.HTML
       */
      isHTML: function(uri) {
        return uri === NAMESPACE.HTML;
      },
      /**
       * The SVG namespace.
       *
       * @see http://www.w3.org/2000/svg
       */
      SVG: "http://www.w3.org/2000/svg",
      /**
       * The `xml:` namespace.
       *
       * @see http://www.w3.org/XML/1998/namespace
       */
      XML: "http://www.w3.org/XML/1998/namespace",
      /**
       * The `xmlns:` namespace
       *
       * @see https://www.w3.org/2000/xmlns/
       */
      XMLNS: "http://www.w3.org/2000/xmlns/"
    });
    exports2.assign = assign;
    exports2.find = find2;
    exports2.freeze = freeze;
    exports2.MIME_TYPE = MIME_TYPE;
    exports2.NAMESPACE = NAMESPACE;
  }
});

// node_modules/@xmldom/xmldom/lib/dom.js
var require_dom = __commonJS({
  "node_modules/@xmldom/xmldom/lib/dom.js"(exports2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var conventions = require_conventions();
    var find2 = conventions.find;
    var NAMESPACE = conventions.NAMESPACE;
    function notEmptyString(input) {
      return input !== "";
    }
    __name(notEmptyString, "notEmptyString");
    function splitOnASCIIWhitespace(input) {
      return input ? input.split(/[\t\n\f\r ]+/).filter(notEmptyString) : [];
    }
    __name(splitOnASCIIWhitespace, "splitOnASCIIWhitespace");
    function orderedSetReducer(current, element) {
      if (!current.hasOwnProperty(element)) {
        current[element] = true;
      }
      return current;
    }
    __name(orderedSetReducer, "orderedSetReducer");
    function toOrderedSet(input) {
      if (!input)
        return [];
      var list = splitOnASCIIWhitespace(input);
      return Object.keys(list.reduce(orderedSetReducer, {}));
    }
    __name(toOrderedSet, "toOrderedSet");
    function arrayIncludes(list) {
      return function(element) {
        return list && list.indexOf(element) !== -1;
      };
    }
    __name(arrayIncludes, "arrayIncludes");
    function copy(src, dest) {
      for (var p2 in src) {
        if (Object.prototype.hasOwnProperty.call(src, p2)) {
          dest[p2] = src[p2];
        }
      }
    }
    __name(copy, "copy");
    function _extends(Class, Super) {
      var pt2 = Class.prototype;
      if (!(pt2 instanceof Super)) {
        let t3 = function() {
        };
        var t2 = t3;
        __name(t3, "t");
        ;
        t3.prototype = Super.prototype;
        t3 = new t3();
        copy(pt2, t3);
        Class.prototype = pt2 = t3;
      }
      if (pt2.constructor != Class) {
        if (typeof Class != "function") {
          console.error("unknown Class:" + Class);
        }
        pt2.constructor = Class;
      }
    }
    __name(_extends, "_extends");
    var NodeType = {};
    var ELEMENT_NODE = NodeType.ELEMENT_NODE = 1;
    var ATTRIBUTE_NODE = NodeType.ATTRIBUTE_NODE = 2;
    var TEXT_NODE = NodeType.TEXT_NODE = 3;
    var CDATA_SECTION_NODE = NodeType.CDATA_SECTION_NODE = 4;
    var ENTITY_REFERENCE_NODE = NodeType.ENTITY_REFERENCE_NODE = 5;
    var ENTITY_NODE = NodeType.ENTITY_NODE = 6;
    var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
    var COMMENT_NODE = NodeType.COMMENT_NODE = 8;
    var DOCUMENT_NODE = NodeType.DOCUMENT_NODE = 9;
    var DOCUMENT_TYPE_NODE = NodeType.DOCUMENT_TYPE_NODE = 10;
    var DOCUMENT_FRAGMENT_NODE = NodeType.DOCUMENT_FRAGMENT_NODE = 11;
    var NOTATION_NODE = NodeType.NOTATION_NODE = 12;
    var ExceptionCode = {};
    var ExceptionMessage = {};
    var INDEX_SIZE_ERR = ExceptionCode.INDEX_SIZE_ERR = (ExceptionMessage[1] = "Index size error", 1);
    var DOMSTRING_SIZE_ERR = ExceptionCode.DOMSTRING_SIZE_ERR = (ExceptionMessage[2] = "DOMString size error", 2);
    var HIERARCHY_REQUEST_ERR = ExceptionCode.HIERARCHY_REQUEST_ERR = (ExceptionMessage[3] = "Hierarchy request error", 3);
    var WRONG_DOCUMENT_ERR = ExceptionCode.WRONG_DOCUMENT_ERR = (ExceptionMessage[4] = "Wrong document", 4);
    var INVALID_CHARACTER_ERR = ExceptionCode.INVALID_CHARACTER_ERR = (ExceptionMessage[5] = "Invalid character", 5);
    var NO_DATA_ALLOWED_ERR = ExceptionCode.NO_DATA_ALLOWED_ERR = (ExceptionMessage[6] = "No data allowed", 6);
    var NO_MODIFICATION_ALLOWED_ERR = ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = (ExceptionMessage[7] = "No modification allowed", 7);
    var NOT_FOUND_ERR = ExceptionCode.NOT_FOUND_ERR = (ExceptionMessage[8] = "Not found", 8);
    var NOT_SUPPORTED_ERR = ExceptionCode.NOT_SUPPORTED_ERR = (ExceptionMessage[9] = "Not supported", 9);
    var INUSE_ATTRIBUTE_ERR = ExceptionCode.INUSE_ATTRIBUTE_ERR = (ExceptionMessage[10] = "Attribute in use", 10);
    var INVALID_STATE_ERR = ExceptionCode.INVALID_STATE_ERR = (ExceptionMessage[11] = "Invalid state", 11);
    var SYNTAX_ERR = ExceptionCode.SYNTAX_ERR = (ExceptionMessage[12] = "Syntax error", 12);
    var INVALID_MODIFICATION_ERR = ExceptionCode.INVALID_MODIFICATION_ERR = (ExceptionMessage[13] = "Invalid modification", 13);
    var NAMESPACE_ERR = ExceptionCode.NAMESPACE_ERR = (ExceptionMessage[14] = "Invalid namespace", 14);
    var INVALID_ACCESS_ERR = ExceptionCode.INVALID_ACCESS_ERR = (ExceptionMessage[15] = "Invalid access", 15);
    function DOMException(code, message) {
      if (message instanceof Error) {
        var error3 = message;
      } else {
        error3 = this;
        Error.call(this, ExceptionMessage[code]);
        this.message = ExceptionMessage[code];
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, DOMException);
      }
      error3.code = code;
      if (message)
        this.message = this.message + ": " + message;
      return error3;
    }
    __name(DOMException, "DOMException");
    DOMException.prototype = Error.prototype;
    copy(ExceptionCode, DOMException);
    function NodeList() {
    }
    __name(NodeList, "NodeList");
    NodeList.prototype = {
      /**
       * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
       * @standard level1
       */
      length: 0,
      /**
       * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
       * @standard level1
       * @param index  unsigned long
       *   Index into the collection.
       * @return Node
       * 	The node at the indexth position in the NodeList, or null if that is not a valid index.
       */
      item: function(index) {
        return index >= 0 && index < this.length ? this[index] : null;
      },
      toString: function(isHTML, nodeFilter) {
        for (var buf = [], i2 = 0; i2 < this.length; i2++) {
          serializeToString(this[i2], buf, isHTML, nodeFilter);
        }
        return buf.join("");
      },
      /**
       * @private
       * @param {function (Node):boolean} predicate
       * @returns {Node[]}
       */
      filter: function(predicate) {
        return Array.prototype.filter.call(this, predicate);
      },
      /**
       * @private
       * @param {Node} item
       * @returns {number}
       */
      indexOf: function(item) {
        return Array.prototype.indexOf.call(this, item);
      }
    };
    function LiveNodeList(node, refresh) {
      this._node = node;
      this._refresh = refresh;
      _updateLiveList(this);
    }
    __name(LiveNodeList, "LiveNodeList");
    function _updateLiveList(list) {
      var inc = list._node._inc || list._node.ownerDocument._inc;
      if (list._inc !== inc) {
        var ls2 = list._refresh(list._node);
        __set__(list, "length", ls2.length);
        if (!list.$$length || ls2.length < list.$$length) {
          for (var i2 = ls2.length; i2 in list; i2++) {
            if (Object.prototype.hasOwnProperty.call(list, i2)) {
              delete list[i2];
            }
          }
        }
        copy(ls2, list);
        list._inc = inc;
      }
    }
    __name(_updateLiveList, "_updateLiveList");
    LiveNodeList.prototype.item = function(i2) {
      _updateLiveList(this);
      return this[i2] || null;
    };
    _extends(LiveNodeList, NodeList);
    function NamedNodeMap() {
    }
    __name(NamedNodeMap, "NamedNodeMap");
    function _findNodeIndex(list, node) {
      var i2 = list.length;
      while (i2--) {
        if (list[i2] === node) {
          return i2;
        }
      }
    }
    __name(_findNodeIndex, "_findNodeIndex");
    function _addNamedNode(el2, list, newAttr, oldAttr) {
      if (oldAttr) {
        list[_findNodeIndex(list, oldAttr)] = newAttr;
      } else {
        list[list.length++] = newAttr;
      }
      if (el2) {
        newAttr.ownerElement = el2;
        var doc = el2.ownerDocument;
        if (doc) {
          oldAttr && _onRemoveAttribute(doc, el2, oldAttr);
          _onAddAttribute(doc, el2, newAttr);
        }
      }
    }
    __name(_addNamedNode, "_addNamedNode");
    function _removeNamedNode(el2, list, attr) {
      var i2 = _findNodeIndex(list, attr);
      if (i2 >= 0) {
        var lastIndex = list.length - 1;
        while (i2 < lastIndex) {
          list[i2] = list[++i2];
        }
        list.length = lastIndex;
        if (el2) {
          var doc = el2.ownerDocument;
          if (doc) {
            _onRemoveAttribute(doc, el2, attr);
            attr.ownerElement = null;
          }
        }
      } else {
        throw new DOMException(NOT_FOUND_ERR, new Error(el2.tagName + "@" + attr));
      }
    }
    __name(_removeNamedNode, "_removeNamedNode");
    NamedNodeMap.prototype = {
      length: 0,
      item: NodeList.prototype.item,
      getNamedItem: function(key) {
        var i2 = this.length;
        while (i2--) {
          var attr = this[i2];
          if (attr.nodeName == key) {
            return attr;
          }
        }
      },
      setNamedItem: function(attr) {
        var el2 = attr.ownerElement;
        if (el2 && el2 != this._ownerElement) {
          throw new DOMException(INUSE_ATTRIBUTE_ERR);
        }
        var oldAttr = this.getNamedItem(attr.nodeName);
        _addNamedNode(this._ownerElement, this, attr, oldAttr);
        return oldAttr;
      },
      /* returns Node */
      setNamedItemNS: function(attr) {
        var el2 = attr.ownerElement, oldAttr;
        if (el2 && el2 != this._ownerElement) {
          throw new DOMException(INUSE_ATTRIBUTE_ERR);
        }
        oldAttr = this.getNamedItemNS(attr.namespaceURI, attr.localName);
        _addNamedNode(this._ownerElement, this, attr, oldAttr);
        return oldAttr;
      },
      /* returns Node */
      removeNamedItem: function(key) {
        var attr = this.getNamedItem(key);
        _removeNamedNode(this._ownerElement, this, attr);
        return attr;
      },
      // raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR
      //for level2
      removeNamedItemNS: function(namespaceURI, localName) {
        var attr = this.getNamedItemNS(namespaceURI, localName);
        _removeNamedNode(this._ownerElement, this, attr);
        return attr;
      },
      getNamedItemNS: function(namespaceURI, localName) {
        var i2 = this.length;
        while (i2--) {
          var node = this[i2];
          if (node.localName == localName && node.namespaceURI == namespaceURI) {
            return node;
          }
        }
        return null;
      }
    };
    function DOMImplementation() {
    }
    __name(DOMImplementation, "DOMImplementation");
    DOMImplementation.prototype = {
      /**
       * The DOMImplementation.hasFeature() method returns a Boolean flag indicating if a given feature is supported.
       * The different implementations fairly diverged in what kind of features were reported.
       * The latest version of the spec settled to force this method to always return true, where the functionality was accurate and in use.
       *
       * @deprecated It is deprecated and modern browsers return true in all cases.
       *
       * @param {string} feature
       * @param {string} [version]
       * @returns {boolean} always true
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/hasFeature MDN
       * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-5CED94D7 DOM Level 1 Core
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-hasfeature DOM Living Standard
       */
      hasFeature: function(feature, version2) {
        return true;
      },
      /**
       * Creates an XML Document object of the specified type with its document element.
       *
       * __It behaves slightly different from the description in the living standard__:
       * - There is no interface/class `XMLDocument`, it returns a `Document` instance.
       * - `contentType`, `encoding`, `mode`, `origin`, `url` fields are currently not declared.
       * - this implementation is not validating names or qualified names
       *   (when parsing XML strings, the SAX parser takes care of that)
       *
       * @param {string|null} namespaceURI
       * @param {string} qualifiedName
       * @param {DocumentType=null} doctype
       * @returns {Document}
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocument MDN
       * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocument DOM Level 2 Core (initial)
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument  DOM Level 2 Core
       *
       * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
       * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
       * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
       */
      createDocument: function(namespaceURI, qualifiedName, doctype) {
        var doc = new Document();
        doc.implementation = this;
        doc.childNodes = new NodeList();
        doc.doctype = doctype || null;
        if (doctype) {
          doc.appendChild(doctype);
        }
        if (qualifiedName) {
          var root = doc.createElementNS(namespaceURI, qualifiedName);
          doc.appendChild(root);
        }
        return doc;
      },
      /**
       * Returns a doctype, with the given `qualifiedName`, `publicId`, and `systemId`.
       *
       * __This behavior is slightly different from the in the specs__:
       * - this implementation is not validating names or qualified names
       *   (when parsing XML strings, the SAX parser takes care of that)
       *
       * @param {string} qualifiedName
       * @param {string} [publicId]
       * @param {string} [systemId]
       * @returns {DocumentType} which can either be used with `DOMImplementation.createDocument` upon document creation
       * 				  or can be put into the document via methods like `Node.insertBefore()` or `Node.replaceChild()`
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocumentType MDN
       * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocType DOM Level 2 Core
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocumenttype DOM Living Standard
       *
       * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
       * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
       * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
       */
      createDocumentType: function(qualifiedName, publicId, systemId) {
        var node = new DocumentType();
        node.name = qualifiedName;
        node.nodeName = qualifiedName;
        node.publicId = publicId || "";
        node.systemId = systemId || "";
        return node;
      }
    };
    function Node2() {
    }
    __name(Node2, "Node");
    Node2.prototype = {
      firstChild: null,
      lastChild: null,
      previousSibling: null,
      nextSibling: null,
      attributes: null,
      parentNode: null,
      childNodes: null,
      ownerDocument: null,
      nodeValue: null,
      namespaceURI: null,
      prefix: null,
      localName: null,
      // Modified in DOM Level 2:
      insertBefore: function(newChild, refChild) {
        return _insertBefore(this, newChild, refChild);
      },
      replaceChild: function(newChild, oldChild) {
        _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
        if (oldChild) {
          this.removeChild(oldChild);
        }
      },
      removeChild: function(oldChild) {
        return _removeChild(this, oldChild);
      },
      appendChild: function(newChild) {
        return this.insertBefore(newChild, null);
      },
      hasChildNodes: function() {
        return this.firstChild != null;
      },
      cloneNode: function(deep) {
        return cloneNode(this.ownerDocument || this, this, deep);
      },
      // Modified in DOM Level 2:
      normalize: function() {
        var child = this.firstChild;
        while (child) {
          var next = child.nextSibling;
          if (next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE) {
            this.removeChild(next);
            child.appendData(next.data);
          } else {
            child.normalize();
            child = next;
          }
        }
      },
      // Introduced in DOM Level 2:
      isSupported: function(feature, version2) {
        return this.ownerDocument.implementation.hasFeature(feature, version2);
      },
      // Introduced in DOM Level 2:
      hasAttributes: function() {
        return this.attributes.length > 0;
      },
      /**
       * Look up the prefix associated to the given namespace URI, starting from this node.
       * **The default namespace declarations are ignored by this method.**
       * See Namespace Prefix Lookup for details on the algorithm used by this method.
       *
       * _Note: The implementation seems to be incomplete when compared to the algorithm described in the specs._
       *
       * @param {string | null} namespaceURI
       * @returns {string | null}
       * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespacePrefix
       * @see https://www.w3.org/TR/DOM-Level-3-Core/namespaces-algorithms.html#lookupNamespacePrefixAlgo
       * @see https://dom.spec.whatwg.org/#dom-node-lookupprefix
       * @see https://github.com/xmldom/xmldom/issues/322
       */
      lookupPrefix: function(namespaceURI) {
        var el2 = this;
        while (el2) {
          var map = el2._nsMap;
          if (map) {
            for (var n2 in map) {
              if (Object.prototype.hasOwnProperty.call(map, n2) && map[n2] === namespaceURI) {
                return n2;
              }
            }
          }
          el2 = el2.nodeType == ATTRIBUTE_NODE ? el2.ownerDocument : el2.parentNode;
        }
        return null;
      },
      // Introduced in DOM Level 3:
      lookupNamespaceURI: function(prefix) {
        var el2 = this;
        while (el2) {
          var map = el2._nsMap;
          if (map) {
            if (Object.prototype.hasOwnProperty.call(map, prefix)) {
              return map[prefix];
            }
          }
          el2 = el2.nodeType == ATTRIBUTE_NODE ? el2.ownerDocument : el2.parentNode;
        }
        return null;
      },
      // Introduced in DOM Level 3:
      isDefaultNamespace: function(namespaceURI) {
        var prefix = this.lookupPrefix(namespaceURI);
        return prefix == null;
      }
    };
    function _xmlEncoder(c2) {
      return c2 == "<" && "&lt;" || c2 == ">" && "&gt;" || c2 == "&" && "&amp;" || c2 == '"' && "&quot;" || "&#" + c2.charCodeAt() + ";";
    }
    __name(_xmlEncoder, "_xmlEncoder");
    copy(NodeType, Node2);
    copy(NodeType, Node2.prototype);
    function _visitNode(node, callback) {
      if (callback(node)) {
        return true;
      }
      if (node = node.firstChild) {
        do {
          if (_visitNode(node, callback)) {
            return true;
          }
        } while (node = node.nextSibling);
      }
    }
    __name(_visitNode, "_visitNode");
    function Document() {
      this.ownerDocument = this;
    }
    __name(Document, "Document");
    function _onAddAttribute(doc, el2, newAttr) {
      doc && doc._inc++;
      var ns2 = newAttr.namespaceURI;
      if (ns2 === NAMESPACE.XMLNS) {
        el2._nsMap[newAttr.prefix ? newAttr.localName : ""] = newAttr.value;
      }
    }
    __name(_onAddAttribute, "_onAddAttribute");
    function _onRemoveAttribute(doc, el2, newAttr, remove) {
      doc && doc._inc++;
      var ns2 = newAttr.namespaceURI;
      if (ns2 === NAMESPACE.XMLNS) {
        delete el2._nsMap[newAttr.prefix ? newAttr.localName : ""];
      }
    }
    __name(_onRemoveAttribute, "_onRemoveAttribute");
    function _onUpdateChild(doc, el2, newChild) {
      if (doc && doc._inc) {
        doc._inc++;
        var cs2 = el2.childNodes;
        if (newChild) {
          cs2[cs2.length++] = newChild;
        } else {
          var child = el2.firstChild;
          var i2 = 0;
          while (child) {
            cs2[i2++] = child;
            child = child.nextSibling;
          }
          cs2.length = i2;
          delete cs2[cs2.length];
        }
      }
    }
    __name(_onUpdateChild, "_onUpdateChild");
    function _removeChild(parentNode, child) {
      var previous = child.previousSibling;
      var next = child.nextSibling;
      if (previous) {
        previous.nextSibling = next;
      } else {
        parentNode.firstChild = next;
      }
      if (next) {
        next.previousSibling = previous;
      } else {
        parentNode.lastChild = previous;
      }
      child.parentNode = null;
      child.previousSibling = null;
      child.nextSibling = null;
      _onUpdateChild(parentNode.ownerDocument, parentNode);
      return child;
    }
    __name(_removeChild, "_removeChild");
    function hasValidParentNodeType(node) {
      return node && (node.nodeType === Node2.DOCUMENT_NODE || node.nodeType === Node2.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node2.ELEMENT_NODE);
    }
    __name(hasValidParentNodeType, "hasValidParentNodeType");
    function hasInsertableNodeType(node) {
      return node && (isElementNode(node) || isTextNode(node) || isDocTypeNode(node) || node.nodeType === Node2.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node2.COMMENT_NODE || node.nodeType === Node2.PROCESSING_INSTRUCTION_NODE);
    }
    __name(hasInsertableNodeType, "hasInsertableNodeType");
    function isDocTypeNode(node) {
      return node && node.nodeType === Node2.DOCUMENT_TYPE_NODE;
    }
    __name(isDocTypeNode, "isDocTypeNode");
    function isElementNode(node) {
      return node && node.nodeType === Node2.ELEMENT_NODE;
    }
    __name(isElementNode, "isElementNode");
    function isTextNode(node) {
      return node && node.nodeType === Node2.TEXT_NODE;
    }
    __name(isTextNode, "isTextNode");
    function isElementInsertionPossible(doc, child) {
      var parentChildNodes = doc.childNodes || [];
      if (find2(parentChildNodes, isElementNode) || isDocTypeNode(child)) {
        return false;
      }
      var docTypeNode = find2(parentChildNodes, isDocTypeNode);
      return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
    }
    __name(isElementInsertionPossible, "isElementInsertionPossible");
    function isElementReplacementPossible(doc, child) {
      var parentChildNodes = doc.childNodes || [];
      function hasElementChildThatIsNotChild(node) {
        return isElementNode(node) && node !== child;
      }
      __name(hasElementChildThatIsNotChild, "hasElementChildThatIsNotChild");
      if (find2(parentChildNodes, hasElementChildThatIsNotChild)) {
        return false;
      }
      var docTypeNode = find2(parentChildNodes, isDocTypeNode);
      return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
    }
    __name(isElementReplacementPossible, "isElementReplacementPossible");
    function assertPreInsertionValidity1to5(parent, node, child) {
      if (!hasValidParentNodeType(parent)) {
        throw new DOMException(HIERARCHY_REQUEST_ERR, "Unexpected parent node type " + parent.nodeType);
      }
      if (child && child.parentNode !== parent) {
        throw new DOMException(NOT_FOUND_ERR, "child not in parent");
      }
      if (
        // 4. If `node` is not a DocumentFragment, DocumentType, Element, or CharacterData node, then throw a "HierarchyRequestError" DOMException.
        !hasInsertableNodeType(node) || // 5. If either `node` is a Text node and `parent` is a document,
        // the sax parser currently adds top level text nodes, this will be fixed in 0.9.0
        // || (node.nodeType === Node.TEXT_NODE && parent.nodeType === Node.DOCUMENT_NODE)
        // or `node` is a doctype and `parent` is not a document, then throw a "HierarchyRequestError" DOMException.
        isDocTypeNode(node) && parent.nodeType !== Node2.DOCUMENT_NODE
      ) {
        throw new DOMException(
          HIERARCHY_REQUEST_ERR,
          "Unexpected node type " + node.nodeType + " for parent node type " + parent.nodeType
        );
      }
    }
    __name(assertPreInsertionValidity1to5, "assertPreInsertionValidity1to5");
    function assertPreInsertionValidityInDocument(parent, node, child) {
      var parentChildNodes = parent.childNodes || [];
      var nodeChildNodes = node.childNodes || [];
      if (node.nodeType === Node2.DOCUMENT_FRAGMENT_NODE) {
        var nodeChildElements = nodeChildNodes.filter(isElementNode);
        if (nodeChildElements.length > 1 || find2(nodeChildNodes, isTextNode)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
        }
        if (nodeChildElements.length === 1 && !isElementInsertionPossible(parent, child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
        }
      }
      if (isElementNode(node)) {
        if (!isElementInsertionPossible(parent, child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
        }
      }
      if (isDocTypeNode(node)) {
        if (find2(parentChildNodes, isDocTypeNode)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
        }
        var parentElementChild = find2(parentChildNodes, isElementNode);
        if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
        }
        if (!child && parentElementChild) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can not be appended since element is present");
        }
      }
    }
    __name(assertPreInsertionValidityInDocument, "assertPreInsertionValidityInDocument");
    function assertPreReplacementValidityInDocument(parent, node, child) {
      var parentChildNodes = parent.childNodes || [];
      var nodeChildNodes = node.childNodes || [];
      if (node.nodeType === Node2.DOCUMENT_FRAGMENT_NODE) {
        var nodeChildElements = nodeChildNodes.filter(isElementNode);
        if (nodeChildElements.length > 1 || find2(nodeChildNodes, isTextNode)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
        }
        if (nodeChildElements.length === 1 && !isElementReplacementPossible(parent, child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
        }
      }
      if (isElementNode(node)) {
        if (!isElementReplacementPossible(parent, child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
        }
      }
      if (isDocTypeNode(node)) {
        let hasDoctypeChildThatIsNotChild2 = function(node2) {
          return isDocTypeNode(node2) && node2 !== child;
        };
        var hasDoctypeChildThatIsNotChild = hasDoctypeChildThatIsNotChild2;
        __name(hasDoctypeChildThatIsNotChild2, "hasDoctypeChildThatIsNotChild");
        if (find2(parentChildNodes, hasDoctypeChildThatIsNotChild2)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
        }
        var parentElementChild = find2(parentChildNodes, isElementNode);
        if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
        }
      }
    }
    __name(assertPreReplacementValidityInDocument, "assertPreReplacementValidityInDocument");
    function _insertBefore(parent, node, child, _inDocumentAssertion) {
      assertPreInsertionValidity1to5(parent, node, child);
      if (parent.nodeType === Node2.DOCUMENT_NODE) {
        (_inDocumentAssertion || assertPreInsertionValidityInDocument)(parent, node, child);
      }
      var cp = node.parentNode;
      if (cp) {
        cp.removeChild(node);
      }
      if (node.nodeType === DOCUMENT_FRAGMENT_NODE) {
        var newFirst = node.firstChild;
        if (newFirst == null) {
          return node;
        }
        var newLast = node.lastChild;
      } else {
        newFirst = newLast = node;
      }
      var pre = child ? child.previousSibling : parent.lastChild;
      newFirst.previousSibling = pre;
      newLast.nextSibling = child;
      if (pre) {
        pre.nextSibling = newFirst;
      } else {
        parent.firstChild = newFirst;
      }
      if (child == null) {
        parent.lastChild = newLast;
      } else {
        child.previousSibling = newLast;
      }
      do {
        newFirst.parentNode = parent;
        var targetDoc = parent.ownerDocument || parent;
        _updateOwnerDocument(newFirst, targetDoc);
      } while (newFirst !== newLast && (newFirst = newFirst.nextSibling));
      _onUpdateChild(parent.ownerDocument || parent, parent);
      if (node.nodeType == DOCUMENT_FRAGMENT_NODE) {
        node.firstChild = node.lastChild = null;
      }
      return node;
    }
    __name(_insertBefore, "_insertBefore");
    function _updateOwnerDocument(node, newOwnerDocument) {
      if (node.ownerDocument === newOwnerDocument) {
        return;
      }
      node.ownerDocument = newOwnerDocument;
      if (node.nodeType === ELEMENT_NODE && node.attributes) {
        for (var i2 = 0; i2 < node.attributes.length; i2++) {
          var attr = node.attributes.item(i2);
          if (attr) {
            attr.ownerDocument = newOwnerDocument;
          }
        }
      }
      var child = node.firstChild;
      while (child) {
        _updateOwnerDocument(child, newOwnerDocument);
        child = child.nextSibling;
      }
    }
    __name(_updateOwnerDocument, "_updateOwnerDocument");
    function _appendSingleChild(parentNode, newChild) {
      if (newChild.parentNode) {
        newChild.parentNode.removeChild(newChild);
      }
      newChild.parentNode = parentNode;
      newChild.previousSibling = parentNode.lastChild;
      newChild.nextSibling = null;
      if (newChild.previousSibling) {
        newChild.previousSibling.nextSibling = newChild;
      } else {
        parentNode.firstChild = newChild;
      }
      parentNode.lastChild = newChild;
      _onUpdateChild(parentNode.ownerDocument, parentNode, newChild);
      var targetDoc = parentNode.ownerDocument || parentNode;
      _updateOwnerDocument(newChild, targetDoc);
      return newChild;
    }
    __name(_appendSingleChild, "_appendSingleChild");
    Document.prototype = {
      //implementation : null,
      nodeName: "#document",
      nodeType: DOCUMENT_NODE,
      /**
       * The DocumentType node of the document.
       *
       * @readonly
       * @type DocumentType
       */
      doctype: null,
      documentElement: null,
      _inc: 1,
      insertBefore: function(newChild, refChild) {
        if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
          var child = newChild.firstChild;
          while (child) {
            var next = child.nextSibling;
            this.insertBefore(child, refChild);
            child = next;
          }
          return newChild;
        }
        _insertBefore(this, newChild, refChild);
        _updateOwnerDocument(newChild, this);
        if (this.documentElement === null && newChild.nodeType === ELEMENT_NODE) {
          this.documentElement = newChild;
        }
        return newChild;
      },
      removeChild: function(oldChild) {
        if (this.documentElement == oldChild) {
          this.documentElement = null;
        }
        return _removeChild(this, oldChild);
      },
      replaceChild: function(newChild, oldChild) {
        _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
        _updateOwnerDocument(newChild, this);
        if (oldChild) {
          this.removeChild(oldChild);
        }
        if (isElementNode(newChild)) {
          this.documentElement = newChild;
        }
      },
      // Introduced in DOM Level 2:
      importNode: function(importedNode, deep) {
        return importNode(this, importedNode, deep);
      },
      // Introduced in DOM Level 2:
      getElementById: function(id) {
        var rtv = null;
        _visitNode(this.documentElement, function(node) {
          if (node.nodeType == ELEMENT_NODE) {
            if (node.getAttribute("id") == id) {
              rtv = node;
              return true;
            }
          }
        });
        return rtv;
      },
      /**
       * The `getElementsByClassName` method of `Document` interface returns an array-like object
       * of all child elements which have **all** of the given class name(s).
       *
       * Returns an empty list if `classeNames` is an empty string or only contains HTML white space characters.
       *
       *
       * Warning: This is a live LiveNodeList.
       * Changes in the DOM will reflect in the array as the changes occur.
       * If an element selected by this array no longer qualifies for the selector,
       * it will automatically be removed. Be aware of this for iteration purposes.
       *
       * @param {string} classNames is a string representing the class name(s) to match; multiple class names are separated by (ASCII-)whitespace
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
       * @see https://dom.spec.whatwg.org/#concept-getelementsbyclassname
       */
      getElementsByClassName: function(classNames) {
        var classNamesSet = toOrderedSet(classNames);
        return new LiveNodeList(this, function(base) {
          var ls2 = [];
          if (classNamesSet.length > 0) {
            _visitNode(base.documentElement, function(node) {
              if (node !== base && node.nodeType === ELEMENT_NODE) {
                var nodeClassNames = node.getAttribute("class");
                if (nodeClassNames) {
                  var matches = classNames === nodeClassNames;
                  if (!matches) {
                    var nodeClassNamesSet = toOrderedSet(nodeClassNames);
                    matches = classNamesSet.every(arrayIncludes(nodeClassNamesSet));
                  }
                  if (matches) {
                    ls2.push(node);
                  }
                }
              }
            });
          }
          return ls2;
        });
      },
      //document factory method:
      createElement: function(tagName) {
        var node = new Element();
        node.ownerDocument = this;
        node.nodeName = tagName;
        node.tagName = tagName;
        node.localName = tagName;
        node.childNodes = new NodeList();
        var attrs = node.attributes = new NamedNodeMap();
        attrs._ownerElement = node;
        return node;
      },
      createDocumentFragment: function() {
        var node = new DocumentFragment();
        node.ownerDocument = this;
        node.childNodes = new NodeList();
        return node;
      },
      createTextNode: function(data) {
        var node = new Text2();
        node.ownerDocument = this;
        node.appendData(data);
        return node;
      },
      createComment: function(data) {
        var node = new Comment2();
        node.ownerDocument = this;
        node.appendData(data);
        return node;
      },
      createCDATASection: function(data) {
        var node = new CDATASection();
        node.ownerDocument = this;
        node.appendData(data);
        return node;
      },
      createProcessingInstruction: function(target, data) {
        var node = new ProcessingInstruction();
        node.ownerDocument = this;
        node.tagName = node.nodeName = node.target = target;
        node.nodeValue = node.data = data;
        return node;
      },
      createAttribute: function(name) {
        var node = new Attr();
        node.ownerDocument = this;
        node.name = name;
        node.nodeName = name;
        node.localName = name;
        node.specified = true;
        return node;
      },
      createEntityReference: function(name) {
        var node = new EntityReference();
        node.ownerDocument = this;
        node.nodeName = name;
        return node;
      },
      // Introduced in DOM Level 2:
      createElementNS: function(namespaceURI, qualifiedName) {
        var node = new Element();
        var pl2 = qualifiedName.split(":");
        var attrs = node.attributes = new NamedNodeMap();
        node.childNodes = new NodeList();
        node.ownerDocument = this;
        node.nodeName = qualifiedName;
        node.tagName = qualifiedName;
        node.namespaceURI = namespaceURI;
        if (pl2.length == 2) {
          node.prefix = pl2[0];
          node.localName = pl2[1];
        } else {
          node.localName = qualifiedName;
        }
        attrs._ownerElement = node;
        return node;
      },
      // Introduced in DOM Level 2:
      createAttributeNS: function(namespaceURI, qualifiedName) {
        var node = new Attr();
        var pl2 = qualifiedName.split(":");
        node.ownerDocument = this;
        node.nodeName = qualifiedName;
        node.name = qualifiedName;
        node.namespaceURI = namespaceURI;
        node.specified = true;
        if (pl2.length == 2) {
          node.prefix = pl2[0];
          node.localName = pl2[1];
        } else {
          node.localName = qualifiedName;
        }
        return node;
      }
    };
    _extends(Document, Node2);
    function Element() {
      this._nsMap = {};
    }
    __name(Element, "Element");
    Element.prototype = {
      nodeType: ELEMENT_NODE,
      hasAttribute: function(name) {
        return this.getAttributeNode(name) != null;
      },
      getAttribute: function(name) {
        var attr = this.getAttributeNode(name);
        return attr && attr.value || "";
      },
      getAttributeNode: function(name) {
        return this.attributes.getNamedItem(name);
      },
      setAttribute: function(name, value) {
        var attr = this.ownerDocument.createAttribute(name);
        attr.value = attr.nodeValue = "" + value;
        this.setAttributeNode(attr);
      },
      removeAttribute: function(name) {
        var attr = this.getAttributeNode(name);
        attr && this.removeAttributeNode(attr);
      },
      //four real opeartion method
      appendChild: function(newChild) {
        if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {
          return this.insertBefore(newChild, null);
        } else {
          return _appendSingleChild(this, newChild);
        }
      },
      setAttributeNode: function(newAttr) {
        return this.attributes.setNamedItem(newAttr);
      },
      setAttributeNodeNS: function(newAttr) {
        return this.attributes.setNamedItemNS(newAttr);
      },
      removeAttributeNode: function(oldAttr) {
        return this.attributes.removeNamedItem(oldAttr.nodeName);
      },
      //get real attribute name,and remove it by removeAttributeNode
      removeAttributeNS: function(namespaceURI, localName) {
        var old = this.getAttributeNodeNS(namespaceURI, localName);
        old && this.removeAttributeNode(old);
      },
      hasAttributeNS: function(namespaceURI, localName) {
        return this.getAttributeNodeNS(namespaceURI, localName) != null;
      },
      getAttributeNS: function(namespaceURI, localName) {
        var attr = this.getAttributeNodeNS(namespaceURI, localName);
        return attr && attr.value || "";
      },
      setAttributeNS: function(namespaceURI, qualifiedName, value) {
        var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
        attr.value = attr.nodeValue = "" + value;
        this.setAttributeNode(attr);
      },
      getAttributeNodeNS: function(namespaceURI, localName) {
        return this.attributes.getNamedItemNS(namespaceURI, localName);
      },
      getElementsByTagName: function(tagName) {
        return new LiveNodeList(this, function(base) {
          var ls2 = [];
          _visitNode(base, function(node) {
            if (node !== base && node.nodeType == ELEMENT_NODE && (tagName === "*" || node.tagName == tagName)) {
              ls2.push(node);
            }
          });
          return ls2;
        });
      },
      getElementsByTagNameNS: function(namespaceURI, localName) {
        return new LiveNodeList(this, function(base) {
          var ls2 = [];
          _visitNode(base, function(node) {
            if (node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === "*" || node.namespaceURI === namespaceURI) && (localName === "*" || node.localName == localName)) {
              ls2.push(node);
            }
          });
          return ls2;
        });
      }
    };
    Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
    Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;
    _extends(Element, Node2);
    function Attr() {
    }
    __name(Attr, "Attr");
    Attr.prototype.nodeType = ATTRIBUTE_NODE;
    _extends(Attr, Node2);
    function CharacterData() {
    }
    __name(CharacterData, "CharacterData");
    CharacterData.prototype = {
      data: "",
      substringData: function(offset, count3) {
        return this.data.substring(offset, offset + count3);
      },
      appendData: function(text) {
        text = this.data + text;
        this.nodeValue = this.data = text;
        this.length = text.length;
      },
      insertData: function(offset, text) {
        this.replaceData(offset, 0, text);
      },
      appendChild: function(newChild) {
        throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR]);
      },
      deleteData: function(offset, count3) {
        this.replaceData(offset, count3, "");
      },
      replaceData: function(offset, count3, text) {
        var start = this.data.substring(0, offset);
        var end = this.data.substring(offset + count3);
        text = start + text + end;
        this.nodeValue = this.data = text;
        this.length = text.length;
      }
    };
    _extends(CharacterData, Node2);
    function Text2() {
    }
    __name(Text2, "Text");
    Text2.prototype = {
      nodeName: "#text",
      nodeType: TEXT_NODE,
      splitText: function(offset) {
        var text = this.data;
        var newText = text.substring(offset);
        text = text.substring(0, offset);
        this.data = this.nodeValue = text;
        this.length = text.length;
        var newNode = this.ownerDocument.createTextNode(newText);
        if (this.parentNode) {
          this.parentNode.insertBefore(newNode, this.nextSibling);
        }
        return newNode;
      }
    };
    _extends(Text2, CharacterData);
    function Comment2() {
    }
    __name(Comment2, "Comment");
    Comment2.prototype = {
      nodeName: "#comment",
      nodeType: COMMENT_NODE
    };
    _extends(Comment2, CharacterData);
    function CDATASection() {
    }
    __name(CDATASection, "CDATASection");
    CDATASection.prototype = {
      nodeName: "#cdata-section",
      nodeType: CDATA_SECTION_NODE
    };
    _extends(CDATASection, CharacterData);
    function DocumentType() {
    }
    __name(DocumentType, "DocumentType");
    DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
    _extends(DocumentType, Node2);
    function Notation() {
    }
    __name(Notation, "Notation");
    Notation.prototype.nodeType = NOTATION_NODE;
    _extends(Notation, Node2);
    function Entity() {
    }
    __name(Entity, "Entity");
    Entity.prototype.nodeType = ENTITY_NODE;
    _extends(Entity, Node2);
    function EntityReference() {
    }
    __name(EntityReference, "EntityReference");
    EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
    _extends(EntityReference, Node2);
    function DocumentFragment() {
    }
    __name(DocumentFragment, "DocumentFragment");
    DocumentFragment.prototype.nodeName = "#document-fragment";
    DocumentFragment.prototype.nodeType = DOCUMENT_FRAGMENT_NODE;
    _extends(DocumentFragment, Node2);
    function ProcessingInstruction() {
    }
    __name(ProcessingInstruction, "ProcessingInstruction");
    ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
    _extends(ProcessingInstruction, Node2);
    function XMLSerializer() {
    }
    __name(XMLSerializer, "XMLSerializer");
    XMLSerializer.prototype.serializeToString = function(node, isHtml, nodeFilter) {
      return nodeSerializeToString.call(node, isHtml, nodeFilter);
    };
    Node2.prototype.toString = nodeSerializeToString;
    function nodeSerializeToString(isHtml, nodeFilter) {
      var buf = [];
      var refNode = this.nodeType == 9 && this.documentElement || this;
      var prefix = refNode.prefix;
      var uri = refNode.namespaceURI;
      if (uri && prefix == null) {
        var prefix = refNode.lookupPrefix(uri);
        if (prefix == null) {
          var visibleNamespaces = [
            { namespace: uri, prefix: null }
            //{namespace:uri,prefix:''}
          ];
        }
      }
      serializeToString(this, buf, isHtml, nodeFilter, visibleNamespaces);
      return buf.join("");
    }
    __name(nodeSerializeToString, "nodeSerializeToString");
    function needNamespaceDefine(node, isHTML, visibleNamespaces) {
      var prefix = node.prefix || "";
      var uri = node.namespaceURI;
      if (!uri) {
        return false;
      }
      if (prefix === "xml" && uri === NAMESPACE.XML || uri === NAMESPACE.XMLNS) {
        return false;
      }
      var i2 = visibleNamespaces.length;
      while (i2--) {
        var ns2 = visibleNamespaces[i2];
        if (ns2.prefix === prefix) {
          return ns2.namespace !== uri;
        }
      }
      return true;
    }
    __name(needNamespaceDefine, "needNamespaceDefine");
    function addSerializedAttribute(buf, qualifiedName, value) {
      buf.push(" ", qualifiedName, '="', value.replace(/[<>&"\t\n\r]/g, _xmlEncoder), '"');
    }
    __name(addSerializedAttribute, "addSerializedAttribute");
    function serializeToString(node, buf, isHTML, nodeFilter, visibleNamespaces) {
      if (!visibleNamespaces) {
        visibleNamespaces = [];
      }
      if (nodeFilter) {
        node = nodeFilter(node);
        if (node) {
          if (typeof node == "string") {
            buf.push(node);
            return;
          }
        } else {
          return;
        }
      }
      switch (node.nodeType) {
        case ELEMENT_NODE:
          var attrs = node.attributes;
          var len = attrs.length;
          var child = node.firstChild;
          var nodeName = node.tagName;
          isHTML = NAMESPACE.isHTML(node.namespaceURI) || isHTML;
          var prefixedNodeName = nodeName;
          if (!isHTML && !node.prefix && node.namespaceURI) {
            var defaultNS;
            for (var ai2 = 0; ai2 < attrs.length; ai2++) {
              if (attrs.item(ai2).name === "xmlns") {
                defaultNS = attrs.item(ai2).value;
                break;
              }
            }
            if (!defaultNS) {
              for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
                var namespace = visibleNamespaces[nsi];
                if (namespace.prefix === "" && namespace.namespace === node.namespaceURI) {
                  defaultNS = namespace.namespace;
                  break;
                }
              }
            }
            if (defaultNS !== node.namespaceURI) {
              for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
                var namespace = visibleNamespaces[nsi];
                if (namespace.namespace === node.namespaceURI) {
                  if (namespace.prefix) {
                    prefixedNodeName = namespace.prefix + ":" + nodeName;
                  }
                  break;
                }
              }
            }
          }
          buf.push("<", prefixedNodeName);
          for (var i2 = 0; i2 < len; i2++) {
            var attr = attrs.item(i2);
            if (attr.prefix == "xmlns") {
              visibleNamespaces.push({ prefix: attr.localName, namespace: attr.value });
            } else if (attr.nodeName == "xmlns") {
              visibleNamespaces.push({ prefix: "", namespace: attr.value });
            }
          }
          for (var i2 = 0; i2 < len; i2++) {
            var attr = attrs.item(i2);
            if (needNamespaceDefine(attr, isHTML, visibleNamespaces)) {
              var prefix = attr.prefix || "";
              var uri = attr.namespaceURI;
              addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
              visibleNamespaces.push({ prefix, namespace: uri });
            }
            serializeToString(attr, buf, isHTML, nodeFilter, visibleNamespaces);
          }
          if (nodeName === prefixedNodeName && needNamespaceDefine(node, isHTML, visibleNamespaces)) {
            var prefix = node.prefix || "";
            var uri = node.namespaceURI;
            addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
            visibleNamespaces.push({ prefix, namespace: uri });
          }
          if (child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)) {
            buf.push(">");
            if (isHTML && /^script$/i.test(nodeName)) {
              while (child) {
                if (child.data) {
                  buf.push(child.data);
                } else {
                  serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
                }
                child = child.nextSibling;
              }
            } else {
              while (child) {
                serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
                child = child.nextSibling;
              }
            }
            buf.push("</", prefixedNodeName, ">");
          } else {
            buf.push("/>");
          }
          return;
        case DOCUMENT_NODE:
        case DOCUMENT_FRAGMENT_NODE:
          var child = node.firstChild;
          while (child) {
            serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
            child = child.nextSibling;
          }
          return;
        case ATTRIBUTE_NODE:
          return addSerializedAttribute(buf, node.name, node.value);
        case TEXT_NODE:
          return buf.push(
            node.data.replace(/[<&>]/g, _xmlEncoder)
          );
        case CDATA_SECTION_NODE:
          return buf.push("<![CDATA[", node.data, "]]>");
        case COMMENT_NODE:
          return buf.push("<!--", node.data, "-->");
        case DOCUMENT_TYPE_NODE:
          var pubid = node.publicId;
          var sysid = node.systemId;
          buf.push("<!DOCTYPE ", node.name);
          if (pubid) {
            buf.push(" PUBLIC ", pubid);
            if (sysid && sysid != ".") {
              buf.push(" ", sysid);
            }
            buf.push(">");
          } else if (sysid && sysid != ".") {
            buf.push(" SYSTEM ", sysid, ">");
          } else {
            var sub = node.internalSubset;
            if (sub) {
              buf.push(" [", sub, "]");
            }
            buf.push(">");
          }
          return;
        case PROCESSING_INSTRUCTION_NODE:
          return buf.push("<?", node.target, " ", node.data, "?>");
        case ENTITY_REFERENCE_NODE:
          return buf.push("&", node.nodeName, ";");
        default:
          buf.push("??", node.nodeName);
      }
    }
    __name(serializeToString, "serializeToString");
    function importNode(doc, node, deep) {
      var node2;
      switch (node.nodeType) {
        case ELEMENT_NODE:
          node2 = node.cloneNode(false);
          node2.ownerDocument = doc;
        case DOCUMENT_FRAGMENT_NODE:
          break;
        case ATTRIBUTE_NODE:
          deep = true;
          break;
      }
      if (!node2) {
        node2 = node.cloneNode(false);
      }
      node2.ownerDocument = doc;
      node2.parentNode = null;
      if (deep) {
        var child = node.firstChild;
        while (child) {
          node2.appendChild(importNode(doc, child, deep));
          child = child.nextSibling;
        }
      }
      return node2;
    }
    __name(importNode, "importNode");
    function cloneNode(doc, node, deep) {
      var node2 = new node.constructor();
      for (var n2 in node) {
        if (Object.prototype.hasOwnProperty.call(node, n2)) {
          var v2 = node[n2];
          if (typeof v2 != "object") {
            if (v2 != node2[n2]) {
              node2[n2] = v2;
            }
          }
        }
      }
      if (node.childNodes) {
        node2.childNodes = new NodeList();
      }
      node2.ownerDocument = doc;
      switch (node2.nodeType) {
        case ELEMENT_NODE:
          var attrs = node.attributes;
          var attrs2 = node2.attributes = new NamedNodeMap();
          var len = attrs.length;
          attrs2._ownerElement = node2;
          for (var i2 = 0; i2 < len; i2++) {
            node2.setAttributeNode(cloneNode(doc, attrs.item(i2), true));
          }
          break;
          ;
        case ATTRIBUTE_NODE:
          deep = true;
      }
      if (deep) {
        var child = node.firstChild;
        while (child) {
          node2.appendChild(cloneNode(doc, child, deep));
          child = child.nextSibling;
        }
      }
      return node2;
    }
    __name(cloneNode, "cloneNode");
    function __set__(object, key, value) {
      object[key] = value;
    }
    __name(__set__, "__set__");
    try {
      if (Object.defineProperty) {
        let getTextContent2 = function(node) {
          switch (node.nodeType) {
            case ELEMENT_NODE:
            case DOCUMENT_FRAGMENT_NODE:
              var buf = [];
              node = node.firstChild;
              while (node) {
                if (node.nodeType !== 7 && node.nodeType !== 8) {
                  buf.push(getTextContent2(node));
                }
                node = node.nextSibling;
              }
              return buf.join("");
            default:
              return node.nodeValue;
          }
        };
        getTextContent = getTextContent2;
        __name(getTextContent2, "getTextContent");
        Object.defineProperty(LiveNodeList.prototype, "length", {
          get: function() {
            _updateLiveList(this);
            return this.$$length;
          }
        });
        Object.defineProperty(Node2.prototype, "textContent", {
          get: function() {
            return getTextContent2(this);
          },
          set: function(data) {
            switch (this.nodeType) {
              case ELEMENT_NODE:
              case DOCUMENT_FRAGMENT_NODE:
                while (this.firstChild) {
                  this.removeChild(this.firstChild);
                }
                if (data || String(data)) {
                  this.appendChild(this.ownerDocument.createTextNode(data));
                }
                break;
              default:
                this.data = data;
                this.value = data;
                this.nodeValue = data;
            }
          }
        });
        __set__ = /* @__PURE__ */ __name(function(object, key, value) {
          object["$$" + key] = value;
        }, "__set__");
      }
    } catch (e2) {
    }
    var getTextContent;
    exports2.DocumentType = DocumentType;
    exports2.DOMException = DOMException;
    exports2.DOMImplementation = DOMImplementation;
    exports2.Element = Element;
    exports2.Node = Node2;
    exports2.NodeList = NodeList;
    exports2.XMLSerializer = XMLSerializer;
  }
});

// node_modules/@xmldom/xmldom/lib/entities.js
var require_entities = __commonJS({
  "node_modules/@xmldom/xmldom/lib/entities.js"(exports2) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var freeze = require_conventions().freeze;
    exports2.XML_ENTITIES = freeze({
      amp: "&",
      apos: "'",
      gt: ">",
      lt: "<",
      quot: '"'
    });
    exports2.HTML_ENTITIES = freeze({
      Aacute: "\xC1",
      aacute: "\xE1",
      Abreve: "\u0102",
      abreve: "\u0103",
      ac: "\u223E",
      acd: "\u223F",
      acE: "\u223E\u0333",
      Acirc: "\xC2",
      acirc: "\xE2",
      acute: "\xB4",
      Acy: "\u0410",
      acy: "\u0430",
      AElig: "\xC6",
      aelig: "\xE6",
      af: "\u2061",
      Afr: "\u{1D504}",
      afr: "\u{1D51E}",
      Agrave: "\xC0",
      agrave: "\xE0",
      alefsym: "\u2135",
      aleph: "\u2135",
      Alpha: "\u0391",
      alpha: "\u03B1",
      Amacr: "\u0100",
      amacr: "\u0101",
      amalg: "\u2A3F",
      AMP: "&",
      amp: "&",
      And: "\u2A53",
      and: "\u2227",
      andand: "\u2A55",
      andd: "\u2A5C",
      andslope: "\u2A58",
      andv: "\u2A5A",
      ang: "\u2220",
      ange: "\u29A4",
      angle: "\u2220",
      angmsd: "\u2221",
      angmsdaa: "\u29A8",
      angmsdab: "\u29A9",
      angmsdac: "\u29AA",
      angmsdad: "\u29AB",
      angmsdae: "\u29AC",
      angmsdaf: "\u29AD",
      angmsdag: "\u29AE",
      angmsdah: "\u29AF",
      angrt: "\u221F",
      angrtvb: "\u22BE",
      angrtvbd: "\u299D",
      angsph: "\u2222",
      angst: "\xC5",
      angzarr: "\u237C",
      Aogon: "\u0104",
      aogon: "\u0105",
      Aopf: "\u{1D538}",
      aopf: "\u{1D552}",
      ap: "\u2248",
      apacir: "\u2A6F",
      apE: "\u2A70",
      ape: "\u224A",
      apid: "\u224B",
      apos: "'",
      ApplyFunction: "\u2061",
      approx: "\u2248",
      approxeq: "\u224A",
      Aring: "\xC5",
      aring: "\xE5",
      Ascr: "\u{1D49C}",
      ascr: "\u{1D4B6}",
      Assign: "\u2254",
      ast: "*",
      asymp: "\u2248",
      asympeq: "\u224D",
      Atilde: "\xC3",
      atilde: "\xE3",
      Auml: "\xC4",
      auml: "\xE4",
      awconint: "\u2233",
      awint: "\u2A11",
      backcong: "\u224C",
      backepsilon: "\u03F6",
      backprime: "\u2035",
      backsim: "\u223D",
      backsimeq: "\u22CD",
      Backslash: "\u2216",
      Barv: "\u2AE7",
      barvee: "\u22BD",
      Barwed: "\u2306",
      barwed: "\u2305",
      barwedge: "\u2305",
      bbrk: "\u23B5",
      bbrktbrk: "\u23B6",
      bcong: "\u224C",
      Bcy: "\u0411",
      bcy: "\u0431",
      bdquo: "\u201E",
      becaus: "\u2235",
      Because: "\u2235",
      because: "\u2235",
      bemptyv: "\u29B0",
      bepsi: "\u03F6",
      bernou: "\u212C",
      Bernoullis: "\u212C",
      Beta: "\u0392",
      beta: "\u03B2",
      beth: "\u2136",
      between: "\u226C",
      Bfr: "\u{1D505}",
      bfr: "\u{1D51F}",
      bigcap: "\u22C2",
      bigcirc: "\u25EF",
      bigcup: "\u22C3",
      bigodot: "\u2A00",
      bigoplus: "\u2A01",
      bigotimes: "\u2A02",
      bigsqcup: "\u2A06",
      bigstar: "\u2605",
      bigtriangledown: "\u25BD",
      bigtriangleup: "\u25B3",
      biguplus: "\u2A04",
      bigvee: "\u22C1",
      bigwedge: "\u22C0",
      bkarow: "\u290D",
      blacklozenge: "\u29EB",
      blacksquare: "\u25AA",
      blacktriangle: "\u25B4",
      blacktriangledown: "\u25BE",
      blacktriangleleft: "\u25C2",
      blacktriangleright: "\u25B8",
      blank: "\u2423",
      blk12: "\u2592",
      blk14: "\u2591",
      blk34: "\u2593",
      block: "\u2588",
      bne: "=\u20E5",
      bnequiv: "\u2261\u20E5",
      bNot: "\u2AED",
      bnot: "\u2310",
      Bopf: "\u{1D539}",
      bopf: "\u{1D553}",
      bot: "\u22A5",
      bottom: "\u22A5",
      bowtie: "\u22C8",
      boxbox: "\u29C9",
      boxDL: "\u2557",
      boxDl: "\u2556",
      boxdL: "\u2555",
      boxdl: "\u2510",
      boxDR: "\u2554",
      boxDr: "\u2553",
      boxdR: "\u2552",
      boxdr: "\u250C",
      boxH: "\u2550",
      boxh: "\u2500",
      boxHD: "\u2566",
      boxHd: "\u2564",
      boxhD: "\u2565",
      boxhd: "\u252C",
      boxHU: "\u2569",
      boxHu: "\u2567",
      boxhU: "\u2568",
      boxhu: "\u2534",
      boxminus: "\u229F",
      boxplus: "\u229E",
      boxtimes: "\u22A0",
      boxUL: "\u255D",
      boxUl: "\u255C",
      boxuL: "\u255B",
      boxul: "\u2518",
      boxUR: "\u255A",
      boxUr: "\u2559",
      boxuR: "\u2558",
      boxur: "\u2514",
      boxV: "\u2551",
      boxv: "\u2502",
      boxVH: "\u256C",
      boxVh: "\u256B",
      boxvH: "\u256A",
      boxvh: "\u253C",
      boxVL: "\u2563",
      boxVl: "\u2562",
      boxvL: "\u2561",
      boxvl: "\u2524",
      boxVR: "\u2560",
      boxVr: "\u255F",
      boxvR: "\u255E",
      boxvr: "\u251C",
      bprime: "\u2035",
      Breve: "\u02D8",
      breve: "\u02D8",
      brvbar: "\xA6",
      Bscr: "\u212C",
      bscr: "\u{1D4B7}",
      bsemi: "\u204F",
      bsim: "\u223D",
      bsime: "\u22CD",
      bsol: "\\",
      bsolb: "\u29C5",
      bsolhsub: "\u27C8",
      bull: "\u2022",
      bullet: "\u2022",
      bump: "\u224E",
      bumpE: "\u2AAE",
      bumpe: "\u224F",
      Bumpeq: "\u224E",
      bumpeq: "\u224F",
      Cacute: "\u0106",
      cacute: "\u0107",
      Cap: "\u22D2",
      cap: "\u2229",
      capand: "\u2A44",
      capbrcup: "\u2A49",
      capcap: "\u2A4B",
      capcup: "\u2A47",
      capdot: "\u2A40",
      CapitalDifferentialD: "\u2145",
      caps: "\u2229\uFE00",
      caret: "\u2041",
      caron: "\u02C7",
      Cayleys: "\u212D",
      ccaps: "\u2A4D",
      Ccaron: "\u010C",
      ccaron: "\u010D",
      Ccedil: "\xC7",
      ccedil: "\xE7",
      Ccirc: "\u0108",
      ccirc: "\u0109",
      Cconint: "\u2230",
      ccups: "\u2A4C",
      ccupssm: "\u2A50",
      Cdot: "\u010A",
      cdot: "\u010B",
      cedil: "\xB8",
      Cedilla: "\xB8",
      cemptyv: "\u29B2",
      cent: "\xA2",
      CenterDot: "\xB7",
      centerdot: "\xB7",
      Cfr: "\u212D",
      cfr: "\u{1D520}",
      CHcy: "\u0427",
      chcy: "\u0447",
      check: "\u2713",
      checkmark: "\u2713",
      Chi: "\u03A7",
      chi: "\u03C7",
      cir: "\u25CB",
      circ: "\u02C6",
      circeq: "\u2257",
      circlearrowleft: "\u21BA",
      circlearrowright: "\u21BB",
      circledast: "\u229B",
      circledcirc: "\u229A",
      circleddash: "\u229D",
      CircleDot: "\u2299",
      circledR: "\xAE",
      circledS: "\u24C8",
      CircleMinus: "\u2296",
      CirclePlus: "\u2295",
      CircleTimes: "\u2297",
      cirE: "\u29C3",
      cire: "\u2257",
      cirfnint: "\u2A10",
      cirmid: "\u2AEF",
      cirscir: "\u29C2",
      ClockwiseContourIntegral: "\u2232",
      CloseCurlyDoubleQuote: "\u201D",
      CloseCurlyQuote: "\u2019",
      clubs: "\u2663",
      clubsuit: "\u2663",
      Colon: "\u2237",
      colon: ":",
      Colone: "\u2A74",
      colone: "\u2254",
      coloneq: "\u2254",
      comma: ",",
      commat: "@",
      comp: "\u2201",
      compfn: "\u2218",
      complement: "\u2201",
      complexes: "\u2102",
      cong: "\u2245",
      congdot: "\u2A6D",
      Congruent: "\u2261",
      Conint: "\u222F",
      conint: "\u222E",
      ContourIntegral: "\u222E",
      Copf: "\u2102",
      copf: "\u{1D554}",
      coprod: "\u2210",
      Coproduct: "\u2210",
      COPY: "\xA9",
      copy: "\xA9",
      copysr: "\u2117",
      CounterClockwiseContourIntegral: "\u2233",
      crarr: "\u21B5",
      Cross: "\u2A2F",
      cross: "\u2717",
      Cscr: "\u{1D49E}",
      cscr: "\u{1D4B8}",
      csub: "\u2ACF",
      csube: "\u2AD1",
      csup: "\u2AD0",
      csupe: "\u2AD2",
      ctdot: "\u22EF",
      cudarrl: "\u2938",
      cudarrr: "\u2935",
      cuepr: "\u22DE",
      cuesc: "\u22DF",
      cularr: "\u21B6",
      cularrp: "\u293D",
      Cup: "\u22D3",
      cup: "\u222A",
      cupbrcap: "\u2A48",
      CupCap: "\u224D",
      cupcap: "\u2A46",
      cupcup: "\u2A4A",
      cupdot: "\u228D",
      cupor: "\u2A45",
      cups: "\u222A\uFE00",
      curarr: "\u21B7",
      curarrm: "\u293C",
      curlyeqprec: "\u22DE",
      curlyeqsucc: "\u22DF",
      curlyvee: "\u22CE",
      curlywedge: "\u22CF",
      curren: "\xA4",
      curvearrowleft: "\u21B6",
      curvearrowright: "\u21B7",
      cuvee: "\u22CE",
      cuwed: "\u22CF",
      cwconint: "\u2232",
      cwint: "\u2231",
      cylcty: "\u232D",
      Dagger: "\u2021",
      dagger: "\u2020",
      daleth: "\u2138",
      Darr: "\u21A1",
      dArr: "\u21D3",
      darr: "\u2193",
      dash: "\u2010",
      Dashv: "\u2AE4",
      dashv: "\u22A3",
      dbkarow: "\u290F",
      dblac: "\u02DD",
      Dcaron: "\u010E",
      dcaron: "\u010F",
      Dcy: "\u0414",
      dcy: "\u0434",
      DD: "\u2145",
      dd: "\u2146",
      ddagger: "\u2021",
      ddarr: "\u21CA",
      DDotrahd: "\u2911",
      ddotseq: "\u2A77",
      deg: "\xB0",
      Del: "\u2207",
      Delta: "\u0394",
      delta: "\u03B4",
      demptyv: "\u29B1",
      dfisht: "\u297F",
      Dfr: "\u{1D507}",
      dfr: "\u{1D521}",
      dHar: "\u2965",
      dharl: "\u21C3",
      dharr: "\u21C2",
      DiacriticalAcute: "\xB4",
      DiacriticalDot: "\u02D9",
      DiacriticalDoubleAcute: "\u02DD",
      DiacriticalGrave: "`",
      DiacriticalTilde: "\u02DC",
      diam: "\u22C4",
      Diamond: "\u22C4",
      diamond: "\u22C4",
      diamondsuit: "\u2666",
      diams: "\u2666",
      die: "\xA8",
      DifferentialD: "\u2146",
      digamma: "\u03DD",
      disin: "\u22F2",
      div: "\xF7",
      divide: "\xF7",
      divideontimes: "\u22C7",
      divonx: "\u22C7",
      DJcy: "\u0402",
      djcy: "\u0452",
      dlcorn: "\u231E",
      dlcrop: "\u230D",
      dollar: "$",
      Dopf: "\u{1D53B}",
      dopf: "\u{1D555}",
      Dot: "\xA8",
      dot: "\u02D9",
      DotDot: "\u20DC",
      doteq: "\u2250",
      doteqdot: "\u2251",
      DotEqual: "\u2250",
      dotminus: "\u2238",
      dotplus: "\u2214",
      dotsquare: "\u22A1",
      doublebarwedge: "\u2306",
      DoubleContourIntegral: "\u222F",
      DoubleDot: "\xA8",
      DoubleDownArrow: "\u21D3",
      DoubleLeftArrow: "\u21D0",
      DoubleLeftRightArrow: "\u21D4",
      DoubleLeftTee: "\u2AE4",
      DoubleLongLeftArrow: "\u27F8",
      DoubleLongLeftRightArrow: "\u27FA",
      DoubleLongRightArrow: "\u27F9",
      DoubleRightArrow: "\u21D2",
      DoubleRightTee: "\u22A8",
      DoubleUpArrow: "\u21D1",
      DoubleUpDownArrow: "\u21D5",
      DoubleVerticalBar: "\u2225",
      DownArrow: "\u2193",
      Downarrow: "\u21D3",
      downarrow: "\u2193",
      DownArrowBar: "\u2913",
      DownArrowUpArrow: "\u21F5",
      DownBreve: "\u0311",
      downdownarrows: "\u21CA",
      downharpoonleft: "\u21C3",
      downharpoonright: "\u21C2",
      DownLeftRightVector: "\u2950",
      DownLeftTeeVector: "\u295E",
      DownLeftVector: "\u21BD",
      DownLeftVectorBar: "\u2956",
      DownRightTeeVector: "\u295F",
      DownRightVector: "\u21C1",
      DownRightVectorBar: "\u2957",
      DownTee: "\u22A4",
      DownTeeArrow: "\u21A7",
      drbkarow: "\u2910",
      drcorn: "\u231F",
      drcrop: "\u230C",
      Dscr: "\u{1D49F}",
      dscr: "\u{1D4B9}",
      DScy: "\u0405",
      dscy: "\u0455",
      dsol: "\u29F6",
      Dstrok: "\u0110",
      dstrok: "\u0111",
      dtdot: "\u22F1",
      dtri: "\u25BF",
      dtrif: "\u25BE",
      duarr: "\u21F5",
      duhar: "\u296F",
      dwangle: "\u29A6",
      DZcy: "\u040F",
      dzcy: "\u045F",
      dzigrarr: "\u27FF",
      Eacute: "\xC9",
      eacute: "\xE9",
      easter: "\u2A6E",
      Ecaron: "\u011A",
      ecaron: "\u011B",
      ecir: "\u2256",
      Ecirc: "\xCA",
      ecirc: "\xEA",
      ecolon: "\u2255",
      Ecy: "\u042D",
      ecy: "\u044D",
      eDDot: "\u2A77",
      Edot: "\u0116",
      eDot: "\u2251",
      edot: "\u0117",
      ee: "\u2147",
      efDot: "\u2252",
      Efr: "\u{1D508}",
      efr: "\u{1D522}",
      eg: "\u2A9A",
      Egrave: "\xC8",
      egrave: "\xE8",
      egs: "\u2A96",
      egsdot: "\u2A98",
      el: "\u2A99",
      Element: "\u2208",
      elinters: "\u23E7",
      ell: "\u2113",
      els: "\u2A95",
      elsdot: "\u2A97",
      Emacr: "\u0112",
      emacr: "\u0113",
      empty: "\u2205",
      emptyset: "\u2205",
      EmptySmallSquare: "\u25FB",
      emptyv: "\u2205",
      EmptyVerySmallSquare: "\u25AB",
      emsp: "\u2003",
      emsp13: "\u2004",
      emsp14: "\u2005",
      ENG: "\u014A",
      eng: "\u014B",
      ensp: "\u2002",
      Eogon: "\u0118",
      eogon: "\u0119",
      Eopf: "\u{1D53C}",
      eopf: "\u{1D556}",
      epar: "\u22D5",
      eparsl: "\u29E3",
      eplus: "\u2A71",
      epsi: "\u03B5",
      Epsilon: "\u0395",
      epsilon: "\u03B5",
      epsiv: "\u03F5",
      eqcirc: "\u2256",
      eqcolon: "\u2255",
      eqsim: "\u2242",
      eqslantgtr: "\u2A96",
      eqslantless: "\u2A95",
      Equal: "\u2A75",
      equals: "=",
      EqualTilde: "\u2242",
      equest: "\u225F",
      Equilibrium: "\u21CC",
      equiv: "\u2261",
      equivDD: "\u2A78",
      eqvparsl: "\u29E5",
      erarr: "\u2971",
      erDot: "\u2253",
      Escr: "\u2130",
      escr: "\u212F",
      esdot: "\u2250",
      Esim: "\u2A73",
      esim: "\u2242",
      Eta: "\u0397",
      eta: "\u03B7",
      ETH: "\xD0",
      eth: "\xF0",
      Euml: "\xCB",
      euml: "\xEB",
      euro: "\u20AC",
      excl: "!",
      exist: "\u2203",
      Exists: "\u2203",
      expectation: "\u2130",
      ExponentialE: "\u2147",
      exponentiale: "\u2147",
      fallingdotseq: "\u2252",
      Fcy: "\u0424",
      fcy: "\u0444",
      female: "\u2640",
      ffilig: "\uFB03",
      fflig: "\uFB00",
      ffllig: "\uFB04",
      Ffr: "\u{1D509}",
      ffr: "\u{1D523}",
      filig: "\uFB01",
      FilledSmallSquare: "\u25FC",
      FilledVerySmallSquare: "\u25AA",
      fjlig: "fj",
      flat: "\u266D",
      fllig: "\uFB02",
      fltns: "\u25B1",
      fnof: "\u0192",
      Fopf: "\u{1D53D}",
      fopf: "\u{1D557}",
      ForAll: "\u2200",
      forall: "\u2200",
      fork: "\u22D4",
      forkv: "\u2AD9",
      Fouriertrf: "\u2131",
      fpartint: "\u2A0D",
      frac12: "\xBD",
      frac13: "\u2153",
      frac14: "\xBC",
      frac15: "\u2155",
      frac16: "\u2159",
      frac18: "\u215B",
      frac23: "\u2154",
      frac25: "\u2156",
      frac34: "\xBE",
      frac35: "\u2157",
      frac38: "\u215C",
      frac45: "\u2158",
      frac56: "\u215A",
      frac58: "\u215D",
      frac78: "\u215E",
      frasl: "\u2044",
      frown: "\u2322",
      Fscr: "\u2131",
      fscr: "\u{1D4BB}",
      gacute: "\u01F5",
      Gamma: "\u0393",
      gamma: "\u03B3",
      Gammad: "\u03DC",
      gammad: "\u03DD",
      gap: "\u2A86",
      Gbreve: "\u011E",
      gbreve: "\u011F",
      Gcedil: "\u0122",
      Gcirc: "\u011C",
      gcirc: "\u011D",
      Gcy: "\u0413",
      gcy: "\u0433",
      Gdot: "\u0120",
      gdot: "\u0121",
      gE: "\u2267",
      ge: "\u2265",
      gEl: "\u2A8C",
      gel: "\u22DB",
      geq: "\u2265",
      geqq: "\u2267",
      geqslant: "\u2A7E",
      ges: "\u2A7E",
      gescc: "\u2AA9",
      gesdot: "\u2A80",
      gesdoto: "\u2A82",
      gesdotol: "\u2A84",
      gesl: "\u22DB\uFE00",
      gesles: "\u2A94",
      Gfr: "\u{1D50A}",
      gfr: "\u{1D524}",
      Gg: "\u22D9",
      gg: "\u226B",
      ggg: "\u22D9",
      gimel: "\u2137",
      GJcy: "\u0403",
      gjcy: "\u0453",
      gl: "\u2277",
      gla: "\u2AA5",
      glE: "\u2A92",
      glj: "\u2AA4",
      gnap: "\u2A8A",
      gnapprox: "\u2A8A",
      gnE: "\u2269",
      gne: "\u2A88",
      gneq: "\u2A88",
      gneqq: "\u2269",
      gnsim: "\u22E7",
      Gopf: "\u{1D53E}",
      gopf: "\u{1D558}",
      grave: "`",
      GreaterEqual: "\u2265",
      GreaterEqualLess: "\u22DB",
      GreaterFullEqual: "\u2267",
      GreaterGreater: "\u2AA2",
      GreaterLess: "\u2277",
      GreaterSlantEqual: "\u2A7E",
      GreaterTilde: "\u2273",
      Gscr: "\u{1D4A2}",
      gscr: "\u210A",
      gsim: "\u2273",
      gsime: "\u2A8E",
      gsiml: "\u2A90",
      Gt: "\u226B",
      GT: ">",
      gt: ">",
      gtcc: "\u2AA7",
      gtcir: "\u2A7A",
      gtdot: "\u22D7",
      gtlPar: "\u2995",
      gtquest: "\u2A7C",
      gtrapprox: "\u2A86",
      gtrarr: "\u2978",
      gtrdot: "\u22D7",
      gtreqless: "\u22DB",
      gtreqqless: "\u2A8C",
      gtrless: "\u2277",
      gtrsim: "\u2273",
      gvertneqq: "\u2269\uFE00",
      gvnE: "\u2269\uFE00",
      Hacek: "\u02C7",
      hairsp: "\u200A",
      half: "\xBD",
      hamilt: "\u210B",
      HARDcy: "\u042A",
      hardcy: "\u044A",
      hArr: "\u21D4",
      harr: "\u2194",
      harrcir: "\u2948",
      harrw: "\u21AD",
      Hat: "^",
      hbar: "\u210F",
      Hcirc: "\u0124",
      hcirc: "\u0125",
      hearts: "\u2665",
      heartsuit: "\u2665",
      hellip: "\u2026",
      hercon: "\u22B9",
      Hfr: "\u210C",
      hfr: "\u{1D525}",
      HilbertSpace: "\u210B",
      hksearow: "\u2925",
      hkswarow: "\u2926",
      hoarr: "\u21FF",
      homtht: "\u223B",
      hookleftarrow: "\u21A9",
      hookrightarrow: "\u21AA",
      Hopf: "\u210D",
      hopf: "\u{1D559}",
      horbar: "\u2015",
      HorizontalLine: "\u2500",
      Hscr: "\u210B",
      hscr: "\u{1D4BD}",
      hslash: "\u210F",
      Hstrok: "\u0126",
      hstrok: "\u0127",
      HumpDownHump: "\u224E",
      HumpEqual: "\u224F",
      hybull: "\u2043",
      hyphen: "\u2010",
      Iacute: "\xCD",
      iacute: "\xED",
      ic: "\u2063",
      Icirc: "\xCE",
      icirc: "\xEE",
      Icy: "\u0418",
      icy: "\u0438",
      Idot: "\u0130",
      IEcy: "\u0415",
      iecy: "\u0435",
      iexcl: "\xA1",
      iff: "\u21D4",
      Ifr: "\u2111",
      ifr: "\u{1D526}",
      Igrave: "\xCC",
      igrave: "\xEC",
      ii: "\u2148",
      iiiint: "\u2A0C",
      iiint: "\u222D",
      iinfin: "\u29DC",
      iiota: "\u2129",
      IJlig: "\u0132",
      ijlig: "\u0133",
      Im: "\u2111",
      Imacr: "\u012A",
      imacr: "\u012B",
      image: "\u2111",
      ImaginaryI: "\u2148",
      imagline: "\u2110",
      imagpart: "\u2111",
      imath: "\u0131",
      imof: "\u22B7",
      imped: "\u01B5",
      Implies: "\u21D2",
      in: "\u2208",
      incare: "\u2105",
      infin: "\u221E",
      infintie: "\u29DD",
      inodot: "\u0131",
      Int: "\u222C",
      int: "\u222B",
      intcal: "\u22BA",
      integers: "\u2124",
      Integral: "\u222B",
      intercal: "\u22BA",
      Intersection: "\u22C2",
      intlarhk: "\u2A17",
      intprod: "\u2A3C",
      InvisibleComma: "\u2063",
      InvisibleTimes: "\u2062",
      IOcy: "\u0401",
      iocy: "\u0451",
      Iogon: "\u012E",
      iogon: "\u012F",
      Iopf: "\u{1D540}",
      iopf: "\u{1D55A}",
      Iota: "\u0399",
      iota: "\u03B9",
      iprod: "\u2A3C",
      iquest: "\xBF",
      Iscr: "\u2110",
      iscr: "\u{1D4BE}",
      isin: "\u2208",
      isindot: "\u22F5",
      isinE: "\u22F9",
      isins: "\u22F4",
      isinsv: "\u22F3",
      isinv: "\u2208",
      it: "\u2062",
      Itilde: "\u0128",
      itilde: "\u0129",
      Iukcy: "\u0406",
      iukcy: "\u0456",
      Iuml: "\xCF",
      iuml: "\xEF",
      Jcirc: "\u0134",
      jcirc: "\u0135",
      Jcy: "\u0419",
      jcy: "\u0439",
      Jfr: "\u{1D50D}",
      jfr: "\u{1D527}",
      jmath: "\u0237",
      Jopf: "\u{1D541}",
      jopf: "\u{1D55B}",
      Jscr: "\u{1D4A5}",
      jscr: "\u{1D4BF}",
      Jsercy: "\u0408",
      jsercy: "\u0458",
      Jukcy: "\u0404",
      jukcy: "\u0454",
      Kappa: "\u039A",
      kappa: "\u03BA",
      kappav: "\u03F0",
      Kcedil: "\u0136",
      kcedil: "\u0137",
      Kcy: "\u041A",
      kcy: "\u043A",
      Kfr: "\u{1D50E}",
      kfr: "\u{1D528}",
      kgreen: "\u0138",
      KHcy: "\u0425",
      khcy: "\u0445",
      KJcy: "\u040C",
      kjcy: "\u045C",
      Kopf: "\u{1D542}",
      kopf: "\u{1D55C}",
      Kscr: "\u{1D4A6}",
      kscr: "\u{1D4C0}",
      lAarr: "\u21DA",
      Lacute: "\u0139",
      lacute: "\u013A",
      laemptyv: "\u29B4",
      lagran: "\u2112",
      Lambda: "\u039B",
      lambda: "\u03BB",
      Lang: "\u27EA",
      lang: "\u27E8",
      langd: "\u2991",
      langle: "\u27E8",
      lap: "\u2A85",
      Laplacetrf: "\u2112",
      laquo: "\xAB",
      Larr: "\u219E",
      lArr: "\u21D0",
      larr: "\u2190",
      larrb: "\u21E4",
      larrbfs: "\u291F",
      larrfs: "\u291D",
      larrhk: "\u21A9",
      larrlp: "\u21AB",
      larrpl: "\u2939",
      larrsim: "\u2973",
      larrtl: "\u21A2",
      lat: "\u2AAB",
      lAtail: "\u291B",
      latail: "\u2919",
      late: "\u2AAD",
      lates: "\u2AAD\uFE00",
      lBarr: "\u290E",
      lbarr: "\u290C",
      lbbrk: "\u2772",
      lbrace: "{",
      lbrack: "[",
      lbrke: "\u298B",
      lbrksld: "\u298F",
      lbrkslu: "\u298D",
      Lcaron: "\u013D",
      lcaron: "\u013E",
      Lcedil: "\u013B",
      lcedil: "\u013C",
      lceil: "\u2308",
      lcub: "{",
      Lcy: "\u041B",
      lcy: "\u043B",
      ldca: "\u2936",
      ldquo: "\u201C",
      ldquor: "\u201E",
      ldrdhar: "\u2967",
      ldrushar: "\u294B",
      ldsh: "\u21B2",
      lE: "\u2266",
      le: "\u2264",
      LeftAngleBracket: "\u27E8",
      LeftArrow: "\u2190",
      Leftarrow: "\u21D0",
      leftarrow: "\u2190",
      LeftArrowBar: "\u21E4",
      LeftArrowRightArrow: "\u21C6",
      leftarrowtail: "\u21A2",
      LeftCeiling: "\u2308",
      LeftDoubleBracket: "\u27E6",
      LeftDownTeeVector: "\u2961",
      LeftDownVector: "\u21C3",
      LeftDownVectorBar: "\u2959",
      LeftFloor: "\u230A",
      leftharpoondown: "\u21BD",
      leftharpoonup: "\u21BC",
      leftleftarrows: "\u21C7",
      LeftRightArrow: "\u2194",
      Leftrightarrow: "\u21D4",
      leftrightarrow: "\u2194",
      leftrightarrows: "\u21C6",
      leftrightharpoons: "\u21CB",
      leftrightsquigarrow: "\u21AD",
      LeftRightVector: "\u294E",
      LeftTee: "\u22A3",
      LeftTeeArrow: "\u21A4",
      LeftTeeVector: "\u295A",
      leftthreetimes: "\u22CB",
      LeftTriangle: "\u22B2",
      LeftTriangleBar: "\u29CF",
      LeftTriangleEqual: "\u22B4",
      LeftUpDownVector: "\u2951",
      LeftUpTeeVector: "\u2960",
      LeftUpVector: "\u21BF",
      LeftUpVectorBar: "\u2958",
      LeftVector: "\u21BC",
      LeftVectorBar: "\u2952",
      lEg: "\u2A8B",
      leg: "\u22DA",
      leq: "\u2264",
      leqq: "\u2266",
      leqslant: "\u2A7D",
      les: "\u2A7D",
      lescc: "\u2AA8",
      lesdot: "\u2A7F",
      lesdoto: "\u2A81",
      lesdotor: "\u2A83",
      lesg: "\u22DA\uFE00",
      lesges: "\u2A93",
      lessapprox: "\u2A85",
      lessdot: "\u22D6",
      lesseqgtr: "\u22DA",
      lesseqqgtr: "\u2A8B",
      LessEqualGreater: "\u22DA",
      LessFullEqual: "\u2266",
      LessGreater: "\u2276",
      lessgtr: "\u2276",
      LessLess: "\u2AA1",
      lesssim: "\u2272",
      LessSlantEqual: "\u2A7D",
      LessTilde: "\u2272",
      lfisht: "\u297C",
      lfloor: "\u230A",
      Lfr: "\u{1D50F}",
      lfr: "\u{1D529}",
      lg: "\u2276",
      lgE: "\u2A91",
      lHar: "\u2962",
      lhard: "\u21BD",
      lharu: "\u21BC",
      lharul: "\u296A",
      lhblk: "\u2584",
      LJcy: "\u0409",
      ljcy: "\u0459",
      Ll: "\u22D8",
      ll: "\u226A",
      llarr: "\u21C7",
      llcorner: "\u231E",
      Lleftarrow: "\u21DA",
      llhard: "\u296B",
      lltri: "\u25FA",
      Lmidot: "\u013F",
      lmidot: "\u0140",
      lmoust: "\u23B0",
      lmoustache: "\u23B0",
      lnap: "\u2A89",
      lnapprox: "\u2A89",
      lnE: "\u2268",
      lne: "\u2A87",
      lneq: "\u2A87",
      lneqq: "\u2268",
      lnsim: "\u22E6",
      loang: "\u27EC",
      loarr: "\u21FD",
      lobrk: "\u27E6",
      LongLeftArrow: "\u27F5",
      Longleftarrow: "\u27F8",
      longleftarrow: "\u27F5",
      LongLeftRightArrow: "\u27F7",
      Longleftrightarrow: "\u27FA",
      longleftrightarrow: "\u27F7",
      longmapsto: "\u27FC",
      LongRightArrow: "\u27F6",
      Longrightarrow: "\u27F9",
      longrightarrow: "\u27F6",
      looparrowleft: "\u21AB",
      looparrowright: "\u21AC",
      lopar: "\u2985",
      Lopf: "\u{1D543}",
      lopf: "\u{1D55D}",
      loplus: "\u2A2D",
      lotimes: "\u2A34",
      lowast: "\u2217",
      lowbar: "_",
      LowerLeftArrow: "\u2199",
      LowerRightArrow: "\u2198",
      loz: "\u25CA",
      lozenge: "\u25CA",
      lozf: "\u29EB",
      lpar: "(",
      lparlt: "\u2993",
      lrarr: "\u21C6",
      lrcorner: "\u231F",
      lrhar: "\u21CB",
      lrhard: "\u296D",
      lrm: "\u200E",
      lrtri: "\u22BF",
      lsaquo: "\u2039",
      Lscr: "\u2112",
      lscr: "\u{1D4C1}",
      Lsh: "\u21B0",
      lsh: "\u21B0",
      lsim: "\u2272",
      lsime: "\u2A8D",
      lsimg: "\u2A8F",
      lsqb: "[",
      lsquo: "\u2018",
      lsquor: "\u201A",
      Lstrok: "\u0141",
      lstrok: "\u0142",
      Lt: "\u226A",
      LT: "<",
      lt: "<",
      ltcc: "\u2AA6",
      ltcir: "\u2A79",
      ltdot: "\u22D6",
      lthree: "\u22CB",
      ltimes: "\u22C9",
      ltlarr: "\u2976",
      ltquest: "\u2A7B",
      ltri: "\u25C3",
      ltrie: "\u22B4",
      ltrif: "\u25C2",
      ltrPar: "\u2996",
      lurdshar: "\u294A",
      luruhar: "\u2966",
      lvertneqq: "\u2268\uFE00",
      lvnE: "\u2268\uFE00",
      macr: "\xAF",
      male: "\u2642",
      malt: "\u2720",
      maltese: "\u2720",
      Map: "\u2905",
      map: "\u21A6",
      mapsto: "\u21A6",
      mapstodown: "\u21A7",
      mapstoleft: "\u21A4",
      mapstoup: "\u21A5",
      marker: "\u25AE",
      mcomma: "\u2A29",
      Mcy: "\u041C",
      mcy: "\u043C",
      mdash: "\u2014",
      mDDot: "\u223A",
      measuredangle: "\u2221",
      MediumSpace: "\u205F",
      Mellintrf: "\u2133",
      Mfr: "\u{1D510}",
      mfr: "\u{1D52A}",
      mho: "\u2127",
      micro: "\xB5",
      mid: "\u2223",
      midast: "*",
      midcir: "\u2AF0",
      middot: "\xB7",
      minus: "\u2212",
      minusb: "\u229F",
      minusd: "\u2238",
      minusdu: "\u2A2A",
      MinusPlus: "\u2213",
      mlcp: "\u2ADB",
      mldr: "\u2026",
      mnplus: "\u2213",
      models: "\u22A7",
      Mopf: "\u{1D544}",
      mopf: "\u{1D55E}",
      mp: "\u2213",
      Mscr: "\u2133",
      mscr: "\u{1D4C2}",
      mstpos: "\u223E",
      Mu: "\u039C",
      mu: "\u03BC",
      multimap: "\u22B8",
      mumap: "\u22B8",
      nabla: "\u2207",
      Nacute: "\u0143",
      nacute: "\u0144",
      nang: "\u2220\u20D2",
      nap: "\u2249",
      napE: "\u2A70\u0338",
      napid: "\u224B\u0338",
      napos: "\u0149",
      napprox: "\u2249",
      natur: "\u266E",
      natural: "\u266E",
      naturals: "\u2115",
      nbsp: "\xA0",
      nbump: "\u224E\u0338",
      nbumpe: "\u224F\u0338",
      ncap: "\u2A43",
      Ncaron: "\u0147",
      ncaron: "\u0148",
      Ncedil: "\u0145",
      ncedil: "\u0146",
      ncong: "\u2247",
      ncongdot: "\u2A6D\u0338",
      ncup: "\u2A42",
      Ncy: "\u041D",
      ncy: "\u043D",
      ndash: "\u2013",
      ne: "\u2260",
      nearhk: "\u2924",
      neArr: "\u21D7",
      nearr: "\u2197",
      nearrow: "\u2197",
      nedot: "\u2250\u0338",
      NegativeMediumSpace: "\u200B",
      NegativeThickSpace: "\u200B",
      NegativeThinSpace: "\u200B",
      NegativeVeryThinSpace: "\u200B",
      nequiv: "\u2262",
      nesear: "\u2928",
      nesim: "\u2242\u0338",
      NestedGreaterGreater: "\u226B",
      NestedLessLess: "\u226A",
      NewLine: "\n",
      nexist: "\u2204",
      nexists: "\u2204",
      Nfr: "\u{1D511}",
      nfr: "\u{1D52B}",
      ngE: "\u2267\u0338",
      nge: "\u2271",
      ngeq: "\u2271",
      ngeqq: "\u2267\u0338",
      ngeqslant: "\u2A7E\u0338",
      nges: "\u2A7E\u0338",
      nGg: "\u22D9\u0338",
      ngsim: "\u2275",
      nGt: "\u226B\u20D2",
      ngt: "\u226F",
      ngtr: "\u226F",
      nGtv: "\u226B\u0338",
      nhArr: "\u21CE",
      nharr: "\u21AE",
      nhpar: "\u2AF2",
      ni: "\u220B",
      nis: "\u22FC",
      nisd: "\u22FA",
      niv: "\u220B",
      NJcy: "\u040A",
      njcy: "\u045A",
      nlArr: "\u21CD",
      nlarr: "\u219A",
      nldr: "\u2025",
      nlE: "\u2266\u0338",
      nle: "\u2270",
      nLeftarrow: "\u21CD",
      nleftarrow: "\u219A",
      nLeftrightarrow: "\u21CE",
      nleftrightarrow: "\u21AE",
      nleq: "\u2270",
      nleqq: "\u2266\u0338",
      nleqslant: "\u2A7D\u0338",
      nles: "\u2A7D\u0338",
      nless: "\u226E",
      nLl: "\u22D8\u0338",
      nlsim: "\u2274",
      nLt: "\u226A\u20D2",
      nlt: "\u226E",
      nltri: "\u22EA",
      nltrie: "\u22EC",
      nLtv: "\u226A\u0338",
      nmid: "\u2224",
      NoBreak: "\u2060",
      NonBreakingSpace: "\xA0",
      Nopf: "\u2115",
      nopf: "\u{1D55F}",
      Not: "\u2AEC",
      not: "\xAC",
      NotCongruent: "\u2262",
      NotCupCap: "\u226D",
      NotDoubleVerticalBar: "\u2226",
      NotElement: "\u2209",
      NotEqual: "\u2260",
      NotEqualTilde: "\u2242\u0338",
      NotExists: "\u2204",
      NotGreater: "\u226F",
      NotGreaterEqual: "\u2271",
      NotGreaterFullEqual: "\u2267\u0338",
      NotGreaterGreater: "\u226B\u0338",
      NotGreaterLess: "\u2279",
      NotGreaterSlantEqual: "\u2A7E\u0338",
      NotGreaterTilde: "\u2275",
      NotHumpDownHump: "\u224E\u0338",
      NotHumpEqual: "\u224F\u0338",
      notin: "\u2209",
      notindot: "\u22F5\u0338",
      notinE: "\u22F9\u0338",
      notinva: "\u2209",
      notinvb: "\u22F7",
      notinvc: "\u22F6",
      NotLeftTriangle: "\u22EA",
      NotLeftTriangleBar: "\u29CF\u0338",
      NotLeftTriangleEqual: "\u22EC",
      NotLess: "\u226E",
      NotLessEqual: "\u2270",
      NotLessGreater: "\u2278",
      NotLessLess: "\u226A\u0338",
      NotLessSlantEqual: "\u2A7D\u0338",
      NotLessTilde: "\u2274",
      NotNestedGreaterGreater: "\u2AA2\u0338",
      NotNestedLessLess: "\u2AA1\u0338",
      notni: "\u220C",
      notniva: "\u220C",
      notnivb: "\u22FE",
      notnivc: "\u22FD",
      NotPrecedes: "\u2280",
      NotPrecedesEqual: "\u2AAF\u0338",
      NotPrecedesSlantEqual: "\u22E0",
      NotReverseElement: "\u220C",
      NotRightTriangle: "\u22EB",
      NotRightTriangleBar: "\u29D0\u0338",
      NotRightTriangleEqual: "\u22ED",
      NotSquareSubset: "\u228F\u0338",
      NotSquareSubsetEqual: "\u22E2",
      NotSquareSuperset: "\u2290\u0338",
      NotSquareSupersetEqual: "\u22E3",
      NotSubset: "\u2282\u20D2",
      NotSubsetEqual: "\u2288",
      NotSucceeds: "\u2281",
      NotSucceedsEqual: "\u2AB0\u0338",
      NotSucceedsSlantEqual: "\u22E1",
      NotSucceedsTilde: "\u227F\u0338",
      NotSuperset: "\u2283\u20D2",
      NotSupersetEqual: "\u2289",
      NotTilde: "\u2241",
      NotTildeEqual: "\u2244",
      NotTildeFullEqual: "\u2247",
      NotTildeTilde: "\u2249",
      NotVerticalBar: "\u2224",
      npar: "\u2226",
      nparallel: "\u2226",
      nparsl: "\u2AFD\u20E5",
      npart: "\u2202\u0338",
      npolint: "\u2A14",
      npr: "\u2280",
      nprcue: "\u22E0",
      npre: "\u2AAF\u0338",
      nprec: "\u2280",
      npreceq: "\u2AAF\u0338",
      nrArr: "\u21CF",
      nrarr: "\u219B",
      nrarrc: "\u2933\u0338",
      nrarrw: "\u219D\u0338",
      nRightarrow: "\u21CF",
      nrightarrow: "\u219B",
      nrtri: "\u22EB",
      nrtrie: "\u22ED",
      nsc: "\u2281",
      nsccue: "\u22E1",
      nsce: "\u2AB0\u0338",
      Nscr: "\u{1D4A9}",
      nscr: "\u{1D4C3}",
      nshortmid: "\u2224",
      nshortparallel: "\u2226",
      nsim: "\u2241",
      nsime: "\u2244",
      nsimeq: "\u2244",
      nsmid: "\u2224",
      nspar: "\u2226",
      nsqsube: "\u22E2",
      nsqsupe: "\u22E3",
      nsub: "\u2284",
      nsubE: "\u2AC5\u0338",
      nsube: "\u2288",
      nsubset: "\u2282\u20D2",
      nsubseteq: "\u2288",
      nsubseteqq: "\u2AC5\u0338",
      nsucc: "\u2281",
      nsucceq: "\u2AB0\u0338",
      nsup: "\u2285",
      nsupE: "\u2AC6\u0338",
      nsupe: "\u2289",
      nsupset: "\u2283\u20D2",
      nsupseteq: "\u2289",
      nsupseteqq: "\u2AC6\u0338",
      ntgl: "\u2279",
      Ntilde: "\xD1",
      ntilde: "\xF1",
      ntlg: "\u2278",
      ntriangleleft: "\u22EA",
      ntrianglelefteq: "\u22EC",
      ntriangleright: "\u22EB",
      ntrianglerighteq: "\u22ED",
      Nu: "\u039D",
      nu: "\u03BD",
      num: "#",
      numero: "\u2116",
      numsp: "\u2007",
      nvap: "\u224D\u20D2",
      nVDash: "\u22AF",
      nVdash: "\u22AE",
      nvDash: "\u22AD",
      nvdash: "\u22AC",
      nvge: "\u2265\u20D2",
      nvgt: ">\u20D2",
      nvHarr: "\u2904",
      nvinfin: "\u29DE",
      nvlArr: "\u2902",
      nvle: "\u2264\u20D2",
      nvlt: "<\u20D2",
      nvltrie: "\u22B4\u20D2",
      nvrArr: "\u2903",
      nvrtrie: "\u22B5\u20D2",
      nvsim: "\u223C\u20D2",
      nwarhk: "\u2923",
      nwArr: "\u21D6",
      nwarr: "\u2196",
      nwarrow: "\u2196",
      nwnear: "\u2927",
      Oacute: "\xD3",
      oacute: "\xF3",
      oast: "\u229B",
      ocir: "\u229A",
      Ocirc: "\xD4",
      ocirc: "\xF4",
      Ocy: "\u041E",
      ocy: "\u043E",
      odash: "\u229D",
      Odblac: "\u0150",
      odblac: "\u0151",
      odiv: "\u2A38",
      odot: "\u2299",
      odsold: "\u29BC",
      OElig: "\u0152",
      oelig: "\u0153",
      ofcir: "\u29BF",
      Ofr: "\u{1D512}",
      ofr: "\u{1D52C}",
      ogon: "\u02DB",
      Ograve: "\xD2",
      ograve: "\xF2",
      ogt: "\u29C1",
      ohbar: "\u29B5",
      ohm: "\u03A9",
      oint: "\u222E",
      olarr: "\u21BA",
      olcir: "\u29BE",
      olcross: "\u29BB",
      oline: "\u203E",
      olt: "\u29C0",
      Omacr: "\u014C",
      omacr: "\u014D",
      Omega: "\u03A9",
      omega: "\u03C9",
      Omicron: "\u039F",
      omicron: "\u03BF",
      omid: "\u29B6",
      ominus: "\u2296",
      Oopf: "\u{1D546}",
      oopf: "\u{1D560}",
      opar: "\u29B7",
      OpenCurlyDoubleQuote: "\u201C",
      OpenCurlyQuote: "\u2018",
      operp: "\u29B9",
      oplus: "\u2295",
      Or: "\u2A54",
      or: "\u2228",
      orarr: "\u21BB",
      ord: "\u2A5D",
      order: "\u2134",
      orderof: "\u2134",
      ordf: "\xAA",
      ordm: "\xBA",
      origof: "\u22B6",
      oror: "\u2A56",
      orslope: "\u2A57",
      orv: "\u2A5B",
      oS: "\u24C8",
      Oscr: "\u{1D4AA}",
      oscr: "\u2134",
      Oslash: "\xD8",
      oslash: "\xF8",
      osol: "\u2298",
      Otilde: "\xD5",
      otilde: "\xF5",
      Otimes: "\u2A37",
      otimes: "\u2297",
      otimesas: "\u2A36",
      Ouml: "\xD6",
      ouml: "\xF6",
      ovbar: "\u233D",
      OverBar: "\u203E",
      OverBrace: "\u23DE",
      OverBracket: "\u23B4",
      OverParenthesis: "\u23DC",
      par: "\u2225",
      para: "\xB6",
      parallel: "\u2225",
      parsim: "\u2AF3",
      parsl: "\u2AFD",
      part: "\u2202",
      PartialD: "\u2202",
      Pcy: "\u041F",
      pcy: "\u043F",
      percnt: "%",
      period: ".",
      permil: "\u2030",
      perp: "\u22A5",
      pertenk: "\u2031",
      Pfr: "\u{1D513}",
      pfr: "\u{1D52D}",
      Phi: "\u03A6",
      phi: "\u03C6",
      phiv: "\u03D5",
      phmmat: "\u2133",
      phone: "\u260E",
      Pi: "\u03A0",
      pi: "\u03C0",
      pitchfork: "\u22D4",
      piv: "\u03D6",
      planck: "\u210F",
      planckh: "\u210E",
      plankv: "\u210F",
      plus: "+",
      plusacir: "\u2A23",
      plusb: "\u229E",
      pluscir: "\u2A22",
      plusdo: "\u2214",
      plusdu: "\u2A25",
      pluse: "\u2A72",
      PlusMinus: "\xB1",
      plusmn: "\xB1",
      plussim: "\u2A26",
      plustwo: "\u2A27",
      pm: "\xB1",
      Poincareplane: "\u210C",
      pointint: "\u2A15",
      Popf: "\u2119",
      popf: "\u{1D561}",
      pound: "\xA3",
      Pr: "\u2ABB",
      pr: "\u227A",
      prap: "\u2AB7",
      prcue: "\u227C",
      prE: "\u2AB3",
      pre: "\u2AAF",
      prec: "\u227A",
      precapprox: "\u2AB7",
      preccurlyeq: "\u227C",
      Precedes: "\u227A",
      PrecedesEqual: "\u2AAF",
      PrecedesSlantEqual: "\u227C",
      PrecedesTilde: "\u227E",
      preceq: "\u2AAF",
      precnapprox: "\u2AB9",
      precneqq: "\u2AB5",
      precnsim: "\u22E8",
      precsim: "\u227E",
      Prime: "\u2033",
      prime: "\u2032",
      primes: "\u2119",
      prnap: "\u2AB9",
      prnE: "\u2AB5",
      prnsim: "\u22E8",
      prod: "\u220F",
      Product: "\u220F",
      profalar: "\u232E",
      profline: "\u2312",
      profsurf: "\u2313",
      prop: "\u221D",
      Proportion: "\u2237",
      Proportional: "\u221D",
      propto: "\u221D",
      prsim: "\u227E",
      prurel: "\u22B0",
      Pscr: "\u{1D4AB}",
      pscr: "\u{1D4C5}",
      Psi: "\u03A8",
      psi: "\u03C8",
      puncsp: "\u2008",
      Qfr: "\u{1D514}",
      qfr: "\u{1D52E}",
      qint: "\u2A0C",
      Qopf: "\u211A",
      qopf: "\u{1D562}",
      qprime: "\u2057",
      Qscr: "\u{1D4AC}",
      qscr: "\u{1D4C6}",
      quaternions: "\u210D",
      quatint: "\u2A16",
      quest: "?",
      questeq: "\u225F",
      QUOT: '"',
      quot: '"',
      rAarr: "\u21DB",
      race: "\u223D\u0331",
      Racute: "\u0154",
      racute: "\u0155",
      radic: "\u221A",
      raemptyv: "\u29B3",
      Rang: "\u27EB",
      rang: "\u27E9",
      rangd: "\u2992",
      range: "\u29A5",
      rangle: "\u27E9",
      raquo: "\xBB",
      Rarr: "\u21A0",
      rArr: "\u21D2",
      rarr: "\u2192",
      rarrap: "\u2975",
      rarrb: "\u21E5",
      rarrbfs: "\u2920",
      rarrc: "\u2933",
      rarrfs: "\u291E",
      rarrhk: "\u21AA",
      rarrlp: "\u21AC",
      rarrpl: "\u2945",
      rarrsim: "\u2974",
      Rarrtl: "\u2916",
      rarrtl: "\u21A3",
      rarrw: "\u219D",
      rAtail: "\u291C",
      ratail: "\u291A",
      ratio: "\u2236",
      rationals: "\u211A",
      RBarr: "\u2910",
      rBarr: "\u290F",
      rbarr: "\u290D",
      rbbrk: "\u2773",
      rbrace: "}",
      rbrack: "]",
      rbrke: "\u298C",
      rbrksld: "\u298E",
      rbrkslu: "\u2990",
      Rcaron: "\u0158",
      rcaron: "\u0159",
      Rcedil: "\u0156",
      rcedil: "\u0157",
      rceil: "\u2309",
      rcub: "}",
      Rcy: "\u0420",
      rcy: "\u0440",
      rdca: "\u2937",
      rdldhar: "\u2969",
      rdquo: "\u201D",
      rdquor: "\u201D",
      rdsh: "\u21B3",
      Re: "\u211C",
      real: "\u211C",
      realine: "\u211B",
      realpart: "\u211C",
      reals: "\u211D",
      rect: "\u25AD",
      REG: "\xAE",
      reg: "\xAE",
      ReverseElement: "\u220B",
      ReverseEquilibrium: "\u21CB",
      ReverseUpEquilibrium: "\u296F",
      rfisht: "\u297D",
      rfloor: "\u230B",
      Rfr: "\u211C",
      rfr: "\u{1D52F}",
      rHar: "\u2964",
      rhard: "\u21C1",
      rharu: "\u21C0",
      rharul: "\u296C",
      Rho: "\u03A1",
      rho: "\u03C1",
      rhov: "\u03F1",
      RightAngleBracket: "\u27E9",
      RightArrow: "\u2192",
      Rightarrow: "\u21D2",
      rightarrow: "\u2192",
      RightArrowBar: "\u21E5",
      RightArrowLeftArrow: "\u21C4",
      rightarrowtail: "\u21A3",
      RightCeiling: "\u2309",
      RightDoubleBracket: "\u27E7",
      RightDownTeeVector: "\u295D",
      RightDownVector: "\u21C2",
      RightDownVectorBar: "\u2955",
      RightFloor: "\u230B",
      rightharpoondown: "\u21C1",
      rightharpoonup: "\u21C0",
      rightleftarrows: "\u21C4",
      rightleftharpoons: "\u21CC",
      rightrightarrows: "\u21C9",
      rightsquigarrow: "\u219D",
      RightTee: "\u22A2",
      RightTeeArrow: "\u21A6",
      RightTeeVector: "\u295B",
      rightthreetimes: "\u22CC",
      RightTriangle: "\u22B3",
      RightTriangleBar: "\u29D0",
      RightTriangleEqual: "\u22B5",
      RightUpDownVector: "\u294F",
      RightUpTeeVector: "\u295C",
      RightUpVector: "\u21BE",
      RightUpVectorBar: "\u2954",
      RightVector: "\u21C0",
      RightVectorBar: "\u2953",
      ring: "\u02DA",
      risingdotseq: "\u2253",
      rlarr: "\u21C4",
      rlhar: "\u21CC",
      rlm: "\u200F",
      rmoust: "\u23B1",
      rmoustache: "\u23B1",
      rnmid: "\u2AEE",
      roang: "\u27ED",
      roarr: "\u21FE",
      robrk: "\u27E7",
      ropar: "\u2986",
      Ropf: "\u211D",
      ropf: "\u{1D563}",
      roplus: "\u2A2E",
      rotimes: "\u2A35",
      RoundImplies: "\u2970",
      rpar: ")",
      rpargt: "\u2994",
      rppolint: "\u2A12",
      rrarr: "\u21C9",
      Rrightarrow: "\u21DB",
      rsaquo: "\u203A",
      Rscr: "\u211B",
      rscr: "\u{1D4C7}",
      Rsh: "\u21B1",
      rsh: "\u21B1",
      rsqb: "]",
      rsquo: "\u2019",
      rsquor: "\u2019",
      rthree: "\u22CC",
      rtimes: "\u22CA",
      rtri: "\u25B9",
      rtrie: "\u22B5",
      rtrif: "\u25B8",
      rtriltri: "\u29CE",
      RuleDelayed: "\u29F4",
      ruluhar: "\u2968",
      rx: "\u211E",
      Sacute: "\u015A",
      sacute: "\u015B",
      sbquo: "\u201A",
      Sc: "\u2ABC",
      sc: "\u227B",
      scap: "\u2AB8",
      Scaron: "\u0160",
      scaron: "\u0161",
      sccue: "\u227D",
      scE: "\u2AB4",
      sce: "\u2AB0",
      Scedil: "\u015E",
      scedil: "\u015F",
      Scirc: "\u015C",
      scirc: "\u015D",
      scnap: "\u2ABA",
      scnE: "\u2AB6",
      scnsim: "\u22E9",
      scpolint: "\u2A13",
      scsim: "\u227F",
      Scy: "\u0421",
      scy: "\u0441",
      sdot: "\u22C5",
      sdotb: "\u22A1",
      sdote: "\u2A66",
      searhk: "\u2925",
      seArr: "\u21D8",
      searr: "\u2198",
      searrow: "\u2198",
      sect: "\xA7",
      semi: ";",
      seswar: "\u2929",
      setminus: "\u2216",
      setmn: "\u2216",
      sext: "\u2736",
      Sfr: "\u{1D516}",
      sfr: "\u{1D530}",
      sfrown: "\u2322",
      sharp: "\u266F",
      SHCHcy: "\u0429",
      shchcy: "\u0449",
      SHcy: "\u0428",
      shcy: "\u0448",
      ShortDownArrow: "\u2193",
      ShortLeftArrow: "\u2190",
      shortmid: "\u2223",
      shortparallel: "\u2225",
      ShortRightArrow: "\u2192",
      ShortUpArrow: "\u2191",
      shy: "\xAD",
      Sigma: "\u03A3",
      sigma: "\u03C3",
      sigmaf: "\u03C2",
      sigmav: "\u03C2",
      sim: "\u223C",
      simdot: "\u2A6A",
      sime: "\u2243",
      simeq: "\u2243",
      simg: "\u2A9E",
      simgE: "\u2AA0",
      siml: "\u2A9D",
      simlE: "\u2A9F",
      simne: "\u2246",
      simplus: "\u2A24",
      simrarr: "\u2972",
      slarr: "\u2190",
      SmallCircle: "\u2218",
      smallsetminus: "\u2216",
      smashp: "\u2A33",
      smeparsl: "\u29E4",
      smid: "\u2223",
      smile: "\u2323",
      smt: "\u2AAA",
      smte: "\u2AAC",
      smtes: "\u2AAC\uFE00",
      SOFTcy: "\u042C",
      softcy: "\u044C",
      sol: "/",
      solb: "\u29C4",
      solbar: "\u233F",
      Sopf: "\u{1D54A}",
      sopf: "\u{1D564}",
      spades: "\u2660",
      spadesuit: "\u2660",
      spar: "\u2225",
      sqcap: "\u2293",
      sqcaps: "\u2293\uFE00",
      sqcup: "\u2294",
      sqcups: "\u2294\uFE00",
      Sqrt: "\u221A",
      sqsub: "\u228F",
      sqsube: "\u2291",
      sqsubset: "\u228F",
      sqsubseteq: "\u2291",
      sqsup: "\u2290",
      sqsupe: "\u2292",
      sqsupset: "\u2290",
      sqsupseteq: "\u2292",
      squ: "\u25A1",
      Square: "\u25A1",
      square: "\u25A1",
      SquareIntersection: "\u2293",
      SquareSubset: "\u228F",
      SquareSubsetEqual: "\u2291",
      SquareSuperset: "\u2290",
      SquareSupersetEqual: "\u2292",
      SquareUnion: "\u2294",
      squarf: "\u25AA",
      squf: "\u25AA",
      srarr: "\u2192",
      Sscr: "\u{1D4AE}",
      sscr: "\u{1D4C8}",
      ssetmn: "\u2216",
      ssmile: "\u2323",
      sstarf: "\u22C6",
      Star: "\u22C6",
      star: "\u2606",
      starf: "\u2605",
      straightepsilon: "\u03F5",
      straightphi: "\u03D5",
      strns: "\xAF",
      Sub: "\u22D0",
      sub: "\u2282",
      subdot: "\u2ABD",
      subE: "\u2AC5",
      sube: "\u2286",
      subedot: "\u2AC3",
      submult: "\u2AC1",
      subnE: "\u2ACB",
      subne: "\u228A",
      subplus: "\u2ABF",
      subrarr: "\u2979",
      Subset: "\u22D0",
      subset: "\u2282",
      subseteq: "\u2286",
      subseteqq: "\u2AC5",
      SubsetEqual: "\u2286",
      subsetneq: "\u228A",
      subsetneqq: "\u2ACB",
      subsim: "\u2AC7",
      subsub: "\u2AD5",
      subsup: "\u2AD3",
      succ: "\u227B",
      succapprox: "\u2AB8",
      succcurlyeq: "\u227D",
      Succeeds: "\u227B",
      SucceedsEqual: "\u2AB0",
      SucceedsSlantEqual: "\u227D",
      SucceedsTilde: "\u227F",
      succeq: "\u2AB0",
      succnapprox: "\u2ABA",
      succneqq: "\u2AB6",
      succnsim: "\u22E9",
      succsim: "\u227F",
      SuchThat: "\u220B",
      Sum: "\u2211",
      sum: "\u2211",
      sung: "\u266A",
      Sup: "\u22D1",
      sup: "\u2283",
      sup1: "\xB9",
      sup2: "\xB2",
      sup3: "\xB3",
      supdot: "\u2ABE",
      supdsub: "\u2AD8",
      supE: "\u2AC6",
      supe: "\u2287",
      supedot: "\u2AC4",
      Superset: "\u2283",
      SupersetEqual: "\u2287",
      suphsol: "\u27C9",
      suphsub: "\u2AD7",
      suplarr: "\u297B",
      supmult: "\u2AC2",
      supnE: "\u2ACC",
      supne: "\u228B",
      supplus: "\u2AC0",
      Supset: "\u22D1",
      supset: "\u2283",
      supseteq: "\u2287",
      supseteqq: "\u2AC6",
      supsetneq: "\u228B",
      supsetneqq: "\u2ACC",
      supsim: "\u2AC8",
      supsub: "\u2AD4",
      supsup: "\u2AD6",
      swarhk: "\u2926",
      swArr: "\u21D9",
      swarr: "\u2199",
      swarrow: "\u2199",
      swnwar: "\u292A",
      szlig: "\xDF",
      Tab: "	",
      target: "\u2316",
      Tau: "\u03A4",
      tau: "\u03C4",
      tbrk: "\u23B4",
      Tcaron: "\u0164",
      tcaron: "\u0165",
      Tcedil: "\u0162",
      tcedil: "\u0163",
      Tcy: "\u0422",
      tcy: "\u0442",
      tdot: "\u20DB",
      telrec: "\u2315",
      Tfr: "\u{1D517}",
      tfr: "\u{1D531}",
      there4: "\u2234",
      Therefore: "\u2234",
      therefore: "\u2234",
      Theta: "\u0398",
      theta: "\u03B8",
      thetasym: "\u03D1",
      thetav: "\u03D1",
      thickapprox: "\u2248",
      thicksim: "\u223C",
      ThickSpace: "\u205F\u200A",
      thinsp: "\u2009",
      ThinSpace: "\u2009",
      thkap: "\u2248",
      thksim: "\u223C",
      THORN: "\xDE",
      thorn: "\xFE",
      Tilde: "\u223C",
      tilde: "\u02DC",
      TildeEqual: "\u2243",
      TildeFullEqual: "\u2245",
      TildeTilde: "\u2248",
      times: "\xD7",
      timesb: "\u22A0",
      timesbar: "\u2A31",
      timesd: "\u2A30",
      tint: "\u222D",
      toea: "\u2928",
      top: "\u22A4",
      topbot: "\u2336",
      topcir: "\u2AF1",
      Topf: "\u{1D54B}",
      topf: "\u{1D565}",
      topfork: "\u2ADA",
      tosa: "\u2929",
      tprime: "\u2034",
      TRADE: "\u2122",
      trade: "\u2122",
      triangle: "\u25B5",
      triangledown: "\u25BF",
      triangleleft: "\u25C3",
      trianglelefteq: "\u22B4",
      triangleq: "\u225C",
      triangleright: "\u25B9",
      trianglerighteq: "\u22B5",
      tridot: "\u25EC",
      trie: "\u225C",
      triminus: "\u2A3A",
      TripleDot: "\u20DB",
      triplus: "\u2A39",
      trisb: "\u29CD",
      tritime: "\u2A3B",
      trpezium: "\u23E2",
      Tscr: "\u{1D4AF}",
      tscr: "\u{1D4C9}",
      TScy: "\u0426",
      tscy: "\u0446",
      TSHcy: "\u040B",
      tshcy: "\u045B",
      Tstrok: "\u0166",
      tstrok: "\u0167",
      twixt: "\u226C",
      twoheadleftarrow: "\u219E",
      twoheadrightarrow: "\u21A0",
      Uacute: "\xDA",
      uacute: "\xFA",
      Uarr: "\u219F",
      uArr: "\u21D1",
      uarr: "\u2191",
      Uarrocir: "\u2949",
      Ubrcy: "\u040E",
      ubrcy: "\u045E",
      Ubreve: "\u016C",
      ubreve: "\u016D",
      Ucirc: "\xDB",
      ucirc: "\xFB",
      Ucy: "\u0423",
      ucy: "\u0443",
      udarr: "\u21C5",
      Udblac: "\u0170",
      udblac: "\u0171",
      udhar: "\u296E",
      ufisht: "\u297E",
      Ufr: "\u{1D518}",
      ufr: "\u{1D532}",
      Ugrave: "\xD9",
      ugrave: "\xF9",
      uHar: "\u2963",
      uharl: "\u21BF",
      uharr: "\u21BE",
      uhblk: "\u2580",
      ulcorn: "\u231C",
      ulcorner: "\u231C",
      ulcrop: "\u230F",
      ultri: "\u25F8",
      Umacr: "\u016A",
      umacr: "\u016B",
      uml: "\xA8",
      UnderBar: "_",
      UnderBrace: "\u23DF",
      UnderBracket: "\u23B5",
      UnderParenthesis: "\u23DD",
      Union: "\u22C3",
      UnionPlus: "\u228E",
      Uogon: "\u0172",
      uogon: "\u0173",
      Uopf: "\u{1D54C}",
      uopf: "\u{1D566}",
      UpArrow: "\u2191",
      Uparrow: "\u21D1",
      uparrow: "\u2191",
      UpArrowBar: "\u2912",
      UpArrowDownArrow: "\u21C5",
      UpDownArrow: "\u2195",
      Updownarrow: "\u21D5",
      updownarrow: "\u2195",
      UpEquilibrium: "\u296E",
      upharpoonleft: "\u21BF",
      upharpoonright: "\u21BE",
      uplus: "\u228E",
      UpperLeftArrow: "\u2196",
      UpperRightArrow: "\u2197",
      Upsi: "\u03D2",
      upsi: "\u03C5",
      upsih: "\u03D2",
      Upsilon: "\u03A5",
      upsilon: "\u03C5",
      UpTee: "\u22A5",
      UpTeeArrow: "\u21A5",
      upuparrows: "\u21C8",
      urcorn: "\u231D",
      urcorner: "\u231D",
      urcrop: "\u230E",
      Uring: "\u016E",
      uring: "\u016F",
      urtri: "\u25F9",
      Uscr: "\u{1D4B0}",
      uscr: "\u{1D4CA}",
      utdot: "\u22F0",
      Utilde: "\u0168",
      utilde: "\u0169",
      utri: "\u25B5",
      utrif: "\u25B4",
      uuarr: "\u21C8",
      Uuml: "\xDC",
      uuml: "\xFC",
      uwangle: "\u29A7",
      vangrt: "\u299C",
      varepsilon: "\u03F5",
      varkappa: "\u03F0",
      varnothing: "\u2205",
      varphi: "\u03D5",
      varpi: "\u03D6",
      varpropto: "\u221D",
      vArr: "\u21D5",
      varr: "\u2195",
      varrho: "\u03F1",
      varsigma: "\u03C2",
      varsubsetneq: "\u228A\uFE00",
      varsubsetneqq: "\u2ACB\uFE00",
      varsupsetneq: "\u228B\uFE00",
      varsupsetneqq: "\u2ACC\uFE00",
      vartheta: "\u03D1",
      vartriangleleft: "\u22B2",
      vartriangleright: "\u22B3",
      Vbar: "\u2AEB",
      vBar: "\u2AE8",
      vBarv: "\u2AE9",
      Vcy: "\u0412",
      vcy: "\u0432",
      VDash: "\u22AB",
      Vdash: "\u22A9",
      vDash: "\u22A8",
      vdash: "\u22A2",
      Vdashl: "\u2AE6",
      Vee: "\u22C1",
      vee: "\u2228",
      veebar: "\u22BB",
      veeeq: "\u225A",
      vellip: "\u22EE",
      Verbar: "\u2016",
      verbar: "|",
      Vert: "\u2016",
      vert: "|",
      VerticalBar: "\u2223",
      VerticalLine: "|",
      VerticalSeparator: "\u2758",
      VerticalTilde: "\u2240",
      VeryThinSpace: "\u200A",
      Vfr: "\u{1D519}",
      vfr: "\u{1D533}",
      vltri: "\u22B2",
      vnsub: "\u2282\u20D2",
      vnsup: "\u2283\u20D2",
      Vopf: "\u{1D54D}",
      vopf: "\u{1D567}",
      vprop: "\u221D",
      vrtri: "\u22B3",
      Vscr: "\u{1D4B1}",
      vscr: "\u{1D4CB}",
      vsubnE: "\u2ACB\uFE00",
      vsubne: "\u228A\uFE00",
      vsupnE: "\u2ACC\uFE00",
      vsupne: "\u228B\uFE00",
      Vvdash: "\u22AA",
      vzigzag: "\u299A",
      Wcirc: "\u0174",
      wcirc: "\u0175",
      wedbar: "\u2A5F",
      Wedge: "\u22C0",
      wedge: "\u2227",
      wedgeq: "\u2259",
      weierp: "\u2118",
      Wfr: "\u{1D51A}",
      wfr: "\u{1D534}",
      Wopf: "\u{1D54E}",
      wopf: "\u{1D568}",
      wp: "\u2118",
      wr: "\u2240",
      wreath: "\u2240",
      Wscr: "\u{1D4B2}",
      wscr: "\u{1D4CC}",
      xcap: "\u22C2",
      xcirc: "\u25EF",
      xcup: "\u22C3",
      xdtri: "\u25BD",
      Xfr: "\u{1D51B}",
      xfr: "\u{1D535}",
      xhArr: "\u27FA",
      xharr: "\u27F7",
      Xi: "\u039E",
      xi: "\u03BE",
      xlArr: "\u27F8",
      xlarr: "\u27F5",
      xmap: "\u27FC",
      xnis: "\u22FB",
      xodot: "\u2A00",
      Xopf: "\u{1D54F}",
      xopf: "\u{1D569}",
      xoplus: "\u2A01",
      xotime: "\u2A02",
      xrArr: "\u27F9",
      xrarr: "\u27F6",
      Xscr: "\u{1D4B3}",
      xscr: "\u{1D4CD}",
      xsqcup: "\u2A06",
      xuplus: "\u2A04",
      xutri: "\u25B3",
      xvee: "\u22C1",
      xwedge: "\u22C0",
      Yacute: "\xDD",
      yacute: "\xFD",
      YAcy: "\u042F",
      yacy: "\u044F",
      Ycirc: "\u0176",
      ycirc: "\u0177",
      Ycy: "\u042B",
      ycy: "\u044B",
      yen: "\xA5",
      Yfr: "\u{1D51C}",
      yfr: "\u{1D536}",
      YIcy: "\u0407",
      yicy: "\u0457",
      Yopf: "\u{1D550}",
      yopf: "\u{1D56A}",
      Yscr: "\u{1D4B4}",
      yscr: "\u{1D4CE}",
      YUcy: "\u042E",
      yucy: "\u044E",
      Yuml: "\u0178",
      yuml: "\xFF",
      Zacute: "\u0179",
      zacute: "\u017A",
      Zcaron: "\u017D",
      zcaron: "\u017E",
      Zcy: "\u0417",
      zcy: "\u0437",
      Zdot: "\u017B",
      zdot: "\u017C",
      zeetrf: "\u2128",
      ZeroWidthSpace: "\u200B",
      Zeta: "\u0396",
      zeta: "\u03B6",
      Zfr: "\u2128",
      zfr: "\u{1D537}",
      ZHcy: "\u0416",
      zhcy: "\u0436",
      zigrarr: "\u21DD",
      Zopf: "\u2124",
      zopf: "\u{1D56B}",
      Zscr: "\u{1D4B5}",
      zscr: "\u{1D4CF}",
      zwj: "\u200D",
      zwnj: "\u200C"
    });
    exports2.entityMap = exports2.HTML_ENTITIES;
  }
});

// node_modules/@xmldom/xmldom/lib/sax.js
var require_sax = __commonJS({
  "node_modules/@xmldom/xmldom/lib/sax.js"(exports2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var NAMESPACE = require_conventions().NAMESPACE;
    var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var nameChar = new RegExp("[\\-\\.0-9" + nameStartChar.source.slice(1, -1) + "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]");
    var tagNamePattern = new RegExp("^" + nameStartChar.source + nameChar.source + "*(?::" + nameStartChar.source + nameChar.source + "*)?$");
    var S_TAG = 0;
    var S_ATTR = 1;
    var S_ATTR_SPACE = 2;
    var S_EQ = 3;
    var S_ATTR_NOQUOT_VALUE = 4;
    var S_ATTR_END = 5;
    var S_TAG_SPACE = 6;
    var S_TAG_CLOSE = 7;
    function ParseError(message, locator) {
      this.message = message;
      this.locator = locator;
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, ParseError);
    }
    __name(ParseError, "ParseError");
    ParseError.prototype = new Error();
    ParseError.prototype.name = ParseError.name;
    function XMLReader() {
    }
    __name(XMLReader, "XMLReader");
    XMLReader.prototype = {
      parse: function(source, defaultNSMap, entityMap) {
        var domBuilder = this.domBuilder;
        domBuilder.startDocument();
        _copy(defaultNSMap, defaultNSMap = {});
        parse(
          source,
          defaultNSMap,
          entityMap,
          domBuilder,
          this.errorHandler
        );
        domBuilder.endDocument();
      }
    };
    function parse(source, defaultNSMapCopy, entityMap, domBuilder, errorHandler) {
      function fixedFromCharCode(code) {
        if (code > 65535) {
          code -= 65536;
          var surrogate1 = 55296 + (code >> 10), surrogate2 = 56320 + (code & 1023);
          return String.fromCharCode(surrogate1, surrogate2);
        } else {
          return String.fromCharCode(code);
        }
      }
      __name(fixedFromCharCode, "fixedFromCharCode");
      function entityReplacer(a3) {
        var k2 = a3.slice(1, -1);
        if (Object.hasOwnProperty.call(entityMap, k2)) {
          return entityMap[k2];
        } else if (k2.charAt(0) === "#") {
          return fixedFromCharCode(parseInt(k2.substr(1).replace("x", "0x")));
        } else {
          errorHandler.error("entity not found:" + a3);
          return a3;
        }
      }
      __name(entityReplacer, "entityReplacer");
      function appendText(end2) {
        if (end2 > start) {
          var xt2 = source.substring(start, end2).replace(/&#?\w+;/g, entityReplacer);
          locator && position(start);
          domBuilder.characters(xt2, 0, end2 - start);
          start = end2;
        }
      }
      __name(appendText, "appendText");
      function position(p2, m2) {
        while (p2 >= lineEnd && (m2 = linePattern.exec(source))) {
          lineStart = m2.index;
          lineEnd = lineStart + m2[0].length;
          locator.lineNumber++;
        }
        locator.columnNumber = p2 - lineStart + 1;
      }
      __name(position, "position");
      var lineStart = 0;
      var lineEnd = 0;
      var linePattern = /.*(?:\r\n?|\n)|.*$/g;
      var locator = domBuilder.locator;
      var parseStack = [{ currentNSMap: defaultNSMapCopy }];
      var closeMap = {};
      var start = 0;
      while (true) {
        try {
          var tagStart = source.indexOf("<", start);
          if (tagStart < 0) {
            if (!source.substr(start).match(/^\s*$/)) {
              var doc = domBuilder.doc;
              var text = doc.createTextNode(source.substr(start));
              doc.appendChild(text);
              domBuilder.currentElement = text;
            }
            return;
          }
          if (tagStart > start) {
            appendText(tagStart);
          }
          switch (source.charAt(tagStart + 1)) {
            case "/":
              var end = source.indexOf(">", tagStart + 3);
              var tagName = source.substring(tagStart + 2, end).replace(/[ \t\n\r]+$/g, "");
              var config2 = parseStack.pop();
              if (end < 0) {
                tagName = source.substring(tagStart + 2).replace(/[\s<].*/, "");
                errorHandler.error("end tag name: " + tagName + " is not complete:" + config2.tagName);
                end = tagStart + 1 + tagName.length;
              } else if (tagName.match(/\s</)) {
                tagName = tagName.replace(/[\s<].*/, "");
                errorHandler.error("end tag name: " + tagName + " maybe not complete");
                end = tagStart + 1 + tagName.length;
              }
              var localNSMap = config2.localNSMap;
              var endMatch = config2.tagName == tagName;
              var endIgnoreCaseMach = endMatch || config2.tagName && config2.tagName.toLowerCase() == tagName.toLowerCase();
              if (endIgnoreCaseMach) {
                domBuilder.endElement(config2.uri, config2.localName, tagName);
                if (localNSMap) {
                  for (var prefix in localNSMap) {
                    if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
                      domBuilder.endPrefixMapping(prefix);
                    }
                  }
                }
                if (!endMatch) {
                  errorHandler.fatalError("end tag name: " + tagName + " is not match the current start tagName:" + config2.tagName);
                }
              } else {
                parseStack.push(config2);
              }
              end++;
              break;
            case "?":
              locator && position(tagStart);
              end = parseInstruction(source, tagStart, domBuilder);
              break;
            case "!":
              locator && position(tagStart);
              end = parseDCC(source, tagStart, domBuilder, errorHandler);
              break;
            default:
              locator && position(tagStart);
              var el2 = new ElementAttributes();
              var currentNSMap = parseStack[parseStack.length - 1].currentNSMap;
              var end = parseElementStartPart(source, tagStart, el2, currentNSMap, entityReplacer, errorHandler);
              var len = el2.length;
              if (!el2.closed && fixSelfClosed(source, end, el2.tagName, closeMap)) {
                el2.closed = true;
                if (!entityMap.nbsp) {
                  errorHandler.warning("unclosed xml attribute");
                }
              }
              if (locator && len) {
                var locator2 = copyLocator(locator, {});
                for (var i2 = 0; i2 < len; i2++) {
                  var a2 = el2[i2];
                  position(a2.offset);
                  a2.locator = copyLocator(locator, {});
                }
                domBuilder.locator = locator2;
                if (appendElement(el2, domBuilder, currentNSMap)) {
                  parseStack.push(el2);
                }
                domBuilder.locator = locator;
              } else {
                if (appendElement(el2, domBuilder, currentNSMap)) {
                  parseStack.push(el2);
                }
              }
              if (NAMESPACE.isHTML(el2.uri) && !el2.closed) {
                end = parseHtmlSpecialContent(source, end, el2.tagName, entityReplacer, domBuilder);
              } else {
                end++;
              }
          }
        } catch (e2) {
          if (e2 instanceof ParseError) {
            throw e2;
          }
          errorHandler.error("element parse error: " + e2);
          end = -1;
        }
        if (end > start) {
          start = end;
        } else {
          appendText(Math.max(tagStart, start) + 1);
        }
      }
    }
    __name(parse, "parse");
    function copyLocator(f2, t2) {
      t2.lineNumber = f2.lineNumber;
      t2.columnNumber = f2.columnNumber;
      return t2;
    }
    __name(copyLocator, "copyLocator");
    function parseElementStartPart(source, start, el2, currentNSMap, entityReplacer, errorHandler) {
      function addAttribute(qname, value2, startIndex) {
        if (el2.attributeNames.hasOwnProperty(qname)) {
          errorHandler.fatalError("Attribute " + qname + " redefined");
        }
        el2.addValue(
          qname,
          // @see https://www.w3.org/TR/xml/#AVNormalize
          // since the xmldom sax parser does not "interpret" DTD the following is not implemented:
          // - recursive replacement of (DTD) entity references
          // - trimming and collapsing multiple spaces into a single one for attributes that are not of type CDATA
          value2.replace(/[\t\n\r]/g, " ").replace(/&#?\w+;/g, entityReplacer),
          startIndex
        );
      }
      __name(addAttribute, "addAttribute");
      var attrName;
      var value;
      var p2 = ++start;
      var s2 = S_TAG;
      while (true) {
        var c2 = source.charAt(p2);
        switch (c2) {
          case "=":
            if (s2 === S_ATTR) {
              attrName = source.slice(start, p2);
              s2 = S_EQ;
            } else if (s2 === S_ATTR_SPACE) {
              s2 = S_EQ;
            } else {
              throw new Error("attribute equal must after attrName");
            }
            break;
          case "'":
          case '"':
            if (s2 === S_EQ || s2 === S_ATTR) {
              if (s2 === S_ATTR) {
                errorHandler.warning('attribute value must after "="');
                attrName = source.slice(start, p2);
              }
              start = p2 + 1;
              p2 = source.indexOf(c2, start);
              if (p2 > 0) {
                value = source.slice(start, p2);
                addAttribute(attrName, value, start - 1);
                s2 = S_ATTR_END;
              } else {
                throw new Error("attribute value no end '" + c2 + "' match");
              }
            } else if (s2 == S_ATTR_NOQUOT_VALUE) {
              value = source.slice(start, p2);
              addAttribute(attrName, value, start);
              errorHandler.warning('attribute "' + attrName + '" missed start quot(' + c2 + ")!!");
              start = p2 + 1;
              s2 = S_ATTR_END;
            } else {
              throw new Error('attribute value must after "="');
            }
            break;
          case "/":
            switch (s2) {
              case S_TAG:
                el2.setTagName(source.slice(start, p2));
              case S_ATTR_END:
              case S_TAG_SPACE:
              case S_TAG_CLOSE:
                s2 = S_TAG_CLOSE;
                el2.closed = true;
              case S_ATTR_NOQUOT_VALUE:
              case S_ATTR:
                break;
              case S_ATTR_SPACE:
                el2.closed = true;
                break;
              default:
                throw new Error("attribute invalid close char('/')");
            }
            break;
          case "":
            errorHandler.error("unexpected end of input");
            if (s2 == S_TAG) {
              el2.setTagName(source.slice(start, p2));
            }
            return p2;
          case ">":
            switch (s2) {
              case S_TAG:
                el2.setTagName(source.slice(start, p2));
              case S_ATTR_END:
              case S_TAG_SPACE:
              case S_TAG_CLOSE:
                break;
              case S_ATTR_NOQUOT_VALUE:
              case S_ATTR:
                value = source.slice(start, p2);
                if (value.slice(-1) === "/") {
                  el2.closed = true;
                  value = value.slice(0, -1);
                }
              case S_ATTR_SPACE:
                if (s2 === S_ATTR_SPACE) {
                  value = attrName;
                }
                if (s2 == S_ATTR_NOQUOT_VALUE) {
                  errorHandler.warning('attribute "' + value + '" missed quot(")!');
                  addAttribute(attrName, value, start);
                } else {
                  if (!NAMESPACE.isHTML(currentNSMap[""]) || !value.match(/^(?:disabled|checked|selected)$/i)) {
                    errorHandler.warning('attribute "' + value + '" missed value!! "' + value + '" instead!!');
                  }
                  addAttribute(value, value, start);
                }
                break;
              case S_EQ:
                throw new Error("attribute value missed!!");
            }
            return p2;
          case "\x80":
            c2 = " ";
          default:
            if (c2 <= " ") {
              switch (s2) {
                case S_TAG:
                  el2.setTagName(source.slice(start, p2));
                  s2 = S_TAG_SPACE;
                  break;
                case S_ATTR:
                  attrName = source.slice(start, p2);
                  s2 = S_ATTR_SPACE;
                  break;
                case S_ATTR_NOQUOT_VALUE:
                  var value = source.slice(start, p2);
                  errorHandler.warning('attribute "' + value + '" missed quot(")!!');
                  addAttribute(attrName, value, start);
                case S_ATTR_END:
                  s2 = S_TAG_SPACE;
                  break;
              }
            } else {
              switch (s2) {
                case S_ATTR_SPACE:
                  var tagName = el2.tagName;
                  if (!NAMESPACE.isHTML(currentNSMap[""]) || !attrName.match(/^(?:disabled|checked|selected)$/i)) {
                    errorHandler.warning('attribute "' + attrName + '" missed value!! "' + attrName + '" instead2!!');
                  }
                  addAttribute(attrName, attrName, start);
                  start = p2;
                  s2 = S_ATTR;
                  break;
                case S_ATTR_END:
                  errorHandler.warning('attribute space is required"' + attrName + '"!!');
                case S_TAG_SPACE:
                  s2 = S_ATTR;
                  start = p2;
                  break;
                case S_EQ:
                  s2 = S_ATTR_NOQUOT_VALUE;
                  start = p2;
                  break;
                case S_TAG_CLOSE:
                  throw new Error("elements closed character '/' and '>' must be connected to");
              }
            }
        }
        p2++;
      }
    }
    __name(parseElementStartPart, "parseElementStartPart");
    function appendElement(el2, domBuilder, currentNSMap) {
      var tagName = el2.tagName;
      var localNSMap = null;
      var i2 = el2.length;
      while (i2--) {
        var a2 = el2[i2];
        var qName = a2.qName;
        var value = a2.value;
        var nsp = qName.indexOf(":");
        if (nsp > 0) {
          var prefix = a2.prefix = qName.slice(0, nsp);
          var localName = qName.slice(nsp + 1);
          var nsPrefix = prefix === "xmlns" && localName;
        } else {
          localName = qName;
          prefix = null;
          nsPrefix = qName === "xmlns" && "";
        }
        a2.localName = localName;
        if (nsPrefix !== false) {
          if (localNSMap == null) {
            localNSMap = {};
            _copy(currentNSMap, currentNSMap = {});
          }
          currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
          a2.uri = NAMESPACE.XMLNS;
          domBuilder.startPrefixMapping(nsPrefix, value);
        }
      }
      var i2 = el2.length;
      while (i2--) {
        a2 = el2[i2];
        var prefix = a2.prefix;
        if (prefix) {
          if (prefix === "xml") {
            a2.uri = NAMESPACE.XML;
          }
          if (prefix !== "xmlns") {
            a2.uri = currentNSMap[prefix || ""];
          }
        }
      }
      var nsp = tagName.indexOf(":");
      if (nsp > 0) {
        prefix = el2.prefix = tagName.slice(0, nsp);
        localName = el2.localName = tagName.slice(nsp + 1);
      } else {
        prefix = null;
        localName = el2.localName = tagName;
      }
      var ns2 = el2.uri = currentNSMap[prefix || ""];
      domBuilder.startElement(ns2, localName, tagName, el2);
      if (el2.closed) {
        domBuilder.endElement(ns2, localName, tagName);
        if (localNSMap) {
          for (prefix in localNSMap) {
            if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
              domBuilder.endPrefixMapping(prefix);
            }
          }
        }
      } else {
        el2.currentNSMap = currentNSMap;
        el2.localNSMap = localNSMap;
        return true;
      }
    }
    __name(appendElement, "appendElement");
    function parseHtmlSpecialContent(source, elStartEnd, tagName, entityReplacer, domBuilder) {
      if (/^(?:script|textarea)$/i.test(tagName)) {
        var elEndStart = source.indexOf("</" + tagName + ">", elStartEnd);
        var text = source.substring(elStartEnd + 1, elEndStart);
        if (/[&<]/.test(text)) {
          if (/^script$/i.test(tagName)) {
            domBuilder.characters(text, 0, text.length);
            return elEndStart;
          }
          text = text.replace(/&#?\w+;/g, entityReplacer);
          domBuilder.characters(text, 0, text.length);
          return elEndStart;
        }
      }
      return elStartEnd + 1;
    }
    __name(parseHtmlSpecialContent, "parseHtmlSpecialContent");
    function fixSelfClosed(source, elStartEnd, tagName, closeMap) {
      var pos = closeMap[tagName];
      if (pos == null) {
        pos = source.lastIndexOf("</" + tagName + ">");
        if (pos < elStartEnd) {
          pos = source.lastIndexOf("</" + tagName);
        }
        closeMap[tagName] = pos;
      }
      return pos < elStartEnd;
    }
    __name(fixSelfClosed, "fixSelfClosed");
    function _copy(source, target) {
      for (var n2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, n2)) {
          target[n2] = source[n2];
        }
      }
    }
    __name(_copy, "_copy");
    function parseDCC(source, start, domBuilder, errorHandler) {
      var next = source.charAt(start + 2);
      switch (next) {
        case "-":
          if (source.charAt(start + 3) === "-") {
            var end = source.indexOf("-->", start + 4);
            if (end > start) {
              domBuilder.comment(source, start + 4, end - start - 4);
              return end + 3;
            } else {
              errorHandler.error("Unclosed comment");
              return -1;
            }
          } else {
            return -1;
          }
        default:
          if (source.substr(start + 3, 6) == "CDATA[") {
            var end = source.indexOf("]]>", start + 9);
            domBuilder.startCDATA();
            domBuilder.characters(source, start + 9, end - start - 9);
            domBuilder.endCDATA();
            return end + 3;
          }
          var matchs = split(source, start);
          var len = matchs.length;
          if (len > 1 && /!doctype/i.test(matchs[0][0])) {
            var name = matchs[1][0];
            var pubid = false;
            var sysid = false;
            if (len > 3) {
              if (/^public$/i.test(matchs[2][0])) {
                pubid = matchs[3][0];
                sysid = len > 4 && matchs[4][0];
              } else if (/^system$/i.test(matchs[2][0])) {
                sysid = matchs[3][0];
              }
            }
            var lastMatch = matchs[len - 1];
            domBuilder.startDTD(name, pubid, sysid);
            domBuilder.endDTD();
            return lastMatch.index + lastMatch[0].length;
          }
      }
      return -1;
    }
    __name(parseDCC, "parseDCC");
    function parseInstruction(source, start, domBuilder) {
      var end = source.indexOf("?>", start);
      if (end) {
        var match = source.substring(start, end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
        if (match) {
          var len = match[0].length;
          domBuilder.processingInstruction(match[1], match[2]);
          return end + 2;
        } else {
          return -1;
        }
      }
      return -1;
    }
    __name(parseInstruction, "parseInstruction");
    function ElementAttributes() {
      this.attributeNames = {};
    }
    __name(ElementAttributes, "ElementAttributes");
    ElementAttributes.prototype = {
      setTagName: function(tagName) {
        if (!tagNamePattern.test(tagName)) {
          throw new Error("invalid tagName:" + tagName);
        }
        this.tagName = tagName;
      },
      addValue: function(qName, value, offset) {
        if (!tagNamePattern.test(qName)) {
          throw new Error("invalid attribute:" + qName);
        }
        this.attributeNames[qName] = this.length;
        this[this.length++] = { qName, value, offset };
      },
      length: 0,
      getLocalName: function(i2) {
        return this[i2].localName;
      },
      getLocator: function(i2) {
        return this[i2].locator;
      },
      getQName: function(i2) {
        return this[i2].qName;
      },
      getURI: function(i2) {
        return this[i2].uri;
      },
      getValue: function(i2) {
        return this[i2].value;
      }
      //	,getIndex:function(uri, localName)){
      //		if(localName){
      //
      //		}else{
      //			var qName = uri
      //		}
      //	},
      //	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
      //	getType:function(uri,localName){}
      //	getType:function(i){},
    };
    function split(source, start) {
      var match;
      var buf = [];
      var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
      reg.lastIndex = start;
      reg.exec(source);
      while (match = reg.exec(source)) {
        buf.push(match);
        if (match[1])
          return buf;
      }
    }
    __name(split, "split");
    exports2.XMLReader = XMLReader;
    exports2.ParseError = ParseError;
  }
});

// node_modules/@xmldom/xmldom/lib/dom-parser.js
var require_dom_parser = __commonJS({
  "node_modules/@xmldom/xmldom/lib/dom-parser.js"(exports2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var conventions = require_conventions();
    var dom = require_dom();
    var entities = require_entities();
    var sax = require_sax();
    var DOMImplementation = dom.DOMImplementation;
    var NAMESPACE = conventions.NAMESPACE;
    var ParseError = sax.ParseError;
    var XMLReader = sax.XMLReader;
    function normalizeLineEndings(input) {
      return input.replace(/\r[\n\u0085]/g, "\n").replace(/[\r\u0085\u2028]/g, "\n");
    }
    __name(normalizeLineEndings, "normalizeLineEndings");
    function DOMParser(options) {
      this.options = options || { locator: {} };
    }
    __name(DOMParser, "DOMParser");
    DOMParser.prototype.parseFromString = function(source, mimeType) {
      var options = this.options;
      var sax2 = new XMLReader();
      var domBuilder = options.domBuilder || new DOMHandler();
      var errorHandler = options.errorHandler;
      var locator = options.locator;
      var defaultNSMap = options.xmlns || {};
      var isHTML = /\/x?html?$/.test(mimeType);
      var entityMap = isHTML ? entities.HTML_ENTITIES : entities.XML_ENTITIES;
      if (locator) {
        domBuilder.setDocumentLocator(locator);
      }
      sax2.errorHandler = buildErrorHandler(errorHandler, domBuilder, locator);
      sax2.domBuilder = options.domBuilder || domBuilder;
      if (isHTML) {
        defaultNSMap[""] = NAMESPACE.HTML;
      }
      defaultNSMap.xml = defaultNSMap.xml || NAMESPACE.XML;
      var normalize = options.normalizeLineEndings || normalizeLineEndings;
      if (source && typeof source === "string") {
        sax2.parse(
          normalize(source),
          defaultNSMap,
          entityMap
        );
      } else {
        sax2.errorHandler.error("invalid doc source");
      }
      return domBuilder.doc;
    };
    function buildErrorHandler(errorImpl, domBuilder, locator) {
      if (!errorImpl) {
        if (domBuilder instanceof DOMHandler) {
          return domBuilder;
        }
        errorImpl = domBuilder;
      }
      var errorHandler = {};
      var isCallback = errorImpl instanceof Function;
      locator = locator || {};
      function build(key) {
        var fn2 = errorImpl[key];
        if (!fn2 && isCallback) {
          fn2 = errorImpl.length == 2 ? function(msg) {
            errorImpl(key, msg);
          } : errorImpl;
        }
        errorHandler[key] = fn2 && function(msg) {
          fn2("[xmldom " + key + "]	" + msg + _locator(locator));
        } || function() {
        };
      }
      __name(build, "build");
      build("warning");
      build("error");
      build("fatalError");
      return errorHandler;
    }
    __name(buildErrorHandler, "buildErrorHandler");
    function DOMHandler() {
      this.cdata = false;
    }
    __name(DOMHandler, "DOMHandler");
    function position(locator, node) {
      node.lineNumber = locator.lineNumber;
      node.columnNumber = locator.columnNumber;
    }
    __name(position, "position");
    DOMHandler.prototype = {
      startDocument: function() {
        this.doc = new DOMImplementation().createDocument(null, null, null);
        if (this.locator) {
          this.doc.documentURI = this.locator.systemId;
        }
      },
      startElement: function(namespaceURI, localName, qName, attrs) {
        var doc = this.doc;
        var el2 = doc.createElementNS(namespaceURI, qName || localName);
        var len = attrs.length;
        appendElement(this, el2);
        this.currentElement = el2;
        this.locator && position(this.locator, el2);
        for (var i2 = 0; i2 < len; i2++) {
          var namespaceURI = attrs.getURI(i2);
          var value = attrs.getValue(i2);
          var qName = attrs.getQName(i2);
          var attr = doc.createAttributeNS(namespaceURI, qName);
          this.locator && position(attrs.getLocator(i2), attr);
          attr.value = attr.nodeValue = value;
          el2.setAttributeNode(attr);
        }
      },
      endElement: function(namespaceURI, localName, qName) {
        var current = this.currentElement;
        var tagName = current.tagName;
        this.currentElement = current.parentNode;
      },
      startPrefixMapping: function(prefix, uri) {
      },
      endPrefixMapping: function(prefix) {
      },
      processingInstruction: function(target, data) {
        var ins = this.doc.createProcessingInstruction(target, data);
        this.locator && position(this.locator, ins);
        appendElement(this, ins);
      },
      ignorableWhitespace: function(ch2, start, length) {
      },
      characters: function(chars, start, length) {
        chars = _toString.apply(this, arguments);
        if (chars) {
          if (this.cdata) {
            var charNode = this.doc.createCDATASection(chars);
          } else {
            var charNode = this.doc.createTextNode(chars);
          }
          if (this.currentElement) {
            this.currentElement.appendChild(charNode);
          } else if (/^\s*$/.test(chars)) {
            this.doc.appendChild(charNode);
          }
          this.locator && position(this.locator, charNode);
        }
      },
      skippedEntity: function(name) {
      },
      endDocument: function() {
        this.doc.normalize();
      },
      setDocumentLocator: function(locator) {
        if (this.locator = locator) {
          locator.lineNumber = 0;
        }
      },
      //LexicalHandler
      comment: function(chars, start, length) {
        chars = _toString.apply(this, arguments);
        var comm = this.doc.createComment(chars);
        this.locator && position(this.locator, comm);
        appendElement(this, comm);
      },
      startCDATA: function() {
        this.cdata = true;
      },
      endCDATA: function() {
        this.cdata = false;
      },
      startDTD: function(name, publicId, systemId) {
        var impl = this.doc.implementation;
        if (impl && impl.createDocumentType) {
          var dt2 = impl.createDocumentType(name, publicId, systemId);
          this.locator && position(this.locator, dt2);
          appendElement(this, dt2);
          this.doc.doctype = dt2;
        }
      },
      /**
       * @see org.xml.sax.ErrorHandler
       * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
       */
      warning: function(error3) {
        console.warn("[xmldom warning]	" + error3, _locator(this.locator));
      },
      error: function(error3) {
        console.error("[xmldom error]	" + error3, _locator(this.locator));
      },
      fatalError: function(error3) {
        throw new ParseError(error3, this.locator);
      }
    };
    function _locator(l3) {
      if (l3) {
        return "\n@" + (l3.systemId || "") + "#[line:" + l3.lineNumber + ",col:" + l3.columnNumber + "]";
      }
    }
    __name(_locator, "_locator");
    function _toString(chars, start, length) {
      if (typeof chars == "string") {
        return chars.substr(start, length);
      } else {
        if (chars.length >= start + length || start) {
          return new java.lang.String(chars, start, length) + "";
        }
        return chars;
      }
    }
    __name(_toString, "_toString");
    "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, function(key) {
      DOMHandler.prototype[key] = function() {
        return null;
      };
    });
    function appendElement(hander, node) {
      if (!hander.currentElement) {
        hander.doc.appendChild(node);
      } else {
        hander.currentElement.appendChild(node);
      }
    }
    __name(appendElement, "appendElement");
    exports2.__DOMHandler = DOMHandler;
    exports2.normalizeLineEndings = normalizeLineEndings;
    exports2.DOMParser = DOMParser;
  }
});

// node_modules/@xmldom/xmldom/lib/index.js
var require_lib = __commonJS({
  "node_modules/@xmldom/xmldom/lib/index.js"(exports2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var dom = require_dom();
    exports2.DOMImplementation = dom.DOMImplementation;
    exports2.XMLSerializer = dom.XMLSerializer;
    exports2.DOMParser = require_dom_parser().DOMParser;
  }
});

// node_modules/mammoth/lib/xml/xmldom.js
var require_xmldom = __commonJS({
  "node_modules/mammoth/lib/xml/xmldom.js"(exports2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var xmldom = require_lib();
    var dom = require_dom();
    function parseFromString(string) {
      var error3 = null;
      var domParser = new xmldom.DOMParser({
        errorHandler: function(level, message) {
          error3 = { level, message };
        }
      });
      var document2 = domParser.parseFromString(string);
      if (error3 === null) {
        return document2;
      } else {
        throw new Error(error3.level + ": " + error3.message);
      }
    }
    __name(parseFromString, "parseFromString");
    exports2.parseFromString = parseFromString;
    exports2.Node = dom.Node;
  }
});

// node_modules/mammoth/lib/xml/reader.js
var require_reader = __commonJS({
  "node_modules/mammoth/lib/xml/reader.js"(exports2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var promises = require_promises();
    var _2 = require_underscore_umd();
    var xmldom = require_xmldom();
    var nodes = require_nodes();
    var Element = nodes.Element;
    exports2.readString = readString;
    var Node2 = xmldom.Node;
    function readString(xmlString, namespaceMap) {
      namespaceMap = namespaceMap || {};
      try {
        var document2 = xmldom.parseFromString(xmlString, "text/xml");
      } catch (error3) {
        return promises.reject(error3);
      }
      if (document2.documentElement.tagName === "parsererror") {
        return promises.resolve(new Error(document2.documentElement.textContent));
      }
      function convertNode(node) {
        switch (node.nodeType) {
          case Node2.ELEMENT_NODE:
            return convertElement(node);
          case Node2.TEXT_NODE:
            return nodes.text(node.nodeValue);
        }
      }
      __name(convertNode, "convertNode");
      function convertElement(element) {
        var convertedName = convertName(element);
        var convertedChildren = [];
        _2.forEach(element.childNodes, function(childNode) {
          var convertedNode = convertNode(childNode);
          if (convertedNode) {
            convertedChildren.push(convertedNode);
          }
        });
        var convertedAttributes = {};
        _2.forEach(element.attributes, function(attribute) {
          convertedAttributes[convertName(attribute)] = attribute.value;
        });
        return new Element(convertedName, convertedAttributes, convertedChildren);
      }
      __name(convertElement, "convertElement");
      function convertName(node) {
        if (node.namespaceURI) {
          var mappedPrefix = namespaceMap[node.namespaceURI];
          var prefix;
          if (mappedPrefix) {
            prefix = mappedPrefix + ":";
          } else {
            prefix = "{" + node.namespaceURI + "}";
          }
          return prefix + node.localName;
        } else {
          return node.localName;
        }
      }
      __name(convertName, "convertName");
      return promises.resolve(convertNode(document2.documentElement));
    }
    __name(readString, "readString");
  }
});

// node_modules/xmlbuilder/lib/Utility.js
var require_Utility = __commonJS({
  "node_modules/xmlbuilder/lib/Utility.js"(exports2, module2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function() {
      var assign, getValue, isArray, isEmpty, isFunction, isObject2, isPlainObject, slice = [].slice, hasProp = {}.hasOwnProperty;
      assign = /* @__PURE__ */ __name(function() {
        var i2, key, len, source, sources, target;
        target = arguments[0], sources = 2 <= arguments.length ? slice.call(arguments, 1) : [];
        if (isFunction(Object.assign)) {
          Object.assign.apply(null, arguments);
        } else {
          for (i2 = 0, len = sources.length; i2 < len; i2++) {
            source = sources[i2];
            if (source != null) {
              for (key in source) {
                if (!hasProp.call(source, key))
                  continue;
                target[key] = source[key];
              }
            }
          }
        }
        return target;
      }, "assign");
      isFunction = /* @__PURE__ */ __name(function(val) {
        return !!val && Object.prototype.toString.call(val) === "[object Function]";
      }, "isFunction");
      isObject2 = /* @__PURE__ */ __name(function(val) {
        var ref;
        return !!val && ((ref = typeof val) === "function" || ref === "object");
      }, "isObject");
      isArray = /* @__PURE__ */ __name(function(val) {
        if (isFunction(Array.isArray)) {
          return Array.isArray(val);
        } else {
          return Object.prototype.toString.call(val) === "[object Array]";
        }
      }, "isArray");
      isEmpty = /* @__PURE__ */ __name(function(val) {
        var key;
        if (isArray(val)) {
          return !val.length;
        } else {
          for (key in val) {
            if (!hasProp.call(val, key))
              continue;
            return false;
          }
          return true;
        }
      }, "isEmpty");
      isPlainObject = /* @__PURE__ */ __name(function(val) {
        var ctor, proto;
        return isObject2(val) && (proto = Object.getPrototypeOf(val)) && (ctor = proto.constructor) && typeof ctor === "function" && ctor instanceof ctor && Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object);
      }, "isPlainObject");
      getValue = /* @__PURE__ */ __name(function(obj2) {
        if (isFunction(obj2.valueOf)) {
          return obj2.valueOf();
        } else {
          return obj2;
        }
      }, "getValue");
      module2.exports.assign = assign;
      module2.exports.isFunction = isFunction;
      module2.exports.isObject = isObject2;
      module2.exports.isArray = isArray;
      module2.exports.isEmpty = isEmpty;
      module2.exports.isPlainObject = isPlainObject;
      module2.exports.getValue = getValue;
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLAttribute.js
var require_XMLAttribute = __commonJS({
  "node_modules/xmlbuilder/lib/XMLAttribute.js"(exports2, module2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function() {
      var XMLAttribute;
      module2.exports = XMLAttribute = function() {
        function XMLAttribute2(parent, name, value) {
          this.options = parent.options;
          this.stringify = parent.stringify;
          this.parent = parent;
          if (name == null) {
            throw new Error("Missing attribute name. " + this.debugInfo(name));
          }
          if (value == null) {
            throw new Error("Missing attribute value. " + this.debugInfo(name));
          }
          this.name = this.stringify.attName(name);
          this.value = this.stringify.attValue(value);
        }
        __name(XMLAttribute2, "XMLAttribute");
        XMLAttribute2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLAttribute2.prototype.toString = function(options) {
          return this.options.writer.set(options).attribute(this);
        };
        XMLAttribute2.prototype.debugInfo = function(name) {
          name = name || this.name;
          if (name == null) {
            return "parent: <" + this.parent.name + ">";
          } else {
            return "attribute: {" + name + "}, parent: <" + this.parent.name + ">";
          }
        };
        return XMLAttribute2;
      }();
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLElement.js
var require_XMLElement = __commonJS({
  "node_modules/xmlbuilder/lib/XMLElement.js"(exports2, module2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function() {
      var XMLAttribute, XMLElement, XMLNode, getValue, isFunction, isObject2, ref, extend = /* @__PURE__ */ __name(function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        __name(ctor, "ctor");
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, "extend"), hasProp = {}.hasOwnProperty;
      ref = require_Utility(), isObject2 = ref.isObject, isFunction = ref.isFunction, getValue = ref.getValue;
      XMLNode = require_XMLNode();
      XMLAttribute = require_XMLAttribute();
      module2.exports = XMLElement = function(superClass) {
        extend(XMLElement2, superClass);
        function XMLElement2(parent, name, attributes) {
          XMLElement2.__super__.constructor.call(this, parent);
          if (name == null) {
            throw new Error("Missing element name. " + this.debugInfo());
          }
          this.name = this.stringify.eleName(name);
          this.attributes = {};
          if (attributes != null) {
            this.attribute(attributes);
          }
          if (parent.isDocument) {
            this.isRoot = true;
            this.documentObject = parent;
            parent.rootObject = this;
          }
        }
        __name(XMLElement2, "XMLElement");
        XMLElement2.prototype.clone = function() {
          var att, attName, clonedSelf, ref1;
          clonedSelf = Object.create(this);
          if (clonedSelf.isRoot) {
            clonedSelf.documentObject = null;
          }
          clonedSelf.attributes = {};
          ref1 = this.attributes;
          for (attName in ref1) {
            if (!hasProp.call(ref1, attName))
              continue;
            att = ref1[attName];
            clonedSelf.attributes[attName] = att.clone();
          }
          clonedSelf.children = [];
          this.children.forEach(function(child) {
            var clonedChild;
            clonedChild = child.clone();
            clonedChild.parent = clonedSelf;
            return clonedSelf.children.push(clonedChild);
          });
          return clonedSelf;
        };
        XMLElement2.prototype.attribute = function(name, value) {
          var attName, attValue;
          if (name != null) {
            name = getValue(name);
          }
          if (isObject2(name)) {
            for (attName in name) {
              if (!hasProp.call(name, attName))
                continue;
              attValue = name[attName];
              this.attribute(attName, attValue);
            }
          } else {
            if (isFunction(value)) {
              value = value.apply();
            }
            if (!this.options.skipNullAttributes || value != null) {
              this.attributes[name] = new XMLAttribute(this, name, value);
            }
          }
          return this;
        };
        XMLElement2.prototype.removeAttribute = function(name) {
          var attName, i2, len;
          if (name == null) {
            throw new Error("Missing attribute name. " + this.debugInfo());
          }
          name = getValue(name);
          if (Array.isArray(name)) {
            for (i2 = 0, len = name.length; i2 < len; i2++) {
              attName = name[i2];
              delete this.attributes[attName];
            }
          } else {
            delete this.attributes[name];
          }
          return this;
        };
        XMLElement2.prototype.toString = function(options) {
          return this.options.writer.set(options).element(this);
        };
        XMLElement2.prototype.att = function(name, value) {
          return this.attribute(name, value);
        };
        XMLElement2.prototype.a = function(name, value) {
          return this.attribute(name, value);
        };
        return XMLElement2;
      }(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLCData.js
var require_XMLCData = __commonJS({
  "node_modules/xmlbuilder/lib/XMLCData.js"(exports2, module2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function() {
      var XMLCData, XMLNode, extend = /* @__PURE__ */ __name(function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        __name(ctor, "ctor");
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, "extend"), hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      module2.exports = XMLCData = function(superClass) {
        extend(XMLCData2, superClass);
        function XMLCData2(parent, text) {
          XMLCData2.__super__.constructor.call(this, parent);
          if (text == null) {
            throw new Error("Missing CDATA text. " + this.debugInfo());
          }
          this.text = this.stringify.cdata(text);
        }
        __name(XMLCData2, "XMLCData");
        XMLCData2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLCData2.prototype.toString = function(options) {
          return this.options.writer.set(options).cdata(this);
        };
        return XMLCData2;
      }(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLComment.js
var require_XMLComment = __commonJS({
  "node_modules/xmlbuilder/lib/XMLComment.js"(exports2, module2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function() {
      var XMLComment, XMLNode, extend = /* @__PURE__ */ __name(function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        __name(ctor, "ctor");
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, "extend"), hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      module2.exports = XMLComment = function(superClass) {
        extend(XMLComment2, superClass);
        function XMLComment2(parent, text) {
          XMLComment2.__super__.constructor.call(this, parent);
          if (text == null) {
            throw new Error("Missing comment text. " + this.debugInfo());
          }
          this.text = this.stringify.comment(text);
        }
        __name(XMLComment2, "XMLComment");
        XMLComment2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLComment2.prototype.toString = function(options) {
          return this.options.writer.set(options).comment(this);
        };
        return XMLComment2;
      }(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLDeclaration.js
var require_XMLDeclaration = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDeclaration.js"(exports2, module2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function() {
      var XMLDeclaration, XMLNode, isObject2, extend = /* @__PURE__ */ __name(function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        __name(ctor, "ctor");
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, "extend"), hasProp = {}.hasOwnProperty;
      isObject2 = require_Utility().isObject;
      XMLNode = require_XMLNode();
      module2.exports = XMLDeclaration = function(superClass) {
        extend(XMLDeclaration2, superClass);
        function XMLDeclaration2(parent, version2, encoding, standalone) {
          var ref;
          XMLDeclaration2.__super__.constructor.call(this, parent);
          if (isObject2(version2)) {
            ref = version2, version2 = ref.version, encoding = ref.encoding, standalone = ref.standalone;
          }
          if (!version2) {
            version2 = "1.0";
          }
          this.version = this.stringify.xmlVersion(version2);
          if (encoding != null) {
            this.encoding = this.stringify.xmlEncoding(encoding);
          }
          if (standalone != null) {
            this.standalone = this.stringify.xmlStandalone(standalone);
          }
        }
        __name(XMLDeclaration2, "XMLDeclaration");
        XMLDeclaration2.prototype.toString = function(options) {
          return this.options.writer.set(options).declaration(this);
        };
        return XMLDeclaration2;
      }(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLDTDAttList.js
var require_XMLDTDAttList = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDTDAttList.js"(exports2, module2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function() {
      var XMLDTDAttList, XMLNode, extend = /* @__PURE__ */ __name(function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        __name(ctor, "ctor");
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, "extend"), hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      module2.exports = XMLDTDAttList = function(superClass) {
        extend(XMLDTDAttList2, superClass);
        function XMLDTDAttList2(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {
          XMLDTDAttList2.__super__.constructor.call(this, parent);
          if (elementName == null) {
            throw new Error("Missing DTD element name. " + this.debugInfo());
          }
          if (attributeName == null) {
            throw new Error("Missing DTD attribute name. " + this.debugInfo(elementName));
          }
          if (!attributeType) {
            throw new Error("Missing DTD attribute type. " + this.debugInfo(elementName));
          }
          if (!defaultValueType) {
            throw new Error("Missing DTD attribute default. " + this.debugInfo(elementName));
          }
          if (defaultValueType.indexOf("#") !== 0) {
            defaultValueType = "#" + defaultValueType;
          }
          if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) {
            throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT. " + this.debugInfo(elementName));
          }
          if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) {
            throw new Error("Default value only applies to #FIXED or #DEFAULT. " + this.debugInfo(elementName));
          }
          this.elementName = this.stringify.eleName(elementName);
          this.attributeName = this.stringify.attName(attributeName);
          this.attributeType = this.stringify.dtdAttType(attributeType);
          this.defaultValue = this.stringify.dtdAttDefault(defaultValue);
          this.defaultValueType = defaultValueType;
        }
        __name(XMLDTDAttList2, "XMLDTDAttList");
        XMLDTDAttList2.prototype.toString = function(options) {
          return this.options.writer.set(options).dtdAttList(this);
        };
        return XMLDTDAttList2;
      }(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLDTDEntity.js
var require_XMLDTDEntity = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDTDEntity.js"(exports2, module2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function() {
      var XMLDTDEntity, XMLNode, isObject2, extend = /* @__PURE__ */ __name(function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        __name(ctor, "ctor");
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, "extend"), hasProp = {}.hasOwnProperty;
      isObject2 = require_Utility().isObject;
      XMLNode = require_XMLNode();
      module2.exports = XMLDTDEntity = function(superClass) {
        extend(XMLDTDEntity2, superClass);
        function XMLDTDEntity2(parent, pe2, name, value) {
          XMLDTDEntity2.__super__.constructor.call(this, parent);
          if (name == null) {
            throw new Error("Missing DTD entity name. " + this.debugInfo(name));
          }
          if (value == null) {
            throw new Error("Missing DTD entity value. " + this.debugInfo(name));
          }
          this.pe = !!pe2;
          this.name = this.stringify.eleName(name);
          if (!isObject2(value)) {
            this.value = this.stringify.dtdEntityValue(value);
          } else {
            if (!value.pubID && !value.sysID) {
              throw new Error("Public and/or system identifiers are required for an external entity. " + this.debugInfo(name));
            }
            if (value.pubID && !value.sysID) {
              throw new Error("System identifier is required for a public external entity. " + this.debugInfo(name));
            }
            if (value.pubID != null) {
              this.pubID = this.stringify.dtdPubID(value.pubID);
            }
            if (value.sysID != null) {
              this.sysID = this.stringify.dtdSysID(value.sysID);
            }
            if (value.nData != null) {
              this.nData = this.stringify.dtdNData(value.nData);
            }
            if (this.pe && this.nData) {
              throw new Error("Notation declaration is not allowed in a parameter entity. " + this.debugInfo(name));
            }
          }
        }
        __name(XMLDTDEntity2, "XMLDTDEntity");
        XMLDTDEntity2.prototype.toString = function(options) {
          return this.options.writer.set(options).dtdEntity(this);
        };
        return XMLDTDEntity2;
      }(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLDTDElement.js
var require_XMLDTDElement = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDTDElement.js"(exports2, module2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function() {
      var XMLDTDElement, XMLNode, extend = /* @__PURE__ */ __name(function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        __name(ctor, "ctor");
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, "extend"), hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      module2.exports = XMLDTDElement = function(superClass) {
        extend(XMLDTDElement2, superClass);
        function XMLDTDElement2(parent, name, value) {
          XMLDTDElement2.__super__.constructor.call(this, parent);
          if (name == null) {
            throw new Error("Missing DTD element name. " + this.debugInfo());
          }
          if (!value) {
            value = "(#PCDATA)";
          }
          if (Array.isArray(value)) {
            value = "(" + value.join(",") + ")";
          }
          this.name = this.stringify.eleName(name);
          this.value = this.stringify.dtdElementValue(value);
        }
        __name(XMLDTDElement2, "XMLDTDElement");
        XMLDTDElement2.prototype.toString = function(options) {
          return this.options.writer.set(options).dtdElement(this);
        };
        return XMLDTDElement2;
      }(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLDTDNotation.js
var require_XMLDTDNotation = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDTDNotation.js"(exports2, module2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function() {
      var XMLDTDNotation, XMLNode, extend = /* @__PURE__ */ __name(function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        __name(ctor, "ctor");
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, "extend"), hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      module2.exports = XMLDTDNotation = function(superClass) {
        extend(XMLDTDNotation2, superClass);
        function XMLDTDNotation2(parent, name, value) {
          XMLDTDNotation2.__super__.constructor.call(this, parent);
          if (name == null) {
            throw new Error("Missing DTD notation name. " + this.debugInfo(name));
          }
          if (!value.pubID && !value.sysID) {
            throw new Error("Public or system identifiers are required for an external entity. " + this.debugInfo(name));
          }
          this.name = this.stringify.eleName(name);
          if (value.pubID != null) {
            this.pubID = this.stringify.dtdPubID(value.pubID);
          }
          if (value.sysID != null) {
            this.sysID = this.stringify.dtdSysID(value.sysID);
          }
        }
        __name(XMLDTDNotation2, "XMLDTDNotation");
        XMLDTDNotation2.prototype.toString = function(options) {
          return this.options.writer.set(options).dtdNotation(this);
        };
        return XMLDTDNotation2;
      }(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLDocType.js
var require_XMLDocType = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDocType.js"(exports2, module2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function() {
      var XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDocType, XMLNode, isObject2, extend = /* @__PURE__ */ __name(function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        __name(ctor, "ctor");
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, "extend"), hasProp = {}.hasOwnProperty;
      isObject2 = require_Utility().isObject;
      XMLNode = require_XMLNode();
      XMLDTDAttList = require_XMLDTDAttList();
      XMLDTDEntity = require_XMLDTDEntity();
      XMLDTDElement = require_XMLDTDElement();
      XMLDTDNotation = require_XMLDTDNotation();
      module2.exports = XMLDocType = function(superClass) {
        extend(XMLDocType2, superClass);
        function XMLDocType2(parent, pubID, sysID) {
          var ref, ref1;
          XMLDocType2.__super__.constructor.call(this, parent);
          this.name = "!DOCTYPE";
          this.documentObject = parent;
          if (isObject2(pubID)) {
            ref = pubID, pubID = ref.pubID, sysID = ref.sysID;
          }
          if (sysID == null) {
            ref1 = [pubID, sysID], sysID = ref1[0], pubID = ref1[1];
          }
          if (pubID != null) {
            this.pubID = this.stringify.dtdPubID(pubID);
          }
          if (sysID != null) {
            this.sysID = this.stringify.dtdSysID(sysID);
          }
        }
        __name(XMLDocType2, "XMLDocType");
        XMLDocType2.prototype.element = function(name, value) {
          var child;
          child = new XMLDTDElement(this, name, value);
          this.children.push(child);
          return this;
        };
        XMLDocType2.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
          var child;
          child = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
          this.children.push(child);
          return this;
        };
        XMLDocType2.prototype.entity = function(name, value) {
          var child;
          child = new XMLDTDEntity(this, false, name, value);
          this.children.push(child);
          return this;
        };
        XMLDocType2.prototype.pEntity = function(name, value) {
          var child;
          child = new XMLDTDEntity(this, true, name, value);
          this.children.push(child);
          return this;
        };
        XMLDocType2.prototype.notation = function(name, value) {
          var child;
          child = new XMLDTDNotation(this, name, value);
          this.children.push(child);
          return this;
        };
        XMLDocType2.prototype.toString = function(options) {
          return this.options.writer.set(options).docType(this);
        };
        XMLDocType2.prototype.ele = function(name, value) {
          return this.element(name, value);
        };
        XMLDocType2.prototype.att = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
          return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);
        };
        XMLDocType2.prototype.ent = function(name, value) {
          return this.entity(name, value);
        };
        XMLDocType2.prototype.pent = function(name, value) {
          return this.pEntity(name, value);
        };
        XMLDocType2.prototype.not = function(name, value) {
          return this.notation(name, value);
        };
        XMLDocType2.prototype.up = function() {
          return this.root() || this.documentObject;
        };
        return XMLDocType2;
      }(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLRaw.js
var require_XMLRaw = __commonJS({
  "node_modules/xmlbuilder/lib/XMLRaw.js"(exports2, module2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function() {
      var XMLNode, XMLRaw, extend = /* @__PURE__ */ __name(function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        __name(ctor, "ctor");
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, "extend"), hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      module2.exports = XMLRaw = function(superClass) {
        extend(XMLRaw2, superClass);
        function XMLRaw2(parent, text) {
          XMLRaw2.__super__.constructor.call(this, parent);
          if (text == null) {
            throw new Error("Missing raw text. " + this.debugInfo());
          }
          this.value = this.stringify.raw(text);
        }
        __name(XMLRaw2, "XMLRaw");
        XMLRaw2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLRaw2.prototype.toString = function(options) {
          return this.options.writer.set(options).raw(this);
        };
        return XMLRaw2;
      }(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLText.js
var require_XMLText = __commonJS({
  "node_modules/xmlbuilder/lib/XMLText.js"(exports2, module2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function() {
      var XMLNode, XMLText, extend = /* @__PURE__ */ __name(function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        __name(ctor, "ctor");
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, "extend"), hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      module2.exports = XMLText = function(superClass) {
        extend(XMLText2, superClass);
        function XMLText2(parent, text) {
          XMLText2.__super__.constructor.call(this, parent);
          if (text == null) {
            throw new Error("Missing element text. " + this.debugInfo());
          }
          this.value = this.stringify.eleText(text);
        }
        __name(XMLText2, "XMLText");
        XMLText2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLText2.prototype.toString = function(options) {
          return this.options.writer.set(options).text(this);
        };
        return XMLText2;
      }(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLProcessingInstruction.js
var require_XMLProcessingInstruction = __commonJS({
  "node_modules/xmlbuilder/lib/XMLProcessingInstruction.js"(exports2, module2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function() {
      var XMLNode, XMLProcessingInstruction, extend = /* @__PURE__ */ __name(function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        __name(ctor, "ctor");
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, "extend"), hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      module2.exports = XMLProcessingInstruction = function(superClass) {
        extend(XMLProcessingInstruction2, superClass);
        function XMLProcessingInstruction2(parent, target, value) {
          XMLProcessingInstruction2.__super__.constructor.call(this, parent);
          if (target == null) {
            throw new Error("Missing instruction target. " + this.debugInfo());
          }
          this.target = this.stringify.insTarget(target);
          if (value) {
            this.value = this.stringify.insValue(value);
          }
        }
        __name(XMLProcessingInstruction2, "XMLProcessingInstruction");
        XMLProcessingInstruction2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLProcessingInstruction2.prototype.toString = function(options) {
          return this.options.writer.set(options).processingInstruction(this);
        };
        return XMLProcessingInstruction2;
      }(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLDummy.js
var require_XMLDummy = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDummy.js"(exports2, module2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function() {
      var XMLDummy, XMLNode, extend = /* @__PURE__ */ __name(function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        __name(ctor, "ctor");
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, "extend"), hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      module2.exports = XMLDummy = function(superClass) {
        extend(XMLDummy2, superClass);
        function XMLDummy2(parent) {
          XMLDummy2.__super__.constructor.call(this, parent);
          this.isDummy = true;
        }
        __name(XMLDummy2, "XMLDummy");
        XMLDummy2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLDummy2.prototype.toString = function(options) {
          return "";
        };
        return XMLDummy2;
      }(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLNode.js
var require_XMLNode = __commonJS({
  "node_modules/xmlbuilder/lib/XMLNode.js"(exports2, module2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function() {
      var XMLCData, XMLComment, XMLDeclaration, XMLDocType, XMLDummy, XMLElement, XMLNode, XMLProcessingInstruction, XMLRaw, XMLText, getValue, isEmpty, isFunction, isObject2, ref, hasProp = {}.hasOwnProperty;
      ref = require_Utility(), isObject2 = ref.isObject, isFunction = ref.isFunction, isEmpty = ref.isEmpty, getValue = ref.getValue;
      XMLElement = null;
      XMLCData = null;
      XMLComment = null;
      XMLDeclaration = null;
      XMLDocType = null;
      XMLRaw = null;
      XMLText = null;
      XMLProcessingInstruction = null;
      XMLDummy = null;
      module2.exports = XMLNode = function() {
        function XMLNode2(parent) {
          this.parent = parent;
          if (this.parent) {
            this.options = this.parent.options;
            this.stringify = this.parent.stringify;
          }
          this.children = [];
          if (!XMLElement) {
            XMLElement = require_XMLElement();
            XMLCData = require_XMLCData();
            XMLComment = require_XMLComment();
            XMLDeclaration = require_XMLDeclaration();
            XMLDocType = require_XMLDocType();
            XMLRaw = require_XMLRaw();
            XMLText = require_XMLText();
            XMLProcessingInstruction = require_XMLProcessingInstruction();
            XMLDummy = require_XMLDummy();
          }
        }
        __name(XMLNode2, "XMLNode");
        XMLNode2.prototype.element = function(name, attributes, text) {
          var childNode, item, j2, k2, key, lastChild, len, len1, ref1, ref2, val;
          lastChild = null;
          if (attributes === null && text == null) {
            ref1 = [{}, null], attributes = ref1[0], text = ref1[1];
          }
          if (attributes == null) {
            attributes = {};
          }
          attributes = getValue(attributes);
          if (!isObject2(attributes)) {
            ref2 = [attributes, text], text = ref2[0], attributes = ref2[1];
          }
          if (name != null) {
            name = getValue(name);
          }
          if (Array.isArray(name)) {
            for (j2 = 0, len = name.length; j2 < len; j2++) {
              item = name[j2];
              lastChild = this.element(item);
            }
          } else if (isFunction(name)) {
            lastChild = this.element(name.apply());
          } else if (isObject2(name)) {
            for (key in name) {
              if (!hasProp.call(name, key))
                continue;
              val = name[key];
              if (isFunction(val)) {
                val = val.apply();
              }
              if (isObject2(val) && isEmpty(val)) {
                val = null;
              }
              if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) {
                lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);
              } else if (!this.options.separateArrayItems && Array.isArray(val)) {
                for (k2 = 0, len1 = val.length; k2 < len1; k2++) {
                  item = val[k2];
                  childNode = {};
                  childNode[key] = item;
                  lastChild = this.element(childNode);
                }
              } else if (isObject2(val)) {
                lastChild = this.element(key);
                lastChild.element(val);
              } else {
                lastChild = this.element(key, val);
              }
            }
          } else if (this.options.skipNullNodes && text === null) {
            lastChild = this.dummy();
          } else {
            if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) {
              lastChild = this.text(text);
            } else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) {
              lastChild = this.cdata(text);
            } else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) {
              lastChild = this.comment(text);
            } else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) {
              lastChild = this.raw(text);
            } else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && name.indexOf(this.stringify.convertPIKey) === 0) {
              lastChild = this.instruction(name.substr(this.stringify.convertPIKey.length), text);
            } else {
              lastChild = this.node(name, attributes, text);
            }
          }
          if (lastChild == null) {
            throw new Error("Could not create any elements with: " + name + ". " + this.debugInfo());
          }
          return lastChild;
        };
        XMLNode2.prototype.insertBefore = function(name, attributes, text) {
          var child, i2, removed;
          if (this.isRoot) {
            throw new Error("Cannot insert elements at root level. " + this.debugInfo(name));
          }
          i2 = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i2);
          child = this.parent.element(name, attributes, text);
          Array.prototype.push.apply(this.parent.children, removed);
          return child;
        };
        XMLNode2.prototype.insertAfter = function(name, attributes, text) {
          var child, i2, removed;
          if (this.isRoot) {
            throw new Error("Cannot insert elements at root level. " + this.debugInfo(name));
          }
          i2 = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i2 + 1);
          child = this.parent.element(name, attributes, text);
          Array.prototype.push.apply(this.parent.children, removed);
          return child;
        };
        XMLNode2.prototype.remove = function() {
          var i2, ref1;
          if (this.isRoot) {
            throw new Error("Cannot remove the root element. " + this.debugInfo());
          }
          i2 = this.parent.children.indexOf(this);
          [].splice.apply(this.parent.children, [i2, i2 - i2 + 1].concat(ref1 = [])), ref1;
          return this.parent;
        };
        XMLNode2.prototype.node = function(name, attributes, text) {
          var child, ref1;
          if (name != null) {
            name = getValue(name);
          }
          attributes || (attributes = {});
          attributes = getValue(attributes);
          if (!isObject2(attributes)) {
            ref1 = [attributes, text], text = ref1[0], attributes = ref1[1];
          }
          child = new XMLElement(this, name, attributes);
          if (text != null) {
            child.text(text);
          }
          this.children.push(child);
          return child;
        };
        XMLNode2.prototype.text = function(value) {
          var child;
          child = new XMLText(this, value);
          this.children.push(child);
          return this;
        };
        XMLNode2.prototype.cdata = function(value) {
          var child;
          child = new XMLCData(this, value);
          this.children.push(child);
          return this;
        };
        XMLNode2.prototype.comment = function(value) {
          var child;
          child = new XMLComment(this, value);
          this.children.push(child);
          return this;
        };
        XMLNode2.prototype.commentBefore = function(value) {
          var child, i2, removed;
          i2 = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i2);
          child = this.parent.comment(value);
          Array.prototype.push.apply(this.parent.children, removed);
          return this;
        };
        XMLNode2.prototype.commentAfter = function(value) {
          var child, i2, removed;
          i2 = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i2 + 1);
          child = this.parent.comment(value);
          Array.prototype.push.apply(this.parent.children, removed);
          return this;
        };
        XMLNode2.prototype.raw = function(value) {
          var child;
          child = new XMLRaw(this, value);
          this.children.push(child);
          return this;
        };
        XMLNode2.prototype.dummy = function() {
          var child;
          child = new XMLDummy(this);
          this.children.push(child);
          return child;
        };
        XMLNode2.prototype.instruction = function(target, value) {
          var insTarget, insValue, instruction, j2, len;
          if (target != null) {
            target = getValue(target);
          }
          if (value != null) {
            value = getValue(value);
          }
          if (Array.isArray(target)) {
            for (j2 = 0, len = target.length; j2 < len; j2++) {
              insTarget = target[j2];
              this.instruction(insTarget);
            }
          } else if (isObject2(target)) {
            for (insTarget in target) {
              if (!hasProp.call(target, insTarget))
                continue;
              insValue = target[insTarget];
              this.instruction(insTarget, insValue);
            }
          } else {
            if (isFunction(value)) {
              value = value.apply();
            }
            instruction = new XMLProcessingInstruction(this, target, value);
            this.children.push(instruction);
          }
          return this;
        };
        XMLNode2.prototype.instructionBefore = function(target, value) {
          var child, i2, removed;
          i2 = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i2);
          child = this.parent.instruction(target, value);
          Array.prototype.push.apply(this.parent.children, removed);
          return this;
        };
        XMLNode2.prototype.instructionAfter = function(target, value) {
          var child, i2, removed;
          i2 = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i2 + 1);
          child = this.parent.instruction(target, value);
          Array.prototype.push.apply(this.parent.children, removed);
          return this;
        };
        XMLNode2.prototype.declaration = function(version2, encoding, standalone) {
          var doc, xmldec;
          doc = this.document();
          xmldec = new XMLDeclaration(doc, version2, encoding, standalone);
          if (doc.children[0] instanceof XMLDeclaration) {
            doc.children[0] = xmldec;
          } else {
            doc.children.unshift(xmldec);
          }
          return doc.root() || doc;
        };
        XMLNode2.prototype.doctype = function(pubID, sysID) {
          var child, doc, doctype, i2, j2, k2, len, len1, ref1, ref2;
          doc = this.document();
          doctype = new XMLDocType(doc, pubID, sysID);
          ref1 = doc.children;
          for (i2 = j2 = 0, len = ref1.length; j2 < len; i2 = ++j2) {
            child = ref1[i2];
            if (child instanceof XMLDocType) {
              doc.children[i2] = doctype;
              return doctype;
            }
          }
          ref2 = doc.children;
          for (i2 = k2 = 0, len1 = ref2.length; k2 < len1; i2 = ++k2) {
            child = ref2[i2];
            if (child.isRoot) {
              doc.children.splice(i2, 0, doctype);
              return doctype;
            }
          }
          doc.children.push(doctype);
          return doctype;
        };
        XMLNode2.prototype.up = function() {
          if (this.isRoot) {
            throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
          }
          return this.parent;
        };
        XMLNode2.prototype.root = function() {
          var node;
          node = this;
          while (node) {
            if (node.isDocument) {
              return node.rootObject;
            } else if (node.isRoot) {
              return node;
            } else {
              node = node.parent;
            }
          }
        };
        XMLNode2.prototype.document = function() {
          var node;
          node = this;
          while (node) {
            if (node.isDocument) {
              return node;
            } else {
              node = node.parent;
            }
          }
        };
        XMLNode2.prototype.end = function(options) {
          return this.document().end(options);
        };
        XMLNode2.prototype.prev = function() {
          var i2;
          i2 = this.parent.children.indexOf(this);
          while (i2 > 0 && this.parent.children[i2 - 1].isDummy) {
            i2 = i2 - 1;
          }
          if (i2 < 1) {
            throw new Error("Already at the first node. " + this.debugInfo());
          }
          return this.parent.children[i2 - 1];
        };
        XMLNode2.prototype.next = function() {
          var i2;
          i2 = this.parent.children.indexOf(this);
          while (i2 < this.parent.children.length - 1 && this.parent.children[i2 + 1].isDummy) {
            i2 = i2 + 1;
          }
          if (i2 === -1 || i2 === this.parent.children.length - 1) {
            throw new Error("Already at the last node. " + this.debugInfo());
          }
          return this.parent.children[i2 + 1];
        };
        XMLNode2.prototype.importDocument = function(doc) {
          var clonedRoot;
          clonedRoot = doc.root().clone();
          clonedRoot.parent = this;
          clonedRoot.isRoot = false;
          this.children.push(clonedRoot);
          return this;
        };
        XMLNode2.prototype.debugInfo = function(name) {
          var ref1, ref2;
          name = name || this.name;
          if (name == null && !((ref1 = this.parent) != null ? ref1.name : void 0)) {
            return "";
          } else if (name == null) {
            return "parent: <" + this.parent.name + ">";
          } else if (!((ref2 = this.parent) != null ? ref2.name : void 0)) {
            return "node: <" + name + ">";
          } else {
            return "node: <" + name + ">, parent: <" + this.parent.name + ">";
          }
        };
        XMLNode2.prototype.ele = function(name, attributes, text) {
          return this.element(name, attributes, text);
        };
        XMLNode2.prototype.nod = function(name, attributes, text) {
          return this.node(name, attributes, text);
        };
        XMLNode2.prototype.txt = function(value) {
          return this.text(value);
        };
        XMLNode2.prototype.dat = function(value) {
          return this.cdata(value);
        };
        XMLNode2.prototype.com = function(value) {
          return this.comment(value);
        };
        XMLNode2.prototype.ins = function(target, value) {
          return this.instruction(target, value);
        };
        XMLNode2.prototype.doc = function() {
          return this.document();
        };
        XMLNode2.prototype.dec = function(version2, encoding, standalone) {
          return this.declaration(version2, encoding, standalone);
        };
        XMLNode2.prototype.dtd = function(pubID, sysID) {
          return this.doctype(pubID, sysID);
        };
        XMLNode2.prototype.e = function(name, attributes, text) {
          return this.element(name, attributes, text);
        };
        XMLNode2.prototype.n = function(name, attributes, text) {
          return this.node(name, attributes, text);
        };
        XMLNode2.prototype.t = function(value) {
          return this.text(value);
        };
        XMLNode2.prototype.d = function(value) {
          return this.cdata(value);
        };
        XMLNode2.prototype.c = function(value) {
          return this.comment(value);
        };
        XMLNode2.prototype.r = function(value) {
          return this.raw(value);
        };
        XMLNode2.prototype.i = function(target, value) {
          return this.instruction(target, value);
        };
        XMLNode2.prototype.u = function() {
          return this.up();
        };
        XMLNode2.prototype.importXMLBuilder = function(doc) {
          return this.importDocument(doc);
        };
        return XMLNode2;
      }();
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLStringifier.js
var require_XMLStringifier = __commonJS({
  "node_modules/xmlbuilder/lib/XMLStringifier.js"(exports2, module2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function() {
      var XMLStringifier, bind = /* @__PURE__ */ __name(function(fn2, me2) {
        return function() {
          return fn2.apply(me2, arguments);
        };
      }, "bind"), hasProp = {}.hasOwnProperty;
      module2.exports = XMLStringifier = function() {
        function XMLStringifier2(options) {
          this.assertLegalChar = bind(this.assertLegalChar, this);
          var key, ref, value;
          options || (options = {});
          this.noDoubleEncoding = options.noDoubleEncoding;
          ref = options.stringify || {};
          for (key in ref) {
            if (!hasProp.call(ref, key))
              continue;
            value = ref[key];
            this[key] = value;
          }
        }
        __name(XMLStringifier2, "XMLStringifier");
        XMLStringifier2.prototype.eleName = function(val) {
          val = "" + val || "";
          return this.assertLegalChar(val);
        };
        XMLStringifier2.prototype.eleText = function(val) {
          val = "" + val || "";
          return this.assertLegalChar(this.elEscape(val));
        };
        XMLStringifier2.prototype.cdata = function(val) {
          val = "" + val || "";
          val = val.replace("]]>", "]]]]><![CDATA[>");
          return this.assertLegalChar(val);
        };
        XMLStringifier2.prototype.comment = function(val) {
          val = "" + val || "";
          if (val.match(/--/)) {
            throw new Error("Comment text cannot contain double-hypen: " + val);
          }
          return this.assertLegalChar(val);
        };
        XMLStringifier2.prototype.raw = function(val) {
          return "" + val || "";
        };
        XMLStringifier2.prototype.attName = function(val) {
          return val = "" + val || "";
        };
        XMLStringifier2.prototype.attValue = function(val) {
          val = "" + val || "";
          return this.attEscape(val);
        };
        XMLStringifier2.prototype.insTarget = function(val) {
          return "" + val || "";
        };
        XMLStringifier2.prototype.insValue = function(val) {
          val = "" + val || "";
          if (val.match(/\?>/)) {
            throw new Error("Invalid processing instruction value: " + val);
          }
          return val;
        };
        XMLStringifier2.prototype.xmlVersion = function(val) {
          val = "" + val || "";
          if (!val.match(/1\.[0-9]+/)) {
            throw new Error("Invalid version number: " + val);
          }
          return val;
        };
        XMLStringifier2.prototype.xmlEncoding = function(val) {
          val = "" + val || "";
          if (!val.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/)) {
            throw new Error("Invalid encoding: " + val);
          }
          return val;
        };
        XMLStringifier2.prototype.xmlStandalone = function(val) {
          if (val) {
            return "yes";
          } else {
            return "no";
          }
        };
        XMLStringifier2.prototype.dtdPubID = function(val) {
          return "" + val || "";
        };
        XMLStringifier2.prototype.dtdSysID = function(val) {
          return "" + val || "";
        };
        XMLStringifier2.prototype.dtdElementValue = function(val) {
          return "" + val || "";
        };
        XMLStringifier2.prototype.dtdAttType = function(val) {
          return "" + val || "";
        };
        XMLStringifier2.prototype.dtdAttDefault = function(val) {
          if (val != null) {
            return "" + val || "";
          } else {
            return val;
          }
        };
        XMLStringifier2.prototype.dtdEntityValue = function(val) {
          return "" + val || "";
        };
        XMLStringifier2.prototype.dtdNData = function(val) {
          return "" + val || "";
        };
        XMLStringifier2.prototype.convertAttKey = "@";
        XMLStringifier2.prototype.convertPIKey = "?";
        XMLStringifier2.prototype.convertTextKey = "#text";
        XMLStringifier2.prototype.convertCDataKey = "#cdata";
        XMLStringifier2.prototype.convertCommentKey = "#comment";
        XMLStringifier2.prototype.convertRawKey = "#raw";
        XMLStringifier2.prototype.assertLegalChar = function(str) {
          var res;
          res = str.match(/[\0\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/);
          if (res) {
            throw new Error("Invalid character in string: " + str + " at index " + res.index);
          }
          return str;
        };
        XMLStringifier2.prototype.elEscape = function(str) {
          var ampregex;
          ampregex = this.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
          return str.replace(ampregex, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r/g, "&#xD;");
        };
        XMLStringifier2.prototype.attEscape = function(str) {
          var ampregex;
          ampregex = this.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
          return str.replace(ampregex, "&amp;").replace(/</g, "&lt;").replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
        };
        return XMLStringifier2;
      }();
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLWriterBase.js
var require_XMLWriterBase = __commonJS({
  "node_modules/xmlbuilder/lib/XMLWriterBase.js"(exports2, module2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function() {
      var XMLWriterBase, hasProp = {}.hasOwnProperty;
      module2.exports = XMLWriterBase = function() {
        function XMLWriterBase2(options) {
          var key, ref, ref1, ref2, ref3, ref4, ref5, ref6, value;
          options || (options = {});
          this.pretty = options.pretty || false;
          this.allowEmpty = (ref = options.allowEmpty) != null ? ref : false;
          if (this.pretty) {
            this.indent = (ref1 = options.indent) != null ? ref1 : "  ";
            this.newline = (ref2 = options.newline) != null ? ref2 : "\n";
            this.offset = (ref3 = options.offset) != null ? ref3 : 0;
            this.dontprettytextnodes = (ref4 = options.dontprettytextnodes) != null ? ref4 : 0;
          } else {
            this.indent = "";
            this.newline = "";
            this.offset = 0;
            this.dontprettytextnodes = 0;
          }
          this.spacebeforeslash = (ref5 = options.spacebeforeslash) != null ? ref5 : "";
          if (this.spacebeforeslash === true) {
            this.spacebeforeslash = " ";
          }
          this.newlinedefault = this.newline;
          this.prettydefault = this.pretty;
          ref6 = options.writer || {};
          for (key in ref6) {
            if (!hasProp.call(ref6, key))
              continue;
            value = ref6[key];
            this[key] = value;
          }
        }
        __name(XMLWriterBase2, "XMLWriterBase");
        XMLWriterBase2.prototype.set = function(options) {
          var key, ref, value;
          options || (options = {});
          if ("pretty" in options) {
            this.pretty = options.pretty;
          }
          if ("allowEmpty" in options) {
            this.allowEmpty = options.allowEmpty;
          }
          if (this.pretty) {
            this.indent = "indent" in options ? options.indent : "  ";
            this.newline = "newline" in options ? options.newline : "\n";
            this.offset = "offset" in options ? options.offset : 0;
            this.dontprettytextnodes = "dontprettytextnodes" in options ? options.dontprettytextnodes : 0;
          } else {
            this.indent = "";
            this.newline = "";
            this.offset = 0;
            this.dontprettytextnodes = 0;
          }
          this.spacebeforeslash = "spacebeforeslash" in options ? options.spacebeforeslash : "";
          if (this.spacebeforeslash === true) {
            this.spacebeforeslash = " ";
          }
          this.newlinedefault = this.newline;
          this.prettydefault = this.pretty;
          ref = options.writer || {};
          for (key in ref) {
            if (!hasProp.call(ref, key))
              continue;
            value = ref[key];
            this[key] = value;
          }
          return this;
        };
        XMLWriterBase2.prototype.space = function(level) {
          var indent;
          if (this.pretty) {
            indent = (level || 0) + this.offset + 1;
            if (indent > 0) {
              return new Array(indent).join(this.indent);
            } else {
              return "";
            }
          } else {
            return "";
          }
        };
        return XMLWriterBase2;
      }();
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLStringWriter.js
var require_XMLStringWriter = __commonJS({
  "node_modules/xmlbuilder/lib/XMLStringWriter.js"(exports2, module2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function() {
      var XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDummy, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStringWriter, XMLText, XMLWriterBase, extend = /* @__PURE__ */ __name(function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        __name(ctor, "ctor");
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, "extend"), hasProp = {}.hasOwnProperty;
      XMLDeclaration = require_XMLDeclaration();
      XMLDocType = require_XMLDocType();
      XMLCData = require_XMLCData();
      XMLComment = require_XMLComment();
      XMLElement = require_XMLElement();
      XMLRaw = require_XMLRaw();
      XMLText = require_XMLText();
      XMLProcessingInstruction = require_XMLProcessingInstruction();
      XMLDummy = require_XMLDummy();
      XMLDTDAttList = require_XMLDTDAttList();
      XMLDTDElement = require_XMLDTDElement();
      XMLDTDEntity = require_XMLDTDEntity();
      XMLDTDNotation = require_XMLDTDNotation();
      XMLWriterBase = require_XMLWriterBase();
      module2.exports = XMLStringWriter = function(superClass) {
        extend(XMLStringWriter2, superClass);
        function XMLStringWriter2(options) {
          XMLStringWriter2.__super__.constructor.call(this, options);
        }
        __name(XMLStringWriter2, "XMLStringWriter");
        XMLStringWriter2.prototype.document = function(doc) {
          var child, i2, len, r2, ref;
          this.textispresent = false;
          r2 = "";
          ref = doc.children;
          for (i2 = 0, len = ref.length; i2 < len; i2++) {
            child = ref[i2];
            if (child instanceof XMLDummy) {
              continue;
            }
            r2 += function() {
              switch (false) {
                case !(child instanceof XMLDeclaration):
                  return this.declaration(child);
                case !(child instanceof XMLDocType):
                  return this.docType(child);
                case !(child instanceof XMLComment):
                  return this.comment(child);
                case !(child instanceof XMLProcessingInstruction):
                  return this.processingInstruction(child);
                default:
                  return this.element(child, 0);
              }
            }.call(this);
          }
          if (this.pretty && r2.slice(-this.newline.length) === this.newline) {
            r2 = r2.slice(0, -this.newline.length);
          }
          return r2;
        };
        XMLStringWriter2.prototype.attribute = function(att) {
          return " " + att.name + '="' + att.value + '"';
        };
        XMLStringWriter2.prototype.cdata = function(node, level) {
          return this.space(level) + "<![CDATA[" + node.text + "]]>" + this.newline;
        };
        XMLStringWriter2.prototype.comment = function(node, level) {
          return this.space(level) + "<!-- " + node.text + " -->" + this.newline;
        };
        XMLStringWriter2.prototype.declaration = function(node, level) {
          var r2;
          r2 = this.space(level);
          r2 += '<?xml version="' + node.version + '"';
          if (node.encoding != null) {
            r2 += ' encoding="' + node.encoding + '"';
          }
          if (node.standalone != null) {
            r2 += ' standalone="' + node.standalone + '"';
          }
          r2 += this.spacebeforeslash + "?>";
          r2 += this.newline;
          return r2;
        };
        XMLStringWriter2.prototype.docType = function(node, level) {
          var child, i2, len, r2, ref;
          level || (level = 0);
          r2 = this.space(level);
          r2 += "<!DOCTYPE " + node.root().name;
          if (node.pubID && node.sysID) {
            r2 += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
          } else if (node.sysID) {
            r2 += ' SYSTEM "' + node.sysID + '"';
          }
          if (node.children.length > 0) {
            r2 += " [";
            r2 += this.newline;
            ref = node.children;
            for (i2 = 0, len = ref.length; i2 < len; i2++) {
              child = ref[i2];
              r2 += function() {
                switch (false) {
                  case !(child instanceof XMLDTDAttList):
                    return this.dtdAttList(child, level + 1);
                  case !(child instanceof XMLDTDElement):
                    return this.dtdElement(child, level + 1);
                  case !(child instanceof XMLDTDEntity):
                    return this.dtdEntity(child, level + 1);
                  case !(child instanceof XMLDTDNotation):
                    return this.dtdNotation(child, level + 1);
                  case !(child instanceof XMLCData):
                    return this.cdata(child, level + 1);
                  case !(child instanceof XMLComment):
                    return this.comment(child, level + 1);
                  case !(child instanceof XMLProcessingInstruction):
                    return this.processingInstruction(child, level + 1);
                  default:
                    throw new Error("Unknown DTD node type: " + child.constructor.name);
                }
              }.call(this);
            }
            r2 += "]";
          }
          r2 += this.spacebeforeslash + ">";
          r2 += this.newline;
          return r2;
        };
        XMLStringWriter2.prototype.element = function(node, level) {
          var att, child, i2, j2, len, len1, name, r2, ref, ref1, ref2, space, textispresentwasset;
          level || (level = 0);
          textispresentwasset = false;
          if (this.textispresent) {
            this.newline = "";
            this.pretty = false;
          } else {
            this.newline = this.newlinedefault;
            this.pretty = this.prettydefault;
          }
          space = this.space(level);
          r2 = "";
          r2 += space + "<" + node.name;
          ref = node.attributes;
          for (name in ref) {
            if (!hasProp.call(ref, name))
              continue;
            att = ref[name];
            r2 += this.attribute(att);
          }
          if (node.children.length === 0 || node.children.every(function(e2) {
            return e2.value === "";
          })) {
            if (this.allowEmpty) {
              r2 += "></" + node.name + ">" + this.newline;
            } else {
              r2 += this.spacebeforeslash + "/>" + this.newline;
            }
          } else if (this.pretty && node.children.length === 1 && node.children[0].value != null) {
            r2 += ">";
            r2 += node.children[0].value;
            r2 += "</" + node.name + ">" + this.newline;
          } else {
            if (this.dontprettytextnodes) {
              ref1 = node.children;
              for (i2 = 0, len = ref1.length; i2 < len; i2++) {
                child = ref1[i2];
                if (child.value != null) {
                  this.textispresent++;
                  textispresentwasset = true;
                  break;
                }
              }
            }
            if (this.textispresent) {
              this.newline = "";
              this.pretty = false;
              space = this.space(level);
            }
            r2 += ">" + this.newline;
            ref2 = node.children;
            for (j2 = 0, len1 = ref2.length; j2 < len1; j2++) {
              child = ref2[j2];
              r2 += function() {
                switch (false) {
                  case !(child instanceof XMLCData):
                    return this.cdata(child, level + 1);
                  case !(child instanceof XMLComment):
                    return this.comment(child, level + 1);
                  case !(child instanceof XMLElement):
                    return this.element(child, level + 1);
                  case !(child instanceof XMLRaw):
                    return this.raw(child, level + 1);
                  case !(child instanceof XMLText):
                    return this.text(child, level + 1);
                  case !(child instanceof XMLProcessingInstruction):
                    return this.processingInstruction(child, level + 1);
                  case !(child instanceof XMLDummy):
                    return "";
                  default:
                    throw new Error("Unknown XML node type: " + child.constructor.name);
                }
              }.call(this);
            }
            if (textispresentwasset) {
              this.textispresent--;
            }
            if (!this.textispresent) {
              this.newline = this.newlinedefault;
              this.pretty = this.prettydefault;
            }
            r2 += space + "</" + node.name + ">" + this.newline;
          }
          return r2;
        };
        XMLStringWriter2.prototype.processingInstruction = function(node, level) {
          var r2;
          r2 = this.space(level) + "<?" + node.target;
          if (node.value) {
            r2 += " " + node.value;
          }
          r2 += this.spacebeforeslash + "?>" + this.newline;
          return r2;
        };
        XMLStringWriter2.prototype.raw = function(node, level) {
          return this.space(level) + node.value + this.newline;
        };
        XMLStringWriter2.prototype.text = function(node, level) {
          return this.space(level) + node.value + this.newline;
        };
        XMLStringWriter2.prototype.dtdAttList = function(node, level) {
          var r2;
          r2 = this.space(level) + "<!ATTLIST " + node.elementName + " " + node.attributeName + " " + node.attributeType;
          if (node.defaultValueType !== "#DEFAULT") {
            r2 += " " + node.defaultValueType;
          }
          if (node.defaultValue) {
            r2 += ' "' + node.defaultValue + '"';
          }
          r2 += this.spacebeforeslash + ">" + this.newline;
          return r2;
        };
        XMLStringWriter2.prototype.dtdElement = function(node, level) {
          return this.space(level) + "<!ELEMENT " + node.name + " " + node.value + this.spacebeforeslash + ">" + this.newline;
        };
        XMLStringWriter2.prototype.dtdEntity = function(node, level) {
          var r2;
          r2 = this.space(level) + "<!ENTITY";
          if (node.pe) {
            r2 += " %";
          }
          r2 += " " + node.name;
          if (node.value) {
            r2 += ' "' + node.value + '"';
          } else {
            if (node.pubID && node.sysID) {
              r2 += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
            } else if (node.sysID) {
              r2 += ' SYSTEM "' + node.sysID + '"';
            }
            if (node.nData) {
              r2 += " NDATA " + node.nData;
            }
          }
          r2 += this.spacebeforeslash + ">" + this.newline;
          return r2;
        };
        XMLStringWriter2.prototype.dtdNotation = function(node, level) {
          var r2;
          r2 = this.space(level) + "<!NOTATION " + node.name;
          if (node.pubID && node.sysID) {
            r2 += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
          } else if (node.pubID) {
            r2 += ' PUBLIC "' + node.pubID + '"';
          } else if (node.sysID) {
            r2 += ' SYSTEM "' + node.sysID + '"';
          }
          r2 += this.spacebeforeslash + ">" + this.newline;
          return r2;
        };
        XMLStringWriter2.prototype.openNode = function(node, level) {
          var att, name, r2, ref;
          level || (level = 0);
          if (node instanceof XMLElement) {
            r2 = this.space(level) + "<" + node.name;
            ref = node.attributes;
            for (name in ref) {
              if (!hasProp.call(ref, name))
                continue;
              att = ref[name];
              r2 += this.attribute(att);
            }
            r2 += (node.children ? ">" : "/>") + this.newline;
            return r2;
          } else {
            r2 = this.space(level) + "<!DOCTYPE " + node.rootNodeName;
            if (node.pubID && node.sysID) {
              r2 += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
            } else if (node.sysID) {
              r2 += ' SYSTEM "' + node.sysID + '"';
            }
            r2 += (node.children ? " [" : ">") + this.newline;
            return r2;
          }
        };
        XMLStringWriter2.prototype.closeNode = function(node, level) {
          level || (level = 0);
          switch (false) {
            case !(node instanceof XMLElement):
              return this.space(level) + "</" + node.name + ">" + this.newline;
            case !(node instanceof XMLDocType):
              return this.space(level) + "]>" + this.newline;
          }
        };
        return XMLStringWriter2;
      }(XMLWriterBase);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLDocument.js
var require_XMLDocument = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDocument.js"(exports2, module2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function() {
      var XMLDocument, XMLNode, XMLStringWriter, XMLStringifier, isPlainObject, extend = /* @__PURE__ */ __name(function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        __name(ctor, "ctor");
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, "extend"), hasProp = {}.hasOwnProperty;
      isPlainObject = require_Utility().isPlainObject;
      XMLNode = require_XMLNode();
      XMLStringifier = require_XMLStringifier();
      XMLStringWriter = require_XMLStringWriter();
      module2.exports = XMLDocument = function(superClass) {
        extend(XMLDocument2, superClass);
        function XMLDocument2(options) {
          XMLDocument2.__super__.constructor.call(this, null);
          this.name = "?xml";
          options || (options = {});
          if (!options.writer) {
            options.writer = new XMLStringWriter();
          }
          this.options = options;
          this.stringify = new XMLStringifier(options);
          this.isDocument = true;
        }
        __name(XMLDocument2, "XMLDocument");
        XMLDocument2.prototype.end = function(writer) {
          var writerOptions;
          if (!writer) {
            writer = this.options.writer;
          } else if (isPlainObject(writer)) {
            writerOptions = writer;
            writer = this.options.writer.set(writerOptions);
          }
          return writer.document(this);
        };
        XMLDocument2.prototype.toString = function(options) {
          return this.options.writer.set(options).document(this);
        };
        return XMLDocument2;
      }(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLDocumentCB.js
var require_XMLDocumentCB = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDocumentCB.js"(exports2, module2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function() {
      var XMLAttribute, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDocumentCB, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStringWriter, XMLStringifier, XMLText, getValue, isFunction, isObject2, isPlainObject, ref, hasProp = {}.hasOwnProperty;
      ref = require_Utility(), isObject2 = ref.isObject, isFunction = ref.isFunction, isPlainObject = ref.isPlainObject, getValue = ref.getValue;
      XMLElement = require_XMLElement();
      XMLCData = require_XMLCData();
      XMLComment = require_XMLComment();
      XMLRaw = require_XMLRaw();
      XMLText = require_XMLText();
      XMLProcessingInstruction = require_XMLProcessingInstruction();
      XMLDeclaration = require_XMLDeclaration();
      XMLDocType = require_XMLDocType();
      XMLDTDAttList = require_XMLDTDAttList();
      XMLDTDEntity = require_XMLDTDEntity();
      XMLDTDElement = require_XMLDTDElement();
      XMLDTDNotation = require_XMLDTDNotation();
      XMLAttribute = require_XMLAttribute();
      XMLStringifier = require_XMLStringifier();
      XMLStringWriter = require_XMLStringWriter();
      module2.exports = XMLDocumentCB = function() {
        function XMLDocumentCB2(options, onData, onEnd) {
          var writerOptions;
          this.name = "?xml";
          options || (options = {});
          if (!options.writer) {
            options.writer = new XMLStringWriter(options);
          } else if (isPlainObject(options.writer)) {
            writerOptions = options.writer;
            options.writer = new XMLStringWriter(writerOptions);
          }
          this.options = options;
          this.writer = options.writer;
          this.stringify = new XMLStringifier(options);
          this.onDataCallback = onData || function() {
          };
          this.onEndCallback = onEnd || function() {
          };
          this.currentNode = null;
          this.currentLevel = -1;
          this.openTags = {};
          this.documentStarted = false;
          this.documentCompleted = false;
          this.root = null;
        }
        __name(XMLDocumentCB2, "XMLDocumentCB");
        XMLDocumentCB2.prototype.node = function(name, attributes, text) {
          var ref1, ref2;
          if (name == null) {
            throw new Error("Missing node name.");
          }
          if (this.root && this.currentLevel === -1) {
            throw new Error("Document can only have one root node. " + this.debugInfo(name));
          }
          this.openCurrent();
          name = getValue(name);
          if (attributes === null && text == null) {
            ref1 = [{}, null], attributes = ref1[0], text = ref1[1];
          }
          if (attributes == null) {
            attributes = {};
          }
          attributes = getValue(attributes);
          if (!isObject2(attributes)) {
            ref2 = [attributes, text], text = ref2[0], attributes = ref2[1];
          }
          this.currentNode = new XMLElement(this, name, attributes);
          this.currentNode.children = false;
          this.currentLevel++;
          this.openTags[this.currentLevel] = this.currentNode;
          if (text != null) {
            this.text(text);
          }
          return this;
        };
        XMLDocumentCB2.prototype.element = function(name, attributes, text) {
          if (this.currentNode && this.currentNode instanceof XMLDocType) {
            return this.dtdElement.apply(this, arguments);
          } else {
            return this.node(name, attributes, text);
          }
        };
        XMLDocumentCB2.prototype.attribute = function(name, value) {
          var attName, attValue;
          if (!this.currentNode || this.currentNode.children) {
            throw new Error("att() can only be used immediately after an ele() call in callback mode. " + this.debugInfo(name));
          }
          if (name != null) {
            name = getValue(name);
          }
          if (isObject2(name)) {
            for (attName in name) {
              if (!hasProp.call(name, attName))
                continue;
              attValue = name[attName];
              this.attribute(attName, attValue);
            }
          } else {
            if (isFunction(value)) {
              value = value.apply();
            }
            if (!this.options.skipNullAttributes || value != null) {
              this.currentNode.attributes[name] = new XMLAttribute(this, name, value);
            }
          }
          return this;
        };
        XMLDocumentCB2.prototype.text = function(value) {
          var node;
          this.openCurrent();
          node = new XMLText(this, value);
          this.onData(this.writer.text(node, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.cdata = function(value) {
          var node;
          this.openCurrent();
          node = new XMLCData(this, value);
          this.onData(this.writer.cdata(node, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.comment = function(value) {
          var node;
          this.openCurrent();
          node = new XMLComment(this, value);
          this.onData(this.writer.comment(node, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.raw = function(value) {
          var node;
          this.openCurrent();
          node = new XMLRaw(this, value);
          this.onData(this.writer.raw(node, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.instruction = function(target, value) {
          var i2, insTarget, insValue, len, node;
          this.openCurrent();
          if (target != null) {
            target = getValue(target);
          }
          if (value != null) {
            value = getValue(value);
          }
          if (Array.isArray(target)) {
            for (i2 = 0, len = target.length; i2 < len; i2++) {
              insTarget = target[i2];
              this.instruction(insTarget);
            }
          } else if (isObject2(target)) {
            for (insTarget in target) {
              if (!hasProp.call(target, insTarget))
                continue;
              insValue = target[insTarget];
              this.instruction(insTarget, insValue);
            }
          } else {
            if (isFunction(value)) {
              value = value.apply();
            }
            node = new XMLProcessingInstruction(this, target, value);
            this.onData(this.writer.processingInstruction(node, this.currentLevel + 1), this.currentLevel + 1);
          }
          return this;
        };
        XMLDocumentCB2.prototype.declaration = function(version2, encoding, standalone) {
          var node;
          this.openCurrent();
          if (this.documentStarted) {
            throw new Error("declaration() must be the first node.");
          }
          node = new XMLDeclaration(this, version2, encoding, standalone);
          this.onData(this.writer.declaration(node, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.doctype = function(root, pubID, sysID) {
          this.openCurrent();
          if (root == null) {
            throw new Error("Missing root node name.");
          }
          if (this.root) {
            throw new Error("dtd() must come before the root node.");
          }
          this.currentNode = new XMLDocType(this, pubID, sysID);
          this.currentNode.rootNodeName = root;
          this.currentNode.children = false;
          this.currentLevel++;
          this.openTags[this.currentLevel] = this.currentNode;
          return this;
        };
        XMLDocumentCB2.prototype.dtdElement = function(name, value) {
          var node;
          this.openCurrent();
          node = new XMLDTDElement(this, name, value);
          this.onData(this.writer.dtdElement(node, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
          var node;
          this.openCurrent();
          node = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
          this.onData(this.writer.dtdAttList(node, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.entity = function(name, value) {
          var node;
          this.openCurrent();
          node = new XMLDTDEntity(this, false, name, value);
          this.onData(this.writer.dtdEntity(node, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.pEntity = function(name, value) {
          var node;
          this.openCurrent();
          node = new XMLDTDEntity(this, true, name, value);
          this.onData(this.writer.dtdEntity(node, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.notation = function(name, value) {
          var node;
          this.openCurrent();
          node = new XMLDTDNotation(this, name, value);
          this.onData(this.writer.dtdNotation(node, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.up = function() {
          if (this.currentLevel < 0) {
            throw new Error("The document node has no parent.");
          }
          if (this.currentNode) {
            if (this.currentNode.children) {
              this.closeNode(this.currentNode);
            } else {
              this.openNode(this.currentNode);
            }
            this.currentNode = null;
          } else {
            this.closeNode(this.openTags[this.currentLevel]);
          }
          delete this.openTags[this.currentLevel];
          this.currentLevel--;
          return this;
        };
        XMLDocumentCB2.prototype.end = function() {
          while (this.currentLevel >= 0) {
            this.up();
          }
          return this.onEnd();
        };
        XMLDocumentCB2.prototype.openCurrent = function() {
          if (this.currentNode) {
            this.currentNode.children = true;
            return this.openNode(this.currentNode);
          }
        };
        XMLDocumentCB2.prototype.openNode = function(node) {
          if (!node.isOpen) {
            if (!this.root && this.currentLevel === 0 && node instanceof XMLElement) {
              this.root = node;
            }
            this.onData(this.writer.openNode(node, this.currentLevel), this.currentLevel);
            return node.isOpen = true;
          }
        };
        XMLDocumentCB2.prototype.closeNode = function(node) {
          if (!node.isClosed) {
            this.onData(this.writer.closeNode(node, this.currentLevel), this.currentLevel);
            return node.isClosed = true;
          }
        };
        XMLDocumentCB2.prototype.onData = function(chunk, level) {
          this.documentStarted = true;
          return this.onDataCallback(chunk, level + 1);
        };
        XMLDocumentCB2.prototype.onEnd = function() {
          this.documentCompleted = true;
          return this.onEndCallback();
        };
        XMLDocumentCB2.prototype.debugInfo = function(name) {
          if (name == null) {
            return "";
          } else {
            return "node: <" + name + ">";
          }
        };
        XMLDocumentCB2.prototype.ele = function() {
          return this.element.apply(this, arguments);
        };
        XMLDocumentCB2.prototype.nod = function(name, attributes, text) {
          return this.node(name, attributes, text);
        };
        XMLDocumentCB2.prototype.txt = function(value) {
          return this.text(value);
        };
        XMLDocumentCB2.prototype.dat = function(value) {
          return this.cdata(value);
        };
        XMLDocumentCB2.prototype.com = function(value) {
          return this.comment(value);
        };
        XMLDocumentCB2.prototype.ins = function(target, value) {
          return this.instruction(target, value);
        };
        XMLDocumentCB2.prototype.dec = function(version2, encoding, standalone) {
          return this.declaration(version2, encoding, standalone);
        };
        XMLDocumentCB2.prototype.dtd = function(root, pubID, sysID) {
          return this.doctype(root, pubID, sysID);
        };
        XMLDocumentCB2.prototype.e = function(name, attributes, text) {
          return this.element(name, attributes, text);
        };
        XMLDocumentCB2.prototype.n = function(name, attributes, text) {
          return this.node(name, attributes, text);
        };
        XMLDocumentCB2.prototype.t = function(value) {
          return this.text(value);
        };
        XMLDocumentCB2.prototype.d = function(value) {
          return this.cdata(value);
        };
        XMLDocumentCB2.prototype.c = function(value) {
          return this.comment(value);
        };
        XMLDocumentCB2.prototype.r = function(value) {
          return this.raw(value);
        };
        XMLDocumentCB2.prototype.i = function(target, value) {
          return this.instruction(target, value);
        };
        XMLDocumentCB2.prototype.att = function() {
          if (this.currentNode && this.currentNode instanceof XMLDocType) {
            return this.attList.apply(this, arguments);
          } else {
            return this.attribute.apply(this, arguments);
          }
        };
        XMLDocumentCB2.prototype.a = function() {
          if (this.currentNode && this.currentNode instanceof XMLDocType) {
            return this.attList.apply(this, arguments);
          } else {
            return this.attribute.apply(this, arguments);
          }
        };
        XMLDocumentCB2.prototype.ent = function(name, value) {
          return this.entity(name, value);
        };
        XMLDocumentCB2.prototype.pent = function(name, value) {
          return this.pEntity(name, value);
        };
        XMLDocumentCB2.prototype.not = function(name, value) {
          return this.notation(name, value);
        };
        return XMLDocumentCB2;
      }();
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLStreamWriter.js
var require_XMLStreamWriter = __commonJS({
  "node_modules/xmlbuilder/lib/XMLStreamWriter.js"(exports2, module2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function() {
      var XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDummy, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStreamWriter, XMLText, XMLWriterBase, extend = /* @__PURE__ */ __name(function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        __name(ctor, "ctor");
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, "extend"), hasProp = {}.hasOwnProperty;
      XMLDeclaration = require_XMLDeclaration();
      XMLDocType = require_XMLDocType();
      XMLCData = require_XMLCData();
      XMLComment = require_XMLComment();
      XMLElement = require_XMLElement();
      XMLRaw = require_XMLRaw();
      XMLText = require_XMLText();
      XMLProcessingInstruction = require_XMLProcessingInstruction();
      XMLDummy = require_XMLDummy();
      XMLDTDAttList = require_XMLDTDAttList();
      XMLDTDElement = require_XMLDTDElement();
      XMLDTDEntity = require_XMLDTDEntity();
      XMLDTDNotation = require_XMLDTDNotation();
      XMLWriterBase = require_XMLWriterBase();
      module2.exports = XMLStreamWriter = function(superClass) {
        extend(XMLStreamWriter2, superClass);
        function XMLStreamWriter2(stream, options) {
          XMLStreamWriter2.__super__.constructor.call(this, options);
          this.stream = stream;
        }
        __name(XMLStreamWriter2, "XMLStreamWriter");
        XMLStreamWriter2.prototype.document = function(doc) {
          var child, i2, j2, len, len1, ref, ref1, results;
          ref = doc.children;
          for (i2 = 0, len = ref.length; i2 < len; i2++) {
            child = ref[i2];
            child.isLastRootNode = false;
          }
          doc.children[doc.children.length - 1].isLastRootNode = true;
          ref1 = doc.children;
          results = [];
          for (j2 = 0, len1 = ref1.length; j2 < len1; j2++) {
            child = ref1[j2];
            if (child instanceof XMLDummy) {
              continue;
            }
            switch (false) {
              case !(child instanceof XMLDeclaration):
                results.push(this.declaration(child));
                break;
              case !(child instanceof XMLDocType):
                results.push(this.docType(child));
                break;
              case !(child instanceof XMLComment):
                results.push(this.comment(child));
                break;
              case !(child instanceof XMLProcessingInstruction):
                results.push(this.processingInstruction(child));
                break;
              default:
                results.push(this.element(child));
            }
          }
          return results;
        };
        XMLStreamWriter2.prototype.attribute = function(att) {
          return this.stream.write(" " + att.name + '="' + att.value + '"');
        };
        XMLStreamWriter2.prototype.cdata = function(node, level) {
          return this.stream.write(this.space(level) + "<![CDATA[" + node.text + "]]>" + this.endline(node));
        };
        XMLStreamWriter2.prototype.comment = function(node, level) {
          return this.stream.write(this.space(level) + "<!-- " + node.text + " -->" + this.endline(node));
        };
        XMLStreamWriter2.prototype.declaration = function(node, level) {
          this.stream.write(this.space(level));
          this.stream.write('<?xml version="' + node.version + '"');
          if (node.encoding != null) {
            this.stream.write(' encoding="' + node.encoding + '"');
          }
          if (node.standalone != null) {
            this.stream.write(' standalone="' + node.standalone + '"');
          }
          this.stream.write(this.spacebeforeslash + "?>");
          return this.stream.write(this.endline(node));
        };
        XMLStreamWriter2.prototype.docType = function(node, level) {
          var child, i2, len, ref;
          level || (level = 0);
          this.stream.write(this.space(level));
          this.stream.write("<!DOCTYPE " + node.root().name);
          if (node.pubID && node.sysID) {
            this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
          } else if (node.sysID) {
            this.stream.write(' SYSTEM "' + node.sysID + '"');
          }
          if (node.children.length > 0) {
            this.stream.write(" [");
            this.stream.write(this.endline(node));
            ref = node.children;
            for (i2 = 0, len = ref.length; i2 < len; i2++) {
              child = ref[i2];
              switch (false) {
                case !(child instanceof XMLDTDAttList):
                  this.dtdAttList(child, level + 1);
                  break;
                case !(child instanceof XMLDTDElement):
                  this.dtdElement(child, level + 1);
                  break;
                case !(child instanceof XMLDTDEntity):
                  this.dtdEntity(child, level + 1);
                  break;
                case !(child instanceof XMLDTDNotation):
                  this.dtdNotation(child, level + 1);
                  break;
                case !(child instanceof XMLCData):
                  this.cdata(child, level + 1);
                  break;
                case !(child instanceof XMLComment):
                  this.comment(child, level + 1);
                  break;
                case !(child instanceof XMLProcessingInstruction):
                  this.processingInstruction(child, level + 1);
                  break;
                default:
                  throw new Error("Unknown DTD node type: " + child.constructor.name);
              }
            }
            this.stream.write("]");
          }
          this.stream.write(this.spacebeforeslash + ">");
          return this.stream.write(this.endline(node));
        };
        XMLStreamWriter2.prototype.element = function(node, level) {
          var att, child, i2, len, name, ref, ref1, space;
          level || (level = 0);
          space = this.space(level);
          this.stream.write(space + "<" + node.name);
          ref = node.attributes;
          for (name in ref) {
            if (!hasProp.call(ref, name))
              continue;
            att = ref[name];
            this.attribute(att);
          }
          if (node.children.length === 0 || node.children.every(function(e2) {
            return e2.value === "";
          })) {
            if (this.allowEmpty) {
              this.stream.write("></" + node.name + ">");
            } else {
              this.stream.write(this.spacebeforeslash + "/>");
            }
          } else if (this.pretty && node.children.length === 1 && node.children[0].value != null) {
            this.stream.write(">");
            this.stream.write(node.children[0].value);
            this.stream.write("</" + node.name + ">");
          } else {
            this.stream.write(">" + this.newline);
            ref1 = node.children;
            for (i2 = 0, len = ref1.length; i2 < len; i2++) {
              child = ref1[i2];
              switch (false) {
                case !(child instanceof XMLCData):
                  this.cdata(child, level + 1);
                  break;
                case !(child instanceof XMLComment):
                  this.comment(child, level + 1);
                  break;
                case !(child instanceof XMLElement):
                  this.element(child, level + 1);
                  break;
                case !(child instanceof XMLRaw):
                  this.raw(child, level + 1);
                  break;
                case !(child instanceof XMLText):
                  this.text(child, level + 1);
                  break;
                case !(child instanceof XMLProcessingInstruction):
                  this.processingInstruction(child, level + 1);
                  break;
                case !(child instanceof XMLDummy):
                  "";
                  break;
                default:
                  throw new Error("Unknown XML node type: " + child.constructor.name);
              }
            }
            this.stream.write(space + "</" + node.name + ">");
          }
          return this.stream.write(this.endline(node));
        };
        XMLStreamWriter2.prototype.processingInstruction = function(node, level) {
          this.stream.write(this.space(level) + "<?" + node.target);
          if (node.value) {
            this.stream.write(" " + node.value);
          }
          return this.stream.write(this.spacebeforeslash + "?>" + this.endline(node));
        };
        XMLStreamWriter2.prototype.raw = function(node, level) {
          return this.stream.write(this.space(level) + node.value + this.endline(node));
        };
        XMLStreamWriter2.prototype.text = function(node, level) {
          return this.stream.write(this.space(level) + node.value + this.endline(node));
        };
        XMLStreamWriter2.prototype.dtdAttList = function(node, level) {
          this.stream.write(this.space(level) + "<!ATTLIST " + node.elementName + " " + node.attributeName + " " + node.attributeType);
          if (node.defaultValueType !== "#DEFAULT") {
            this.stream.write(" " + node.defaultValueType);
          }
          if (node.defaultValue) {
            this.stream.write(' "' + node.defaultValue + '"');
          }
          return this.stream.write(this.spacebeforeslash + ">" + this.endline(node));
        };
        XMLStreamWriter2.prototype.dtdElement = function(node, level) {
          this.stream.write(this.space(level) + "<!ELEMENT " + node.name + " " + node.value);
          return this.stream.write(this.spacebeforeslash + ">" + this.endline(node));
        };
        XMLStreamWriter2.prototype.dtdEntity = function(node, level) {
          this.stream.write(this.space(level) + "<!ENTITY");
          if (node.pe) {
            this.stream.write(" %");
          }
          this.stream.write(" " + node.name);
          if (node.value) {
            this.stream.write(' "' + node.value + '"');
          } else {
            if (node.pubID && node.sysID) {
              this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
            } else if (node.sysID) {
              this.stream.write(' SYSTEM "' + node.sysID + '"');
            }
            if (node.nData) {
              this.stream.write(" NDATA " + node.nData);
            }
          }
          return this.stream.write(this.spacebeforeslash + ">" + this.endline(node));
        };
        XMLStreamWriter2.prototype.dtdNotation = function(node, level) {
          this.stream.write(this.space(level) + "<!NOTATION " + node.name);
          if (node.pubID && node.sysID) {
            this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
          } else if (node.pubID) {
            this.stream.write(' PUBLIC "' + node.pubID + '"');
          } else if (node.sysID) {
            this.stream.write(' SYSTEM "' + node.sysID + '"');
          }
          return this.stream.write(this.spacebeforeslash + ">" + this.endline(node));
        };
        XMLStreamWriter2.prototype.endline = function(node) {
          if (!node.isLastRootNode) {
            return this.newline;
          } else {
            return "";
          }
        };
        return XMLStreamWriter2;
      }(XMLWriterBase);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/xmlbuilder/lib/index.js"(exports2, module2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function() {
      var XMLDocument, XMLDocumentCB, XMLStreamWriter, XMLStringWriter, assign, isFunction, ref;
      ref = require_Utility(), assign = ref.assign, isFunction = ref.isFunction;
      XMLDocument = require_XMLDocument();
      XMLDocumentCB = require_XMLDocumentCB();
      XMLStringWriter = require_XMLStringWriter();
      XMLStreamWriter = require_XMLStreamWriter();
      module2.exports.create = function(name, xmldec, doctype, options) {
        var doc, root;
        if (name == null) {
          throw new Error("Root element needs a name.");
        }
        options = assign({}, xmldec, doctype, options);
        doc = new XMLDocument(options);
        root = doc.element(name);
        if (!options.headless) {
          doc.declaration(options);
          if (options.pubID != null || options.sysID != null) {
            doc.doctype(options);
          }
        }
        return root;
      };
      module2.exports.begin = function(options, onData, onEnd) {
        var ref1;
        if (isFunction(options)) {
          ref1 = [options, onData], onData = ref1[0], onEnd = ref1[1];
          options = {};
        }
        if (onData) {
          return new XMLDocumentCB(options, onData, onEnd);
        } else {
          return new XMLDocument(options);
        }
      };
      module2.exports.stringWriter = function(options) {
        return new XMLStringWriter(options);
      };
      module2.exports.streamWriter = function(stream, options) {
        return new XMLStreamWriter(stream, options);
      };
    }).call(exports2);
  }
});

// node_modules/mammoth/lib/xml/writer.js
var require_writer = __commonJS({
  "node_modules/mammoth/lib/xml/writer.js"(exports2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var _2 = require_underscore_umd();
    var xmlbuilder = require_lib2();
    exports2.writeString = writeString2;
    function writeString2(root, namespaces) {
      var uriToPrefix = _2.invert(namespaces);
      var nodeWriters = {
        element: writeElement,
        text: writeTextNode
      };
      function writeNode(builder, node) {
        return nodeWriters[node.type](builder, node);
      }
      __name(writeNode, "writeNode");
      function writeElement(builder, element) {
        var elementBuilder = builder.element(mapElementName(element.name), element.attributes);
        element.children.forEach(function(child) {
          writeNode(elementBuilder, child);
        });
      }
      __name(writeElement, "writeElement");
      function mapElementName(name) {
        var longFormMatch = /^\{(.*)\}(.*)$/.exec(name);
        if (longFormMatch) {
          var prefix = uriToPrefix[longFormMatch[1]];
          return prefix + (prefix === "" ? "" : ":") + longFormMatch[2];
        } else {
          return name;
        }
      }
      __name(mapElementName, "mapElementName");
      function writeDocument(root2) {
        var builder = xmlbuilder.create(mapElementName(root2.name), {
          version: "1.0",
          encoding: "UTF-8",
          standalone: true
        });
        _2.forEach(namespaces, function(uri, prefix) {
          var key = "xmlns" + (prefix === "" ? "" : ":" + prefix);
          builder.attribute(key, uri);
        });
        root2.children.forEach(function(child) {
          writeNode(builder, child);
        });
        return builder.end();
      }
      __name(writeDocument, "writeDocument");
      return writeDocument(root);
    }
    __name(writeString2, "writeString");
    function writeTextNode(builder, node) {
      builder.text(node.value);
    }
    __name(writeTextNode, "writeTextNode");
  }
});

// node_modules/mammoth/lib/xml/index.js
var require_xml = __commonJS({
  "node_modules/mammoth/lib/xml/index.js"(exports2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var nodes = require_nodes();
    exports2.Element = nodes.Element;
    exports2.element = nodes.element;
    exports2.emptyElement = nodes.emptyElement;
    exports2.text = nodes.text;
    exports2.readString = require_reader().readString;
    exports2.writeString = require_writer().writeString;
  }
});

// node_modules/mammoth/lib/docx/office-xml-reader.js
var require_office_xml_reader = __commonJS({
  "node_modules/mammoth/lib/docx/office-xml-reader.js"(exports2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var _2 = require_underscore_umd();
    var promises = require_promises();
    var xml = require_xml();
    exports2.read = read;
    exports2.readXmlFromZipFile = readXmlFromZipFile;
    var xmlNamespaceMap = {
      // Transitional format
      "http://schemas.openxmlformats.org/wordprocessingml/2006/main": "w",
      "http://schemas.openxmlformats.org/officeDocument/2006/relationships": "r",
      "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing": "wp",
      "http://schemas.openxmlformats.org/drawingml/2006/main": "a",
      "http://schemas.openxmlformats.org/drawingml/2006/picture": "pic",
      // Strict format
      "http://purl.oclc.org/ooxml/wordprocessingml/main": "w",
      "http://purl.oclc.org/ooxml/officeDocument/relationships": "r",
      "http://purl.oclc.org/ooxml/drawingml/wordprocessingDrawing": "wp",
      "http://purl.oclc.org/ooxml/drawingml/main": "a",
      "http://purl.oclc.org/ooxml/drawingml/picture": "pic",
      // Common
      "http://schemas.openxmlformats.org/package/2006/content-types": "content-types",
      "http://schemas.openxmlformats.org/package/2006/relationships": "relationships",
      "http://schemas.openxmlformats.org/markup-compatibility/2006": "mc",
      "urn:schemas-microsoft-com:vml": "v",
      "urn:schemas-microsoft-com:office:word": "office-word",
      // [MS-DOCX]: Word Extensions to the Office Open XML (.docx) File Format
      // https://learn.microsoft.com/en-us/openspecs/office_standards/ms-docx/b839fe1f-e1ca-4fa6-8c26-5954d0abbccd
      "http://schemas.microsoft.com/office/word/2010/wordml": "wordml"
    };
    function read(xmlString) {
      return xml.readString(xmlString, xmlNamespaceMap).then(function(document2) {
        return collapseAlternateContent(document2)[0];
      });
    }
    __name(read, "read");
    function readXmlFromZipFile(docxFile, path) {
      if (docxFile.exists(path)) {
        return docxFile.read(path, "utf-8").then(stripUtf8Bom).then(read);
      } else {
        return promises.resolve(null);
      }
    }
    __name(readXmlFromZipFile, "readXmlFromZipFile");
    function stripUtf8Bom(xmlString) {
      return xmlString.replace(/^\uFEFF/g, "");
    }
    __name(stripUtf8Bom, "stripUtf8Bom");
    function collapseAlternateContent(node) {
      if (node.type === "element") {
        if (node.name === "mc:AlternateContent") {
          return node.firstOrEmpty("mc:Fallback").children;
        } else {
          node.children = _2.flatten(node.children.map(collapseAlternateContent, true));
          return [node];
        }
      } else {
        return [node];
      }
    }
    __name(collapseAlternateContent, "collapseAlternateContent");
  }
});

// node_modules/dingbat-to-unicode/dist/dingbats.js
var require_dingbats = __commonJS({
  "node_modules/dingbat-to-unicode/dist/dingbats.js"(exports2) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var dingbats = [
      { "Typeface name": "Symbol", "Dingbat dec": "32", "Dingbat hex": "20", "Unicode dec": "32", "Unicode hex": "20" },
      { "Typeface name": "Symbol", "Dingbat dec": "33", "Dingbat hex": "21", "Unicode dec": "33", "Unicode hex": "21" },
      { "Typeface name": "Symbol", "Dingbat dec": "34", "Dingbat hex": "22", "Unicode dec": "8704", "Unicode hex": "2200" },
      { "Typeface name": "Symbol", "Dingbat dec": "35", "Dingbat hex": "23", "Unicode dec": "35", "Unicode hex": "23" },
      { "Typeface name": "Symbol", "Dingbat dec": "36", "Dingbat hex": "24", "Unicode dec": "8707", "Unicode hex": "2203" },
      { "Typeface name": "Symbol", "Dingbat dec": "37", "Dingbat hex": "25", "Unicode dec": "37", "Unicode hex": "25" },
      { "Typeface name": "Symbol", "Dingbat dec": "38", "Dingbat hex": "26", "Unicode dec": "38", "Unicode hex": "26" },
      { "Typeface name": "Symbol", "Dingbat dec": "39", "Dingbat hex": "27", "Unicode dec": "8717", "Unicode hex": "220D" },
      { "Typeface name": "Symbol", "Dingbat dec": "40", "Dingbat hex": "28", "Unicode dec": "40", "Unicode hex": "28" },
      { "Typeface name": "Symbol", "Dingbat dec": "41", "Dingbat hex": "29", "Unicode dec": "41", "Unicode hex": "29" },
      { "Typeface name": "Symbol", "Dingbat dec": "42", "Dingbat hex": "2A", "Unicode dec": "42", "Unicode hex": "2A" },
      { "Typeface name": "Symbol", "Dingbat dec": "43", "Dingbat hex": "2B", "Unicode dec": "43", "Unicode hex": "2B" },
      { "Typeface name": "Symbol", "Dingbat dec": "44", "Dingbat hex": "2C", "Unicode dec": "44", "Unicode hex": "2C" },
      { "Typeface name": "Symbol", "Dingbat dec": "45", "Dingbat hex": "2D", "Unicode dec": "8722", "Unicode hex": "2212" },
      { "Typeface name": "Symbol", "Dingbat dec": "46", "Dingbat hex": "2E", "Unicode dec": "46", "Unicode hex": "2E" },
      { "Typeface name": "Symbol", "Dingbat dec": "47", "Dingbat hex": "2F", "Unicode dec": "47", "Unicode hex": "2F" },
      { "Typeface name": "Symbol", "Dingbat dec": "48", "Dingbat hex": "30", "Unicode dec": "48", "Unicode hex": "30" },
      { "Typeface name": "Symbol", "Dingbat dec": "49", "Dingbat hex": "31", "Unicode dec": "49", "Unicode hex": "31" },
      { "Typeface name": "Symbol", "Dingbat dec": "50", "Dingbat hex": "32", "Unicode dec": "50", "Unicode hex": "32" },
      { "Typeface name": "Symbol", "Dingbat dec": "51", "Dingbat hex": "33", "Unicode dec": "51", "Unicode hex": "33" },
      { "Typeface name": "Symbol", "Dingbat dec": "52", "Dingbat hex": "34", "Unicode dec": "52", "Unicode hex": "34" },
      { "Typeface name": "Symbol", "Dingbat dec": "53", "Dingbat hex": "35", "Unicode dec": "53", "Unicode hex": "35" },
      { "Typeface name": "Symbol", "Dingbat dec": "54", "Dingbat hex": "36", "Unicode dec": "54", "Unicode hex": "36" },
      { "Typeface name": "Symbol", "Dingbat dec": "55", "Dingbat hex": "37", "Unicode dec": "55", "Unicode hex": "37" },
      { "Typeface name": "Symbol", "Dingbat dec": "56", "Dingbat hex": "38", "Unicode dec": "56", "Unicode hex": "38" },
      { "Typeface name": "Symbol", "Dingbat dec": "57", "Dingbat hex": "39", "Unicode dec": "57", "Unicode hex": "39" },
      { "Typeface name": "Symbol", "Dingbat dec": "58", "Dingbat hex": "3A", "Unicode dec": "58", "Unicode hex": "3A" },
      { "Typeface name": "Symbol", "Dingbat dec": "59", "Dingbat hex": "3B", "Unicode dec": "59", "Unicode hex": "3B" },
      { "Typeface name": "Symbol", "Dingbat dec": "60", "Dingbat hex": "3C", "Unicode dec": "60", "Unicode hex": "3C" },
      { "Typeface name": "Symbol", "Dingbat dec": "61", "Dingbat hex": "3D", "Unicode dec": "61", "Unicode hex": "3D" },
      { "Typeface name": "Symbol", "Dingbat dec": "62", "Dingbat hex": "3E", "Unicode dec": "62", "Unicode hex": "3E" },
      { "Typeface name": "Symbol", "Dingbat dec": "63", "Dingbat hex": "3F", "Unicode dec": "63", "Unicode hex": "3F" },
      { "Typeface name": "Symbol", "Dingbat dec": "64", "Dingbat hex": "40", "Unicode dec": "8773", "Unicode hex": "2245" },
      { "Typeface name": "Symbol", "Dingbat dec": "65", "Dingbat hex": "41", "Unicode dec": "913", "Unicode hex": "391" },
      { "Typeface name": "Symbol", "Dingbat dec": "66", "Dingbat hex": "42", "Unicode dec": "914", "Unicode hex": "392" },
      { "Typeface name": "Symbol", "Dingbat dec": "67", "Dingbat hex": "43", "Unicode dec": "935", "Unicode hex": "3A7" },
      { "Typeface name": "Symbol", "Dingbat dec": "68", "Dingbat hex": "44", "Unicode dec": "916", "Unicode hex": "394" },
      { "Typeface name": "Symbol", "Dingbat dec": "69", "Dingbat hex": "45", "Unicode dec": "917", "Unicode hex": "395" },
      { "Typeface name": "Symbol", "Dingbat dec": "70", "Dingbat hex": "46", "Unicode dec": "934", "Unicode hex": "3A6" },
      { "Typeface name": "Symbol", "Dingbat dec": "71", "Dingbat hex": "47", "Unicode dec": "915", "Unicode hex": "393" },
      { "Typeface name": "Symbol", "Dingbat dec": "72", "Dingbat hex": "48", "Unicode dec": "919", "Unicode hex": "397" },
      { "Typeface name": "Symbol", "Dingbat dec": "73", "Dingbat hex": "49", "Unicode dec": "921", "Unicode hex": "399" },
      { "Typeface name": "Symbol", "Dingbat dec": "74", "Dingbat hex": "4A", "Unicode dec": "977", "Unicode hex": "3D1" },
      { "Typeface name": "Symbol", "Dingbat dec": "75", "Dingbat hex": "4B", "Unicode dec": "922", "Unicode hex": "39A" },
      { "Typeface name": "Symbol", "Dingbat dec": "76", "Dingbat hex": "4C", "Unicode dec": "923", "Unicode hex": "39B" },
      { "Typeface name": "Symbol", "Dingbat dec": "77", "Dingbat hex": "4D", "Unicode dec": "924", "Unicode hex": "39C" },
      { "Typeface name": "Symbol", "Dingbat dec": "78", "Dingbat hex": "4E", "Unicode dec": "925", "Unicode hex": "39D" },
      { "Typeface name": "Symbol", "Dingbat dec": "79", "Dingbat hex": "4F", "Unicode dec": "927", "Unicode hex": "39F" },
      { "Typeface name": "Symbol", "Dingbat dec": "80", "Dingbat hex": "50", "Unicode dec": "928", "Unicode hex": "3A0" },
      { "Typeface name": "Symbol", "Dingbat dec": "81", "Dingbat hex": "51", "Unicode dec": "920", "Unicode hex": "398" },
      { "Typeface name": "Symbol", "Dingbat dec": "82", "Dingbat hex": "52", "Unicode dec": "929", "Unicode hex": "3A1" },
      { "Typeface name": "Symbol", "Dingbat dec": "83", "Dingbat hex": "53", "Unicode dec": "931", "Unicode hex": "3A3" },
      { "Typeface name": "Symbol", "Dingbat dec": "84", "Dingbat hex": "54", "Unicode dec": "932", "Unicode hex": "3A4" },
      { "Typeface name": "Symbol", "Dingbat dec": "85", "Dingbat hex": "55", "Unicode dec": "933", "Unicode hex": "3A5" },
      { "Typeface name": "Symbol", "Dingbat dec": "86", "Dingbat hex": "56", "Unicode dec": "962", "Unicode hex": "3C2" },
      { "Typeface name": "Symbol", "Dingbat dec": "87", "Dingbat hex": "57", "Unicode dec": "937", "Unicode hex": "3A9" },
      { "Typeface name": "Symbol", "Dingbat dec": "88", "Dingbat hex": "58", "Unicode dec": "926", "Unicode hex": "39E" },
      { "Typeface name": "Symbol", "Dingbat dec": "89", "Dingbat hex": "59", "Unicode dec": "936", "Unicode hex": "3A8" },
      { "Typeface name": "Symbol", "Dingbat dec": "90", "Dingbat hex": "5A", "Unicode dec": "918", "Unicode hex": "396" },
      { "Typeface name": "Symbol", "Dingbat dec": "91", "Dingbat hex": "5B", "Unicode dec": "91", "Unicode hex": "5B" },
      { "Typeface name": "Symbol", "Dingbat dec": "92", "Dingbat hex": "5C", "Unicode dec": "8756", "Unicode hex": "2234" },
      { "Typeface name": "Symbol", "Dingbat dec": "93", "Dingbat hex": "5D", "Unicode dec": "93", "Unicode hex": "5D" },
      { "Typeface name": "Symbol", "Dingbat dec": "94", "Dingbat hex": "5E", "Unicode dec": "8869", "Unicode hex": "22A5" },
      { "Typeface name": "Symbol", "Dingbat dec": "95", "Dingbat hex": "5F", "Unicode dec": "95", "Unicode hex": "5F" },
      { "Typeface name": "Symbol", "Dingbat dec": "96", "Dingbat hex": "60", "Unicode dec": "8254", "Unicode hex": "203E" },
      { "Typeface name": "Symbol", "Dingbat dec": "97", "Dingbat hex": "61", "Unicode dec": "945", "Unicode hex": "3B1" },
      { "Typeface name": "Symbol", "Dingbat dec": "98", "Dingbat hex": "62", "Unicode dec": "946", "Unicode hex": "3B2" },
      { "Typeface name": "Symbol", "Dingbat dec": "99", "Dingbat hex": "63", "Unicode dec": "967", "Unicode hex": "3C7" },
      { "Typeface name": "Symbol", "Dingbat dec": "100", "Dingbat hex": "64", "Unicode dec": "948", "Unicode hex": "3B4" },
      { "Typeface name": "Symbol", "Dingbat dec": "101", "Dingbat hex": "65", "Unicode dec": "949", "Unicode hex": "3B5" },
      { "Typeface name": "Symbol", "Dingbat dec": "102", "Dingbat hex": "66", "Unicode dec": "966", "Unicode hex": "3C6" },
      { "Typeface name": "Symbol", "Dingbat dec": "103", "Dingbat hex": "67", "Unicode dec": "947", "Unicode hex": "3B3" },
      { "Typeface name": "Symbol", "Dingbat dec": "104", "Dingbat hex": "68", "Unicode dec": "951", "Unicode hex": "3B7" },
      { "Typeface name": "Symbol", "Dingbat dec": "105", "Dingbat hex": "69", "Unicode dec": "953", "Unicode hex": "3B9" },
      { "Typeface name": "Symbol", "Dingbat dec": "106", "Dingbat hex": "6A", "Unicode dec": "981", "Unicode hex": "3D5" },
      { "Typeface name": "Symbol", "Dingbat dec": "107", "Dingbat hex": "6B", "Unicode dec": "954", "Unicode hex": "3BA" },
      { "Typeface name": "Symbol", "Dingbat dec": "108", "Dingbat hex": "6C", "Unicode dec": "955", "Unicode hex": "3BB" },
      { "Typeface name": "Symbol", "Dingbat dec": "109", "Dingbat hex": "6D", "Unicode dec": "956", "Unicode hex": "3BC" },
      { "Typeface name": "Symbol", "Dingbat dec": "110", "Dingbat hex": "6E", "Unicode dec": "957", "Unicode hex": "3BD" },
      { "Typeface name": "Symbol", "Dingbat dec": "111", "Dingbat hex": "6F", "Unicode dec": "959", "Unicode hex": "3BF" },
      { "Typeface name": "Symbol", "Dingbat dec": "112", "Dingbat hex": "70", "Unicode dec": "960", "Unicode hex": "3C0" },
      { "Typeface name": "Symbol", "Dingbat dec": "113", "Dingbat hex": "71", "Unicode dec": "952", "Unicode hex": "3B8" },
      { "Typeface name": "Symbol", "Dingbat dec": "114", "Dingbat hex": "72", "Unicode dec": "961", "Unicode hex": "3C1" },
      { "Typeface name": "Symbol", "Dingbat dec": "115", "Dingbat hex": "73", "Unicode dec": "963", "Unicode hex": "3C3" },
      { "Typeface name": "Symbol", "Dingbat dec": "116", "Dingbat hex": "74", "Unicode dec": "964", "Unicode hex": "3C4" },
      { "Typeface name": "Symbol", "Dingbat dec": "117", "Dingbat hex": "75", "Unicode dec": "965", "Unicode hex": "3C5" },
      { "Typeface name": "Symbol", "Dingbat dec": "118", "Dingbat hex": "76", "Unicode dec": "982", "Unicode hex": "3D6" },
      { "Typeface name": "Symbol", "Dingbat dec": "119", "Dingbat hex": "77", "Unicode dec": "969", "Unicode hex": "3C9" },
      { "Typeface name": "Symbol", "Dingbat dec": "120", "Dingbat hex": "78", "Unicode dec": "958", "Unicode hex": "3BE" },
      { "Typeface name": "Symbol", "Dingbat dec": "121", "Dingbat hex": "79", "Unicode dec": "968", "Unicode hex": "3C8" },
      { "Typeface name": "Symbol", "Dingbat dec": "122", "Dingbat hex": "7A", "Unicode dec": "950", "Unicode hex": "3B6" },
      { "Typeface name": "Symbol", "Dingbat dec": "123", "Dingbat hex": "7B", "Unicode dec": "123", "Unicode hex": "7B" },
      { "Typeface name": "Symbol", "Dingbat dec": "124", "Dingbat hex": "7C", "Unicode dec": "124", "Unicode hex": "7C" },
      { "Typeface name": "Symbol", "Dingbat dec": "125", "Dingbat hex": "7D", "Unicode dec": "125", "Unicode hex": "7D" },
      { "Typeface name": "Symbol", "Dingbat dec": "126", "Dingbat hex": "7E", "Unicode dec": "126", "Unicode hex": "7E" },
      { "Typeface name": "Symbol", "Dingbat dec": "160", "Dingbat hex": "A0", "Unicode dec": "8364", "Unicode hex": "20AC" },
      { "Typeface name": "Symbol", "Dingbat dec": "161", "Dingbat hex": "A1", "Unicode dec": "978", "Unicode hex": "3D2" },
      { "Typeface name": "Symbol", "Dingbat dec": "162", "Dingbat hex": "A2", "Unicode dec": "8242", "Unicode hex": "2032" },
      { "Typeface name": "Symbol", "Dingbat dec": "163", "Dingbat hex": "A3", "Unicode dec": "8804", "Unicode hex": "2264" },
      { "Typeface name": "Symbol", "Dingbat dec": "164", "Dingbat hex": "A4", "Unicode dec": "8260", "Unicode hex": "2044" },
      { "Typeface name": "Symbol", "Dingbat dec": "165", "Dingbat hex": "A5", "Unicode dec": "8734", "Unicode hex": "221E" },
      { "Typeface name": "Symbol", "Dingbat dec": "166", "Dingbat hex": "A6", "Unicode dec": "402", "Unicode hex": "192" },
      { "Typeface name": "Symbol", "Dingbat dec": "167", "Dingbat hex": "A7", "Unicode dec": "9827", "Unicode hex": "2663" },
      { "Typeface name": "Symbol", "Dingbat dec": "168", "Dingbat hex": "A8", "Unicode dec": "9830", "Unicode hex": "2666" },
      { "Typeface name": "Symbol", "Dingbat dec": "169", "Dingbat hex": "A9", "Unicode dec": "9829", "Unicode hex": "2665" },
      { "Typeface name": "Symbol", "Dingbat dec": "170", "Dingbat hex": "AA", "Unicode dec": "9824", "Unicode hex": "2660" },
      { "Typeface name": "Symbol", "Dingbat dec": "171", "Dingbat hex": "AB", "Unicode dec": "8596", "Unicode hex": "2194" },
      { "Typeface name": "Symbol", "Dingbat dec": "172", "Dingbat hex": "AC", "Unicode dec": "8592", "Unicode hex": "2190" },
      { "Typeface name": "Symbol", "Dingbat dec": "173", "Dingbat hex": "AD", "Unicode dec": "8593", "Unicode hex": "2191" },
      { "Typeface name": "Symbol", "Dingbat dec": "174", "Dingbat hex": "AE", "Unicode dec": "8594", "Unicode hex": "2192" },
      { "Typeface name": "Symbol", "Dingbat dec": "175", "Dingbat hex": "AF", "Unicode dec": "8595", "Unicode hex": "2193" },
      { "Typeface name": "Symbol", "Dingbat dec": "176", "Dingbat hex": "B0", "Unicode dec": "176", "Unicode hex": "B0" },
      { "Typeface name": "Symbol", "Dingbat dec": "177", "Dingbat hex": "B1", "Unicode dec": "177", "Unicode hex": "B1" },
      { "Typeface name": "Symbol", "Dingbat dec": "178", "Dingbat hex": "B2", "Unicode dec": "8243", "Unicode hex": "2033" },
      { "Typeface name": "Symbol", "Dingbat dec": "179", "Dingbat hex": "B3", "Unicode dec": "8805", "Unicode hex": "2265" },
      { "Typeface name": "Symbol", "Dingbat dec": "180", "Dingbat hex": "B4", "Unicode dec": "215", "Unicode hex": "D7" },
      { "Typeface name": "Symbol", "Dingbat dec": "181", "Dingbat hex": "B5", "Unicode dec": "8733", "Unicode hex": "221D" },
      { "Typeface name": "Symbol", "Dingbat dec": "182", "Dingbat hex": "B6", "Unicode dec": "8706", "Unicode hex": "2202" },
      { "Typeface name": "Symbol", "Dingbat dec": "183", "Dingbat hex": "B7", "Unicode dec": "8226", "Unicode hex": "2022" },
      { "Typeface name": "Symbol", "Dingbat dec": "184", "Dingbat hex": "B8", "Unicode dec": "247", "Unicode hex": "F7" },
      { "Typeface name": "Symbol", "Dingbat dec": "185", "Dingbat hex": "B9", "Unicode dec": "8800", "Unicode hex": "2260" },
      { "Typeface name": "Symbol", "Dingbat dec": "186", "Dingbat hex": "BA", "Unicode dec": "8801", "Unicode hex": "2261" },
      { "Typeface name": "Symbol", "Dingbat dec": "187", "Dingbat hex": "BB", "Unicode dec": "8776", "Unicode hex": "2248" },
      { "Typeface name": "Symbol", "Dingbat dec": "188", "Dingbat hex": "BC", "Unicode dec": "8230", "Unicode hex": "2026" },
      { "Typeface name": "Symbol", "Dingbat dec": "189", "Dingbat hex": "BD", "Unicode dec": "9168", "Unicode hex": "23D0" },
      { "Typeface name": "Symbol", "Dingbat dec": "190", "Dingbat hex": "BE", "Unicode dec": "9135", "Unicode hex": "23AF" },
      { "Typeface name": "Symbol", "Dingbat dec": "191", "Dingbat hex": "BF", "Unicode dec": "8629", "Unicode hex": "21B5" },
      { "Typeface name": "Symbol", "Dingbat dec": "192", "Dingbat hex": "C0", "Unicode dec": "8501", "Unicode hex": "2135" },
      { "Typeface name": "Symbol", "Dingbat dec": "193", "Dingbat hex": "C1", "Unicode dec": "8465", "Unicode hex": "2111" },
      { "Typeface name": "Symbol", "Dingbat dec": "194", "Dingbat hex": "C2", "Unicode dec": "8476", "Unicode hex": "211C" },
      { "Typeface name": "Symbol", "Dingbat dec": "195", "Dingbat hex": "C3", "Unicode dec": "8472", "Unicode hex": "2118" },
      { "Typeface name": "Symbol", "Dingbat dec": "196", "Dingbat hex": "C4", "Unicode dec": "8855", "Unicode hex": "2297" },
      { "Typeface name": "Symbol", "Dingbat dec": "197", "Dingbat hex": "C5", "Unicode dec": "8853", "Unicode hex": "2295" },
      { "Typeface name": "Symbol", "Dingbat dec": "198", "Dingbat hex": "C6", "Unicode dec": "8709", "Unicode hex": "2205" },
      { "Typeface name": "Symbol", "Dingbat dec": "199", "Dingbat hex": "C7", "Unicode dec": "8745", "Unicode hex": "2229" },
      { "Typeface name": "Symbol", "Dingbat dec": "200", "Dingbat hex": "C8", "Unicode dec": "8746", "Unicode hex": "222A" },
      { "Typeface name": "Symbol", "Dingbat dec": "201", "Dingbat hex": "C9", "Unicode dec": "8835", "Unicode hex": "2283" },
      { "Typeface name": "Symbol", "Dingbat dec": "202", "Dingbat hex": "CA", "Unicode dec": "8839", "Unicode hex": "2287" },
      { "Typeface name": "Symbol", "Dingbat dec": "203", "Dingbat hex": "CB", "Unicode dec": "8836", "Unicode hex": "2284" },
      { "Typeface name": "Symbol", "Dingbat dec": "204", "Dingbat hex": "CC", "Unicode dec": "8834", "Unicode hex": "2282" },
      { "Typeface name": "Symbol", "Dingbat dec": "205", "Dingbat hex": "CD", "Unicode dec": "8838", "Unicode hex": "2286" },
      { "Typeface name": "Symbol", "Dingbat dec": "206", "Dingbat hex": "CE", "Unicode dec": "8712", "Unicode hex": "2208" },
      { "Typeface name": "Symbol", "Dingbat dec": "207", "Dingbat hex": "CF", "Unicode dec": "8713", "Unicode hex": "2209" },
      { "Typeface name": "Symbol", "Dingbat dec": "208", "Dingbat hex": "D0", "Unicode dec": "8736", "Unicode hex": "2220" },
      { "Typeface name": "Symbol", "Dingbat dec": "209", "Dingbat hex": "D1", "Unicode dec": "8711", "Unicode hex": "2207" },
      { "Typeface name": "Symbol", "Dingbat dec": "210", "Dingbat hex": "D2", "Unicode dec": "174", "Unicode hex": "AE" },
      { "Typeface name": "Symbol", "Dingbat dec": "211", "Dingbat hex": "D3", "Unicode dec": "169", "Unicode hex": "A9" },
      { "Typeface name": "Symbol", "Dingbat dec": "212", "Dingbat hex": "D4", "Unicode dec": "8482", "Unicode hex": "2122" },
      { "Typeface name": "Symbol", "Dingbat dec": "213", "Dingbat hex": "D5", "Unicode dec": "8719", "Unicode hex": "220F" },
      { "Typeface name": "Symbol", "Dingbat dec": "214", "Dingbat hex": "D6", "Unicode dec": "8730", "Unicode hex": "221A" },
      { "Typeface name": "Symbol", "Dingbat dec": "215", "Dingbat hex": "D7", "Unicode dec": "8901", "Unicode hex": "22C5" },
      { "Typeface name": "Symbol", "Dingbat dec": "216", "Dingbat hex": "D8", "Unicode dec": "172", "Unicode hex": "AC" },
      { "Typeface name": "Symbol", "Dingbat dec": "217", "Dingbat hex": "D9", "Unicode dec": "8743", "Unicode hex": "2227" },
      { "Typeface name": "Symbol", "Dingbat dec": "218", "Dingbat hex": "DA", "Unicode dec": "8744", "Unicode hex": "2228" },
      { "Typeface name": "Symbol", "Dingbat dec": "219", "Dingbat hex": "DB", "Unicode dec": "8660", "Unicode hex": "21D4" },
      { "Typeface name": "Symbol", "Dingbat dec": "220", "Dingbat hex": "DC", "Unicode dec": "8656", "Unicode hex": "21D0" },
      { "Typeface name": "Symbol", "Dingbat dec": "221", "Dingbat hex": "DD", "Unicode dec": "8657", "Unicode hex": "21D1" },
      { "Typeface name": "Symbol", "Dingbat dec": "222", "Dingbat hex": "DE", "Unicode dec": "8658", "Unicode hex": "21D2" },
      { "Typeface name": "Symbol", "Dingbat dec": "223", "Dingbat hex": "DF", "Unicode dec": "8659", "Unicode hex": "21D3" },
      { "Typeface name": "Symbol", "Dingbat dec": "224", "Dingbat hex": "E0", "Unicode dec": "9674", "Unicode hex": "25CA" },
      { "Typeface name": "Symbol", "Dingbat dec": "225", "Dingbat hex": "E1", "Unicode dec": "12296", "Unicode hex": "3008" },
      { "Typeface name": "Symbol", "Dingbat dec": "226", "Dingbat hex": "E2", "Unicode dec": "174", "Unicode hex": "AE" },
      { "Typeface name": "Symbol", "Dingbat dec": "227", "Dingbat hex": "E3", "Unicode dec": "169", "Unicode hex": "A9" },
      { "Typeface name": "Symbol", "Dingbat dec": "228", "Dingbat hex": "E4", "Unicode dec": "8482", "Unicode hex": "2122" },
      { "Typeface name": "Symbol", "Dingbat dec": "229", "Dingbat hex": "E5", "Unicode dec": "8721", "Unicode hex": "2211" },
      { "Typeface name": "Symbol", "Dingbat dec": "230", "Dingbat hex": "E6", "Unicode dec": "9115", "Unicode hex": "239B" },
      { "Typeface name": "Symbol", "Dingbat dec": "231", "Dingbat hex": "E7", "Unicode dec": "9116", "Unicode hex": "239C" },
      { "Typeface name": "Symbol", "Dingbat dec": "232", "Dingbat hex": "E8", "Unicode dec": "9117", "Unicode hex": "239D" },
      { "Typeface name": "Symbol", "Dingbat dec": "233", "Dingbat hex": "E9", "Unicode dec": "9121", "Unicode hex": "23A1" },
      { "Typeface name": "Symbol", "Dingbat dec": "234", "Dingbat hex": "EA", "Unicode dec": "9122", "Unicode hex": "23A2" },
      { "Typeface name": "Symbol", "Dingbat dec": "235", "Dingbat hex": "EB", "Unicode dec": "9123", "Unicode hex": "23A3" },
      { "Typeface name": "Symbol", "Dingbat dec": "236", "Dingbat hex": "EC", "Unicode dec": "9127", "Unicode hex": "23A7" },
      { "Typeface name": "Symbol", "Dingbat dec": "237", "Dingbat hex": "ED", "Unicode dec": "9128", "Unicode hex": "23A8" },
      { "Typeface name": "Symbol", "Dingbat dec": "238", "Dingbat hex": "EE", "Unicode dec": "9129", "Unicode hex": "23A9" },
      { "Typeface name": "Symbol", "Dingbat dec": "239", "Dingbat hex": "EF", "Unicode dec": "9130", "Unicode hex": "23AA" },
      { "Typeface name": "Symbol", "Dingbat dec": "240", "Dingbat hex": "F0", "Unicode dec": "63743", "Unicode hex": "F8FF" },
      { "Typeface name": "Symbol", "Dingbat dec": "241", "Dingbat hex": "F1", "Unicode dec": "12297", "Unicode hex": "3009" },
      { "Typeface name": "Symbol", "Dingbat dec": "242", "Dingbat hex": "F2", "Unicode dec": "8747", "Unicode hex": "222B" },
      { "Typeface name": "Symbol", "Dingbat dec": "243", "Dingbat hex": "F3", "Unicode dec": "8992", "Unicode hex": "2320" },
      { "Typeface name": "Symbol", "Dingbat dec": "244", "Dingbat hex": "F4", "Unicode dec": "9134", "Unicode hex": "23AE" },
      { "Typeface name": "Symbol", "Dingbat dec": "245", "Dingbat hex": "F5", "Unicode dec": "8993", "Unicode hex": "2321" },
      { "Typeface name": "Symbol", "Dingbat dec": "246", "Dingbat hex": "F6", "Unicode dec": "9118", "Unicode hex": "239E" },
      { "Typeface name": "Symbol", "Dingbat dec": "247", "Dingbat hex": "F7", "Unicode dec": "9119", "Unicode hex": "239F" },
      { "Typeface name": "Symbol", "Dingbat dec": "248", "Dingbat hex": "F8", "Unicode dec": "9120", "Unicode hex": "23A0" },
      { "Typeface name": "Symbol", "Dingbat dec": "249", "Dingbat hex": "F9", "Unicode dec": "9124", "Unicode hex": "23A4" },
      { "Typeface name": "Symbol", "Dingbat dec": "250", "Dingbat hex": "FA", "Unicode dec": "9125", "Unicode hex": "23A5" },
      { "Typeface name": "Symbol", "Dingbat dec": "251", "Dingbat hex": "FB", "Unicode dec": "9126", "Unicode hex": "23A6" },
      { "Typeface name": "Symbol", "Dingbat dec": "252", "Dingbat hex": "FC", "Unicode dec": "9131", "Unicode hex": "23AB" },
      { "Typeface name": "Symbol", "Dingbat dec": "253", "Dingbat hex": "FD", "Unicode dec": "9132", "Unicode hex": "23AC" },
      { "Typeface name": "Symbol", "Dingbat dec": "254", "Dingbat hex": "FE", "Unicode dec": "9133", "Unicode hex": "23AD" },
      { "Typeface name": "Webdings", "Dingbat dec": "32", "Dingbat hex": "20", "Unicode dec": "32", "Unicode hex": "20" },
      { "Typeface name": "Webdings", "Dingbat dec": "33", "Dingbat hex": "21", "Unicode dec": "128375", "Unicode hex": "1F577" },
      { "Typeface name": "Webdings", "Dingbat dec": "34", "Dingbat hex": "22", "Unicode dec": "128376", "Unicode hex": "1F578" },
      { "Typeface name": "Webdings", "Dingbat dec": "35", "Dingbat hex": "23", "Unicode dec": "128370", "Unicode hex": "1F572" },
      { "Typeface name": "Webdings", "Dingbat dec": "36", "Dingbat hex": "24", "Unicode dec": "128374", "Unicode hex": "1F576" },
      { "Typeface name": "Webdings", "Dingbat dec": "37", "Dingbat hex": "25", "Unicode dec": "127942", "Unicode hex": "1F3C6" },
      { "Typeface name": "Webdings", "Dingbat dec": "38", "Dingbat hex": "26", "Unicode dec": "127894", "Unicode hex": "1F396" },
      { "Typeface name": "Webdings", "Dingbat dec": "39", "Dingbat hex": "27", "Unicode dec": "128391", "Unicode hex": "1F587" },
      { "Typeface name": "Webdings", "Dingbat dec": "40", "Dingbat hex": "28", "Unicode dec": "128488", "Unicode hex": "1F5E8" },
      { "Typeface name": "Webdings", "Dingbat dec": "41", "Dingbat hex": "29", "Unicode dec": "128489", "Unicode hex": "1F5E9" },
      { "Typeface name": "Webdings", "Dingbat dec": "42", "Dingbat hex": "2A", "Unicode dec": "128496", "Unicode hex": "1F5F0" },
      { "Typeface name": "Webdings", "Dingbat dec": "43", "Dingbat hex": "2B", "Unicode dec": "128497", "Unicode hex": "1F5F1" },
      { "Typeface name": "Webdings", "Dingbat dec": "44", "Dingbat hex": "2C", "Unicode dec": "127798", "Unicode hex": "1F336" },
      { "Typeface name": "Webdings", "Dingbat dec": "45", "Dingbat hex": "2D", "Unicode dec": "127895", "Unicode hex": "1F397" },
      { "Typeface name": "Webdings", "Dingbat dec": "46", "Dingbat hex": "2E", "Unicode dec": "128638", "Unicode hex": "1F67E" },
      { "Typeface name": "Webdings", "Dingbat dec": "47", "Dingbat hex": "2F", "Unicode dec": "128636", "Unicode hex": "1F67C" },
      { "Typeface name": "Webdings", "Dingbat dec": "48", "Dingbat hex": "30", "Unicode dec": "128469", "Unicode hex": "1F5D5" },
      { "Typeface name": "Webdings", "Dingbat dec": "49", "Dingbat hex": "31", "Unicode dec": "128470", "Unicode hex": "1F5D6" },
      { "Typeface name": "Webdings", "Dingbat dec": "50", "Dingbat hex": "32", "Unicode dec": "128471", "Unicode hex": "1F5D7" },
      { "Typeface name": "Webdings", "Dingbat dec": "51", "Dingbat hex": "33", "Unicode dec": "9204", "Unicode hex": "23F4" },
      { "Typeface name": "Webdings", "Dingbat dec": "52", "Dingbat hex": "34", "Unicode dec": "9205", "Unicode hex": "23F5" },
      { "Typeface name": "Webdings", "Dingbat dec": "53", "Dingbat hex": "35", "Unicode dec": "9206", "Unicode hex": "23F6" },
      { "Typeface name": "Webdings", "Dingbat dec": "54", "Dingbat hex": "36", "Unicode dec": "9207", "Unicode hex": "23F7" },
      { "Typeface name": "Webdings", "Dingbat dec": "55", "Dingbat hex": "37", "Unicode dec": "9194", "Unicode hex": "23EA" },
      { "Typeface name": "Webdings", "Dingbat dec": "56", "Dingbat hex": "38", "Unicode dec": "9193", "Unicode hex": "23E9" },
      { "Typeface name": "Webdings", "Dingbat dec": "57", "Dingbat hex": "39", "Unicode dec": "9198", "Unicode hex": "23EE" },
      { "Typeface name": "Webdings", "Dingbat dec": "58", "Dingbat hex": "3A", "Unicode dec": "9197", "Unicode hex": "23ED" },
      { "Typeface name": "Webdings", "Dingbat dec": "59", "Dingbat hex": "3B", "Unicode dec": "9208", "Unicode hex": "23F8" },
      { "Typeface name": "Webdings", "Dingbat dec": "60", "Dingbat hex": "3C", "Unicode dec": "9209", "Unicode hex": "23F9" },
      { "Typeface name": "Webdings", "Dingbat dec": "61", "Dingbat hex": "3D", "Unicode dec": "9210", "Unicode hex": "23FA" },
      { "Typeface name": "Webdings", "Dingbat dec": "62", "Dingbat hex": "3E", "Unicode dec": "128474", "Unicode hex": "1F5DA" },
      { "Typeface name": "Webdings", "Dingbat dec": "63", "Dingbat hex": "3F", "Unicode dec": "128499", "Unicode hex": "1F5F3" },
      { "Typeface name": "Webdings", "Dingbat dec": "64", "Dingbat hex": "40", "Unicode dec": "128736", "Unicode hex": "1F6E0" },
      { "Typeface name": "Webdings", "Dingbat dec": "65", "Dingbat hex": "41", "Unicode dec": "127959", "Unicode hex": "1F3D7" },
      { "Typeface name": "Webdings", "Dingbat dec": "66", "Dingbat hex": "42", "Unicode dec": "127960", "Unicode hex": "1F3D8" },
      { "Typeface name": "Webdings", "Dingbat dec": "67", "Dingbat hex": "43", "Unicode dec": "127961", "Unicode hex": "1F3D9" },
      { "Typeface name": "Webdings", "Dingbat dec": "68", "Dingbat hex": "44", "Unicode dec": "127962", "Unicode hex": "1F3DA" },
      { "Typeface name": "Webdings", "Dingbat dec": "69", "Dingbat hex": "45", "Unicode dec": "127964", "Unicode hex": "1F3DC" },
      { "Typeface name": "Webdings", "Dingbat dec": "70", "Dingbat hex": "46", "Unicode dec": "127981", "Unicode hex": "1F3ED" },
      { "Typeface name": "Webdings", "Dingbat dec": "71", "Dingbat hex": "47", "Unicode dec": "127963", "Unicode hex": "1F3DB" },
      { "Typeface name": "Webdings", "Dingbat dec": "72", "Dingbat hex": "48", "Unicode dec": "127968", "Unicode hex": "1F3E0" },
      { "Typeface name": "Webdings", "Dingbat dec": "73", "Dingbat hex": "49", "Unicode dec": "127958", "Unicode hex": "1F3D6" },
      { "Typeface name": "Webdings", "Dingbat dec": "74", "Dingbat hex": "4A", "Unicode dec": "127965", "Unicode hex": "1F3DD" },
      { "Typeface name": "Webdings", "Dingbat dec": "75", "Dingbat hex": "4B", "Unicode dec": "128739", "Unicode hex": "1F6E3" },
      { "Typeface name": "Webdings", "Dingbat dec": "76", "Dingbat hex": "4C", "Unicode dec": "128269", "Unicode hex": "1F50D" },
      { "Typeface name": "Webdings", "Dingbat dec": "77", "Dingbat hex": "4D", "Unicode dec": "127956", "Unicode hex": "1F3D4" },
      { "Typeface name": "Webdings", "Dingbat dec": "78", "Dingbat hex": "4E", "Unicode dec": "128065", "Unicode hex": "1F441" },
      { "Typeface name": "Webdings", "Dingbat dec": "79", "Dingbat hex": "4F", "Unicode dec": "128066", "Unicode hex": "1F442" },
      { "Typeface name": "Webdings", "Dingbat dec": "80", "Dingbat hex": "50", "Unicode dec": "127966", "Unicode hex": "1F3DE" },
      { "Typeface name": "Webdings", "Dingbat dec": "81", "Dingbat hex": "51", "Unicode dec": "127957", "Unicode hex": "1F3D5" },
      { "Typeface name": "Webdings", "Dingbat dec": "82", "Dingbat hex": "52", "Unicode dec": "128740", "Unicode hex": "1F6E4" },
      { "Typeface name": "Webdings", "Dingbat dec": "83", "Dingbat hex": "53", "Unicode dec": "127967", "Unicode hex": "1F3DF" },
      { "Typeface name": "Webdings", "Dingbat dec": "84", "Dingbat hex": "54", "Unicode dec": "128755", "Unicode hex": "1F6F3" },
      { "Typeface name": "Webdings", "Dingbat dec": "85", "Dingbat hex": "55", "Unicode dec": "128364", "Unicode hex": "1F56C" },
      { "Typeface name": "Webdings", "Dingbat dec": "86", "Dingbat hex": "56", "Unicode dec": "128363", "Unicode hex": "1F56B" },
      { "Typeface name": "Webdings", "Dingbat dec": "87", "Dingbat hex": "57", "Unicode dec": "128360", "Unicode hex": "1F568" },
      { "Typeface name": "Webdings", "Dingbat dec": "88", "Dingbat hex": "58", "Unicode dec": "128264", "Unicode hex": "1F508" },
      { "Typeface name": "Webdings", "Dingbat dec": "89", "Dingbat hex": "59", "Unicode dec": "127892", "Unicode hex": "1F394" },
      { "Typeface name": "Webdings", "Dingbat dec": "90", "Dingbat hex": "5A", "Unicode dec": "127893", "Unicode hex": "1F395" },
      { "Typeface name": "Webdings", "Dingbat dec": "91", "Dingbat hex": "5B", "Unicode dec": "128492", "Unicode hex": "1F5EC" },
      { "Typeface name": "Webdings", "Dingbat dec": "92", "Dingbat hex": "5C", "Unicode dec": "128637", "Unicode hex": "1F67D" },
      { "Typeface name": "Webdings", "Dingbat dec": "93", "Dingbat hex": "5D", "Unicode dec": "128493", "Unicode hex": "1F5ED" },
      { "Typeface name": "Webdings", "Dingbat dec": "94", "Dingbat hex": "5E", "Unicode dec": "128490", "Unicode hex": "1F5EA" },
      { "Typeface name": "Webdings", "Dingbat dec": "95", "Dingbat hex": "5F", "Unicode dec": "128491", "Unicode hex": "1F5EB" },
      { "Typeface name": "Webdings", "Dingbat dec": "96", "Dingbat hex": "60", "Unicode dec": "11156", "Unicode hex": "2B94" },
      { "Typeface name": "Webdings", "Dingbat dec": "97", "Dingbat hex": "61", "Unicode dec": "10004", "Unicode hex": "2714" },
      { "Typeface name": "Webdings", "Dingbat dec": "98", "Dingbat hex": "62", "Unicode dec": "128690", "Unicode hex": "1F6B2" },
      { "Typeface name": "Webdings", "Dingbat dec": "99", "Dingbat hex": "63", "Unicode dec": "11036", "Unicode hex": "2B1C" },
      { "Typeface name": "Webdings", "Dingbat dec": "100", "Dingbat hex": "64", "Unicode dec": "128737", "Unicode hex": "1F6E1" },
      { "Typeface name": "Webdings", "Dingbat dec": "101", "Dingbat hex": "65", "Unicode dec": "128230", "Unicode hex": "1F4E6" },
      { "Typeface name": "Webdings", "Dingbat dec": "102", "Dingbat hex": "66", "Unicode dec": "128753", "Unicode hex": "1F6F1" },
      { "Typeface name": "Webdings", "Dingbat dec": "103", "Dingbat hex": "67", "Unicode dec": "11035", "Unicode hex": "2B1B" },
      { "Typeface name": "Webdings", "Dingbat dec": "104", "Dingbat hex": "68", "Unicode dec": "128657", "Unicode hex": "1F691" },
      { "Typeface name": "Webdings", "Dingbat dec": "105", "Dingbat hex": "69", "Unicode dec": "128712", "Unicode hex": "1F6C8" },
      { "Typeface name": "Webdings", "Dingbat dec": "106", "Dingbat hex": "6A", "Unicode dec": "128745", "Unicode hex": "1F6E9" },
      { "Typeface name": "Webdings", "Dingbat dec": "107", "Dingbat hex": "6B", "Unicode dec": "128752", "Unicode hex": "1F6F0" },
      { "Typeface name": "Webdings", "Dingbat dec": "108", "Dingbat hex": "6C", "Unicode dec": "128968", "Unicode hex": "1F7C8" },
      { "Typeface name": "Webdings", "Dingbat dec": "109", "Dingbat hex": "6D", "Unicode dec": "128372", "Unicode hex": "1F574" },
      { "Typeface name": "Webdings", "Dingbat dec": "110", "Dingbat hex": "6E", "Unicode dec": "11044", "Unicode hex": "2B24" },
      { "Typeface name": "Webdings", "Dingbat dec": "111", "Dingbat hex": "6F", "Unicode dec": "128741", "Unicode hex": "1F6E5" },
      { "Typeface name": "Webdings", "Dingbat dec": "112", "Dingbat hex": "70", "Unicode dec": "128660", "Unicode hex": "1F694" },
      { "Typeface name": "Webdings", "Dingbat dec": "113", "Dingbat hex": "71", "Unicode dec": "128472", "Unicode hex": "1F5D8" },
      { "Typeface name": "Webdings", "Dingbat dec": "114", "Dingbat hex": "72", "Unicode dec": "128473", "Unicode hex": "1F5D9" },
      { "Typeface name": "Webdings", "Dingbat dec": "115", "Dingbat hex": "73", "Unicode dec": "10067", "Unicode hex": "2753" },
      { "Typeface name": "Webdings", "Dingbat dec": "116", "Dingbat hex": "74", "Unicode dec": "128754", "Unicode hex": "1F6F2" },
      { "Typeface name": "Webdings", "Dingbat dec": "117", "Dingbat hex": "75", "Unicode dec": "128647", "Unicode hex": "1F687" },
      { "Typeface name": "Webdings", "Dingbat dec": "118", "Dingbat hex": "76", "Unicode dec": "128653", "Unicode hex": "1F68D" },
      { "Typeface name": "Webdings", "Dingbat dec": "119", "Dingbat hex": "77", "Unicode dec": "9971", "Unicode hex": "26F3" },
      { "Typeface name": "Webdings", "Dingbat dec": "120", "Dingbat hex": "78", "Unicode dec": "10680", "Unicode hex": "29B8" },
      { "Typeface name": "Webdings", "Dingbat dec": "121", "Dingbat hex": "79", "Unicode dec": "8854", "Unicode hex": "2296" },
      { "Typeface name": "Webdings", "Dingbat dec": "122", "Dingbat hex": "7A", "Unicode dec": "128685", "Unicode hex": "1F6AD" },
      { "Typeface name": "Webdings", "Dingbat dec": "123", "Dingbat hex": "7B", "Unicode dec": "128494", "Unicode hex": "1F5EE" },
      { "Typeface name": "Webdings", "Dingbat dec": "124", "Dingbat hex": "7C", "Unicode dec": "9168", "Unicode hex": "23D0" },
      { "Typeface name": "Webdings", "Dingbat dec": "125", "Dingbat hex": "7D", "Unicode dec": "128495", "Unicode hex": "1F5EF" },
      { "Typeface name": "Webdings", "Dingbat dec": "126", "Dingbat hex": "7E", "Unicode dec": "128498", "Unicode hex": "1F5F2" },
      { "Typeface name": "Webdings", "Dingbat dec": "128", "Dingbat hex": "80", "Unicode dec": "128697", "Unicode hex": "1F6B9" },
      { "Typeface name": "Webdings", "Dingbat dec": "129", "Dingbat hex": "81", "Unicode dec": "128698", "Unicode hex": "1F6BA" },
      { "Typeface name": "Webdings", "Dingbat dec": "130", "Dingbat hex": "82", "Unicode dec": "128713", "Unicode hex": "1F6C9" },
      { "Typeface name": "Webdings", "Dingbat dec": "131", "Dingbat hex": "83", "Unicode dec": "128714", "Unicode hex": "1F6CA" },
      { "Typeface name": "Webdings", "Dingbat dec": "132", "Dingbat hex": "84", "Unicode dec": "128700", "Unicode hex": "1F6BC" },
      { "Typeface name": "Webdings", "Dingbat dec": "133", "Dingbat hex": "85", "Unicode dec": "128125", "Unicode hex": "1F47D" },
      { "Typeface name": "Webdings", "Dingbat dec": "134", "Dingbat hex": "86", "Unicode dec": "127947", "Unicode hex": "1F3CB" },
      { "Typeface name": "Webdings", "Dingbat dec": "135", "Dingbat hex": "87", "Unicode dec": "9975", "Unicode hex": "26F7" },
      { "Typeface name": "Webdings", "Dingbat dec": "136", "Dingbat hex": "88", "Unicode dec": "127938", "Unicode hex": "1F3C2" },
      { "Typeface name": "Webdings", "Dingbat dec": "137", "Dingbat hex": "89", "Unicode dec": "127948", "Unicode hex": "1F3CC" },
      { "Typeface name": "Webdings", "Dingbat dec": "138", "Dingbat hex": "8A", "Unicode dec": "127946", "Unicode hex": "1F3CA" },
      { "Typeface name": "Webdings", "Dingbat dec": "139", "Dingbat hex": "8B", "Unicode dec": "127940", "Unicode hex": "1F3C4" },
      { "Typeface name": "Webdings", "Dingbat dec": "140", "Dingbat hex": "8C", "Unicode dec": "127949", "Unicode hex": "1F3CD" },
      { "Typeface name": "Webdings", "Dingbat dec": "141", "Dingbat hex": "8D", "Unicode dec": "127950", "Unicode hex": "1F3CE" },
      { "Typeface name": "Webdings", "Dingbat dec": "142", "Dingbat hex": "8E", "Unicode dec": "128664", "Unicode hex": "1F698" },
      { "Typeface name": "Webdings", "Dingbat dec": "143", "Dingbat hex": "8F", "Unicode dec": "128480", "Unicode hex": "1F5E0" },
      { "Typeface name": "Webdings", "Dingbat dec": "144", "Dingbat hex": "90", "Unicode dec": "128738", "Unicode hex": "1F6E2" },
      { "Typeface name": "Webdings", "Dingbat dec": "145", "Dingbat hex": "91", "Unicode dec": "128176", "Unicode hex": "1F4B0" },
      { "Typeface name": "Webdings", "Dingbat dec": "146", "Dingbat hex": "92", "Unicode dec": "127991", "Unicode hex": "1F3F7" },
      { "Typeface name": "Webdings", "Dingbat dec": "147", "Dingbat hex": "93", "Unicode dec": "128179", "Unicode hex": "1F4B3" },
      { "Typeface name": "Webdings", "Dingbat dec": "148", "Dingbat hex": "94", "Unicode dec": "128106", "Unicode hex": "1F46A" },
      { "Typeface name": "Webdings", "Dingbat dec": "149", "Dingbat hex": "95", "Unicode dec": "128481", "Unicode hex": "1F5E1" },
      { "Typeface name": "Webdings", "Dingbat dec": "150", "Dingbat hex": "96", "Unicode dec": "128482", "Unicode hex": "1F5E2" },
      { "Typeface name": "Webdings", "Dingbat dec": "151", "Dingbat hex": "97", "Unicode dec": "128483", "Unicode hex": "1F5E3" },
      { "Typeface name": "Webdings", "Dingbat dec": "152", "Dingbat hex": "98", "Unicode dec": "10031", "Unicode hex": "272F" },
      { "Typeface name": "Webdings", "Dingbat dec": "153", "Dingbat hex": "99", "Unicode dec": "128388", "Unicode hex": "1F584" },
      { "Typeface name": "Webdings", "Dingbat dec": "154", "Dingbat hex": "9A", "Unicode dec": "128389", "Unicode hex": "1F585" },
      { "Typeface name": "Webdings", "Dingbat dec": "155", "Dingbat hex": "9B", "Unicode dec": "128387", "Unicode hex": "1F583" },
      { "Typeface name": "Webdings", "Dingbat dec": "156", "Dingbat hex": "9C", "Unicode dec": "128390", "Unicode hex": "1F586" },
      { "Typeface name": "Webdings", "Dingbat dec": "157", "Dingbat hex": "9D", "Unicode dec": "128441", "Unicode hex": "1F5B9" },
      { "Typeface name": "Webdings", "Dingbat dec": "158", "Dingbat hex": "9E", "Unicode dec": "128442", "Unicode hex": "1F5BA" },
      { "Typeface name": "Webdings", "Dingbat dec": "159", "Dingbat hex": "9F", "Unicode dec": "128443", "Unicode hex": "1F5BB" },
      { "Typeface name": "Webdings", "Dingbat dec": "160", "Dingbat hex": "A0", "Unicode dec": "128373", "Unicode hex": "1F575" },
      { "Typeface name": "Webdings", "Dingbat dec": "161", "Dingbat hex": "A1", "Unicode dec": "128368", "Unicode hex": "1F570" },
      { "Typeface name": "Webdings", "Dingbat dec": "162", "Dingbat hex": "A2", "Unicode dec": "128445", "Unicode hex": "1F5BD" },
      { "Typeface name": "Webdings", "Dingbat dec": "163", "Dingbat hex": "A3", "Unicode dec": "128446", "Unicode hex": "1F5BE" },
      { "Typeface name": "Webdings", "Dingbat dec": "164", "Dingbat hex": "A4", "Unicode dec": "128203", "Unicode hex": "1F4CB" },
      { "Typeface name": "Webdings", "Dingbat dec": "165", "Dingbat hex": "A5", "Unicode dec": "128466", "Unicode hex": "1F5D2" },
      { "Typeface name": "Webdings", "Dingbat dec": "166", "Dingbat hex": "A6", "Unicode dec": "128467", "Unicode hex": "1F5D3" },
      { "Typeface name": "Webdings", "Dingbat dec": "167", "Dingbat hex": "A7", "Unicode dec": "128366", "Unicode hex": "1F56E" },
      { "Typeface name": "Webdings", "Dingbat dec": "168", "Dingbat hex": "A8", "Unicode dec": "128218", "Unicode hex": "1F4DA" },
      { "Typeface name": "Webdings", "Dingbat dec": "169", "Dingbat hex": "A9", "Unicode dec": "128478", "Unicode hex": "1F5DE" },
      { "Typeface name": "Webdings", "Dingbat dec": "170", "Dingbat hex": "AA", "Unicode dec": "128479", "Unicode hex": "1F5DF" },
      { "Typeface name": "Webdings", "Dingbat dec": "171", "Dingbat hex": "AB", "Unicode dec": "128451", "Unicode hex": "1F5C3" },
      { "Typeface name": "Webdings", "Dingbat dec": "172", "Dingbat hex": "AC", "Unicode dec": "128450", "Unicode hex": "1F5C2" },
      { "Typeface name": "Webdings", "Dingbat dec": "173", "Dingbat hex": "AD", "Unicode dec": "128444", "Unicode hex": "1F5BC" },
      { "Typeface name": "Webdings", "Dingbat dec": "174", "Dingbat hex": "AE", "Unicode dec": "127917", "Unicode hex": "1F3AD" },
      { "Typeface name": "Webdings", "Dingbat dec": "175", "Dingbat hex": "AF", "Unicode dec": "127900", "Unicode hex": "1F39C" },
      { "Typeface name": "Webdings", "Dingbat dec": "176", "Dingbat hex": "B0", "Unicode dec": "127896", "Unicode hex": "1F398" },
      { "Typeface name": "Webdings", "Dingbat dec": "177", "Dingbat hex": "B1", "Unicode dec": "127897", "Unicode hex": "1F399" },
      { "Typeface name": "Webdings", "Dingbat dec": "178", "Dingbat hex": "B2", "Unicode dec": "127911", "Unicode hex": "1F3A7" },
      { "Typeface name": "Webdings", "Dingbat dec": "179", "Dingbat hex": "B3", "Unicode dec": "128191", "Unicode hex": "1F4BF" },
      { "Typeface name": "Webdings", "Dingbat dec": "180", "Dingbat hex": "B4", "Unicode dec": "127902", "Unicode hex": "1F39E" },
      { "Typeface name": "Webdings", "Dingbat dec": "181", "Dingbat hex": "B5", "Unicode dec": "128247", "Unicode hex": "1F4F7" },
      { "Typeface name": "Webdings", "Dingbat dec": "182", "Dingbat hex": "B6", "Unicode dec": "127903", "Unicode hex": "1F39F" },
      { "Typeface name": "Webdings", "Dingbat dec": "183", "Dingbat hex": "B7", "Unicode dec": "127916", "Unicode hex": "1F3AC" },
      { "Typeface name": "Webdings", "Dingbat dec": "184", "Dingbat hex": "B8", "Unicode dec": "128253", "Unicode hex": "1F4FD" },
      { "Typeface name": "Webdings", "Dingbat dec": "185", "Dingbat hex": "B9", "Unicode dec": "128249", "Unicode hex": "1F4F9" },
      { "Typeface name": "Webdings", "Dingbat dec": "186", "Dingbat hex": "BA", "Unicode dec": "128254", "Unicode hex": "1F4FE" },
      { "Typeface name": "Webdings", "Dingbat dec": "187", "Dingbat hex": "BB", "Unicode dec": "128251", "Unicode hex": "1F4FB" },
      { "Typeface name": "Webdings", "Dingbat dec": "188", "Dingbat hex": "BC", "Unicode dec": "127898", "Unicode hex": "1F39A" },
      { "Typeface name": "Webdings", "Dingbat dec": "189", "Dingbat hex": "BD", "Unicode dec": "127899", "Unicode hex": "1F39B" },
      { "Typeface name": "Webdings", "Dingbat dec": "190", "Dingbat hex": "BE", "Unicode dec": "128250", "Unicode hex": "1F4FA" },
      { "Typeface name": "Webdings", "Dingbat dec": "191", "Dingbat hex": "BF", "Unicode dec": "128187", "Unicode hex": "1F4BB" },
      { "Typeface name": "Webdings", "Dingbat dec": "192", "Dingbat hex": "C0", "Unicode dec": "128421", "Unicode hex": "1F5A5" },
      { "Typeface name": "Webdings", "Dingbat dec": "193", "Dingbat hex": "C1", "Unicode dec": "128422", "Unicode hex": "1F5A6" },
      { "Typeface name": "Webdings", "Dingbat dec": "194", "Dingbat hex": "C2", "Unicode dec": "128423", "Unicode hex": "1F5A7" },
      { "Typeface name": "Webdings", "Dingbat dec": "195", "Dingbat hex": "C3", "Unicode dec": "128377", "Unicode hex": "1F579" },
      { "Typeface name": "Webdings", "Dingbat dec": "196", "Dingbat hex": "C4", "Unicode dec": "127918", "Unicode hex": "1F3AE" },
      { "Typeface name": "Webdings", "Dingbat dec": "197", "Dingbat hex": "C5", "Unicode dec": "128379", "Unicode hex": "1F57B" },
      { "Typeface name": "Webdings", "Dingbat dec": "198", "Dingbat hex": "C6", "Unicode dec": "128380", "Unicode hex": "1F57C" },
      { "Typeface name": "Webdings", "Dingbat dec": "199", "Dingbat hex": "C7", "Unicode dec": "128223", "Unicode hex": "1F4DF" },
      { "Typeface name": "Webdings", "Dingbat dec": "200", "Dingbat hex": "C8", "Unicode dec": "128385", "Unicode hex": "1F581" },
      { "Typeface name": "Webdings", "Dingbat dec": "201", "Dingbat hex": "C9", "Unicode dec": "128384", "Unicode hex": "1F580" },
      { "Typeface name": "Webdings", "Dingbat dec": "202", "Dingbat hex": "CA", "Unicode dec": "128424", "Unicode hex": "1F5A8" },
      { "Typeface name": "Webdings", "Dingbat dec": "203", "Dingbat hex": "CB", "Unicode dec": "128425", "Unicode hex": "1F5A9" },
      { "Typeface name": "Webdings", "Dingbat dec": "204", "Dingbat hex": "CC", "Unicode dec": "128447", "Unicode hex": "1F5BF" },
      { "Typeface name": "Webdings", "Dingbat dec": "205", "Dingbat hex": "CD", "Unicode dec": "128426", "Unicode hex": "1F5AA" },
      { "Typeface name": "Webdings", "Dingbat dec": "206", "Dingbat hex": "CE", "Unicode dec": "128476", "Unicode hex": "1F5DC" },
      { "Typeface name": "Webdings", "Dingbat dec": "207", "Dingbat hex": "CF", "Unicode dec": "128274", "Unicode hex": "1F512" },
      { "Typeface name": "Webdings", "Dingbat dec": "208", "Dingbat hex": "D0", "Unicode dec": "128275", "Unicode hex": "1F513" },
      { "Typeface name": "Webdings", "Dingbat dec": "209", "Dingbat hex": "D1", "Unicode dec": "128477", "Unicode hex": "1F5DD" },
      { "Typeface name": "Webdings", "Dingbat dec": "210", "Dingbat hex": "D2", "Unicode dec": "128229", "Unicode hex": "1F4E5" },
      { "Typeface name": "Webdings", "Dingbat dec": "211", "Dingbat hex": "D3", "Unicode dec": "128228", "Unicode hex": "1F4E4" },
      { "Typeface name": "Webdings", "Dingbat dec": "212", "Dingbat hex": "D4", "Unicode dec": "128371", "Unicode hex": "1F573" },
      { "Typeface name": "Webdings", "Dingbat dec": "213", "Dingbat hex": "D5", "Unicode dec": "127779", "Unicode hex": "1F323" },
      { "Typeface name": "Webdings", "Dingbat dec": "214", "Dingbat hex": "D6", "Unicode dec": "127780", "Unicode hex": "1F324" },
      { "Typeface name": "Webdings", "Dingbat dec": "215", "Dingbat hex": "D7", "Unicode dec": "127781", "Unicode hex": "1F325" },
      { "Typeface name": "Webdings", "Dingbat dec": "216", "Dingbat hex": "D8", "Unicode dec": "127782", "Unicode hex": "1F326" },
      { "Typeface name": "Webdings", "Dingbat dec": "217", "Dingbat hex": "D9", "Unicode dec": "9729", "Unicode hex": "2601" },
      { "Typeface name": "Webdings", "Dingbat dec": "218", "Dingbat hex": "DA", "Unicode dec": "127784", "Unicode hex": "1F328" },
      { "Typeface name": "Webdings", "Dingbat dec": "219", "Dingbat hex": "DB", "Unicode dec": "127783", "Unicode hex": "1F327" },
      { "Typeface name": "Webdings", "Dingbat dec": "220", "Dingbat hex": "DC", "Unicode dec": "127785", "Unicode hex": "1F329" },
      { "Typeface name": "Webdings", "Dingbat dec": "221", "Dingbat hex": "DD", "Unicode dec": "127786", "Unicode hex": "1F32A" },
      { "Typeface name": "Webdings", "Dingbat dec": "222", "Dingbat hex": "DE", "Unicode dec": "127788", "Unicode hex": "1F32C" },
      { "Typeface name": "Webdings", "Dingbat dec": "223", "Dingbat hex": "DF", "Unicode dec": "127787", "Unicode hex": "1F32B" },
      { "Typeface name": "Webdings", "Dingbat dec": "224", "Dingbat hex": "E0", "Unicode dec": "127772", "Unicode hex": "1F31C" },
      { "Typeface name": "Webdings", "Dingbat dec": "225", "Dingbat hex": "E1", "Unicode dec": "127777", "Unicode hex": "1F321" },
      { "Typeface name": "Webdings", "Dingbat dec": "226", "Dingbat hex": "E2", "Unicode dec": "128715", "Unicode hex": "1F6CB" },
      { "Typeface name": "Webdings", "Dingbat dec": "227", "Dingbat hex": "E3", "Unicode dec": "128719", "Unicode hex": "1F6CF" },
      { "Typeface name": "Webdings", "Dingbat dec": "228", "Dingbat hex": "E4", "Unicode dec": "127869", "Unicode hex": "1F37D" },
      { "Typeface name": "Webdings", "Dingbat dec": "229", "Dingbat hex": "E5", "Unicode dec": "127864", "Unicode hex": "1F378" },
      { "Typeface name": "Webdings", "Dingbat dec": "230", "Dingbat hex": "E6", "Unicode dec": "128718", "Unicode hex": "1F6CE" },
      { "Typeface name": "Webdings", "Dingbat dec": "231", "Dingbat hex": "E7", "Unicode dec": "128717", "Unicode hex": "1F6CD" },
      { "Typeface name": "Webdings", "Dingbat dec": "232", "Dingbat hex": "E8", "Unicode dec": "9413", "Unicode hex": "24C5" },
      { "Typeface name": "Webdings", "Dingbat dec": "233", "Dingbat hex": "E9", "Unicode dec": "9855", "Unicode hex": "267F" },
      { "Typeface name": "Webdings", "Dingbat dec": "234", "Dingbat hex": "EA", "Unicode dec": "128710", "Unicode hex": "1F6C6" },
      { "Typeface name": "Webdings", "Dingbat dec": "235", "Dingbat hex": "EB", "Unicode dec": "128392", "Unicode hex": "1F588" },
      { "Typeface name": "Webdings", "Dingbat dec": "236", "Dingbat hex": "EC", "Unicode dec": "127891", "Unicode hex": "1F393" },
      { "Typeface name": "Webdings", "Dingbat dec": "237", "Dingbat hex": "ED", "Unicode dec": "128484", "Unicode hex": "1F5E4" },
      { "Typeface name": "Webdings", "Dingbat dec": "238", "Dingbat hex": "EE", "Unicode dec": "128485", "Unicode hex": "1F5E5" },
      { "Typeface name": "Webdings", "Dingbat dec": "239", "Dingbat hex": "EF", "Unicode dec": "128486", "Unicode hex": "1F5E6" },
      { "Typeface name": "Webdings", "Dingbat dec": "240", "Dingbat hex": "F0", "Unicode dec": "128487", "Unicode hex": "1F5E7" },
      { "Typeface name": "Webdings", "Dingbat dec": "241", "Dingbat hex": "F1", "Unicode dec": "128746", "Unicode hex": "1F6EA" },
      { "Typeface name": "Webdings", "Dingbat dec": "242", "Dingbat hex": "F2", "Unicode dec": "128063", "Unicode hex": "1F43F" },
      { "Typeface name": "Webdings", "Dingbat dec": "243", "Dingbat hex": "F3", "Unicode dec": "128038", "Unicode hex": "1F426" },
      { "Typeface name": "Webdings", "Dingbat dec": "244", "Dingbat hex": "F4", "Unicode dec": "128031", "Unicode hex": "1F41F" },
      { "Typeface name": "Webdings", "Dingbat dec": "245", "Dingbat hex": "F5", "Unicode dec": "128021", "Unicode hex": "1F415" },
      { "Typeface name": "Webdings", "Dingbat dec": "246", "Dingbat hex": "F6", "Unicode dec": "128008", "Unicode hex": "1F408" },
      { "Typeface name": "Webdings", "Dingbat dec": "247", "Dingbat hex": "F7", "Unicode dec": "128620", "Unicode hex": "1F66C" },
      { "Typeface name": "Webdings", "Dingbat dec": "248", "Dingbat hex": "F8", "Unicode dec": "128622", "Unicode hex": "1F66E" },
      { "Typeface name": "Webdings", "Dingbat dec": "249", "Dingbat hex": "F9", "Unicode dec": "128621", "Unicode hex": "1F66D" },
      { "Typeface name": "Webdings", "Dingbat dec": "250", "Dingbat hex": "FA", "Unicode dec": "128623", "Unicode hex": "1F66F" },
      { "Typeface name": "Webdings", "Dingbat dec": "251", "Dingbat hex": "FB", "Unicode dec": "128506", "Unicode hex": "1F5FA" },
      { "Typeface name": "Webdings", "Dingbat dec": "252", "Dingbat hex": "FC", "Unicode dec": "127757", "Unicode hex": "1F30D" },
      { "Typeface name": "Webdings", "Dingbat dec": "253", "Dingbat hex": "FD", "Unicode dec": "127759", "Unicode hex": "1F30F" },
      { "Typeface name": "Webdings", "Dingbat dec": "254", "Dingbat hex": "FE", "Unicode dec": "127758", "Unicode hex": "1F30E" },
      { "Typeface name": "Webdings", "Dingbat dec": "255", "Dingbat hex": "FF", "Unicode dec": "128330", "Unicode hex": "1F54A" },
      { "Typeface name": "Wingdings", "Dingbat dec": "32", "Dingbat hex": "20", "Unicode dec": "32", "Unicode hex": "20" },
      { "Typeface name": "Wingdings", "Dingbat dec": "33", "Dingbat hex": "21", "Unicode dec": "128393", "Unicode hex": "1F589" },
      { "Typeface name": "Wingdings", "Dingbat dec": "34", "Dingbat hex": "22", "Unicode dec": "9986", "Unicode hex": "2702" },
      { "Typeface name": "Wingdings", "Dingbat dec": "35", "Dingbat hex": "23", "Unicode dec": "9985", "Unicode hex": "2701" },
      { "Typeface name": "Wingdings", "Dingbat dec": "36", "Dingbat hex": "24", "Unicode dec": "128083", "Unicode hex": "1F453" },
      { "Typeface name": "Wingdings", "Dingbat dec": "37", "Dingbat hex": "25", "Unicode dec": "128365", "Unicode hex": "1F56D" },
      { "Typeface name": "Wingdings", "Dingbat dec": "38", "Dingbat hex": "26", "Unicode dec": "128366", "Unicode hex": "1F56E" },
      { "Typeface name": "Wingdings", "Dingbat dec": "39", "Dingbat hex": "27", "Unicode dec": "128367", "Unicode hex": "1F56F" },
      { "Typeface name": "Wingdings", "Dingbat dec": "40", "Dingbat hex": "28", "Unicode dec": "128383", "Unicode hex": "1F57F" },
      { "Typeface name": "Wingdings", "Dingbat dec": "41", "Dingbat hex": "29", "Unicode dec": "9990", "Unicode hex": "2706" },
      { "Typeface name": "Wingdings", "Dingbat dec": "42", "Dingbat hex": "2A", "Unicode dec": "128386", "Unicode hex": "1F582" },
      { "Typeface name": "Wingdings", "Dingbat dec": "43", "Dingbat hex": "2B", "Unicode dec": "128387", "Unicode hex": "1F583" },
      { "Typeface name": "Wingdings", "Dingbat dec": "44", "Dingbat hex": "2C", "Unicode dec": "128234", "Unicode hex": "1F4EA" },
      { "Typeface name": "Wingdings", "Dingbat dec": "45", "Dingbat hex": "2D", "Unicode dec": "128235", "Unicode hex": "1F4EB" },
      { "Typeface name": "Wingdings", "Dingbat dec": "46", "Dingbat hex": "2E", "Unicode dec": "128236", "Unicode hex": "1F4EC" },
      { "Typeface name": "Wingdings", "Dingbat dec": "47", "Dingbat hex": "2F", "Unicode dec": "128237", "Unicode hex": "1F4ED" },
      { "Typeface name": "Wingdings", "Dingbat dec": "48", "Dingbat hex": "30", "Unicode dec": "128448", "Unicode hex": "1F5C0" },
      { "Typeface name": "Wingdings", "Dingbat dec": "49", "Dingbat hex": "31", "Unicode dec": "128449", "Unicode hex": "1F5C1" },
      { "Typeface name": "Wingdings", "Dingbat dec": "50", "Dingbat hex": "32", "Unicode dec": "128462", "Unicode hex": "1F5CE" },
      { "Typeface name": "Wingdings", "Dingbat dec": "51", "Dingbat hex": "33", "Unicode dec": "128463", "Unicode hex": "1F5CF" },
      { "Typeface name": "Wingdings", "Dingbat dec": "52", "Dingbat hex": "34", "Unicode dec": "128464", "Unicode hex": "1F5D0" },
      { "Typeface name": "Wingdings", "Dingbat dec": "53", "Dingbat hex": "35", "Unicode dec": "128452", "Unicode hex": "1F5C4" },
      { "Typeface name": "Wingdings", "Dingbat dec": "54", "Dingbat hex": "36", "Unicode dec": "8987", "Unicode hex": "231B" },
      { "Typeface name": "Wingdings", "Dingbat dec": "55", "Dingbat hex": "37", "Unicode dec": "128430", "Unicode hex": "1F5AE" },
      { "Typeface name": "Wingdings", "Dingbat dec": "56", "Dingbat hex": "38", "Unicode dec": "128432", "Unicode hex": "1F5B0" },
      { "Typeface name": "Wingdings", "Dingbat dec": "57", "Dingbat hex": "39", "Unicode dec": "128434", "Unicode hex": "1F5B2" },
      { "Typeface name": "Wingdings", "Dingbat dec": "58", "Dingbat hex": "3A", "Unicode dec": "128435", "Unicode hex": "1F5B3" },
      { "Typeface name": "Wingdings", "Dingbat dec": "59", "Dingbat hex": "3B", "Unicode dec": "128436", "Unicode hex": "1F5B4" },
      { "Typeface name": "Wingdings", "Dingbat dec": "60", "Dingbat hex": "3C", "Unicode dec": "128427", "Unicode hex": "1F5AB" },
      { "Typeface name": "Wingdings", "Dingbat dec": "61", "Dingbat hex": "3D", "Unicode dec": "128428", "Unicode hex": "1F5AC" },
      { "Typeface name": "Wingdings", "Dingbat dec": "62", "Dingbat hex": "3E", "Unicode dec": "9991", "Unicode hex": "2707" },
      { "Typeface name": "Wingdings", "Dingbat dec": "63", "Dingbat hex": "3F", "Unicode dec": "9997", "Unicode hex": "270D" },
      { "Typeface name": "Wingdings", "Dingbat dec": "64", "Dingbat hex": "40", "Unicode dec": "128398", "Unicode hex": "1F58E" },
      { "Typeface name": "Wingdings", "Dingbat dec": "65", "Dingbat hex": "41", "Unicode dec": "9996", "Unicode hex": "270C" },
      { "Typeface name": "Wingdings", "Dingbat dec": "66", "Dingbat hex": "42", "Unicode dec": "128399", "Unicode hex": "1F58F" },
      { "Typeface name": "Wingdings", "Dingbat dec": "67", "Dingbat hex": "43", "Unicode dec": "128077", "Unicode hex": "1F44D" },
      { "Typeface name": "Wingdings", "Dingbat dec": "68", "Dingbat hex": "44", "Unicode dec": "128078", "Unicode hex": "1F44E" },
      { "Typeface name": "Wingdings", "Dingbat dec": "69", "Dingbat hex": "45", "Unicode dec": "9756", "Unicode hex": "261C" },
      { "Typeface name": "Wingdings", "Dingbat dec": "70", "Dingbat hex": "46", "Unicode dec": "9758", "Unicode hex": "261E" },
      { "Typeface name": "Wingdings", "Dingbat dec": "71", "Dingbat hex": "47", "Unicode dec": "9757", "Unicode hex": "261D" },
      { "Typeface name": "Wingdings", "Dingbat dec": "72", "Dingbat hex": "48", "Unicode dec": "9759", "Unicode hex": "261F" },
      { "Typeface name": "Wingdings", "Dingbat dec": "73", "Dingbat hex": "49", "Unicode dec": "128400", "Unicode hex": "1F590" },
      { "Typeface name": "Wingdings", "Dingbat dec": "74", "Dingbat hex": "4A", "Unicode dec": "9786", "Unicode hex": "263A" },
      { "Typeface name": "Wingdings", "Dingbat dec": "75", "Dingbat hex": "4B", "Unicode dec": "128528", "Unicode hex": "1F610" },
      { "Typeface name": "Wingdings", "Dingbat dec": "76", "Dingbat hex": "4C", "Unicode dec": "9785", "Unicode hex": "2639" },
      { "Typeface name": "Wingdings", "Dingbat dec": "77", "Dingbat hex": "4D", "Unicode dec": "128163", "Unicode hex": "1F4A3" },
      { "Typeface name": "Wingdings", "Dingbat dec": "78", "Dingbat hex": "4E", "Unicode dec": "128369", "Unicode hex": "1F571" },
      { "Typeface name": "Wingdings", "Dingbat dec": "79", "Dingbat hex": "4F", "Unicode dec": "127987", "Unicode hex": "1F3F3" },
      { "Typeface name": "Wingdings", "Dingbat dec": "80", "Dingbat hex": "50", "Unicode dec": "127985", "Unicode hex": "1F3F1" },
      { "Typeface name": "Wingdings", "Dingbat dec": "81", "Dingbat hex": "51", "Unicode dec": "9992", "Unicode hex": "2708" },
      { "Typeface name": "Wingdings", "Dingbat dec": "82", "Dingbat hex": "52", "Unicode dec": "9788", "Unicode hex": "263C" },
      { "Typeface name": "Wingdings", "Dingbat dec": "83", "Dingbat hex": "53", "Unicode dec": "127778", "Unicode hex": "1F322" },
      { "Typeface name": "Wingdings", "Dingbat dec": "84", "Dingbat hex": "54", "Unicode dec": "10052", "Unicode hex": "2744" },
      { "Typeface name": "Wingdings", "Dingbat dec": "85", "Dingbat hex": "55", "Unicode dec": "128326", "Unicode hex": "1F546" },
      { "Typeface name": "Wingdings", "Dingbat dec": "86", "Dingbat hex": "56", "Unicode dec": "10014", "Unicode hex": "271E" },
      { "Typeface name": "Wingdings", "Dingbat dec": "87", "Dingbat hex": "57", "Unicode dec": "128328", "Unicode hex": "1F548" },
      { "Typeface name": "Wingdings", "Dingbat dec": "88", "Dingbat hex": "58", "Unicode dec": "10016", "Unicode hex": "2720" },
      { "Typeface name": "Wingdings", "Dingbat dec": "89", "Dingbat hex": "59", "Unicode dec": "10017", "Unicode hex": "2721" },
      { "Typeface name": "Wingdings", "Dingbat dec": "90", "Dingbat hex": "5A", "Unicode dec": "9770", "Unicode hex": "262A" },
      { "Typeface name": "Wingdings", "Dingbat dec": "91", "Dingbat hex": "5B", "Unicode dec": "9775", "Unicode hex": "262F" },
      { "Typeface name": "Wingdings", "Dingbat dec": "92", "Dingbat hex": "5C", "Unicode dec": "128329", "Unicode hex": "1F549" },
      { "Typeface name": "Wingdings", "Dingbat dec": "93", "Dingbat hex": "5D", "Unicode dec": "9784", "Unicode hex": "2638" },
      { "Typeface name": "Wingdings", "Dingbat dec": "94", "Dingbat hex": "5E", "Unicode dec": "9800", "Unicode hex": "2648" },
      { "Typeface name": "Wingdings", "Dingbat dec": "95", "Dingbat hex": "5F", "Unicode dec": "9801", "Unicode hex": "2649" },
      { "Typeface name": "Wingdings", "Dingbat dec": "96", "Dingbat hex": "60", "Unicode dec": "9802", "Unicode hex": "264A" },
      { "Typeface name": "Wingdings", "Dingbat dec": "97", "Dingbat hex": "61", "Unicode dec": "9803", "Unicode hex": "264B" },
      { "Typeface name": "Wingdings", "Dingbat dec": "98", "Dingbat hex": "62", "Unicode dec": "9804", "Unicode hex": "264C" },
      { "Typeface name": "Wingdings", "Dingbat dec": "99", "Dingbat hex": "63", "Unicode dec": "9805", "Unicode hex": "264D" },
      { "Typeface name": "Wingdings", "Dingbat dec": "100", "Dingbat hex": "64", "Unicode dec": "9806", "Unicode hex": "264E" },
      { "Typeface name": "Wingdings", "Dingbat dec": "101", "Dingbat hex": "65", "Unicode dec": "9807", "Unicode hex": "264F" },
      { "Typeface name": "Wingdings", "Dingbat dec": "102", "Dingbat hex": "66", "Unicode dec": "9808", "Unicode hex": "2650" },
      { "Typeface name": "Wingdings", "Dingbat dec": "103", "Dingbat hex": "67", "Unicode dec": "9809", "Unicode hex": "2651" },
      { "Typeface name": "Wingdings", "Dingbat dec": "104", "Dingbat hex": "68", "Unicode dec": "9810", "Unicode hex": "2652" },
      { "Typeface name": "Wingdings", "Dingbat dec": "105", "Dingbat hex": "69", "Unicode dec": "9811", "Unicode hex": "2653" },
      { "Typeface name": "Wingdings", "Dingbat dec": "106", "Dingbat hex": "6A", "Unicode dec": "128624", "Unicode hex": "1F670" },
      { "Typeface name": "Wingdings", "Dingbat dec": "107", "Dingbat hex": "6B", "Unicode dec": "128629", "Unicode hex": "1F675" },
      { "Typeface name": "Wingdings", "Dingbat dec": "108", "Dingbat hex": "6C", "Unicode dec": "9899", "Unicode hex": "26AB" },
      { "Typeface name": "Wingdings", "Dingbat dec": "109", "Dingbat hex": "6D", "Unicode dec": "128318", "Unicode hex": "1F53E" },
      { "Typeface name": "Wingdings", "Dingbat dec": "110", "Dingbat hex": "6E", "Unicode dec": "9724", "Unicode hex": "25FC" },
      { "Typeface name": "Wingdings", "Dingbat dec": "111", "Dingbat hex": "6F", "Unicode dec": "128911", "Unicode hex": "1F78F" },
      { "Typeface name": "Wingdings", "Dingbat dec": "112", "Dingbat hex": "70", "Unicode dec": "128912", "Unicode hex": "1F790" },
      { "Typeface name": "Wingdings", "Dingbat dec": "113", "Dingbat hex": "71", "Unicode dec": "10065", "Unicode hex": "2751" },
      { "Typeface name": "Wingdings", "Dingbat dec": "114", "Dingbat hex": "72", "Unicode dec": "10066", "Unicode hex": "2752" },
      { "Typeface name": "Wingdings", "Dingbat dec": "115", "Dingbat hex": "73", "Unicode dec": "128927", "Unicode hex": "1F79F" },
      { "Typeface name": "Wingdings", "Dingbat dec": "116", "Dingbat hex": "74", "Unicode dec": "10731", "Unicode hex": "29EB" },
      { "Typeface name": "Wingdings", "Dingbat dec": "117", "Dingbat hex": "75", "Unicode dec": "9670", "Unicode hex": "25C6" },
      { "Typeface name": "Wingdings", "Dingbat dec": "118", "Dingbat hex": "76", "Unicode dec": "10070", "Unicode hex": "2756" },
      { "Typeface name": "Wingdings", "Dingbat dec": "119", "Dingbat hex": "77", "Unicode dec": "11049", "Unicode hex": "2B29" },
      { "Typeface name": "Wingdings", "Dingbat dec": "120", "Dingbat hex": "78", "Unicode dec": "8999", "Unicode hex": "2327" },
      { "Typeface name": "Wingdings", "Dingbat dec": "121", "Dingbat hex": "79", "Unicode dec": "11193", "Unicode hex": "2BB9" },
      { "Typeface name": "Wingdings", "Dingbat dec": "122", "Dingbat hex": "7A", "Unicode dec": "8984", "Unicode hex": "2318" },
      { "Typeface name": "Wingdings", "Dingbat dec": "123", "Dingbat hex": "7B", "Unicode dec": "127989", "Unicode hex": "1F3F5" },
      { "Typeface name": "Wingdings", "Dingbat dec": "124", "Dingbat hex": "7C", "Unicode dec": "127990", "Unicode hex": "1F3F6" },
      { "Typeface name": "Wingdings", "Dingbat dec": "125", "Dingbat hex": "7D", "Unicode dec": "128630", "Unicode hex": "1F676" },
      { "Typeface name": "Wingdings", "Dingbat dec": "126", "Dingbat hex": "7E", "Unicode dec": "128631", "Unicode hex": "1F677" },
      { "Typeface name": "Wingdings", "Dingbat dec": "127", "Dingbat hex": "7F", "Unicode dec": "9647", "Unicode hex": "25AF" },
      { "Typeface name": "Wingdings", "Dingbat dec": "128", "Dingbat hex": "80", "Unicode dec": "127243", "Unicode hex": "1F10B" },
      { "Typeface name": "Wingdings", "Dingbat dec": "129", "Dingbat hex": "81", "Unicode dec": "10112", "Unicode hex": "2780" },
      { "Typeface name": "Wingdings", "Dingbat dec": "130", "Dingbat hex": "82", "Unicode dec": "10113", "Unicode hex": "2781" },
      { "Typeface name": "Wingdings", "Dingbat dec": "131", "Dingbat hex": "83", "Unicode dec": "10114", "Unicode hex": "2782" },
      { "Typeface name": "Wingdings", "Dingbat dec": "132", "Dingbat hex": "84", "Unicode dec": "10115", "Unicode hex": "2783" },
      { "Typeface name": "Wingdings", "Dingbat dec": "133", "Dingbat hex": "85", "Unicode dec": "10116", "Unicode hex": "2784" },
      { "Typeface name": "Wingdings", "Dingbat dec": "134", "Dingbat hex": "86", "Unicode dec": "10117", "Unicode hex": "2785" },
      { "Typeface name": "Wingdings", "Dingbat dec": "135", "Dingbat hex": "87", "Unicode dec": "10118", "Unicode hex": "2786" },
      { "Typeface name": "Wingdings", "Dingbat dec": "136", "Dingbat hex": "88", "Unicode dec": "10119", "Unicode hex": "2787" },
      { "Typeface name": "Wingdings", "Dingbat dec": "137", "Dingbat hex": "89", "Unicode dec": "10120", "Unicode hex": "2788" },
      { "Typeface name": "Wingdings", "Dingbat dec": "138", "Dingbat hex": "8A", "Unicode dec": "10121", "Unicode hex": "2789" },
      { "Typeface name": "Wingdings", "Dingbat dec": "139", "Dingbat hex": "8B", "Unicode dec": "127244", "Unicode hex": "1F10C" },
      { "Typeface name": "Wingdings", "Dingbat dec": "140", "Dingbat hex": "8C", "Unicode dec": "10122", "Unicode hex": "278A" },
      { "Typeface name": "Wingdings", "Dingbat dec": "141", "Dingbat hex": "8D", "Unicode dec": "10123", "Unicode hex": "278B" },
      { "Typeface name": "Wingdings", "Dingbat dec": "142", "Dingbat hex": "8E", "Unicode dec": "10124", "Unicode hex": "278C" },
      { "Typeface name": "Wingdings", "Dingbat dec": "143", "Dingbat hex": "8F", "Unicode dec": "10125", "Unicode hex": "278D" },
      { "Typeface name": "Wingdings", "Dingbat dec": "144", "Dingbat hex": "90", "Unicode dec": "10126", "Unicode hex": "278E" },
      { "Typeface name": "Wingdings", "Dingbat dec": "145", "Dingbat hex": "91", "Unicode dec": "10127", "Unicode hex": "278F" },
      { "Typeface name": "Wingdings", "Dingbat dec": "146", "Dingbat hex": "92", "Unicode dec": "10128", "Unicode hex": "2790" },
      { "Typeface name": "Wingdings", "Dingbat dec": "147", "Dingbat hex": "93", "Unicode dec": "10129", "Unicode hex": "2791" },
      { "Typeface name": "Wingdings", "Dingbat dec": "148", "Dingbat hex": "94", "Unicode dec": "10130", "Unicode hex": "2792" },
      { "Typeface name": "Wingdings", "Dingbat dec": "149", "Dingbat hex": "95", "Unicode dec": "10131", "Unicode hex": "2793" },
      { "Typeface name": "Wingdings", "Dingbat dec": "150", "Dingbat hex": "96", "Unicode dec": "128610", "Unicode hex": "1F662" },
      { "Typeface name": "Wingdings", "Dingbat dec": "151", "Dingbat hex": "97", "Unicode dec": "128608", "Unicode hex": "1F660" },
      { "Typeface name": "Wingdings", "Dingbat dec": "152", "Dingbat hex": "98", "Unicode dec": "128609", "Unicode hex": "1F661" },
      { "Typeface name": "Wingdings", "Dingbat dec": "153", "Dingbat hex": "99", "Unicode dec": "128611", "Unicode hex": "1F663" },
      { "Typeface name": "Wingdings", "Dingbat dec": "154", "Dingbat hex": "9A", "Unicode dec": "128606", "Unicode hex": "1F65E" },
      { "Typeface name": "Wingdings", "Dingbat dec": "155", "Dingbat hex": "9B", "Unicode dec": "128604", "Unicode hex": "1F65C" },
      { "Typeface name": "Wingdings", "Dingbat dec": "156", "Dingbat hex": "9C", "Unicode dec": "128605", "Unicode hex": "1F65D" },
      { "Typeface name": "Wingdings", "Dingbat dec": "157", "Dingbat hex": "9D", "Unicode dec": "128607", "Unicode hex": "1F65F" },
      { "Typeface name": "Wingdings", "Dingbat dec": "158", "Dingbat hex": "9E", "Unicode dec": "8729", "Unicode hex": "2219" },
      { "Typeface name": "Wingdings", "Dingbat dec": "159", "Dingbat hex": "9F", "Unicode dec": "8226", "Unicode hex": "2022" },
      { "Typeface name": "Wingdings", "Dingbat dec": "160", "Dingbat hex": "A0", "Unicode dec": "11037", "Unicode hex": "2B1D" },
      { "Typeface name": "Wingdings", "Dingbat dec": "161", "Dingbat hex": "A1", "Unicode dec": "11096", "Unicode hex": "2B58" },
      { "Typeface name": "Wingdings", "Dingbat dec": "162", "Dingbat hex": "A2", "Unicode dec": "128902", "Unicode hex": "1F786" },
      { "Typeface name": "Wingdings", "Dingbat dec": "163", "Dingbat hex": "A3", "Unicode dec": "128904", "Unicode hex": "1F788" },
      { "Typeface name": "Wingdings", "Dingbat dec": "164", "Dingbat hex": "A4", "Unicode dec": "128906", "Unicode hex": "1F78A" },
      { "Typeface name": "Wingdings", "Dingbat dec": "165", "Dingbat hex": "A5", "Unicode dec": "128907", "Unicode hex": "1F78B" },
      { "Typeface name": "Wingdings", "Dingbat dec": "166", "Dingbat hex": "A6", "Unicode dec": "128319", "Unicode hex": "1F53F" },
      { "Typeface name": "Wingdings", "Dingbat dec": "167", "Dingbat hex": "A7", "Unicode dec": "9642", "Unicode hex": "25AA" },
      { "Typeface name": "Wingdings", "Dingbat dec": "168", "Dingbat hex": "A8", "Unicode dec": "128910", "Unicode hex": "1F78E" },
      { "Typeface name": "Wingdings", "Dingbat dec": "169", "Dingbat hex": "A9", "Unicode dec": "128961", "Unicode hex": "1F7C1" },
      { "Typeface name": "Wingdings", "Dingbat dec": "170", "Dingbat hex": "AA", "Unicode dec": "128965", "Unicode hex": "1F7C5" },
      { "Typeface name": "Wingdings", "Dingbat dec": "171", "Dingbat hex": "AB", "Unicode dec": "9733", "Unicode hex": "2605" },
      { "Typeface name": "Wingdings", "Dingbat dec": "172", "Dingbat hex": "AC", "Unicode dec": "128971", "Unicode hex": "1F7CB" },
      { "Typeface name": "Wingdings", "Dingbat dec": "173", "Dingbat hex": "AD", "Unicode dec": "128975", "Unicode hex": "1F7CF" },
      { "Typeface name": "Wingdings", "Dingbat dec": "174", "Dingbat hex": "AE", "Unicode dec": "128979", "Unicode hex": "1F7D3" },
      { "Typeface name": "Wingdings", "Dingbat dec": "175", "Dingbat hex": "AF", "Unicode dec": "128977", "Unicode hex": "1F7D1" },
      { "Typeface name": "Wingdings", "Dingbat dec": "176", "Dingbat hex": "B0", "Unicode dec": "11216", "Unicode hex": "2BD0" },
      { "Typeface name": "Wingdings", "Dingbat dec": "177", "Dingbat hex": "B1", "Unicode dec": "8982", "Unicode hex": "2316" },
      { "Typeface name": "Wingdings", "Dingbat dec": "178", "Dingbat hex": "B2", "Unicode dec": "11214", "Unicode hex": "2BCE" },
      { "Typeface name": "Wingdings", "Dingbat dec": "179", "Dingbat hex": "B3", "Unicode dec": "11215", "Unicode hex": "2BCF" },
      { "Typeface name": "Wingdings", "Dingbat dec": "180", "Dingbat hex": "B4", "Unicode dec": "11217", "Unicode hex": "2BD1" },
      { "Typeface name": "Wingdings", "Dingbat dec": "181", "Dingbat hex": "B5", "Unicode dec": "10026", "Unicode hex": "272A" },
      { "Typeface name": "Wingdings", "Dingbat dec": "182", "Dingbat hex": "B6", "Unicode dec": "10032", "Unicode hex": "2730" },
      { "Typeface name": "Wingdings", "Dingbat dec": "183", "Dingbat hex": "B7", "Unicode dec": "128336", "Unicode hex": "1F550" },
      { "Typeface name": "Wingdings", "Dingbat dec": "184", "Dingbat hex": "B8", "Unicode dec": "128337", "Unicode hex": "1F551" },
      { "Typeface name": "Wingdings", "Dingbat dec": "185", "Dingbat hex": "B9", "Unicode dec": "128338", "Unicode hex": "1F552" },
      { "Typeface name": "Wingdings", "Dingbat dec": "186", "Dingbat hex": "BA", "Unicode dec": "128339", "Unicode hex": "1F553" },
      { "Typeface name": "Wingdings", "Dingbat dec": "187", "Dingbat hex": "BB", "Unicode dec": "128340", "Unicode hex": "1F554" },
      { "Typeface name": "Wingdings", "Dingbat dec": "188", "Dingbat hex": "BC", "Unicode dec": "128341", "Unicode hex": "1F555" },
      { "Typeface name": "Wingdings", "Dingbat dec": "189", "Dingbat hex": "BD", "Unicode dec": "128342", "Unicode hex": "1F556" },
      { "Typeface name": "Wingdings", "Dingbat dec": "190", "Dingbat hex": "BE", "Unicode dec": "128343", "Unicode hex": "1F557" },
      { "Typeface name": "Wingdings", "Dingbat dec": "191", "Dingbat hex": "BF", "Unicode dec": "128344", "Unicode hex": "1F558" },
      { "Typeface name": "Wingdings", "Dingbat dec": "192", "Dingbat hex": "C0", "Unicode dec": "128345", "Unicode hex": "1F559" },
      { "Typeface name": "Wingdings", "Dingbat dec": "193", "Dingbat hex": "C1", "Unicode dec": "128346", "Unicode hex": "1F55A" },
      { "Typeface name": "Wingdings", "Dingbat dec": "194", "Dingbat hex": "C2", "Unicode dec": "128347", "Unicode hex": "1F55B" },
      { "Typeface name": "Wingdings", "Dingbat dec": "195", "Dingbat hex": "C3", "Unicode dec": "11184", "Unicode hex": "2BB0" },
      { "Typeface name": "Wingdings", "Dingbat dec": "196", "Dingbat hex": "C4", "Unicode dec": "11185", "Unicode hex": "2BB1" },
      { "Typeface name": "Wingdings", "Dingbat dec": "197", "Dingbat hex": "C5", "Unicode dec": "11186", "Unicode hex": "2BB2" },
      { "Typeface name": "Wingdings", "Dingbat dec": "198", "Dingbat hex": "C6", "Unicode dec": "11187", "Unicode hex": "2BB3" },
      { "Typeface name": "Wingdings", "Dingbat dec": "199", "Dingbat hex": "C7", "Unicode dec": "11188", "Unicode hex": "2BB4" },
      { "Typeface name": "Wingdings", "Dingbat dec": "200", "Dingbat hex": "C8", "Unicode dec": "11189", "Unicode hex": "2BB5" },
      { "Typeface name": "Wingdings", "Dingbat dec": "201", "Dingbat hex": "C9", "Unicode dec": "11190", "Unicode hex": "2BB6" },
      { "Typeface name": "Wingdings", "Dingbat dec": "202", "Dingbat hex": "CA", "Unicode dec": "11191", "Unicode hex": "2BB7" },
      { "Typeface name": "Wingdings", "Dingbat dec": "203", "Dingbat hex": "CB", "Unicode dec": "128618", "Unicode hex": "1F66A" },
      { "Typeface name": "Wingdings", "Dingbat dec": "204", "Dingbat hex": "CC", "Unicode dec": "128619", "Unicode hex": "1F66B" },
      { "Typeface name": "Wingdings", "Dingbat dec": "205", "Dingbat hex": "CD", "Unicode dec": "128597", "Unicode hex": "1F655" },
      { "Typeface name": "Wingdings", "Dingbat dec": "206", "Dingbat hex": "CE", "Unicode dec": "128596", "Unicode hex": "1F654" },
      { "Typeface name": "Wingdings", "Dingbat dec": "207", "Dingbat hex": "CF", "Unicode dec": "128599", "Unicode hex": "1F657" },
      { "Typeface name": "Wingdings", "Dingbat dec": "208", "Dingbat hex": "D0", "Unicode dec": "128598", "Unicode hex": "1F656" },
      { "Typeface name": "Wingdings", "Dingbat dec": "209", "Dingbat hex": "D1", "Unicode dec": "128592", "Unicode hex": "1F650" },
      { "Typeface name": "Wingdings", "Dingbat dec": "210", "Dingbat hex": "D2", "Unicode dec": "128593", "Unicode hex": "1F651" },
      { "Typeface name": "Wingdings", "Dingbat dec": "211", "Dingbat hex": "D3", "Unicode dec": "128594", "Unicode hex": "1F652" },
      { "Typeface name": "Wingdings", "Dingbat dec": "212", "Dingbat hex": "D4", "Unicode dec": "128595", "Unicode hex": "1F653" },
      { "Typeface name": "Wingdings", "Dingbat dec": "213", "Dingbat hex": "D5", "Unicode dec": "9003", "Unicode hex": "232B" },
      { "Typeface name": "Wingdings", "Dingbat dec": "214", "Dingbat hex": "D6", "Unicode dec": "8998", "Unicode hex": "2326" },
      { "Typeface name": "Wingdings", "Dingbat dec": "215", "Dingbat hex": "D7", "Unicode dec": "11160", "Unicode hex": "2B98" },
      { "Typeface name": "Wingdings", "Dingbat dec": "216", "Dingbat hex": "D8", "Unicode dec": "11162", "Unicode hex": "2B9A" },
      { "Typeface name": "Wingdings", "Dingbat dec": "217", "Dingbat hex": "D9", "Unicode dec": "11161", "Unicode hex": "2B99" },
      { "Typeface name": "Wingdings", "Dingbat dec": "218", "Dingbat hex": "DA", "Unicode dec": "11163", "Unicode hex": "2B9B" },
      { "Typeface name": "Wingdings", "Dingbat dec": "219", "Dingbat hex": "DB", "Unicode dec": "11144", "Unicode hex": "2B88" },
      { "Typeface name": "Wingdings", "Dingbat dec": "220", "Dingbat hex": "DC", "Unicode dec": "11146", "Unicode hex": "2B8A" },
      { "Typeface name": "Wingdings", "Dingbat dec": "221", "Dingbat hex": "DD", "Unicode dec": "11145", "Unicode hex": "2B89" },
      { "Typeface name": "Wingdings", "Dingbat dec": "222", "Dingbat hex": "DE", "Unicode dec": "11147", "Unicode hex": "2B8B" },
      { "Typeface name": "Wingdings", "Dingbat dec": "223", "Dingbat hex": "DF", "Unicode dec": "129128", "Unicode hex": "1F868" },
      { "Typeface name": "Wingdings", "Dingbat dec": "224", "Dingbat hex": "E0", "Unicode dec": "129130", "Unicode hex": "1F86A" },
      { "Typeface name": "Wingdings", "Dingbat dec": "225", "Dingbat hex": "E1", "Unicode dec": "129129", "Unicode hex": "1F869" },
      { "Typeface name": "Wingdings", "Dingbat dec": "226", "Dingbat hex": "E2", "Unicode dec": "129131", "Unicode hex": "1F86B" },
      { "Typeface name": "Wingdings", "Dingbat dec": "227", "Dingbat hex": "E3", "Unicode dec": "129132", "Unicode hex": "1F86C" },
      { "Typeface name": "Wingdings", "Dingbat dec": "228", "Dingbat hex": "E4", "Unicode dec": "129133", "Unicode hex": "1F86D" },
      { "Typeface name": "Wingdings", "Dingbat dec": "229", "Dingbat hex": "E5", "Unicode dec": "129135", "Unicode hex": "1F86F" },
      { "Typeface name": "Wingdings", "Dingbat dec": "230", "Dingbat hex": "E6", "Unicode dec": "129134", "Unicode hex": "1F86E" },
      { "Typeface name": "Wingdings", "Dingbat dec": "231", "Dingbat hex": "E7", "Unicode dec": "129144", "Unicode hex": "1F878" },
      { "Typeface name": "Wingdings", "Dingbat dec": "232", "Dingbat hex": "E8", "Unicode dec": "129146", "Unicode hex": "1F87A" },
      { "Typeface name": "Wingdings", "Dingbat dec": "233", "Dingbat hex": "E9", "Unicode dec": "129145", "Unicode hex": "1F879" },
      { "Typeface name": "Wingdings", "Dingbat dec": "234", "Dingbat hex": "EA", "Unicode dec": "129147", "Unicode hex": "1F87B" },
      { "Typeface name": "Wingdings", "Dingbat dec": "235", "Dingbat hex": "EB", "Unicode dec": "129148", "Unicode hex": "1F87C" },
      { "Typeface name": "Wingdings", "Dingbat dec": "236", "Dingbat hex": "EC", "Unicode dec": "129149", "Unicode hex": "1F87D" },
      { "Typeface name": "Wingdings", "Dingbat dec": "237", "Dingbat hex": "ED", "Unicode dec": "129151", "Unicode hex": "1F87F" },
      { "Typeface name": "Wingdings", "Dingbat dec": "238", "Dingbat hex": "EE", "Unicode dec": "129150", "Unicode hex": "1F87E" },
      { "Typeface name": "Wingdings", "Dingbat dec": "239", "Dingbat hex": "EF", "Unicode dec": "8678", "Unicode hex": "21E6" },
      { "Typeface name": "Wingdings", "Dingbat dec": "240", "Dingbat hex": "F0", "Unicode dec": "8680", "Unicode hex": "21E8" },
      { "Typeface name": "Wingdings", "Dingbat dec": "241", "Dingbat hex": "F1", "Unicode dec": "8679", "Unicode hex": "21E7" },
      { "Typeface name": "Wingdings", "Dingbat dec": "242", "Dingbat hex": "F2", "Unicode dec": "8681", "Unicode hex": "21E9" },
      { "Typeface name": "Wingdings", "Dingbat dec": "243", "Dingbat hex": "F3", "Unicode dec": "11012", "Unicode hex": "2B04" },
      { "Typeface name": "Wingdings", "Dingbat dec": "244", "Dingbat hex": "F4", "Unicode dec": "8691", "Unicode hex": "21F3" },
      { "Typeface name": "Wingdings", "Dingbat dec": "245", "Dingbat hex": "F5", "Unicode dec": "11009", "Unicode hex": "2B01" },
      { "Typeface name": "Wingdings", "Dingbat dec": "246", "Dingbat hex": "F6", "Unicode dec": "11008", "Unicode hex": "2B00" },
      { "Typeface name": "Wingdings", "Dingbat dec": "247", "Dingbat hex": "F7", "Unicode dec": "11011", "Unicode hex": "2B03" },
      { "Typeface name": "Wingdings", "Dingbat dec": "248", "Dingbat hex": "F8", "Unicode dec": "11010", "Unicode hex": "2B02" },
      { "Typeface name": "Wingdings", "Dingbat dec": "249", "Dingbat hex": "F9", "Unicode dec": "129196", "Unicode hex": "1F8AC" },
      { "Typeface name": "Wingdings", "Dingbat dec": "250", "Dingbat hex": "FA", "Unicode dec": "129197", "Unicode hex": "1F8AD" },
      { "Typeface name": "Wingdings", "Dingbat dec": "251", "Dingbat hex": "FB", "Unicode dec": "128502", "Unicode hex": "1F5F6" },
      { "Typeface name": "Wingdings", "Dingbat dec": "252", "Dingbat hex": "FC", "Unicode dec": "10003", "Unicode hex": "2713" },
      { "Typeface name": "Wingdings", "Dingbat dec": "253", "Dingbat hex": "FD", "Unicode dec": "128503", "Unicode hex": "1F5F7" },
      { "Typeface name": "Wingdings", "Dingbat dec": "254", "Dingbat hex": "FE", "Unicode dec": "128505", "Unicode hex": "1F5F9" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "32", "Dingbat hex": "20", "Unicode dec": "32", "Unicode hex": "20" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "33", "Dingbat hex": "21", "Unicode dec": "128394", "Unicode hex": "1F58A" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "34", "Dingbat hex": "22", "Unicode dec": "128395", "Unicode hex": "1F58B" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "35", "Dingbat hex": "23", "Unicode dec": "128396", "Unicode hex": "1F58C" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "36", "Dingbat hex": "24", "Unicode dec": "128397", "Unicode hex": "1F58D" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "37", "Dingbat hex": "25", "Unicode dec": "9988", "Unicode hex": "2704" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "38", "Dingbat hex": "26", "Unicode dec": "9984", "Unicode hex": "2700" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "39", "Dingbat hex": "27", "Unicode dec": "128382", "Unicode hex": "1F57E" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "40", "Dingbat hex": "28", "Unicode dec": "128381", "Unicode hex": "1F57D" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "41", "Dingbat hex": "29", "Unicode dec": "128453", "Unicode hex": "1F5C5" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "42", "Dingbat hex": "2A", "Unicode dec": "128454", "Unicode hex": "1F5C6" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "43", "Dingbat hex": "2B", "Unicode dec": "128455", "Unicode hex": "1F5C7" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "44", "Dingbat hex": "2C", "Unicode dec": "128456", "Unicode hex": "1F5C8" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "45", "Dingbat hex": "2D", "Unicode dec": "128457", "Unicode hex": "1F5C9" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "46", "Dingbat hex": "2E", "Unicode dec": "128458", "Unicode hex": "1F5CA" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "47", "Dingbat hex": "2F", "Unicode dec": "128459", "Unicode hex": "1F5CB" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "48", "Dingbat hex": "30", "Unicode dec": "128460", "Unicode hex": "1F5CC" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "49", "Dingbat hex": "31", "Unicode dec": "128461", "Unicode hex": "1F5CD" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "50", "Dingbat hex": "32", "Unicode dec": "128203", "Unicode hex": "1F4CB" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "51", "Dingbat hex": "33", "Unicode dec": "128465", "Unicode hex": "1F5D1" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "52", "Dingbat hex": "34", "Unicode dec": "128468", "Unicode hex": "1F5D4" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "53", "Dingbat hex": "35", "Unicode dec": "128437", "Unicode hex": "1F5B5" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "54", "Dingbat hex": "36", "Unicode dec": "128438", "Unicode hex": "1F5B6" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "55", "Dingbat hex": "37", "Unicode dec": "128439", "Unicode hex": "1F5B7" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "56", "Dingbat hex": "38", "Unicode dec": "128440", "Unicode hex": "1F5B8" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "57", "Dingbat hex": "39", "Unicode dec": "128429", "Unicode hex": "1F5AD" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "58", "Dingbat hex": "3A", "Unicode dec": "128431", "Unicode hex": "1F5AF" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "59", "Dingbat hex": "3B", "Unicode dec": "128433", "Unicode hex": "1F5B1" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "60", "Dingbat hex": "3C", "Unicode dec": "128402", "Unicode hex": "1F592" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "61", "Dingbat hex": "3D", "Unicode dec": "128403", "Unicode hex": "1F593" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "62", "Dingbat hex": "3E", "Unicode dec": "128408", "Unicode hex": "1F598" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "63", "Dingbat hex": "3F", "Unicode dec": "128409", "Unicode hex": "1F599" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "64", "Dingbat hex": "40", "Unicode dec": "128410", "Unicode hex": "1F59A" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "65", "Dingbat hex": "41", "Unicode dec": "128411", "Unicode hex": "1F59B" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "66", "Dingbat hex": "42", "Unicode dec": "128072", "Unicode hex": "1F448" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "67", "Dingbat hex": "43", "Unicode dec": "128073", "Unicode hex": "1F449" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "68", "Dingbat hex": "44", "Unicode dec": "128412", "Unicode hex": "1F59C" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "69", "Dingbat hex": "45", "Unicode dec": "128413", "Unicode hex": "1F59D" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "70", "Dingbat hex": "46", "Unicode dec": "128414", "Unicode hex": "1F59E" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "71", "Dingbat hex": "47", "Unicode dec": "128415", "Unicode hex": "1F59F" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "72", "Dingbat hex": "48", "Unicode dec": "128416", "Unicode hex": "1F5A0" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "73", "Dingbat hex": "49", "Unicode dec": "128417", "Unicode hex": "1F5A1" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "74", "Dingbat hex": "4A", "Unicode dec": "128070", "Unicode hex": "1F446" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "75", "Dingbat hex": "4B", "Unicode dec": "128071", "Unicode hex": "1F447" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "76", "Dingbat hex": "4C", "Unicode dec": "128418", "Unicode hex": "1F5A2" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "77", "Dingbat hex": "4D", "Unicode dec": "128419", "Unicode hex": "1F5A3" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "78", "Dingbat hex": "4E", "Unicode dec": "128401", "Unicode hex": "1F591" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "79", "Dingbat hex": "4F", "Unicode dec": "128500", "Unicode hex": "1F5F4" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "80", "Dingbat hex": "50", "Unicode dec": "128504", "Unicode hex": "1F5F8" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "81", "Dingbat hex": "51", "Unicode dec": "128501", "Unicode hex": "1F5F5" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "82", "Dingbat hex": "52", "Unicode dec": "9745", "Unicode hex": "2611" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "83", "Dingbat hex": "53", "Unicode dec": "11197", "Unicode hex": "2BBD" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "84", "Dingbat hex": "54", "Unicode dec": "9746", "Unicode hex": "2612" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "85", "Dingbat hex": "55", "Unicode dec": "11198", "Unicode hex": "2BBE" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "86", "Dingbat hex": "56", "Unicode dec": "11199", "Unicode hex": "2BBF" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "87", "Dingbat hex": "57", "Unicode dec": "128711", "Unicode hex": "1F6C7" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "88", "Dingbat hex": "58", "Unicode dec": "10680", "Unicode hex": "29B8" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "89", "Dingbat hex": "59", "Unicode dec": "128625", "Unicode hex": "1F671" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "90", "Dingbat hex": "5A", "Unicode dec": "128628", "Unicode hex": "1F674" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "91", "Dingbat hex": "5B", "Unicode dec": "128626", "Unicode hex": "1F672" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "92", "Dingbat hex": "5C", "Unicode dec": "128627", "Unicode hex": "1F673" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "93", "Dingbat hex": "5D", "Unicode dec": "8253", "Unicode hex": "203D" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "94", "Dingbat hex": "5E", "Unicode dec": "128633", "Unicode hex": "1F679" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "95", "Dingbat hex": "5F", "Unicode dec": "128634", "Unicode hex": "1F67A" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "96", "Dingbat hex": "60", "Unicode dec": "128635", "Unicode hex": "1F67B" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "97", "Dingbat hex": "61", "Unicode dec": "128614", "Unicode hex": "1F666" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "98", "Dingbat hex": "62", "Unicode dec": "128612", "Unicode hex": "1F664" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "99", "Dingbat hex": "63", "Unicode dec": "128613", "Unicode hex": "1F665" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "100", "Dingbat hex": "64", "Unicode dec": "128615", "Unicode hex": "1F667" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "101", "Dingbat hex": "65", "Unicode dec": "128602", "Unicode hex": "1F65A" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "102", "Dingbat hex": "66", "Unicode dec": "128600", "Unicode hex": "1F658" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "103", "Dingbat hex": "67", "Unicode dec": "128601", "Unicode hex": "1F659" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "104", "Dingbat hex": "68", "Unicode dec": "128603", "Unicode hex": "1F65B" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "105", "Dingbat hex": "69", "Unicode dec": "9450", "Unicode hex": "24EA" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "106", "Dingbat hex": "6A", "Unicode dec": "9312", "Unicode hex": "2460" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "107", "Dingbat hex": "6B", "Unicode dec": "9313", "Unicode hex": "2461" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "108", "Dingbat hex": "6C", "Unicode dec": "9314", "Unicode hex": "2462" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "109", "Dingbat hex": "6D", "Unicode dec": "9315", "Unicode hex": "2463" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "110", "Dingbat hex": "6E", "Unicode dec": "9316", "Unicode hex": "2464" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "111", "Dingbat hex": "6F", "Unicode dec": "9317", "Unicode hex": "2465" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "112", "Dingbat hex": "70", "Unicode dec": "9318", "Unicode hex": "2466" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "113", "Dingbat hex": "71", "Unicode dec": "9319", "Unicode hex": "2467" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "114", "Dingbat hex": "72", "Unicode dec": "9320", "Unicode hex": "2468" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "115", "Dingbat hex": "73", "Unicode dec": "9321", "Unicode hex": "2469" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "116", "Dingbat hex": "74", "Unicode dec": "9471", "Unicode hex": "24FF" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "117", "Dingbat hex": "75", "Unicode dec": "10102", "Unicode hex": "2776" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "118", "Dingbat hex": "76", "Unicode dec": "10103", "Unicode hex": "2777" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "119", "Dingbat hex": "77", "Unicode dec": "10104", "Unicode hex": "2778" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "120", "Dingbat hex": "78", "Unicode dec": "10105", "Unicode hex": "2779" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "121", "Dingbat hex": "79", "Unicode dec": "10106", "Unicode hex": "277A" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "122", "Dingbat hex": "7A", "Unicode dec": "10107", "Unicode hex": "277B" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "123", "Dingbat hex": "7B", "Unicode dec": "10108", "Unicode hex": "277C" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "124", "Dingbat hex": "7C", "Unicode dec": "10109", "Unicode hex": "277D" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "125", "Dingbat hex": "7D", "Unicode dec": "10110", "Unicode hex": "277E" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "126", "Dingbat hex": "7E", "Unicode dec": "10111", "Unicode hex": "277F" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "128", "Dingbat hex": "80", "Unicode dec": "9737", "Unicode hex": "2609" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "129", "Dingbat hex": "81", "Unicode dec": "127765", "Unicode hex": "1F315" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "130", "Dingbat hex": "82", "Unicode dec": "9789", "Unicode hex": "263D" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "131", "Dingbat hex": "83", "Unicode dec": "9790", "Unicode hex": "263E" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "132", "Dingbat hex": "84", "Unicode dec": "11839", "Unicode hex": "2E3F" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "133", "Dingbat hex": "85", "Unicode dec": "10013", "Unicode hex": "271D" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "134", "Dingbat hex": "86", "Unicode dec": "128327", "Unicode hex": "1F547" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "135", "Dingbat hex": "87", "Unicode dec": "128348", "Unicode hex": "1F55C" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "136", "Dingbat hex": "88", "Unicode dec": "128349", "Unicode hex": "1F55D" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "137", "Dingbat hex": "89", "Unicode dec": "128350", "Unicode hex": "1F55E" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "138", "Dingbat hex": "8A", "Unicode dec": "128351", "Unicode hex": "1F55F" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "139", "Dingbat hex": "8B", "Unicode dec": "128352", "Unicode hex": "1F560" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "140", "Dingbat hex": "8C", "Unicode dec": "128353", "Unicode hex": "1F561" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "141", "Dingbat hex": "8D", "Unicode dec": "128354", "Unicode hex": "1F562" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "142", "Dingbat hex": "8E", "Unicode dec": "128355", "Unicode hex": "1F563" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "143", "Dingbat hex": "8F", "Unicode dec": "128356", "Unicode hex": "1F564" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "144", "Dingbat hex": "90", "Unicode dec": "128357", "Unicode hex": "1F565" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "145", "Dingbat hex": "91", "Unicode dec": "128358", "Unicode hex": "1F566" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "146", "Dingbat hex": "92", "Unicode dec": "128359", "Unicode hex": "1F567" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "147", "Dingbat hex": "93", "Unicode dec": "128616", "Unicode hex": "1F668" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "148", "Dingbat hex": "94", "Unicode dec": "128617", "Unicode hex": "1F669" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "149", "Dingbat hex": "95", "Unicode dec": "8901", "Unicode hex": "22C5" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "150", "Dingbat hex": "96", "Unicode dec": "128900", "Unicode hex": "1F784" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "151", "Dingbat hex": "97", "Unicode dec": "10625", "Unicode hex": "2981" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "152", "Dingbat hex": "98", "Unicode dec": "9679", "Unicode hex": "25CF" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "153", "Dingbat hex": "99", "Unicode dec": "9675", "Unicode hex": "25CB" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "154", "Dingbat hex": "9A", "Unicode dec": "128901", "Unicode hex": "1F785" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "155", "Dingbat hex": "9B", "Unicode dec": "128903", "Unicode hex": "1F787" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "156", "Dingbat hex": "9C", "Unicode dec": "128905", "Unicode hex": "1F789" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "157", "Dingbat hex": "9D", "Unicode dec": "8857", "Unicode hex": "2299" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "158", "Dingbat hex": "9E", "Unicode dec": "10687", "Unicode hex": "29BF" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "159", "Dingbat hex": "9F", "Unicode dec": "128908", "Unicode hex": "1F78C" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "160", "Dingbat hex": "A0", "Unicode dec": "128909", "Unicode hex": "1F78D" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "161", "Dingbat hex": "A1", "Unicode dec": "9726", "Unicode hex": "25FE" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "162", "Dingbat hex": "A2", "Unicode dec": "9632", "Unicode hex": "25A0" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "163", "Dingbat hex": "A3", "Unicode dec": "9633", "Unicode hex": "25A1" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "164", "Dingbat hex": "A4", "Unicode dec": "128913", "Unicode hex": "1F791" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "165", "Dingbat hex": "A5", "Unicode dec": "128914", "Unicode hex": "1F792" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "166", "Dingbat hex": "A6", "Unicode dec": "128915", "Unicode hex": "1F793" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "167", "Dingbat hex": "A7", "Unicode dec": "128916", "Unicode hex": "1F794" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "168", "Dingbat hex": "A8", "Unicode dec": "9635", "Unicode hex": "25A3" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "169", "Dingbat hex": "A9", "Unicode dec": "128917", "Unicode hex": "1F795" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "170", "Dingbat hex": "AA", "Unicode dec": "128918", "Unicode hex": "1F796" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "171", "Dingbat hex": "AB", "Unicode dec": "128919", "Unicode hex": "1F797" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "172", "Dingbat hex": "AC", "Unicode dec": "128920", "Unicode hex": "1F798" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "173", "Dingbat hex": "AD", "Unicode dec": "11049", "Unicode hex": "2B29" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "174", "Dingbat hex": "AE", "Unicode dec": "11045", "Unicode hex": "2B25" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "175", "Dingbat hex": "AF", "Unicode dec": "9671", "Unicode hex": "25C7" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "176", "Dingbat hex": "B0", "Unicode dec": "128922", "Unicode hex": "1F79A" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "177", "Dingbat hex": "B1", "Unicode dec": "9672", "Unicode hex": "25C8" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "178", "Dingbat hex": "B2", "Unicode dec": "128923", "Unicode hex": "1F79B" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "179", "Dingbat hex": "B3", "Unicode dec": "128924", "Unicode hex": "1F79C" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "180", "Dingbat hex": "B4", "Unicode dec": "128925", "Unicode hex": "1F79D" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "181", "Dingbat hex": "B5", "Unicode dec": "128926", "Unicode hex": "1F79E" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "182", "Dingbat hex": "B6", "Unicode dec": "11050", "Unicode hex": "2B2A" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "183", "Dingbat hex": "B7", "Unicode dec": "11047", "Unicode hex": "2B27" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "184", "Dingbat hex": "B8", "Unicode dec": "9674", "Unicode hex": "25CA" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "185", "Dingbat hex": "B9", "Unicode dec": "128928", "Unicode hex": "1F7A0" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "186", "Dingbat hex": "BA", "Unicode dec": "9686", "Unicode hex": "25D6" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "187", "Dingbat hex": "BB", "Unicode dec": "9687", "Unicode hex": "25D7" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "188", "Dingbat hex": "BC", "Unicode dec": "11210", "Unicode hex": "2BCA" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "189", "Dingbat hex": "BD", "Unicode dec": "11211", "Unicode hex": "2BCB" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "190", "Dingbat hex": "BE", "Unicode dec": "11200", "Unicode hex": "2BC0" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "191", "Dingbat hex": "BF", "Unicode dec": "11201", "Unicode hex": "2BC1" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "192", "Dingbat hex": "C0", "Unicode dec": "11039", "Unicode hex": "2B1F" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "193", "Dingbat hex": "C1", "Unicode dec": "11202", "Unicode hex": "2BC2" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "194", "Dingbat hex": "C2", "Unicode dec": "11043", "Unicode hex": "2B23" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "195", "Dingbat hex": "C3", "Unicode dec": "11042", "Unicode hex": "2B22" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "196", "Dingbat hex": "C4", "Unicode dec": "11203", "Unicode hex": "2BC3" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "197", "Dingbat hex": "C5", "Unicode dec": "11204", "Unicode hex": "2BC4" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "198", "Dingbat hex": "C6", "Unicode dec": "128929", "Unicode hex": "1F7A1" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "199", "Dingbat hex": "C7", "Unicode dec": "128930", "Unicode hex": "1F7A2" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "200", "Dingbat hex": "C8", "Unicode dec": "128931", "Unicode hex": "1F7A3" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "201", "Dingbat hex": "C9", "Unicode dec": "128932", "Unicode hex": "1F7A4" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "202", "Dingbat hex": "CA", "Unicode dec": "128933", "Unicode hex": "1F7A5" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "203", "Dingbat hex": "CB", "Unicode dec": "128934", "Unicode hex": "1F7A6" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "204", "Dingbat hex": "CC", "Unicode dec": "128935", "Unicode hex": "1F7A7" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "205", "Dingbat hex": "CD", "Unicode dec": "128936", "Unicode hex": "1F7A8" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "206", "Dingbat hex": "CE", "Unicode dec": "128937", "Unicode hex": "1F7A9" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "207", "Dingbat hex": "CF", "Unicode dec": "128938", "Unicode hex": "1F7AA" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "208", "Dingbat hex": "D0", "Unicode dec": "128939", "Unicode hex": "1F7AB" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "209", "Dingbat hex": "D1", "Unicode dec": "128940", "Unicode hex": "1F7AC" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "210", "Dingbat hex": "D2", "Unicode dec": "128941", "Unicode hex": "1F7AD" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "211", "Dingbat hex": "D3", "Unicode dec": "128942", "Unicode hex": "1F7AE" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "212", "Dingbat hex": "D4", "Unicode dec": "128943", "Unicode hex": "1F7AF" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "213", "Dingbat hex": "D5", "Unicode dec": "128944", "Unicode hex": "1F7B0" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "214", "Dingbat hex": "D6", "Unicode dec": "128945", "Unicode hex": "1F7B1" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "215", "Dingbat hex": "D7", "Unicode dec": "128946", "Unicode hex": "1F7B2" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "216", "Dingbat hex": "D8", "Unicode dec": "128947", "Unicode hex": "1F7B3" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "217", "Dingbat hex": "D9", "Unicode dec": "128948", "Unicode hex": "1F7B4" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "218", "Dingbat hex": "DA", "Unicode dec": "128949", "Unicode hex": "1F7B5" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "219", "Dingbat hex": "DB", "Unicode dec": "128950", "Unicode hex": "1F7B6" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "220", "Dingbat hex": "DC", "Unicode dec": "128951", "Unicode hex": "1F7B7" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "221", "Dingbat hex": "DD", "Unicode dec": "128952", "Unicode hex": "1F7B8" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "222", "Dingbat hex": "DE", "Unicode dec": "128953", "Unicode hex": "1F7B9" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "223", "Dingbat hex": "DF", "Unicode dec": "128954", "Unicode hex": "1F7BA" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "224", "Dingbat hex": "E0", "Unicode dec": "128955", "Unicode hex": "1F7BB" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "225", "Dingbat hex": "E1", "Unicode dec": "128956", "Unicode hex": "1F7BC" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "226", "Dingbat hex": "E2", "Unicode dec": "128957", "Unicode hex": "1F7BD" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "227", "Dingbat hex": "E3", "Unicode dec": "128958", "Unicode hex": "1F7BE" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "228", "Dingbat hex": "E4", "Unicode dec": "128959", "Unicode hex": "1F7BF" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "229", "Dingbat hex": "E5", "Unicode dec": "128960", "Unicode hex": "1F7C0" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "230", "Dingbat hex": "E6", "Unicode dec": "128962", "Unicode hex": "1F7C2" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "231", "Dingbat hex": "E7", "Unicode dec": "128964", "Unicode hex": "1F7C4" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "232", "Dingbat hex": "E8", "Unicode dec": "128966", "Unicode hex": "1F7C6" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "233", "Dingbat hex": "E9", "Unicode dec": "128969", "Unicode hex": "1F7C9" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "234", "Dingbat hex": "EA", "Unicode dec": "128970", "Unicode hex": "1F7CA" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "235", "Dingbat hex": "EB", "Unicode dec": "10038", "Unicode hex": "2736" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "236", "Dingbat hex": "EC", "Unicode dec": "128972", "Unicode hex": "1F7CC" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "237", "Dingbat hex": "ED", "Unicode dec": "128974", "Unicode hex": "1F7CE" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "238", "Dingbat hex": "EE", "Unicode dec": "128976", "Unicode hex": "1F7D0" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "239", "Dingbat hex": "EF", "Unicode dec": "128978", "Unicode hex": "1F7D2" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "240", "Dingbat hex": "F0", "Unicode dec": "10041", "Unicode hex": "2739" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "241", "Dingbat hex": "F1", "Unicode dec": "128963", "Unicode hex": "1F7C3" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "242", "Dingbat hex": "F2", "Unicode dec": "128967", "Unicode hex": "1F7C7" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "243", "Dingbat hex": "F3", "Unicode dec": "10031", "Unicode hex": "272F" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "244", "Dingbat hex": "F4", "Unicode dec": "128973", "Unicode hex": "1F7CD" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "245", "Dingbat hex": "F5", "Unicode dec": "128980", "Unicode hex": "1F7D4" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "246", "Dingbat hex": "F6", "Unicode dec": "11212", "Unicode hex": "2BCC" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "247", "Dingbat hex": "F7", "Unicode dec": "11213", "Unicode hex": "2BCD" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "248", "Dingbat hex": "F8", "Unicode dec": "8251", "Unicode hex": "203B" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "249", "Dingbat hex": "F9", "Unicode dec": "8258", "Unicode hex": "2042" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "32", "Dingbat hex": "20", "Unicode dec": "32", "Unicode hex": "20" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "33", "Dingbat hex": "21", "Unicode dec": "11104", "Unicode hex": "2B60" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "34", "Dingbat hex": "22", "Unicode dec": "11106", "Unicode hex": "2B62" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "35", "Dingbat hex": "23", "Unicode dec": "11105", "Unicode hex": "2B61" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "36", "Dingbat hex": "24", "Unicode dec": "11107", "Unicode hex": "2B63" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "37", "Dingbat hex": "25", "Unicode dec": "11110", "Unicode hex": "2B66" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "38", "Dingbat hex": "26", "Unicode dec": "11111", "Unicode hex": "2B67" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "39", "Dingbat hex": "27", "Unicode dec": "11113", "Unicode hex": "2B69" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "40", "Dingbat hex": "28", "Unicode dec": "11112", "Unicode hex": "2B68" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "41", "Dingbat hex": "29", "Unicode dec": "11120", "Unicode hex": "2B70" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "42", "Dingbat hex": "2A", "Unicode dec": "11122", "Unicode hex": "2B72" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "43", "Dingbat hex": "2B", "Unicode dec": "11121", "Unicode hex": "2B71" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "44", "Dingbat hex": "2C", "Unicode dec": "11123", "Unicode hex": "2B73" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "45", "Dingbat hex": "2D", "Unicode dec": "11126", "Unicode hex": "2B76" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "46", "Dingbat hex": "2E", "Unicode dec": "11128", "Unicode hex": "2B78" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "47", "Dingbat hex": "2F", "Unicode dec": "11131", "Unicode hex": "2B7B" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "48", "Dingbat hex": "30", "Unicode dec": "11133", "Unicode hex": "2B7D" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "49", "Dingbat hex": "31", "Unicode dec": "11108", "Unicode hex": "2B64" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "50", "Dingbat hex": "32", "Unicode dec": "11109", "Unicode hex": "2B65" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "51", "Dingbat hex": "33", "Unicode dec": "11114", "Unicode hex": "2B6A" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "52", "Dingbat hex": "34", "Unicode dec": "11116", "Unicode hex": "2B6C" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "53", "Dingbat hex": "35", "Unicode dec": "11115", "Unicode hex": "2B6B" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "54", "Dingbat hex": "36", "Unicode dec": "11117", "Unicode hex": "2B6D" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "55", "Dingbat hex": "37", "Unicode dec": "11085", "Unicode hex": "2B4D" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "56", "Dingbat hex": "38", "Unicode dec": "11168", "Unicode hex": "2BA0" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "57", "Dingbat hex": "39", "Unicode dec": "11169", "Unicode hex": "2BA1" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "58", "Dingbat hex": "3A", "Unicode dec": "11170", "Unicode hex": "2BA2" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "59", "Dingbat hex": "3B", "Unicode dec": "11171", "Unicode hex": "2BA3" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "60", "Dingbat hex": "3C", "Unicode dec": "11172", "Unicode hex": "2BA4" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "61", "Dingbat hex": "3D", "Unicode dec": "11173", "Unicode hex": "2BA5" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "62", "Dingbat hex": "3E", "Unicode dec": "11174", "Unicode hex": "2BA6" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "63", "Dingbat hex": "3F", "Unicode dec": "11175", "Unicode hex": "2BA7" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "64", "Dingbat hex": "40", "Unicode dec": "11152", "Unicode hex": "2B90" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "65", "Dingbat hex": "41", "Unicode dec": "11153", "Unicode hex": "2B91" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "66", "Dingbat hex": "42", "Unicode dec": "11154", "Unicode hex": "2B92" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "67", "Dingbat hex": "43", "Unicode dec": "11155", "Unicode hex": "2B93" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "68", "Dingbat hex": "44", "Unicode dec": "11136", "Unicode hex": "2B80" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "69", "Dingbat hex": "45", "Unicode dec": "11139", "Unicode hex": "2B83" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "70", "Dingbat hex": "46", "Unicode dec": "11134", "Unicode hex": "2B7E" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "71", "Dingbat hex": "47", "Unicode dec": "11135", "Unicode hex": "2B7F" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "72", "Dingbat hex": "48", "Unicode dec": "11140", "Unicode hex": "2B84" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "73", "Dingbat hex": "49", "Unicode dec": "11142", "Unicode hex": "2B86" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "74", "Dingbat hex": "4A", "Unicode dec": "11141", "Unicode hex": "2B85" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "75", "Dingbat hex": "4B", "Unicode dec": "11143", "Unicode hex": "2B87" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "76", "Dingbat hex": "4C", "Unicode dec": "11151", "Unicode hex": "2B8F" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "77", "Dingbat hex": "4D", "Unicode dec": "11149", "Unicode hex": "2B8D" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "78", "Dingbat hex": "4E", "Unicode dec": "11150", "Unicode hex": "2B8E" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "79", "Dingbat hex": "4F", "Unicode dec": "11148", "Unicode hex": "2B8C" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "80", "Dingbat hex": "50", "Unicode dec": "11118", "Unicode hex": "2B6E" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "81", "Dingbat hex": "51", "Unicode dec": "11119", "Unicode hex": "2B6F" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "82", "Dingbat hex": "52", "Unicode dec": "9099", "Unicode hex": "238B" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "83", "Dingbat hex": "53", "Unicode dec": "8996", "Unicode hex": "2324" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "84", "Dingbat hex": "54", "Unicode dec": "8963", "Unicode hex": "2303" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "85", "Dingbat hex": "55", "Unicode dec": "8997", "Unicode hex": "2325" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "86", "Dingbat hex": "56", "Unicode dec": "9251", "Unicode hex": "2423" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "87", "Dingbat hex": "57", "Unicode dec": "9085", "Unicode hex": "237D" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "88", "Dingbat hex": "58", "Unicode dec": "8682", "Unicode hex": "21EA" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "89", "Dingbat hex": "59", "Unicode dec": "11192", "Unicode hex": "2BB8" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "90", "Dingbat hex": "5A", "Unicode dec": "129184", "Unicode hex": "1F8A0" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "91", "Dingbat hex": "5B", "Unicode dec": "129185", "Unicode hex": "1F8A1" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "92", "Dingbat hex": "5C", "Unicode dec": "129186", "Unicode hex": "1F8A2" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "93", "Dingbat hex": "5D", "Unicode dec": "129187", "Unicode hex": "1F8A3" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "94", "Dingbat hex": "5E", "Unicode dec": "129188", "Unicode hex": "1F8A4" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "95", "Dingbat hex": "5F", "Unicode dec": "129189", "Unicode hex": "1F8A5" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "96", "Dingbat hex": "60", "Unicode dec": "129190", "Unicode hex": "1F8A6" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "97", "Dingbat hex": "61", "Unicode dec": "129191", "Unicode hex": "1F8A7" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "98", "Dingbat hex": "62", "Unicode dec": "129192", "Unicode hex": "1F8A8" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "99", "Dingbat hex": "63", "Unicode dec": "129193", "Unicode hex": "1F8A9" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "100", "Dingbat hex": "64", "Unicode dec": "129194", "Unicode hex": "1F8AA" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "101", "Dingbat hex": "65", "Unicode dec": "129195", "Unicode hex": "1F8AB" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "102", "Dingbat hex": "66", "Unicode dec": "129104", "Unicode hex": "1F850" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "103", "Dingbat hex": "67", "Unicode dec": "129106", "Unicode hex": "1F852" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "104", "Dingbat hex": "68", "Unicode dec": "129105", "Unicode hex": "1F851" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "105", "Dingbat hex": "69", "Unicode dec": "129107", "Unicode hex": "1F853" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "106", "Dingbat hex": "6A", "Unicode dec": "129108", "Unicode hex": "1F854" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "107", "Dingbat hex": "6B", "Unicode dec": "129109", "Unicode hex": "1F855" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "108", "Dingbat hex": "6C", "Unicode dec": "129111", "Unicode hex": "1F857" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "109", "Dingbat hex": "6D", "Unicode dec": "129110", "Unicode hex": "1F856" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "110", "Dingbat hex": "6E", "Unicode dec": "129112", "Unicode hex": "1F858" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "111", "Dingbat hex": "6F", "Unicode dec": "129113", "Unicode hex": "1F859" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "112", "Dingbat hex": "70", "Unicode dec": "9650", "Unicode hex": "25B2" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "113", "Dingbat hex": "71", "Unicode dec": "9660", "Unicode hex": "25BC" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "114", "Dingbat hex": "72", "Unicode dec": "9651", "Unicode hex": "25B3" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "115", "Dingbat hex": "73", "Unicode dec": "9661", "Unicode hex": "25BD" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "116", "Dingbat hex": "74", "Unicode dec": "9664", "Unicode hex": "25C0" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "117", "Dingbat hex": "75", "Unicode dec": "9654", "Unicode hex": "25B6" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "118", "Dingbat hex": "76", "Unicode dec": "9665", "Unicode hex": "25C1" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "119", "Dingbat hex": "77", "Unicode dec": "9655", "Unicode hex": "25B7" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "120", "Dingbat hex": "78", "Unicode dec": "9699", "Unicode hex": "25E3" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "121", "Dingbat hex": "79", "Unicode dec": "9698", "Unicode hex": "25E2" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "122", "Dingbat hex": "7A", "Unicode dec": "9700", "Unicode hex": "25E4" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "123", "Dingbat hex": "7B", "Unicode dec": "9701", "Unicode hex": "25E5" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "124", "Dingbat hex": "7C", "Unicode dec": "128896", "Unicode hex": "1F780" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "125", "Dingbat hex": "7D", "Unicode dec": "128898", "Unicode hex": "1F782" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "126", "Dingbat hex": "7E", "Unicode dec": "128897", "Unicode hex": "1F781" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "128", "Dingbat hex": "80", "Unicode dec": "128899", "Unicode hex": "1F783" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "129", "Dingbat hex": "81", "Unicode dec": "11205", "Unicode hex": "2BC5" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "130", "Dingbat hex": "82", "Unicode dec": "11206", "Unicode hex": "2BC6" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "131", "Dingbat hex": "83", "Unicode dec": "11207", "Unicode hex": "2BC7" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "132", "Dingbat hex": "84", "Unicode dec": "11208", "Unicode hex": "2BC8" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "133", "Dingbat hex": "85", "Unicode dec": "11164", "Unicode hex": "2B9C" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "134", "Dingbat hex": "86", "Unicode dec": "11166", "Unicode hex": "2B9E" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "135", "Dingbat hex": "87", "Unicode dec": "11165", "Unicode hex": "2B9D" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "136", "Dingbat hex": "88", "Unicode dec": "11167", "Unicode hex": "2B9F" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "137", "Dingbat hex": "89", "Unicode dec": "129040", "Unicode hex": "1F810" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "138", "Dingbat hex": "8A", "Unicode dec": "129042", "Unicode hex": "1F812" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "139", "Dingbat hex": "8B", "Unicode dec": "129041", "Unicode hex": "1F811" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "140", "Dingbat hex": "8C", "Unicode dec": "129043", "Unicode hex": "1F813" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "141", "Dingbat hex": "8D", "Unicode dec": "129044", "Unicode hex": "1F814" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "142", "Dingbat hex": "8E", "Unicode dec": "129046", "Unicode hex": "1F816" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "143", "Dingbat hex": "8F", "Unicode dec": "129045", "Unicode hex": "1F815" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "144", "Dingbat hex": "90", "Unicode dec": "129047", "Unicode hex": "1F817" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "145", "Dingbat hex": "91", "Unicode dec": "129048", "Unicode hex": "1F818" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "146", "Dingbat hex": "92", "Unicode dec": "129050", "Unicode hex": "1F81A" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "147", "Dingbat hex": "93", "Unicode dec": "129049", "Unicode hex": "1F819" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "148", "Dingbat hex": "94", "Unicode dec": "129051", "Unicode hex": "1F81B" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "149", "Dingbat hex": "95", "Unicode dec": "129052", "Unicode hex": "1F81C" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "150", "Dingbat hex": "96", "Unicode dec": "129054", "Unicode hex": "1F81E" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "151", "Dingbat hex": "97", "Unicode dec": "129053", "Unicode hex": "1F81D" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "152", "Dingbat hex": "98", "Unicode dec": "129055", "Unicode hex": "1F81F" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "153", "Dingbat hex": "99", "Unicode dec": "129024", "Unicode hex": "1F800" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "154", "Dingbat hex": "9A", "Unicode dec": "129026", "Unicode hex": "1F802" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "155", "Dingbat hex": "9B", "Unicode dec": "129025", "Unicode hex": "1F801" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "156", "Dingbat hex": "9C", "Unicode dec": "129027", "Unicode hex": "1F803" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "157", "Dingbat hex": "9D", "Unicode dec": "129028", "Unicode hex": "1F804" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "158", "Dingbat hex": "9E", "Unicode dec": "129030", "Unicode hex": "1F806" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "159", "Dingbat hex": "9F", "Unicode dec": "129029", "Unicode hex": "1F805" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "160", "Dingbat hex": "A0", "Unicode dec": "129031", "Unicode hex": "1F807" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "161", "Dingbat hex": "A1", "Unicode dec": "129032", "Unicode hex": "1F808" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "162", "Dingbat hex": "A2", "Unicode dec": "129034", "Unicode hex": "1F80A" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "163", "Dingbat hex": "A3", "Unicode dec": "129033", "Unicode hex": "1F809" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "164", "Dingbat hex": "A4", "Unicode dec": "129035", "Unicode hex": "1F80B" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "165", "Dingbat hex": "A5", "Unicode dec": "129056", "Unicode hex": "1F820" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "166", "Dingbat hex": "A6", "Unicode dec": "129058", "Unicode hex": "1F822" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "167", "Dingbat hex": "A7", "Unicode dec": "129060", "Unicode hex": "1F824" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "168", "Dingbat hex": "A8", "Unicode dec": "129062", "Unicode hex": "1F826" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "169", "Dingbat hex": "A9", "Unicode dec": "129064", "Unicode hex": "1F828" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "170", "Dingbat hex": "AA", "Unicode dec": "129066", "Unicode hex": "1F82A" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "171", "Dingbat hex": "AB", "Unicode dec": "129068", "Unicode hex": "1F82C" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "172", "Dingbat hex": "AC", "Unicode dec": "129180", "Unicode hex": "1F89C" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "173", "Dingbat hex": "AD", "Unicode dec": "129181", "Unicode hex": "1F89D" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "174", "Dingbat hex": "AE", "Unicode dec": "129182", "Unicode hex": "1F89E" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "175", "Dingbat hex": "AF", "Unicode dec": "129183", "Unicode hex": "1F89F" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "176", "Dingbat hex": "B0", "Unicode dec": "129070", "Unicode hex": "1F82E" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "177", "Dingbat hex": "B1", "Unicode dec": "129072", "Unicode hex": "1F830" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "178", "Dingbat hex": "B2", "Unicode dec": "129074", "Unicode hex": "1F832" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "179", "Dingbat hex": "B3", "Unicode dec": "129076", "Unicode hex": "1F834" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "180", "Dingbat hex": "B4", "Unicode dec": "129078", "Unicode hex": "1F836" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "181", "Dingbat hex": "B5", "Unicode dec": "129080", "Unicode hex": "1F838" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "182", "Dingbat hex": "B6", "Unicode dec": "129082", "Unicode hex": "1F83A" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "183", "Dingbat hex": "B7", "Unicode dec": "129081", "Unicode hex": "1F839" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "184", "Dingbat hex": "B8", "Unicode dec": "129083", "Unicode hex": "1F83B" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "185", "Dingbat hex": "B9", "Unicode dec": "129176", "Unicode hex": "1F898" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "186", "Dingbat hex": "BA", "Unicode dec": "129178", "Unicode hex": "1F89A" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "187", "Dingbat hex": "BB", "Unicode dec": "129177", "Unicode hex": "1F899" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "188", "Dingbat hex": "BC", "Unicode dec": "129179", "Unicode hex": "1F89B" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "189", "Dingbat hex": "BD", "Unicode dec": "129084", "Unicode hex": "1F83C" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "190", "Dingbat hex": "BE", "Unicode dec": "129086", "Unicode hex": "1F83E" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "191", "Dingbat hex": "BF", "Unicode dec": "129085", "Unicode hex": "1F83D" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "192", "Dingbat hex": "C0", "Unicode dec": "129087", "Unicode hex": "1F83F" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "193", "Dingbat hex": "C1", "Unicode dec": "129088", "Unicode hex": "1F840" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "194", "Dingbat hex": "C2", "Unicode dec": "129090", "Unicode hex": "1F842" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "195", "Dingbat hex": "C3", "Unicode dec": "129089", "Unicode hex": "1F841" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "196", "Dingbat hex": "C4", "Unicode dec": "129091", "Unicode hex": "1F843" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "197", "Dingbat hex": "C5", "Unicode dec": "129092", "Unicode hex": "1F844" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "198", "Dingbat hex": "C6", "Unicode dec": "129094", "Unicode hex": "1F846" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "199", "Dingbat hex": "C7", "Unicode dec": "129093", "Unicode hex": "1F845" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "200", "Dingbat hex": "C8", "Unicode dec": "129095", "Unicode hex": "1F847" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "201", "Dingbat hex": "C9", "Unicode dec": "11176", "Unicode hex": "2BA8" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "202", "Dingbat hex": "CA", "Unicode dec": "11177", "Unicode hex": "2BA9" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "203", "Dingbat hex": "CB", "Unicode dec": "11178", "Unicode hex": "2BAA" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "204", "Dingbat hex": "CC", "Unicode dec": "11179", "Unicode hex": "2BAB" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "205", "Dingbat hex": "CD", "Unicode dec": "11180", "Unicode hex": "2BAC" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "206", "Dingbat hex": "CE", "Unicode dec": "11181", "Unicode hex": "2BAD" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "207", "Dingbat hex": "CF", "Unicode dec": "11182", "Unicode hex": "2BAE" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "208", "Dingbat hex": "D0", "Unicode dec": "11183", "Unicode hex": "2BAF" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "209", "Dingbat hex": "D1", "Unicode dec": "129120", "Unicode hex": "1F860" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "210", "Dingbat hex": "D2", "Unicode dec": "129122", "Unicode hex": "1F862" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "211", "Dingbat hex": "D3", "Unicode dec": "129121", "Unicode hex": "1F861" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "212", "Dingbat hex": "D4", "Unicode dec": "129123", "Unicode hex": "1F863" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "213", "Dingbat hex": "D5", "Unicode dec": "129124", "Unicode hex": "1F864" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "214", "Dingbat hex": "D6", "Unicode dec": "129125", "Unicode hex": "1F865" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "215", "Dingbat hex": "D7", "Unicode dec": "129127", "Unicode hex": "1F867" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "216", "Dingbat hex": "D8", "Unicode dec": "129126", "Unicode hex": "1F866" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "217", "Dingbat hex": "D9", "Unicode dec": "129136", "Unicode hex": "1F870" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "218", "Dingbat hex": "DA", "Unicode dec": "129138", "Unicode hex": "1F872" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "219", "Dingbat hex": "DB", "Unicode dec": "129137", "Unicode hex": "1F871" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "220", "Dingbat hex": "DC", "Unicode dec": "129139", "Unicode hex": "1F873" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "221", "Dingbat hex": "DD", "Unicode dec": "129140", "Unicode hex": "1F874" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "222", "Dingbat hex": "DE", "Unicode dec": "129141", "Unicode hex": "1F875" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "223", "Dingbat hex": "DF", "Unicode dec": "129143", "Unicode hex": "1F877" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "224", "Dingbat hex": "E0", "Unicode dec": "129142", "Unicode hex": "1F876" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "225", "Dingbat hex": "E1", "Unicode dec": "129152", "Unicode hex": "1F880" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "226", "Dingbat hex": "E2", "Unicode dec": "129154", "Unicode hex": "1F882" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "227", "Dingbat hex": "E3", "Unicode dec": "129153", "Unicode hex": "1F881" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "228", "Dingbat hex": "E4", "Unicode dec": "129155", "Unicode hex": "1F883" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "229", "Dingbat hex": "E5", "Unicode dec": "129156", "Unicode hex": "1F884" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "230", "Dingbat hex": "E6", "Unicode dec": "129157", "Unicode hex": "1F885" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "231", "Dingbat hex": "E7", "Unicode dec": "129159", "Unicode hex": "1F887" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "232", "Dingbat hex": "E8", "Unicode dec": "129158", "Unicode hex": "1F886" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "233", "Dingbat hex": "E9", "Unicode dec": "129168", "Unicode hex": "1F890" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "234", "Dingbat hex": "EA", "Unicode dec": "129170", "Unicode hex": "1F892" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "235", "Dingbat hex": "EB", "Unicode dec": "129169", "Unicode hex": "1F891" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "236", "Dingbat hex": "EC", "Unicode dec": "129171", "Unicode hex": "1F893" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "237", "Dingbat hex": "ED", "Unicode dec": "129172", "Unicode hex": "1F894" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "238", "Dingbat hex": "EE", "Unicode dec": "129174", "Unicode hex": "1F896" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "239", "Dingbat hex": "EF", "Unicode dec": "129173", "Unicode hex": "1F895" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "240", "Dingbat hex": "F0", "Unicode dec": "129175", "Unicode hex": "1F897" }
    ];
    exports2.default = dingbats;
  }
});

// node_modules/dingbat-to-unicode/dist/index.js
var require_dist = __commonJS({
  "node_modules/dingbat-to-unicode/dist/index.js"(exports2) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hex = exports2.dec = exports2.codePoint = void 0;
    var dingbats_1 = __importDefault(require_dingbats());
    var dingbatsByCodePoint = {};
    var fromCodePoint = String.fromCodePoint ? String.fromCodePoint : fromCodePointPolyfill;
    for (_i3 = 0, dingbats_2 = dingbats_1.default; _i3 < dingbats_2.length; _i3++) {
      dingbat = dingbats_2[_i3];
      codePoint_1 = parseInt(dingbat["Unicode dec"], 10);
      scalarValue = {
        codePoint: codePoint_1,
        string: fromCodePoint(codePoint_1)
      };
      dingbatsByCodePoint[dingbat["Typeface name"].toUpperCase() + "_" + dingbat["Dingbat dec"]] = scalarValue;
    }
    var dingbat;
    var codePoint_1;
    var scalarValue;
    var _i3;
    var dingbats_2;
    function codePoint(typeface, codePoint2) {
      return dingbatsByCodePoint[typeface.toUpperCase() + "_" + codePoint2];
    }
    __name(codePoint, "codePoint");
    exports2.codePoint = codePoint;
    function dec(typeface, dec2) {
      return codePoint(typeface, parseInt(dec2, 10));
    }
    __name(dec, "dec");
    exports2.dec = dec;
    function hex(typeface, hex2) {
      return codePoint(typeface, parseInt(hex2, 16));
    }
    __name(hex, "hex");
    exports2.hex = hex;
    function fromCodePointPolyfill(codePoint2) {
      if (codePoint2 <= 65535) {
        return String.fromCharCode(codePoint2);
      } else {
        var highSurrogate = Math.floor((codePoint2 - 65536) / 1024) + 55296;
        var lowSurrogate = (codePoint2 - 65536) % 1024 + 56320;
        return String.fromCharCode(highSurrogate, lowSurrogate);
      }
    }
    __name(fromCodePointPolyfill, "fromCodePointPolyfill");
  }
});

// node_modules/mammoth/lib/transforms.js
var require_transforms = __commonJS({
  "node_modules/mammoth/lib/transforms.js"(exports2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var _2 = require_underscore_umd();
    exports2.paragraph = paragraph;
    exports2.run = run;
    exports2._elements = elements;
    exports2._elementsOfType = elementsOfType;
    exports2.getDescendantsOfType = getDescendantsOfType;
    exports2.getDescendants = getDescendants;
    function paragraph(transform) {
      return elementsOfType("paragraph", transform);
    }
    __name(paragraph, "paragraph");
    function run(transform) {
      return elementsOfType("run", transform);
    }
    __name(run, "run");
    function elementsOfType(elementType, transform) {
      return elements(function(element) {
        if (element.type === elementType) {
          return transform(element);
        } else {
          return element;
        }
      });
    }
    __name(elementsOfType, "elementsOfType");
    function elements(transform) {
      return /* @__PURE__ */ __name(function transformElement(element) {
        if (element.children) {
          var children = _2.map(element.children, transformElement);
          element = _2.extend(element, { children });
        }
        return transform(element);
      }, "transformElement");
    }
    __name(elements, "elements");
    function getDescendantsOfType(element, type) {
      return getDescendants(element).filter(function(descendant) {
        return descendant.type === type;
      });
    }
    __name(getDescendantsOfType, "getDescendantsOfType");
    function getDescendants(element) {
      var descendants = [];
      visitDescendants(element, function(descendant) {
        descendants.push(descendant);
      });
      return descendants;
    }
    __name(getDescendants, "getDescendants");
    function visitDescendants(element, visit) {
      if (element.children) {
        element.children.forEach(function(child) {
          visitDescendants(child, visit);
          visit(child);
        });
      }
    }
    __name(visitDescendants, "visitDescendants");
  }
});

// node_modules/mammoth/lib/docx/uris.js
var require_uris = __commonJS({
  "node_modules/mammoth/lib/docx/uris.js"(exports2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    exports2.uriToZipEntryName = uriToZipEntryName;
    exports2.replaceFragment = replaceFragment;
    function uriToZipEntryName(base, uri) {
      if (uri.charAt(0) === "/") {
        return uri.substr(1);
      } else {
        return base + "/" + uri;
      }
    }
    __name(uriToZipEntryName, "uriToZipEntryName");
    function replaceFragment(uri, fragment) {
      var hashIndex = uri.indexOf("#");
      if (hashIndex !== -1) {
        uri = uri.substring(0, hashIndex);
      }
      return uri + "#" + fragment;
    }
    __name(replaceFragment, "replaceFragment");
  }
});

// node_modules/mammoth/lib/docx/body-reader.js
var require_body_reader = __commonJS({
  "node_modules/mammoth/lib/docx/body-reader.js"(exports2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    exports2.createBodyReader = createBodyReader;
    exports2._readNumberingProperties = readNumberingProperties;
    var dingbatToUnicode = require_dist();
    var _2 = require_underscore_umd();
    var documents = require_documents();
    var Result = require_results().Result;
    var warning = require_results().warning;
    var xml = require_xml();
    var transforms = require_transforms();
    var uris = require_uris();
    function createBodyReader(options) {
      return {
        readXmlElement: function(element) {
          return new BodyReader(options).readXmlElement(element);
        },
        readXmlElements: function(elements) {
          return new BodyReader(options).readXmlElements(elements);
        }
      };
    }
    __name(createBodyReader, "createBodyReader");
    function BodyReader(options) {
      var complexFieldStack = [];
      var currentInstrText = [];
      var deletedParagraphContents = [];
      var relationships = options.relationships;
      var contentTypes = options.contentTypes;
      var docxFile = options.docxFile;
      var files = options.files;
      var numbering = options.numbering;
      var styles = options.styles;
      function readXmlElements(elements) {
        var results = elements.map(readXmlElement);
        return combineResults(results);
      }
      __name(readXmlElements, "readXmlElements");
      function readXmlElement(element) {
        if (element.type === "element") {
          var handler = xmlElementReaders[element.name];
          if (handler) {
            return handler(element);
          } else if (!Object.prototype.hasOwnProperty.call(ignoreElements, element.name)) {
            var message = warning("An unrecognised element was ignored: " + element.name);
            return emptyResultWithMessages([message]);
          }
        }
        return emptyResult();
      }
      __name(readXmlElement, "readXmlElement");
      function readParagraphProperties(element) {
        return readParagraphStyle(element).map(function(style) {
          return {
            type: "paragraphProperties",
            styleId: style.styleId,
            styleName: style.name,
            alignment: element.firstOrEmpty("w:jc").attributes["w:val"],
            numbering: readNumberingProperties(style.styleId, element.firstOrEmpty("w:numPr"), numbering),
            indent: readParagraphIndent(element.firstOrEmpty("w:ind"))
          };
        });
      }
      __name(readParagraphProperties, "readParagraphProperties");
      function readParagraphIndent(element) {
        return {
          start: element.attributes["w:start"] || element.attributes["w:left"],
          end: element.attributes["w:end"] || element.attributes["w:right"],
          firstLine: element.attributes["w:firstLine"],
          hanging: element.attributes["w:hanging"]
        };
      }
      __name(readParagraphIndent, "readParagraphIndent");
      function readRunProperties(element) {
        return readRunStyle(element).map(function(style) {
          var fontSizeString = element.firstOrEmpty("w:sz").attributes["w:val"];
          var fontSize = /^[0-9]+$/.test(fontSizeString) ? parseInt(fontSizeString, 10) / 2 : null;
          return {
            type: "runProperties",
            styleId: style.styleId,
            styleName: style.name,
            verticalAlignment: element.firstOrEmpty("w:vertAlign").attributes["w:val"],
            font: element.firstOrEmpty("w:rFonts").attributes["w:ascii"],
            fontSize,
            isBold: readBooleanElement(element.first("w:b")),
            isUnderline: readUnderline(element.first("w:u")),
            isItalic: readBooleanElement(element.first("w:i")),
            isStrikethrough: readBooleanElement(element.first("w:strike")),
            isAllCaps: readBooleanElement(element.first("w:caps")),
            isSmallCaps: readBooleanElement(element.first("w:smallCaps")),
            highlight: readHighlightValue(element.firstOrEmpty("w:highlight").attributes["w:val"])
          };
        });
      }
      __name(readRunProperties, "readRunProperties");
      function readUnderline(element) {
        if (element) {
          var value = element.attributes["w:val"];
          return value !== void 0 && value !== "false" && value !== "0" && value !== "none";
        } else {
          return false;
        }
      }
      __name(readUnderline, "readUnderline");
      function readBooleanElement(element) {
        if (element) {
          var value = element.attributes["w:val"];
          return value !== "false" && value !== "0";
        } else {
          return false;
        }
      }
      __name(readBooleanElement, "readBooleanElement");
      function readBooleanAttributeValue(value) {
        return value !== "false" && value !== "0";
      }
      __name(readBooleanAttributeValue, "readBooleanAttributeValue");
      function readHighlightValue(value) {
        if (!value || value === "none") {
          return null;
        } else {
          return value;
        }
      }
      __name(readHighlightValue, "readHighlightValue");
      function readParagraphStyle(element) {
        return readStyle(element, "w:pStyle", "Paragraph", styles.findParagraphStyleById);
      }
      __name(readParagraphStyle, "readParagraphStyle");
      function readRunStyle(element) {
        return readStyle(element, "w:rStyle", "Run", styles.findCharacterStyleById);
      }
      __name(readRunStyle, "readRunStyle");
      function readTableStyle(element) {
        return readStyle(element, "w:tblStyle", "Table", styles.findTableStyleById);
      }
      __name(readTableStyle, "readTableStyle");
      function readStyle(element, styleTagName, styleType, findStyleById) {
        var messages = [];
        var styleElement = element.first(styleTagName);
        var styleId = null;
        var name = null;
        if (styleElement) {
          styleId = styleElement.attributes["w:val"];
          if (styleId) {
            var style = findStyleById(styleId);
            if (style) {
              name = style.name;
            } else {
              messages.push(undefinedStyleWarning(styleType, styleId));
            }
          }
        }
        return elementResultWithMessages({ styleId, name }, messages);
      }
      __name(readStyle, "readStyle");
      function readFldChar(element) {
        var type = element.attributes["w:fldCharType"];
        if (type === "begin") {
          complexFieldStack.push({ type: "begin", fldChar: element });
          currentInstrText = [];
        } else if (type === "end") {
          var complexFieldEnd = complexFieldStack.pop();
          if (complexFieldEnd.type === "begin") {
            complexFieldEnd = parseCurrentInstrText(complexFieldEnd);
          }
          if (complexFieldEnd.type === "checkbox") {
            return elementResult(documents.checkbox({
              checked: complexFieldEnd.checked
            }));
          }
        } else if (type === "separate") {
          var complexFieldSeparate = complexFieldStack.pop();
          var complexField = parseCurrentInstrText(complexFieldSeparate);
          complexFieldStack.push(complexField);
        }
        return emptyResult();
      }
      __name(readFldChar, "readFldChar");
      function currentHyperlinkOptions() {
        var topHyperlink = _2.last(complexFieldStack.filter(function(complexField) {
          return complexField.type === "hyperlink";
        }));
        return topHyperlink ? topHyperlink.options : null;
      }
      __name(currentHyperlinkOptions, "currentHyperlinkOptions");
      function parseCurrentInstrText(complexField) {
        return parseInstrText(
          currentInstrText.join(""),
          complexField.type === "begin" ? complexField.fldChar : xml.emptyElement
        );
      }
      __name(parseCurrentInstrText, "parseCurrentInstrText");
      function parseInstrText(instrText, fldChar) {
        var externalLinkResult = /\s*HYPERLINK "(.*)"/.exec(instrText);
        if (externalLinkResult) {
          return { type: "hyperlink", options: { href: externalLinkResult[1] } };
        }
        var internalLinkResult = /\s*HYPERLINK\s+\\l\s+"(.*)"/.exec(instrText);
        if (internalLinkResult) {
          return { type: "hyperlink", options: { anchor: internalLinkResult[1] } };
        }
        var checkboxResult = /\s*FORMCHECKBOX\s*/.exec(instrText);
        if (checkboxResult) {
          var checkboxElement = fldChar.firstOrEmpty("w:ffData").firstOrEmpty("w:checkBox");
          var checkedElement = checkboxElement.first("w:checked");
          var checked = checkedElement == null ? readBooleanElement(checkboxElement.first("w:default")) : readBooleanElement(checkedElement);
          return { type: "checkbox", checked };
        }
        return { type: "unknown" };
      }
      __name(parseInstrText, "parseInstrText");
      function readInstrText(element) {
        currentInstrText.push(element.text());
        return emptyResult();
      }
      __name(readInstrText, "readInstrText");
      function readSymbol(element) {
        var font = element.attributes["w:font"];
        var char = element.attributes["w:char"];
        var unicodeCharacter = dingbatToUnicode.hex(font, char);
        if (unicodeCharacter == null && /^F0..$/.test(char)) {
          unicodeCharacter = dingbatToUnicode.hex(font, char.substring(2));
        }
        if (unicodeCharacter == null) {
          return emptyResultWithMessages([warning(
            "A w:sym element with an unsupported character was ignored: char " + char + " in font " + font
          )]);
        } else {
          return elementResult(new documents.Text(unicodeCharacter.string));
        }
      }
      __name(readSymbol, "readSymbol");
      function noteReferenceReader(noteType) {
        return function(element) {
          var noteId = element.attributes["w:id"];
          return elementResult(new documents.NoteReference({
            noteType,
            noteId
          }));
        };
      }
      __name(noteReferenceReader, "noteReferenceReader");
      function readCommentReference(element) {
        return elementResult(documents.commentReference({
          commentId: element.attributes["w:id"]
        }));
      }
      __name(readCommentReference, "readCommentReference");
      function readChildElements(element) {
        return readXmlElements(element.children);
      }
      __name(readChildElements, "readChildElements");
      var xmlElementReaders = {
        "w:p": function(element) {
          var paragraphPropertiesElement = element.firstOrEmpty("w:pPr");
          var isDeleted = !!paragraphPropertiesElement.firstOrEmpty("w:rPr").first("w:del");
          if (isDeleted) {
            element.children.forEach(function(child) {
              deletedParagraphContents.push(child);
            });
            return emptyResult();
          } else {
            var childrenXml = element.children;
            if (deletedParagraphContents.length > 0) {
              childrenXml = deletedParagraphContents.concat(childrenXml);
              deletedParagraphContents = [];
            }
            return ReadResult.map(
              readParagraphProperties(paragraphPropertiesElement),
              readXmlElements(childrenXml),
              function(properties, children) {
                return new documents.Paragraph(children, properties);
              }
            ).insertExtra();
          }
        },
        "w:r": function(element) {
          return ReadResult.map(
            readRunProperties(element.firstOrEmpty("w:rPr")),
            readXmlElements(element.children),
            function(properties, children) {
              var hyperlinkOptions = currentHyperlinkOptions();
              if (hyperlinkOptions !== null) {
                children = [new documents.Hyperlink(children, hyperlinkOptions)];
              }
              return new documents.Run(children, properties);
            }
          );
        },
        "w:fldChar": readFldChar,
        "w:instrText": readInstrText,
        "w:t": function(element) {
          return elementResult(new documents.Text(element.text()));
        },
        "w:tab": function(element) {
          return elementResult(new documents.Tab());
        },
        "w:noBreakHyphen": function() {
          return elementResult(new documents.Text("\u2011"));
        },
        "w:softHyphen": function(element) {
          return elementResult(new documents.Text("\xAD"));
        },
        "w:sym": readSymbol,
        "w:hyperlink": function(element) {
          var relationshipId = element.attributes["r:id"];
          var anchor = element.attributes["w:anchor"];
          return readXmlElements(element.children).map(function(children) {
            function create(options2) {
              var targetFrame = element.attributes["w:tgtFrame"] || null;
              return new documents.Hyperlink(
                children,
                _2.extend({ targetFrame }, options2)
              );
            }
            __name(create, "create");
            if (relationshipId) {
              var href = relationships.findTargetByRelationshipId(relationshipId);
              if (anchor) {
                href = uris.replaceFragment(href, anchor);
              }
              return create({ href });
            } else if (anchor) {
              return create({ anchor });
            } else {
              return children;
            }
          });
        },
        "w:tbl": readTable,
        "w:tr": readTableRow,
        "w:tc": readTableCell,
        "w:footnoteReference": noteReferenceReader("footnote"),
        "w:endnoteReference": noteReferenceReader("endnote"),
        "w:commentReference": readCommentReference,
        "w:br": function(element) {
          var breakType = element.attributes["w:type"];
          if (breakType == null || breakType === "textWrapping") {
            return elementResult(documents.lineBreak);
          } else if (breakType === "page") {
            return elementResult(documents.pageBreak);
          } else if (breakType === "column") {
            return elementResult(documents.columnBreak);
          } else {
            return emptyResultWithMessages([warning("Unsupported break type: " + breakType)]);
          }
        },
        "w:bookmarkStart": function(element) {
          var name = element.attributes["w:name"];
          if (name === "_GoBack") {
            return emptyResult();
          } else {
            return elementResult(new documents.BookmarkStart({ name }));
          }
        },
        "mc:AlternateContent": function(element) {
          return readChildElements(element.firstOrEmpty("mc:Fallback"));
        },
        "w:sdt": function(element) {
          var contentResult = readXmlElements(element.firstOrEmpty("w:sdtContent").children);
          return contentResult.map(function(content) {
            var checkbox = element.firstOrEmpty("w:sdtPr").first("wordml:checkbox");
            if (checkbox) {
              var checkedElement = checkbox.first("wordml:checked");
              var isChecked = !!checkedElement && readBooleanAttributeValue(
                checkedElement.attributes["wordml:val"]
              );
              var documentCheckbox = documents.checkbox({
                checked: isChecked
              });
              var hasCheckbox = false;
              var replacedContent = content.map(transforms._elementsOfType(
                documents.types.text,
                function(text) {
                  if (text.value.length > 0 && !hasCheckbox) {
                    hasCheckbox = true;
                    return documentCheckbox;
                  } else {
                    return text;
                  }
                }
              ));
              if (hasCheckbox) {
                return replacedContent;
              } else {
                return documentCheckbox;
              }
            } else {
              return content;
            }
          });
        },
        "w:ins": readChildElements,
        "w:object": readChildElements,
        "w:smartTag": readChildElements,
        "w:drawing": readChildElements,
        "w:pict": function(element) {
          return readChildElements(element).toExtra();
        },
        "v:roundrect": readChildElements,
        "v:shape": readChildElements,
        "v:textbox": readChildElements,
        "w:txbxContent": readChildElements,
        "wp:inline": readDrawingElement,
        "wp:anchor": readDrawingElement,
        "v:imagedata": readImageData,
        "v:group": readChildElements,
        "v:rect": readChildElements
      };
      return {
        readXmlElement,
        readXmlElements
      };
      function readTable(element) {
        var propertiesResult = readTableProperties(element.firstOrEmpty("w:tblPr"));
        return readXmlElements(element.children).flatMap(calculateRowSpans).flatMap(function(children) {
          return propertiesResult.map(function(properties) {
            return documents.Table(children, properties);
          });
        });
      }
      __name(readTable, "readTable");
      function readTableProperties(element) {
        return readTableStyle(element).map(function(style) {
          return {
            styleId: style.styleId,
            styleName: style.name
          };
        });
      }
      __name(readTableProperties, "readTableProperties");
      function readTableRow(element) {
        var properties = element.firstOrEmpty("w:trPr");
        var isDeleted = !!properties.first("w:del");
        if (isDeleted) {
          return emptyResult();
        }
        var isHeader = !!properties.first("w:tblHeader");
        return readXmlElements(element.children).map(function(children) {
          return documents.TableRow(children, { isHeader });
        });
      }
      __name(readTableRow, "readTableRow");
      function readTableCell(element) {
        return readXmlElements(element.children).map(function(children) {
          var properties = element.firstOrEmpty("w:tcPr");
          var gridSpan = properties.firstOrEmpty("w:gridSpan").attributes["w:val"];
          var colSpan = gridSpan ? parseInt(gridSpan, 10) : 1;
          var cell = documents.TableCell(children, { colSpan });
          cell._vMerge = readVMerge(properties);
          return cell;
        });
      }
      __name(readTableCell, "readTableCell");
      function readVMerge(properties) {
        var element = properties.first("w:vMerge");
        if (element) {
          var val = element.attributes["w:val"];
          return val === "continue" || !val;
        } else {
          return null;
        }
      }
      __name(readVMerge, "readVMerge");
      function calculateRowSpans(rows) {
        var unexpectedNonRows = _2.any(rows, function(row) {
          return row.type !== documents.types.tableRow;
        });
        if (unexpectedNonRows) {
          removeVMergeProperties(rows);
          return elementResultWithMessages(rows, [warning(
            "unexpected non-row element in table, cell merging may be incorrect"
          )]);
        }
        var unexpectedNonCells = _2.any(rows, function(row) {
          return _2.any(row.children, function(cell) {
            return cell.type !== documents.types.tableCell;
          });
        });
        if (unexpectedNonCells) {
          removeVMergeProperties(rows);
          return elementResultWithMessages(rows, [warning(
            "unexpected non-cell element in table row, cell merging may be incorrect"
          )]);
        }
        var columns = {};
        rows.forEach(function(row) {
          var cellIndex = 0;
          row.children.forEach(function(cell) {
            if (cell._vMerge && columns[cellIndex]) {
              columns[cellIndex].rowSpan++;
            } else {
              columns[cellIndex] = cell;
              cell._vMerge = false;
            }
            cellIndex += cell.colSpan;
          });
        });
        rows.forEach(function(row) {
          row.children = row.children.filter(function(cell) {
            return !cell._vMerge;
          });
          row.children.forEach(function(cell) {
            delete cell._vMerge;
          });
        });
        return elementResult(rows);
      }
      __name(calculateRowSpans, "calculateRowSpans");
      function removeVMergeProperties(rows) {
        rows.forEach(function(row) {
          var cells = transforms.getDescendantsOfType(row, documents.types.tableCell);
          cells.forEach(function(cell) {
            delete cell._vMerge;
          });
        });
      }
      __name(removeVMergeProperties, "removeVMergeProperties");
      function readDrawingElement(element) {
        var blips = element.getElementsByTagName("a:graphic").getElementsByTagName("a:graphicData").getElementsByTagName("pic:pic").getElementsByTagName("pic:blipFill").getElementsByTagName("a:blip");
        return combineResults(blips.map(readBlip.bind(null, element)));
      }
      __name(readDrawingElement, "readDrawingElement");
      function readBlip(element, blip) {
        var properties = element.first("wp:docPr").attributes;
        var altText = isBlank(properties.descr) ? properties.title : properties.descr;
        var blipImageFile = findBlipImageFile(blip);
        if (blipImageFile === null) {
          return emptyResultWithMessages([warning("Could not find image file for a:blip element")]);
        } else {
          return readImage(blipImageFile, altText);
        }
      }
      __name(readBlip, "readBlip");
      function isBlank(value) {
        return value == null || /^\s*$/.test(value);
      }
      __name(isBlank, "isBlank");
      function findBlipImageFile(blip) {
        var embedRelationshipId = blip.attributes["r:embed"];
        var linkRelationshipId = blip.attributes["r:link"];
        if (embedRelationshipId) {
          return findEmbeddedImageFile(embedRelationshipId);
        } else if (linkRelationshipId) {
          var imagePath = relationships.findTargetByRelationshipId(linkRelationshipId);
          return {
            path: imagePath,
            read: files.read.bind(files, imagePath)
          };
        } else {
          return null;
        }
      }
      __name(findBlipImageFile, "findBlipImageFile");
      function readImageData(element) {
        var relationshipId = element.attributes["r:id"];
        if (relationshipId) {
          return readImage(
            findEmbeddedImageFile(relationshipId),
            element.attributes["o:title"]
          );
        } else {
          return emptyResultWithMessages([warning("A v:imagedata element without a relationship ID was ignored")]);
        }
      }
      __name(readImageData, "readImageData");
      function findEmbeddedImageFile(relationshipId) {
        var path = uris.uriToZipEntryName("word", relationships.findTargetByRelationshipId(relationshipId));
        return {
          path,
          read: docxFile.read.bind(docxFile, path)
        };
      }
      __name(findEmbeddedImageFile, "findEmbeddedImageFile");
      function readImage(imageFile, altText) {
        var contentType = contentTypes.findContentType(imageFile.path);
        var image = documents.Image({
          readImage: imageFile.read,
          altText,
          contentType
        });
        var warnings = supportedImageTypes[contentType] ? [] : warning("Image of type " + contentType + " is unlikely to display in web browsers");
        return elementResultWithMessages(image, warnings);
      }
      __name(readImage, "readImage");
      function undefinedStyleWarning(type, styleId) {
        return warning(
          type + " style with ID " + styleId + " was referenced but not defined in the document"
        );
      }
      __name(undefinedStyleWarning, "undefinedStyleWarning");
    }
    __name(BodyReader, "BodyReader");
    function readNumberingProperties(styleId, element, numbering) {
      var level = element.firstOrEmpty("w:ilvl").attributes["w:val"];
      var numId = element.firstOrEmpty("w:numId").attributes["w:val"];
      if (level !== void 0 && numId !== void 0) {
        return numbering.findLevel(numId, level);
      }
      if (styleId != null) {
        var levelByStyleId = numbering.findLevelByParagraphStyleId(styleId);
        if (levelByStyleId != null) {
          return levelByStyleId;
        }
      }
      if (numId !== void 0) {
        return numbering.findLevel(numId, "0");
      }
      return null;
    }
    __name(readNumberingProperties, "readNumberingProperties");
    var supportedImageTypes = {
      "image/png": true,
      "image/gif": true,
      "image/jpeg": true,
      "image/svg+xml": true,
      "image/tiff": true
    };
    var ignoreElements = {
      "office-word:wrap": true,
      "v:shadow": true,
      "v:shapetype": true,
      "w:annotationRef": true,
      "w:bookmarkEnd": true,
      "w:sectPr": true,
      "w:proofErr": true,
      "w:lastRenderedPageBreak": true,
      "w:commentRangeStart": true,
      "w:commentRangeEnd": true,
      "w:del": true,
      "w:footnoteRef": true,
      "w:endnoteRef": true,
      "w:pPr": true,
      "w:rPr": true,
      "w:tblPr": true,
      "w:tblGrid": true,
      "w:trPr": true,
      "w:tcPr": true
    };
    function emptyResultWithMessages(messages) {
      return new ReadResult(null, null, messages);
    }
    __name(emptyResultWithMessages, "emptyResultWithMessages");
    function emptyResult() {
      return new ReadResult(null);
    }
    __name(emptyResult, "emptyResult");
    function elementResult(element) {
      return new ReadResult(element);
    }
    __name(elementResult, "elementResult");
    function elementResultWithMessages(element, messages) {
      return new ReadResult(element, null, messages);
    }
    __name(elementResultWithMessages, "elementResultWithMessages");
    function ReadResult(element, extra, messages) {
      this.value = element || [];
      this.extra = extra || [];
      this._result = new Result({
        element: this.value,
        extra
      }, messages);
      this.messages = this._result.messages;
    }
    __name(ReadResult, "ReadResult");
    ReadResult.prototype.toExtra = function() {
      return new ReadResult(null, joinElements(this.extra, this.value), this.messages);
    };
    ReadResult.prototype.insertExtra = function() {
      var extra = this.extra;
      if (extra && extra.length) {
        return new ReadResult(joinElements(this.value, extra), null, this.messages);
      } else {
        return this;
      }
    };
    ReadResult.prototype.map = function(func) {
      var result = this._result.map(function(value) {
        return func(value.element);
      });
      return new ReadResult(result.value, this.extra, result.messages);
    };
    ReadResult.prototype.flatMap = function(func) {
      var result = this._result.flatMap(function(value) {
        return func(value.element)._result;
      });
      return new ReadResult(result.value.element, joinElements(this.extra, result.value.extra), result.messages);
    };
    ReadResult.map = function(first, second, func) {
      return new ReadResult(
        func(first.value, second.value),
        joinElements(first.extra, second.extra),
        first.messages.concat(second.messages)
      );
    };
    function combineResults(results) {
      var result = Result.combine(_2.pluck(results, "_result"));
      return new ReadResult(
        _2.flatten(_2.pluck(result.value, "element")),
        _2.filter(_2.flatten(_2.pluck(result.value, "extra")), identity),
        result.messages
      );
    }
    __name(combineResults, "combineResults");
    function joinElements(first, second) {
      return _2.flatten([first, second]);
    }
    __name(joinElements, "joinElements");
    function identity(value) {
      return value;
    }
    __name(identity, "identity");
  }
});

// node_modules/mammoth/lib/docx/document-xml-reader.js
var require_document_xml_reader = __commonJS({
  "node_modules/mammoth/lib/docx/document-xml-reader.js"(exports2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    exports2.DocumentXmlReader = DocumentXmlReader;
    var documents = require_documents();
    var Result = require_results().Result;
    function DocumentXmlReader(options) {
      var bodyReader = options.bodyReader;
      function convertXmlToDocument(element) {
        var body = element.first("w:body");
        if (body == null) {
          throw new Error("Could not find the body element: are you sure this is a docx file?");
        }
        var result = bodyReader.readXmlElements(body.children).map(function(children) {
          return new documents.Document(children, {
            notes: options.notes,
            comments: options.comments
          });
        });
        return new Result(result.value, result.messages);
      }
      __name(convertXmlToDocument, "convertXmlToDocument");
      return {
        convertXmlToDocument
      };
    }
    __name(DocumentXmlReader, "DocumentXmlReader");
  }
});

// node_modules/mammoth/lib/docx/relationships-reader.js
var require_relationships_reader = __commonJS({
  "node_modules/mammoth/lib/docx/relationships-reader.js"(exports2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    exports2.readRelationships = readRelationships;
    exports2.defaultValue = new Relationships([]);
    exports2.Relationships = Relationships;
    function readRelationships(element) {
      var relationships = [];
      element.children.forEach(function(child) {
        if (child.name === "relationships:Relationship") {
          var relationship = {
            relationshipId: child.attributes.Id,
            target: child.attributes.Target,
            type: child.attributes.Type
          };
          relationships.push(relationship);
        }
      });
      return new Relationships(relationships);
    }
    __name(readRelationships, "readRelationships");
    function Relationships(relationships) {
      var targetsByRelationshipId = {};
      relationships.forEach(function(relationship) {
        targetsByRelationshipId[relationship.relationshipId] = relationship.target;
      });
      var targetsByType = {};
      relationships.forEach(function(relationship) {
        if (!targetsByType[relationship.type]) {
          targetsByType[relationship.type] = [];
        }
        targetsByType[relationship.type].push(relationship.target);
      });
      return {
        findTargetByRelationshipId: function(relationshipId) {
          return targetsByRelationshipId[relationshipId];
        },
        findTargetsByType: function(type) {
          return targetsByType[type] || [];
        }
      };
    }
    __name(Relationships, "Relationships");
  }
});

// node_modules/mammoth/lib/docx/content-types-reader.js
var require_content_types_reader = __commonJS({
  "node_modules/mammoth/lib/docx/content-types-reader.js"(exports2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    exports2.readContentTypesFromXml = readContentTypesFromXml;
    var fallbackContentTypes = {
      "png": "png",
      "gif": "gif",
      "jpeg": "jpeg",
      "jpg": "jpeg",
      "tif": "tiff",
      "tiff": "tiff",
      "bmp": "bmp"
    };
    exports2.defaultContentTypes = contentTypes({}, {});
    function readContentTypesFromXml(element) {
      var extensionDefaults = {};
      var overrides = {};
      element.children.forEach(function(child) {
        if (child.name === "content-types:Default") {
          extensionDefaults[child.attributes.Extension] = child.attributes.ContentType;
        }
        if (child.name === "content-types:Override") {
          var name = child.attributes.PartName;
          if (name.charAt(0) === "/") {
            name = name.substring(1);
          }
          overrides[name] = child.attributes.ContentType;
        }
      });
      return contentTypes(overrides, extensionDefaults);
    }
    __name(readContentTypesFromXml, "readContentTypesFromXml");
    function contentTypes(overrides, extensionDefaults) {
      return {
        findContentType: function(path) {
          var overrideContentType = overrides[path];
          if (overrideContentType) {
            return overrideContentType;
          } else {
            var pathParts = path.split(".");
            var extension = pathParts[pathParts.length - 1];
            if (extensionDefaults.hasOwnProperty(extension)) {
              return extensionDefaults[extension];
            } else {
              var fallback = fallbackContentTypes[extension.toLowerCase()];
              if (fallback) {
                return "image/" + fallback;
              } else {
                return null;
              }
            }
          }
        }
      };
    }
    __name(contentTypes, "contentTypes");
  }
});

// node_modules/mammoth/lib/docx/numbering-xml.js
var require_numbering_xml = __commonJS({
  "node_modules/mammoth/lib/docx/numbering-xml.js"(exports2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var _2 = require_underscore_umd();
    exports2.readNumberingXml = readNumberingXml;
    exports2.Numbering = Numbering;
    exports2.defaultNumbering = new Numbering({}, {});
    function Numbering(nums, abstractNums, styles) {
      var allLevels = _2.flatten(_2.values(abstractNums).map(function(abstractNum) {
        return _2.values(abstractNum.levels);
      }));
      var levelsByParagraphStyleId = _2.indexBy(
        allLevels.filter(function(level) {
          return level.paragraphStyleId != null;
        }),
        "paragraphStyleId"
      );
      function findLevel(numId, level) {
        var num = nums[numId];
        if (num) {
          var abstractNum = abstractNums[num.abstractNumId];
          if (!abstractNum) {
            return null;
          } else if (abstractNum.numStyleLink == null) {
            return abstractNums[num.abstractNumId].levels[level];
          } else {
            var style = styles.findNumberingStyleById(abstractNum.numStyleLink);
            return findLevel(style.numId, level);
          }
        } else {
          return null;
        }
      }
      __name(findLevel, "findLevel");
      function findLevelByParagraphStyleId(styleId) {
        return levelsByParagraphStyleId[styleId] || null;
      }
      __name(findLevelByParagraphStyleId, "findLevelByParagraphStyleId");
      return {
        findLevel,
        findLevelByParagraphStyleId
      };
    }
    __name(Numbering, "Numbering");
    function readNumberingXml(root, options) {
      if (!options || !options.styles) {
        throw new Error("styles is missing");
      }
      var abstractNums = readAbstractNums(root);
      var nums = readNums(root, abstractNums);
      return new Numbering(nums, abstractNums, options.styles);
    }
    __name(readNumberingXml, "readNumberingXml");
    function readAbstractNums(root) {
      var abstractNums = {};
      root.getElementsByTagName("w:abstractNum").forEach(function(element) {
        var id = element.attributes["w:abstractNumId"];
        abstractNums[id] = readAbstractNum(element);
      });
      return abstractNums;
    }
    __name(readAbstractNums, "readAbstractNums");
    function readAbstractNum(element) {
      var levels = {};
      var levelWithoutIndex = null;
      element.getElementsByTagName("w:lvl").forEach(function(levelElement) {
        var levelIndex = levelElement.attributes["w:ilvl"];
        var numFmt = levelElement.firstOrEmpty("w:numFmt").attributes["w:val"];
        var isOrdered = numFmt !== "bullet";
        var paragraphStyleId = levelElement.firstOrEmpty("w:pStyle").attributes["w:val"];
        if (levelIndex === void 0) {
          levelWithoutIndex = {
            isOrdered,
            level: "0",
            paragraphStyleId
          };
        } else {
          levels[levelIndex] = {
            isOrdered,
            level: levelIndex,
            paragraphStyleId
          };
        }
      });
      if (levelWithoutIndex !== null && levels[levelWithoutIndex.level] === void 0) {
        levels[levelWithoutIndex.level] = levelWithoutIndex;
      }
      var numStyleLink = element.firstOrEmpty("w:numStyleLink").attributes["w:val"];
      return { levels, numStyleLink };
    }
    __name(readAbstractNum, "readAbstractNum");
    function readNums(root) {
      var nums = {};
      root.getElementsByTagName("w:num").forEach(function(element) {
        var numId = element.attributes["w:numId"];
        var abstractNumId = element.first("w:abstractNumId").attributes["w:val"];
        nums[numId] = { abstractNumId };
      });
      return nums;
    }
    __name(readNums, "readNums");
  }
});

// node_modules/mammoth/lib/docx/styles-reader.js
var require_styles_reader = __commonJS({
  "node_modules/mammoth/lib/docx/styles-reader.js"(exports2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    exports2.readStylesXml = readStylesXml;
    exports2.Styles = Styles;
    exports2.defaultStyles = new Styles({}, {});
    function Styles(paragraphStyles, characterStyles, tableStyles, numberingStyles) {
      return {
        findParagraphStyleById: function(styleId) {
          return paragraphStyles[styleId];
        },
        findCharacterStyleById: function(styleId) {
          return characterStyles[styleId];
        },
        findTableStyleById: function(styleId) {
          return tableStyles[styleId];
        },
        findNumberingStyleById: function(styleId) {
          return numberingStyles[styleId];
        }
      };
    }
    __name(Styles, "Styles");
    Styles.EMPTY = new Styles({}, {}, {}, {});
    function readStylesXml(root) {
      var paragraphStyles = {};
      var characterStyles = {};
      var tableStyles = {};
      var numberingStyles = {};
      var styles = {
        "paragraph": paragraphStyles,
        "character": characterStyles,
        "table": tableStyles,
        "numbering": numberingStyles
      };
      root.getElementsByTagName("w:style").forEach(function(styleElement) {
        var style = readStyleElement(styleElement);
        var styleSet = styles[style.type];
        if (styleSet && styleSet[style.styleId] === void 0) {
          styleSet[style.styleId] = style;
        }
      });
      return new Styles(paragraphStyles, characterStyles, tableStyles, numberingStyles);
    }
    __name(readStylesXml, "readStylesXml");
    function readStyleElement(styleElement) {
      var type = styleElement.attributes["w:type"];
      if (type === "numbering") {
        return readNumberingStyleElement(type, styleElement);
      } else {
        var styleId = readStyleId(styleElement);
        var name = styleName(styleElement);
        return { type, styleId, name };
      }
    }
    __name(readStyleElement, "readStyleElement");
    function styleName(styleElement) {
      var nameElement = styleElement.first("w:name");
      return nameElement ? nameElement.attributes["w:val"] : null;
    }
    __name(styleName, "styleName");
    function readNumberingStyleElement(type, styleElement) {
      var styleId = readStyleId(styleElement);
      var numId = styleElement.firstOrEmpty("w:pPr").firstOrEmpty("w:numPr").firstOrEmpty("w:numId").attributes["w:val"];
      return { type, numId, styleId };
    }
    __name(readNumberingStyleElement, "readNumberingStyleElement");
    function readStyleId(styleElement) {
      return styleElement.attributes["w:styleId"];
    }
    __name(readStyleId, "readStyleId");
  }
});

// node_modules/mammoth/lib/docx/notes-reader.js
var require_notes_reader = __commonJS({
  "node_modules/mammoth/lib/docx/notes-reader.js"(exports2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var documents = require_documents();
    var Result = require_results().Result;
    exports2.createFootnotesReader = createReader.bind(exports2, "footnote");
    exports2.createEndnotesReader = createReader.bind(exports2, "endnote");
    function createReader(noteType, bodyReader) {
      function readNotesXml(element) {
        return Result.combine(element.getElementsByTagName("w:" + noteType).filter(isFootnoteElement).map(readFootnoteElement));
      }
      __name(readNotesXml, "readNotesXml");
      function isFootnoteElement(element) {
        var type = element.attributes["w:type"];
        return type !== "continuationSeparator" && type !== "separator";
      }
      __name(isFootnoteElement, "isFootnoteElement");
      function readFootnoteElement(footnoteElement) {
        var id = footnoteElement.attributes["w:id"];
        return bodyReader.readXmlElements(footnoteElement.children).map(function(body) {
          return documents.Note({ noteType, noteId: id, body });
        });
      }
      __name(readFootnoteElement, "readFootnoteElement");
      return readNotesXml;
    }
    __name(createReader, "createReader");
  }
});

// node_modules/mammoth/lib/docx/comments-reader.js
var require_comments_reader = __commonJS({
  "node_modules/mammoth/lib/docx/comments-reader.js"(exports2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var documents = require_documents();
    var Result = require_results().Result;
    function createCommentsReader(bodyReader) {
      function readCommentsXml(element) {
        return Result.combine(element.getElementsByTagName("w:comment").map(readCommentElement));
      }
      __name(readCommentsXml, "readCommentsXml");
      function readCommentElement(element) {
        var id = element.attributes["w:id"];
        function readOptionalAttribute(name) {
          return (element.attributes[name] || "").trim() || null;
        }
        __name(readOptionalAttribute, "readOptionalAttribute");
        return bodyReader.readXmlElements(element.children).map(function(body) {
          return documents.comment({
            commentId: id,
            body,
            authorName: readOptionalAttribute("w:author"),
            authorInitials: readOptionalAttribute("w:initials")
          });
        });
      }
      __name(readCommentElement, "readCommentElement");
      return readCommentsXml;
    }
    __name(createCommentsReader, "createCommentsReader");
    exports2.createCommentsReader = createCommentsReader;
  }
});

// node_modules/mammoth/browser/docx/files.js
var require_files = __commonJS({
  "node_modules/mammoth/browser/docx/files.js"(exports2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var promises = require_promises();
    exports2.Files = Files;
    function Files() {
      function read(uri) {
        return promises.reject(new Error("could not open external image: '" + uri + "'\ncannot open linked files from a web browser"));
      }
      __name(read, "read");
      return {
        read
      };
    }
    __name(Files, "Files");
  }
});

// node_modules/mammoth/lib/docx/docx-reader.js
var require_docx_reader = __commonJS({
  "node_modules/mammoth/lib/docx/docx-reader.js"(exports2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    exports2.read = read;
    exports2._findPartPaths = findPartPaths;
    var promises = require_promises();
    var documents = require_documents();
    var Result = require_results().Result;
    var zipfile = require_zipfile();
    var readXmlFromZipFile = require_office_xml_reader().readXmlFromZipFile;
    var createBodyReader = require_body_reader().createBodyReader;
    var DocumentXmlReader = require_document_xml_reader().DocumentXmlReader;
    var relationshipsReader = require_relationships_reader();
    var contentTypesReader = require_content_types_reader();
    var numberingXml = require_numbering_xml();
    var stylesReader = require_styles_reader();
    var notesReader = require_notes_reader();
    var commentsReader = require_comments_reader();
    var Files = require_files().Files;
    function read(docxFile, input, options) {
      input = input || {};
      options = options || {};
      var files = new Files({
        externalFileAccess: options.externalFileAccess,
        relativeToFile: input.path
      });
      return promises.props({
        contentTypes: readContentTypesFromZipFile(docxFile),
        partPaths: findPartPaths(docxFile),
        docxFile,
        files
      }).also(function(result) {
        return {
          styles: readStylesFromZipFile(docxFile, result.partPaths.styles)
        };
      }).also(function(result) {
        return {
          numbering: readNumberingFromZipFile(docxFile, result.partPaths.numbering, result.styles)
        };
      }).also(function(result) {
        return {
          footnotes: readXmlFileWithBody(result.partPaths.footnotes, result, function(bodyReader, xml) {
            if (xml) {
              return notesReader.createFootnotesReader(bodyReader)(xml);
            } else {
              return new Result([]);
            }
          }),
          endnotes: readXmlFileWithBody(result.partPaths.endnotes, result, function(bodyReader, xml) {
            if (xml) {
              return notesReader.createEndnotesReader(bodyReader)(xml);
            } else {
              return new Result([]);
            }
          }),
          comments: readXmlFileWithBody(result.partPaths.comments, result, function(bodyReader, xml) {
            if (xml) {
              return commentsReader.createCommentsReader(bodyReader)(xml);
            } else {
              return new Result([]);
            }
          })
        };
      }).also(function(result) {
        return {
          notes: result.footnotes.flatMap(function(footnotes) {
            return result.endnotes.map(function(endnotes) {
              return new documents.Notes(footnotes.concat(endnotes));
            });
          })
        };
      }).then(function(result) {
        return readXmlFileWithBody(result.partPaths.mainDocument, result, function(bodyReader, xml) {
          return result.notes.flatMap(function(notes) {
            return result.comments.flatMap(function(comments) {
              var reader = new DocumentXmlReader({
                bodyReader,
                notes,
                comments
              });
              return reader.convertXmlToDocument(xml);
            });
          });
        });
      });
    }
    __name(read, "read");
    function findPartPaths(docxFile) {
      return readPackageRelationships(docxFile).then(function(packageRelationships) {
        var mainDocumentPath = findPartPath({
          docxFile,
          relationships: packageRelationships,
          relationshipType: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
          basePath: "",
          fallbackPath: "word/document.xml"
        });
        if (!docxFile.exists(mainDocumentPath)) {
          throw new Error("Could not find main document part. Are you sure this is a valid .docx file?");
        }
        return xmlFileReader({
          filename: relationshipsFilename(mainDocumentPath),
          readElement: relationshipsReader.readRelationships,
          defaultValue: relationshipsReader.defaultValue
        })(docxFile).then(function(documentRelationships) {
          function findPartRelatedToMainDocument(name) {
            return findPartPath({
              docxFile,
              relationships: documentRelationships,
              relationshipType: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/" + name,
              basePath: zipfile.splitPath(mainDocumentPath).dirname,
              fallbackPath: "word/" + name + ".xml"
            });
          }
          __name(findPartRelatedToMainDocument, "findPartRelatedToMainDocument");
          return {
            mainDocument: mainDocumentPath,
            comments: findPartRelatedToMainDocument("comments"),
            endnotes: findPartRelatedToMainDocument("endnotes"),
            footnotes: findPartRelatedToMainDocument("footnotes"),
            numbering: findPartRelatedToMainDocument("numbering"),
            styles: findPartRelatedToMainDocument("styles")
          };
        });
      });
    }
    __name(findPartPaths, "findPartPaths");
    function findPartPath(options) {
      var docxFile = options.docxFile;
      var relationships = options.relationships;
      var relationshipType = options.relationshipType;
      var basePath = options.basePath;
      var fallbackPath = options.fallbackPath;
      var targets = relationships.findTargetsByType(relationshipType);
      var normalisedTargets = targets.map(function(target) {
        return stripPrefix(zipfile.joinPath(basePath, target), "/");
      });
      var validTargets = normalisedTargets.filter(function(target) {
        return docxFile.exists(target);
      });
      if (validTargets.length === 0) {
        return fallbackPath;
      } else {
        return validTargets[0];
      }
    }
    __name(findPartPath, "findPartPath");
    function stripPrefix(value, prefix) {
      if (value.substring(0, prefix.length) === prefix) {
        return value.substring(prefix.length);
      } else {
        return value;
      }
    }
    __name(stripPrefix, "stripPrefix");
    function xmlFileReader(options) {
      return function(zipFile) {
        return readXmlFromZipFile(zipFile, options.filename).then(function(element) {
          return element ? options.readElement(element) : options.defaultValue;
        });
      };
    }
    __name(xmlFileReader, "xmlFileReader");
    function readXmlFileWithBody(filename, options, func) {
      var readRelationshipsFromZipFile = xmlFileReader({
        filename: relationshipsFilename(filename),
        readElement: relationshipsReader.readRelationships,
        defaultValue: relationshipsReader.defaultValue
      });
      return readRelationshipsFromZipFile(options.docxFile).then(function(relationships) {
        var bodyReader = new createBodyReader({
          relationships,
          contentTypes: options.contentTypes,
          docxFile: options.docxFile,
          numbering: options.numbering,
          styles: options.styles,
          files: options.files
        });
        return readXmlFromZipFile(options.docxFile, filename).then(function(xml) {
          return func(bodyReader, xml);
        });
      });
    }
    __name(readXmlFileWithBody, "readXmlFileWithBody");
    function relationshipsFilename(filename) {
      var split = zipfile.splitPath(filename);
      return zipfile.joinPath(split.dirname, "_rels", split.basename + ".rels");
    }
    __name(relationshipsFilename, "relationshipsFilename");
    var readContentTypesFromZipFile = xmlFileReader({
      filename: "[Content_Types].xml",
      readElement: contentTypesReader.readContentTypesFromXml,
      defaultValue: contentTypesReader.defaultContentTypes
    });
    function readNumberingFromZipFile(zipFile, path, styles) {
      return xmlFileReader({
        filename: path,
        readElement: function(element) {
          return numberingXml.readNumberingXml(element, { styles });
        },
        defaultValue: numberingXml.defaultNumbering
      })(zipFile);
    }
    __name(readNumberingFromZipFile, "readNumberingFromZipFile");
    function readStylesFromZipFile(zipFile, path) {
      return xmlFileReader({
        filename: path,
        readElement: stylesReader.readStylesXml,
        defaultValue: stylesReader.defaultStyles
      })(zipFile);
    }
    __name(readStylesFromZipFile, "readStylesFromZipFile");
    var readPackageRelationships = xmlFileReader({
      filename: "_rels/.rels",
      readElement: relationshipsReader.readRelationships,
      defaultValue: relationshipsReader.defaultValue
    });
  }
});

// node_modules/mammoth/lib/docx/style-map.js
var require_style_map = __commonJS({
  "node_modules/mammoth/lib/docx/style-map.js"(exports2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var _2 = require_underscore_umd();
    var promises = require_promises();
    var xml = require_xml();
    exports2.writeStyleMap = writeStyleMap;
    exports2.readStyleMap = readStyleMap;
    var schema = "http://schemas.zwobble.org/mammoth/style-map";
    var styleMapPath = "mammoth/style-map";
    var styleMapAbsolutePath = "/" + styleMapPath;
    function writeStyleMap(docxFile, styleMap) {
      docxFile.write(styleMapPath, styleMap);
      return updateRelationships(docxFile).then(function() {
        return updateContentTypes(docxFile);
      });
    }
    __name(writeStyleMap, "writeStyleMap");
    function updateRelationships(docxFile) {
      var path = "word/_rels/document.xml.rels";
      var relationshipsUri = "http://schemas.openxmlformats.org/package/2006/relationships";
      var relationshipElementName = "{" + relationshipsUri + "}Relationship";
      return docxFile.read(path, "utf8").then(xml.readString).then(function(relationshipsContainer) {
        var relationships = relationshipsContainer.children;
        addOrUpdateElement(relationships, relationshipElementName, "Id", {
          "Id": "rMammothStyleMap",
          "Type": schema,
          "Target": styleMapAbsolutePath
        });
        var namespaces = { "": relationshipsUri };
        return docxFile.write(path, xml.writeString(relationshipsContainer, namespaces));
      });
    }
    __name(updateRelationships, "updateRelationships");
    function updateContentTypes(docxFile) {
      var path = "[Content_Types].xml";
      var contentTypesUri = "http://schemas.openxmlformats.org/package/2006/content-types";
      var overrideName = "{" + contentTypesUri + "}Override";
      return docxFile.read(path, "utf8").then(xml.readString).then(function(typesElement) {
        var children = typesElement.children;
        addOrUpdateElement(children, overrideName, "PartName", {
          "PartName": styleMapAbsolutePath,
          "ContentType": "text/prs.mammoth.style-map"
        });
        var namespaces = { "": contentTypesUri };
        return docxFile.write(path, xml.writeString(typesElement, namespaces));
      });
    }
    __name(updateContentTypes, "updateContentTypes");
    function addOrUpdateElement(elements, name, identifyingAttribute, attributes) {
      var existingElement = _2.find(elements, function(element) {
        return element.name === name && element.attributes[identifyingAttribute] === attributes[identifyingAttribute];
      });
      if (existingElement) {
        existingElement.attributes = attributes;
      } else {
        elements.push(xml.element(name, attributes));
      }
    }
    __name(addOrUpdateElement, "addOrUpdateElement");
    function readStyleMap(docxFile) {
      if (docxFile.exists(styleMapPath)) {
        return docxFile.read(styleMapPath, "utf8");
      } else {
        return promises.resolve(null);
      }
    }
    __name(readStyleMap, "readStyleMap");
  }
});

// node_modules/mammoth/lib/html/ast.js
var require_ast = __commonJS({
  "node_modules/mammoth/lib/html/ast.js"(exports2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var htmlPaths = require_html_paths();
    function nonFreshElement(tagName, attributes, children) {
      return elementWithTag(
        htmlPaths.element(tagName, attributes, { fresh: false }),
        children
      );
    }
    __name(nonFreshElement, "nonFreshElement");
    function freshElement(tagName, attributes, children) {
      var tag = htmlPaths.element(tagName, attributes, { fresh: true });
      return elementWithTag(tag, children);
    }
    __name(freshElement, "freshElement");
    function elementWithTag(tag, children) {
      return {
        type: "element",
        tag,
        children: children || []
      };
    }
    __name(elementWithTag, "elementWithTag");
    function text(value) {
      return {
        type: "text",
        value
      };
    }
    __name(text, "text");
    var forceWrite = {
      type: "forceWrite"
    };
    exports2.freshElement = freshElement;
    exports2.nonFreshElement = nonFreshElement;
    exports2.elementWithTag = elementWithTag;
    exports2.text = text;
    exports2.forceWrite = forceWrite;
    var voidTagNames = {
      "br": true,
      "hr": true,
      "img": true,
      "input": true
    };
    function isVoidElement(node) {
      return node.children.length === 0 && voidTagNames[node.tag.tagName];
    }
    __name(isVoidElement, "isVoidElement");
    exports2.isVoidElement = isVoidElement;
  }
});

// node_modules/mammoth/lib/html/simplify.js
var require_simplify = __commonJS({
  "node_modules/mammoth/lib/html/simplify.js"(exports2, module2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var _2 = require_underscore_umd();
    var ast = require_ast();
    function simplify(nodes) {
      return collapse(removeEmpty(nodes));
    }
    __name(simplify, "simplify");
    function collapse(nodes) {
      var children = [];
      nodes.map(collapseNode).forEach(function(child) {
        appendChild(children, child);
      });
      return children;
    }
    __name(collapse, "collapse");
    function collapseNode(node) {
      return collapsers[node.type](node);
    }
    __name(collapseNode, "collapseNode");
    var collapsers = {
      element: collapseElement,
      text: identity,
      forceWrite: identity
    };
    function collapseElement(node) {
      return ast.elementWithTag(node.tag, collapse(node.children));
    }
    __name(collapseElement, "collapseElement");
    function identity(value) {
      return value;
    }
    __name(identity, "identity");
    function appendChild(children, child) {
      var lastChild = children[children.length - 1];
      if (child.type === "element" && !child.tag.fresh && lastChild && lastChild.type === "element" && child.tag.matchesElement(lastChild.tag)) {
        if (child.tag.separator) {
          appendChild(lastChild.children, ast.text(child.tag.separator));
        }
        child.children.forEach(function(grandChild) {
          appendChild(lastChild.children, grandChild);
        });
      } else {
        children.push(child);
      }
    }
    __name(appendChild, "appendChild");
    function removeEmpty(nodes) {
      return flatMap(nodes, function(node) {
        return emptiers[node.type](node);
      });
    }
    __name(removeEmpty, "removeEmpty");
    function flatMap(values, func) {
      return _2.flatten(_2.map(values, func), true);
    }
    __name(flatMap, "flatMap");
    var emptiers = {
      element: elementEmptier,
      text: textEmptier,
      forceWrite: neverEmpty
    };
    function neverEmpty(node) {
      return [node];
    }
    __name(neverEmpty, "neverEmpty");
    function elementEmptier(element) {
      var children = removeEmpty(element.children);
      if (children.length === 0 && !ast.isVoidElement(element)) {
        return [];
      } else {
        return [ast.elementWithTag(element.tag, children)];
      }
    }
    __name(elementEmptier, "elementEmptier");
    function textEmptier(node) {
      if (node.value.length === 0) {
        return [];
      } else {
        return [node];
      }
    }
    __name(textEmptier, "textEmptier");
    module2.exports = simplify;
  }
});

// node_modules/mammoth/lib/html/index.js
var require_html = __commonJS({
  "node_modules/mammoth/lib/html/index.js"(exports2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var ast = require_ast();
    exports2.freshElement = ast.freshElement;
    exports2.nonFreshElement = ast.nonFreshElement;
    exports2.elementWithTag = ast.elementWithTag;
    exports2.text = ast.text;
    exports2.forceWrite = ast.forceWrite;
    exports2.simplify = require_simplify();
    function write(writer, nodes) {
      nodes.forEach(function(node) {
        writeNode(writer, node);
      });
    }
    __name(write, "write");
    function writeNode(writer, node) {
      toStrings[node.type](writer, node);
    }
    __name(writeNode, "writeNode");
    var toStrings = {
      element: generateElementString,
      text: generateTextString,
      forceWrite: function() {
      }
    };
    function generateElementString(writer, node) {
      if (ast.isVoidElement(node)) {
        writer.selfClosing(node.tag.tagName, node.tag.attributes);
      } else {
        writer.open(node.tag.tagName, node.tag.attributes);
        write(writer, node.children);
        writer.close(node.tag.tagName);
      }
    }
    __name(generateElementString, "generateElementString");
    function generateTextString(writer, node) {
      writer.text(node.value);
    }
    __name(generateTextString, "generateTextString");
    exports2.write = write;
  }
});

// node_modules/mammoth/lib/styles/html-paths.js
var require_html_paths = __commonJS({
  "node_modules/mammoth/lib/styles/html-paths.js"(exports2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var _2 = require_underscore_umd();
    var html = require_html();
    exports2.topLevelElement = topLevelElement;
    exports2.elements = elements;
    exports2.element = element;
    function topLevelElement(tagName, attributes) {
      return elements([element(tagName, attributes, { fresh: true })]);
    }
    __name(topLevelElement, "topLevelElement");
    function elements(elementStyles) {
      return new HtmlPath(elementStyles.map(function(elementStyle) {
        if (_2.isString(elementStyle)) {
          return element(elementStyle);
        } else {
          return elementStyle;
        }
      }));
    }
    __name(elements, "elements");
    function HtmlPath(elements2) {
      this._elements = elements2;
    }
    __name(HtmlPath, "HtmlPath");
    HtmlPath.prototype.wrap = /* @__PURE__ */ __name(function wrap(children) {
      var result = children();
      for (var index = this._elements.length - 1; index >= 0; index--) {
        result = this._elements[index].wrapNodes(result);
      }
      return result;
    }, "wrap");
    function element(tagName, attributes, options) {
      options = options || {};
      return new Element(tagName, attributes, options);
    }
    __name(element, "element");
    function Element(tagName, attributes, options) {
      var tagNames = {};
      if (_2.isArray(tagName)) {
        tagName.forEach(function(tagName2) {
          tagNames[tagName2] = true;
        });
        tagName = tagName[0];
      } else {
        tagNames[tagName] = true;
      }
      this.tagName = tagName;
      this.tagNames = tagNames;
      this.attributes = attributes || {};
      this.fresh = options.fresh;
      this.separator = options.separator;
    }
    __name(Element, "Element");
    Element.prototype.matchesElement = function(element2) {
      return this.tagNames[element2.tagName] && _2.isEqual(this.attributes || {}, element2.attributes || {});
    };
    Element.prototype.wrap = /* @__PURE__ */ __name(function wrap(generateNodes) {
      return this.wrapNodes(generateNodes());
    }, "wrap");
    Element.prototype.wrapNodes = /* @__PURE__ */ __name(function wrapNodes(nodes) {
      return [html.elementWithTag(this, nodes)];
    }, "wrapNodes");
    exports2.empty = elements([]);
    exports2.ignore = {
      wrap: function() {
        return [];
      }
    };
  }
});

// node_modules/mammoth/lib/images.js
var require_images = __commonJS({
  "node_modules/mammoth/lib/images.js"(exports2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var _2 = require_underscore_umd();
    var promises = require_promises();
    var Html2 = require_html();
    exports2.imgElement = imgElement;
    function imgElement(func) {
      return function(element, messages) {
        return promises.when(func(element)).then(function(result) {
          var attributes = {};
          if (element.altText) {
            attributes.alt = element.altText;
          }
          _2.extend(attributes, result);
          return [Html2.freshElement("img", attributes)];
        });
      };
    }
    __name(imgElement, "imgElement");
    exports2.inline = exports2.imgElement;
    exports2.dataUri = imgElement(function(element) {
      return element.readAsBase64String().then(function(imageBuffer) {
        return {
          src: "data:" + element.contentType + ";base64," + imageBuffer
        };
      });
    });
  }
});

// node_modules/mammoth/lib/writers/html-writer.js
var require_html_writer = __commonJS({
  "node_modules/mammoth/lib/writers/html-writer.js"(exports2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var _2 = require_underscore_umd();
    exports2.writer = writer;
    function writer(options) {
      options = options || {};
      if (options.prettyPrint) {
        return prettyWriter();
      } else {
        return simpleWriter();
      }
    }
    __name(writer, "writer");
    var indentedElements = {
      div: true,
      p: true,
      ul: true,
      li: true
    };
    function prettyWriter() {
      var indentationLevel = 0;
      var indentation = "  ";
      var stack = [];
      var start = true;
      var inText = false;
      var writer2 = simpleWriter();
      function open(tagName, attributes) {
        if (indentedElements[tagName]) {
          indent();
        }
        stack.push(tagName);
        writer2.open(tagName, attributes);
        if (indentedElements[tagName]) {
          indentationLevel++;
        }
        start = false;
      }
      __name(open, "open");
      function close(tagName) {
        if (indentedElements[tagName]) {
          indentationLevel--;
          indent();
        }
        stack.pop();
        writer2.close(tagName);
      }
      __name(close, "close");
      function text(value) {
        startText();
        var text2 = isInPre() ? value : value.replace("\n", "\n" + indentation);
        writer2.text(text2);
      }
      __name(text, "text");
      function selfClosing(tagName, attributes) {
        indent();
        writer2.selfClosing(tagName, attributes);
      }
      __name(selfClosing, "selfClosing");
      function insideIndentedElement() {
        return stack.length === 0 || indentedElements[stack[stack.length - 1]];
      }
      __name(insideIndentedElement, "insideIndentedElement");
      function startText() {
        if (!inText) {
          indent();
          inText = true;
        }
      }
      __name(startText, "startText");
      function indent() {
        inText = false;
        if (!start && insideIndentedElement() && !isInPre()) {
          writer2._append("\n");
          for (var i2 = 0; i2 < indentationLevel; i2++) {
            writer2._append(indentation);
          }
        }
      }
      __name(indent, "indent");
      function isInPre() {
        return _2.some(stack, function(tagName) {
          return tagName === "pre";
        });
      }
      __name(isInPre, "isInPre");
      return {
        asString: writer2.asString,
        open,
        close,
        text,
        selfClosing
      };
    }
    __name(prettyWriter, "prettyWriter");
    function simpleWriter() {
      var fragments = [];
      function open(tagName, attributes) {
        var attributeString = generateAttributeString(attributes);
        fragments.push("<" + tagName + attributeString + ">");
      }
      __name(open, "open");
      function close(tagName) {
        fragments.push("</" + tagName + ">");
      }
      __name(close, "close");
      function selfClosing(tagName, attributes) {
        var attributeString = generateAttributeString(attributes);
        fragments.push("<" + tagName + attributeString + " />");
      }
      __name(selfClosing, "selfClosing");
      function generateAttributeString(attributes) {
        return _2.map(attributes, function(value, key) {
          return " " + key + '="' + escapeHtmlAttribute(value) + '"';
        }).join("");
      }
      __name(generateAttributeString, "generateAttributeString");
      function text(value) {
        fragments.push(escapeHtmlText(value));
      }
      __name(text, "text");
      function append(html) {
        fragments.push(html);
      }
      __name(append, "append");
      function asString() {
        return fragments.join("");
      }
      __name(asString, "asString");
      return {
        asString,
        open,
        close,
        text,
        selfClosing,
        _append: append
      };
    }
    __name(simpleWriter, "simpleWriter");
    function escapeHtmlText(value) {
      return value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }
    __name(escapeHtmlText, "escapeHtmlText");
    function escapeHtmlAttribute(value) {
      return value.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }
    __name(escapeHtmlAttribute, "escapeHtmlAttribute");
  }
});

// node_modules/mammoth/lib/writers/markdown-writer.js
var require_markdown_writer = __commonJS({
  "node_modules/mammoth/lib/writers/markdown-writer.js"(exports2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var _2 = require_underscore_umd();
    function symmetricMarkdownElement(end) {
      return markdownElement(end, end);
    }
    __name(symmetricMarkdownElement, "symmetricMarkdownElement");
    function markdownElement(start, end) {
      return function() {
        return { start, end };
      };
    }
    __name(markdownElement, "markdownElement");
    function markdownLink(attributes) {
      var href = attributes.href || "";
      if (href) {
        return {
          start: "[",
          end: "](" + href + ")",
          anchorPosition: "before"
        };
      } else {
        return {};
      }
    }
    __name(markdownLink, "markdownLink");
    function markdownImage(attributes) {
      var src = attributes.src || "";
      var altText = attributes.alt || "";
      if (src || altText) {
        return { start: "![" + altText + "](" + src + ")" };
      } else {
        return {};
      }
    }
    __name(markdownImage, "markdownImage");
    function markdownList(options) {
      return function(attributes, list) {
        return {
          start: list ? "\n" : "",
          end: list ? "" : "\n",
          list: {
            isOrdered: options.isOrdered,
            indent: list ? list.indent + 1 : 0,
            count: 0
          }
        };
      };
    }
    __name(markdownList, "markdownList");
    function markdownListItem(attributes, list, listItem) {
      list = list || { indent: 0, isOrdered: false, count: 0 };
      list.count++;
      listItem.hasClosed = false;
      var bullet = list.isOrdered ? list.count + "." : "-";
      var start = repeatString("	", list.indent) + bullet + " ";
      return {
        start,
        end: function() {
          if (!listItem.hasClosed) {
            listItem.hasClosed = true;
            return "\n";
          }
        }
      };
    }
    __name(markdownListItem, "markdownListItem");
    var htmlToMarkdown = {
      "p": markdownElement("", "\n\n"),
      "br": markdownElement("", "  \n"),
      "ul": markdownList({ isOrdered: false }),
      "ol": markdownList({ isOrdered: true }),
      "li": markdownListItem,
      "strong": symmetricMarkdownElement("__"),
      "em": symmetricMarkdownElement("*"),
      "a": markdownLink,
      "img": markdownImage
    };
    (function() {
      for (var i2 = 1; i2 <= 6; i2++) {
        htmlToMarkdown["h" + i2] = markdownElement(repeatString("#", i2) + " ", "\n\n");
      }
    })();
    function repeatString(value, count3) {
      return new Array(count3 + 1).join(value);
    }
    __name(repeatString, "repeatString");
    function markdownWriter() {
      var fragments = [];
      var elementStack = [];
      var list = null;
      var listItem = {};
      function open(tagName, attributes) {
        attributes = attributes || {};
        var createElement = htmlToMarkdown[tagName] || function() {
          return {};
        };
        var element = createElement(attributes, list, listItem);
        elementStack.push({ end: element.end, list });
        if (element.list) {
          list = element.list;
        }
        var anchorBeforeStart = element.anchorPosition === "before";
        if (anchorBeforeStart) {
          writeAnchor(attributes);
        }
        fragments.push(element.start || "");
        if (!anchorBeforeStart) {
          writeAnchor(attributes);
        }
      }
      __name(open, "open");
      function writeAnchor(attributes) {
        if (attributes.id) {
          fragments.push('<a id="' + attributes.id + '"></a>');
        }
      }
      __name(writeAnchor, "writeAnchor");
      function close(tagName) {
        var element = elementStack.pop();
        list = element.list;
        var end = _2.isFunction(element.end) ? element.end() : element.end;
        fragments.push(end || "");
      }
      __name(close, "close");
      function selfClosing(tagName, attributes) {
        open(tagName, attributes);
        close(tagName);
      }
      __name(selfClosing, "selfClosing");
      function text(value) {
        fragments.push(escapeMarkdown(value));
      }
      __name(text, "text");
      function asString() {
        return fragments.join("");
      }
      __name(asString, "asString");
      return {
        asString,
        open,
        close,
        text,
        selfClosing
      };
    }
    __name(markdownWriter, "markdownWriter");
    exports2.writer = markdownWriter;
    function escapeMarkdown(value) {
      return value.replace(/\\/g, "\\\\").replace(/([\`\*_\{\}\[\]\(\)\#\+\-\.\!])/g, "\\$1");
    }
    __name(escapeMarkdown, "escapeMarkdown");
  }
});

// node_modules/mammoth/lib/writers/index.js
var require_writers = __commonJS({
  "node_modules/mammoth/lib/writers/index.js"(exports2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var htmlWriter = require_html_writer();
    var markdownWriter = require_markdown_writer();
    exports2.writer = writer;
    function writer(options) {
      options = options || {};
      if (options.outputFormat === "markdown") {
        return markdownWriter.writer();
      } else {
        return htmlWriter.writer(options);
      }
    }
    __name(writer, "writer");
  }
});

// node_modules/mammoth/lib/document-to-html.js
var require_document_to_html = __commonJS({
  "node_modules/mammoth/lib/document-to-html.js"(exports2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var _2 = require_underscore_umd();
    var promises = require_promises();
    var documents = require_documents();
    var htmlPaths = require_html_paths();
    var results = require_results();
    var images = require_images();
    var Html2 = require_html();
    var writers = require_writers();
    exports2.DocumentConverter = DocumentConverter;
    function DocumentConverter(options) {
      return {
        convertToHtml: function(element) {
          var comments = _2.indexBy(
            element.type === documents.types.document ? element.comments : [],
            "commentId"
          );
          var conversion = new DocumentConversion(options, comments);
          return conversion.convertToHtml(element);
        }
      };
    }
    __name(DocumentConverter, "DocumentConverter");
    function DocumentConversion(options, comments) {
      var noteNumber = 1;
      var noteReferences = [];
      var referencedComments = [];
      options = _2.extend({ ignoreEmptyParagraphs: true }, options);
      var idPrefix = options.idPrefix === void 0 ? "" : options.idPrefix;
      var ignoreEmptyParagraphs = options.ignoreEmptyParagraphs;
      var defaultParagraphStyle = htmlPaths.topLevelElement("p");
      var styleMap = options.styleMap || [];
      function convertToHtml(document2) {
        var messages = [];
        var html = elementToHtml(document2, messages, {});
        var deferredNodes = [];
        walkHtml(html, function(node) {
          if (node.type === "deferred") {
            deferredNodes.push(node);
          }
        });
        var deferredValues = {};
        return promises.mapSeries(deferredNodes, function(deferred) {
          return deferred.value().then(function(value) {
            deferredValues[deferred.id] = value;
          });
        }).then(function() {
          function replaceDeferred(nodes) {
            return flatMap(nodes, function(node) {
              if (node.type === "deferred") {
                return deferredValues[node.id];
              } else if (node.children) {
                return [
                  _2.extend({}, node, {
                    children: replaceDeferred(node.children)
                  })
                ];
              } else {
                return [node];
              }
            });
          }
          __name(replaceDeferred, "replaceDeferred");
          var writer = writers.writer({
            prettyPrint: options.prettyPrint,
            outputFormat: options.outputFormat
          });
          Html2.write(writer, Html2.simplify(replaceDeferred(html)));
          return new results.Result(writer.asString(), messages);
        });
      }
      __name(convertToHtml, "convertToHtml");
      function convertElements(elements, messages, options2) {
        return flatMap(elements, function(element) {
          return elementToHtml(element, messages, options2);
        });
      }
      __name(convertElements, "convertElements");
      function elementToHtml(element, messages, options2) {
        if (!options2) {
          throw new Error("options not set");
        }
        var handler = elementConverters[element.type];
        if (handler) {
          return handler(element, messages, options2);
        } else {
          return [];
        }
      }
      __name(elementToHtml, "elementToHtml");
      function convertParagraph(element, messages, options2) {
        return htmlPathForParagraph(element, messages).wrap(function() {
          var content = convertElements(element.children, messages, options2);
          if (ignoreEmptyParagraphs) {
            return content;
          } else {
            return [Html2.forceWrite].concat(content);
          }
        });
      }
      __name(convertParagraph, "convertParagraph");
      function htmlPathForParagraph(element, messages) {
        var style = findStyle(element);
        if (style) {
          return style.to;
        } else {
          if (element.styleId) {
            messages.push(unrecognisedStyleWarning("paragraph", element));
          }
          return defaultParagraphStyle;
        }
      }
      __name(htmlPathForParagraph, "htmlPathForParagraph");
      function convertRun(run, messages, options2) {
        var nodes = /* @__PURE__ */ __name(function() {
          return convertElements(run.children, messages, options2);
        }, "nodes");
        var paths = [];
        if (run.highlight !== null) {
          var path = findHtmlPath({ type: "highlight", color: run.highlight });
          if (path) {
            paths.push(path);
          }
        }
        if (run.isSmallCaps) {
          paths.push(findHtmlPathForRunProperty("smallCaps"));
        }
        if (run.isAllCaps) {
          paths.push(findHtmlPathForRunProperty("allCaps"));
        }
        if (run.isStrikethrough) {
          paths.push(findHtmlPathForRunProperty("strikethrough", "s"));
        }
        if (run.isUnderline) {
          paths.push(findHtmlPathForRunProperty("underline"));
        }
        if (run.verticalAlignment === documents.verticalAlignment.subscript) {
          paths.push(htmlPaths.element("sub", {}, { fresh: false }));
        }
        if (run.verticalAlignment === documents.verticalAlignment.superscript) {
          paths.push(htmlPaths.element("sup", {}, { fresh: false }));
        }
        if (run.isItalic) {
          paths.push(findHtmlPathForRunProperty("italic", "em"));
        }
        if (run.isBold) {
          paths.push(findHtmlPathForRunProperty("bold", "strong"));
        }
        var stylePath = htmlPaths.empty;
        var style = findStyle(run);
        if (style) {
          stylePath = style.to;
        } else if (run.styleId) {
          messages.push(unrecognisedStyleWarning("run", run));
        }
        paths.push(stylePath);
        paths.forEach(function(path2) {
          nodes = path2.wrap.bind(path2, nodes);
        });
        return nodes();
      }
      __name(convertRun, "convertRun");
      function findHtmlPathForRunProperty(elementType, defaultTagName) {
        var path = findHtmlPath({ type: elementType });
        if (path) {
          return path;
        } else if (defaultTagName) {
          return htmlPaths.element(defaultTagName, {}, { fresh: false });
        } else {
          return htmlPaths.empty;
        }
      }
      __name(findHtmlPathForRunProperty, "findHtmlPathForRunProperty");
      function findHtmlPath(element, defaultPath) {
        var style = findStyle(element);
        return style ? style.to : defaultPath;
      }
      __name(findHtmlPath, "findHtmlPath");
      function findStyle(element) {
        for (var i2 = 0; i2 < styleMap.length; i2++) {
          if (styleMap[i2].from.matches(element)) {
            return styleMap[i2];
          }
        }
      }
      __name(findStyle, "findStyle");
      function recoveringConvertImage(convertImage) {
        return function(image, messages) {
          return promises.attempt(function() {
            return convertImage(image, messages);
          }).caught(function(error3) {
            messages.push(results.error(error3));
            return [];
          });
        };
      }
      __name(recoveringConvertImage, "recoveringConvertImage");
      function noteHtmlId(note) {
        return referentHtmlId(note.noteType, note.noteId);
      }
      __name(noteHtmlId, "noteHtmlId");
      function noteRefHtmlId(note) {
        return referenceHtmlId(note.noteType, note.noteId);
      }
      __name(noteRefHtmlId, "noteRefHtmlId");
      function referentHtmlId(referenceType, referenceId) {
        return htmlId(referenceType + "-" + referenceId);
      }
      __name(referentHtmlId, "referentHtmlId");
      function referenceHtmlId(referenceType, referenceId) {
        return htmlId(referenceType + "-ref-" + referenceId);
      }
      __name(referenceHtmlId, "referenceHtmlId");
      function htmlId(suffix) {
        return idPrefix + suffix;
      }
      __name(htmlId, "htmlId");
      var defaultTablePath = htmlPaths.elements([
        htmlPaths.element("table", {}, { fresh: true })
      ]);
      function convertTable(element, messages, options2) {
        return findHtmlPath(element, defaultTablePath).wrap(function() {
          return convertTableChildren(element, messages, options2);
        });
      }
      __name(convertTable, "convertTable");
      function convertTableChildren(element, messages, options2) {
        var bodyIndex = _2.findIndex(element.children, function(child) {
          return !child.type === documents.types.tableRow || !child.isHeader;
        });
        if (bodyIndex === -1) {
          bodyIndex = element.children.length;
        }
        var children;
        if (bodyIndex === 0) {
          children = convertElements(
            element.children,
            messages,
            _2.extend({}, options2, { isTableHeader: false })
          );
        } else {
          var headRows = convertElements(
            element.children.slice(0, bodyIndex),
            messages,
            _2.extend({}, options2, { isTableHeader: true })
          );
          var bodyRows = convertElements(
            element.children.slice(bodyIndex),
            messages,
            _2.extend({}, options2, { isTableHeader: false })
          );
          children = [
            Html2.freshElement("thead", {}, headRows),
            Html2.freshElement("tbody", {}, bodyRows)
          ];
        }
        return [Html2.forceWrite].concat(children);
      }
      __name(convertTableChildren, "convertTableChildren");
      function convertTableRow(element, messages, options2) {
        var children = convertElements(element.children, messages, options2);
        return [
          Html2.freshElement("tr", {}, [Html2.forceWrite].concat(children))
        ];
      }
      __name(convertTableRow, "convertTableRow");
      function convertTableCell(element, messages, options2) {
        var tagName = options2.isTableHeader ? "th" : "td";
        var children = convertElements(element.children, messages, options2);
        var attributes = {};
        if (element.colSpan !== 1) {
          attributes.colspan = element.colSpan.toString();
        }
        if (element.rowSpan !== 1) {
          attributes.rowspan = element.rowSpan.toString();
        }
        return [
          Html2.freshElement(tagName, attributes, [Html2.forceWrite].concat(children))
        ];
      }
      __name(convertTableCell, "convertTableCell");
      function convertCommentReference(reference, messages, options2) {
        return findHtmlPath(reference, htmlPaths.ignore).wrap(function() {
          var comment = comments[reference.commentId];
          var count3 = referencedComments.length + 1;
          var label = "[" + commentAuthorLabel(comment) + count3 + "]";
          referencedComments.push({ label, comment });
          return [
            Html2.freshElement("a", {
              href: "#" + referentHtmlId("comment", reference.commentId),
              id: referenceHtmlId("comment", reference.commentId)
            }, [Html2.text(label)])
          ];
        });
      }
      __name(convertCommentReference, "convertCommentReference");
      function convertComment(referencedComment, messages, options2) {
        var label = referencedComment.label;
        var comment = referencedComment.comment;
        var body = convertElements(comment.body, messages, options2).concat([
          Html2.nonFreshElement("p", {}, [
            Html2.text(" "),
            Html2.freshElement("a", { "href": "#" + referenceHtmlId("comment", comment.commentId) }, [
              Html2.text("\u2191")
            ])
          ])
        ]);
        return [
          Html2.freshElement(
            "dt",
            { "id": referentHtmlId("comment", comment.commentId) },
            [Html2.text("Comment " + label)]
          ),
          Html2.freshElement("dd", {}, body)
        ];
      }
      __name(convertComment, "convertComment");
      function convertBreak(element, messages, options2) {
        return htmlPathForBreak(element).wrap(function() {
          return [];
        });
      }
      __name(convertBreak, "convertBreak");
      function htmlPathForBreak(element) {
        var style = findStyle(element);
        if (style) {
          return style.to;
        } else if (element.breakType === "line") {
          return htmlPaths.topLevelElement("br");
        } else {
          return htmlPaths.empty;
        }
      }
      __name(htmlPathForBreak, "htmlPathForBreak");
      var elementConverters = {
        "document": function(document2, messages, options2) {
          var children = convertElements(document2.children, messages, options2);
          var notes = noteReferences.map(function(noteReference) {
            return document2.notes.resolve(noteReference);
          });
          var notesNodes = convertElements(notes, messages, options2);
          return children.concat([
            Html2.freshElement("ol", {}, notesNodes),
            Html2.freshElement("dl", {}, flatMap(referencedComments, function(referencedComment) {
              return convertComment(referencedComment, messages, options2);
            }))
          ]);
        },
        "paragraph": convertParagraph,
        "run": convertRun,
        "text": function(element, messages, options2) {
          return [Html2.text(element.value)];
        },
        "tab": function(element, messages, options2) {
          return [Html2.text("	")];
        },
        "hyperlink": function(element, messages, options2) {
          var href = element.anchor ? "#" + htmlId(element.anchor) : element.href;
          var attributes = { href };
          if (element.targetFrame != null) {
            attributes.target = element.targetFrame;
          }
          var children = convertElements(element.children, messages, options2);
          return [Html2.nonFreshElement("a", attributes, children)];
        },
        "checkbox": function(element) {
          var attributes = { type: "checkbox" };
          if (element.checked) {
            attributes["checked"] = "checked";
          }
          return [Html2.freshElement("input", attributes)];
        },
        "bookmarkStart": function(element, messages, options2) {
          var anchor = Html2.freshElement("a", {
            id: htmlId(element.name)
          }, [Html2.forceWrite]);
          return [anchor];
        },
        "noteReference": function(element, messages, options2) {
          noteReferences.push(element);
          var anchor = Html2.freshElement("a", {
            href: "#" + noteHtmlId(element),
            id: noteRefHtmlId(element)
          }, [Html2.text("[" + noteNumber++ + "]")]);
          return [Html2.freshElement("sup", {}, [anchor])];
        },
        "note": function(element, messages, options2) {
          var children = convertElements(element.body, messages, options2);
          var backLink = Html2.elementWithTag(htmlPaths.element("p", {}, { fresh: false }), [
            Html2.text(" "),
            Html2.freshElement("a", { href: "#" + noteRefHtmlId(element) }, [Html2.text("\u2191")])
          ]);
          var body = children.concat([backLink]);
          return Html2.freshElement("li", { id: noteHtmlId(element) }, body);
        },
        "commentReference": convertCommentReference,
        "comment": convertComment,
        "image": deferredConversion(recoveringConvertImage(options.convertImage || images.dataUri)),
        "table": convertTable,
        "tableRow": convertTableRow,
        "tableCell": convertTableCell,
        "break": convertBreak
      };
      return {
        convertToHtml
      };
    }
    __name(DocumentConversion, "DocumentConversion");
    var deferredId = 1;
    function deferredConversion(func) {
      return function(element, messages, options) {
        return [
          {
            type: "deferred",
            id: deferredId++,
            value: function() {
              return func(element, messages, options);
            }
          }
        ];
      };
    }
    __name(deferredConversion, "deferredConversion");
    function unrecognisedStyleWarning(type, element) {
      return results.warning(
        "Unrecognised " + type + " style: '" + element.styleName + "' (Style ID: " + element.styleId + ")"
      );
    }
    __name(unrecognisedStyleWarning, "unrecognisedStyleWarning");
    function flatMap(values, func) {
      return _2.flatten(values.map(func), true);
    }
    __name(flatMap, "flatMap");
    function walkHtml(nodes, callback) {
      nodes.forEach(function(node) {
        callback(node);
        if (node.children) {
          walkHtml(node.children, callback);
        }
      });
    }
    __name(walkHtml, "walkHtml");
    var commentAuthorLabel = exports2.commentAuthorLabel = /* @__PURE__ */ __name(function commentAuthorLabel2(comment) {
      return comment.authorInitials || "";
    }, "commentAuthorLabel");
  }
});

// node_modules/mammoth/lib/raw-text.js
var require_raw_text = __commonJS({
  "node_modules/mammoth/lib/raw-text.js"(exports2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var documents = require_documents();
    function convertElementToRawText(element) {
      if (element.type === "text") {
        return element.value;
      } else if (element.type === documents.types.tab) {
        return "	";
      } else {
        var tail = element.type === "paragraph" ? "\n\n" : "";
        return (element.children || []).map(convertElementToRawText).join("") + tail;
      }
    }
    __name(convertElementToRawText, "convertElementToRawText");
    exports2.convertElementToRawText = convertElementToRawText;
  }
});

// node_modules/lop/lib/TokenIterator.js
var require_TokenIterator = __commonJS({
  "node_modules/lop/lib/TokenIterator.js"(exports2, module2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var TokenIterator = module2.exports = function(tokens, startIndex) {
      this._tokens = tokens;
      this._startIndex = startIndex || 0;
    };
    TokenIterator.prototype.head = function() {
      return this._tokens[this._startIndex];
    };
    TokenIterator.prototype.tail = function(startIndex) {
      return new TokenIterator(this._tokens, this._startIndex + 1);
    };
    TokenIterator.prototype.toArray = function() {
      return this._tokens.slice(this._startIndex);
    };
    TokenIterator.prototype.end = function() {
      return this._tokens[this._tokens.length - 1];
    };
    TokenIterator.prototype.to = function(end) {
      var start = this.head().source;
      var endToken = end.head() || end.end();
      return start.to(endToken.source);
    };
  }
});

// node_modules/lop/lib/parser.js
var require_parser = __commonJS({
  "node_modules/lop/lib/parser.js"(exports2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var TokenIterator = require_TokenIterator();
    exports2.Parser = function(options) {
      var parseTokens = /* @__PURE__ */ __name(function(parser, tokens) {
        return parser(new TokenIterator(tokens));
      }, "parseTokens");
      return {
        parseTokens
      };
    };
  }
});

// node_modules/option/index.js
var require_option = __commonJS({
  "node_modules/option/index.js"(exports2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    exports2.none = /* @__PURE__ */ Object.create({
      value: function() {
        throw new Error("Called value on none");
      },
      isNone: function() {
        return true;
      },
      isSome: function() {
        return false;
      },
      map: function() {
        return exports2.none;
      },
      flatMap: function() {
        return exports2.none;
      },
      filter: function() {
        return exports2.none;
      },
      toArray: function() {
        return [];
      },
      orElse: callOrReturn,
      valueOrElse: callOrReturn
    });
    function callOrReturn(value) {
      if (typeof value == "function") {
        return value();
      } else {
        return value;
      }
    }
    __name(callOrReturn, "callOrReturn");
    exports2.some = function(value) {
      return new Some(value);
    };
    var Some = /* @__PURE__ */ __name(function(value) {
      this._value = value;
    }, "Some");
    Some.prototype.value = function() {
      return this._value;
    };
    Some.prototype.isNone = function() {
      return false;
    };
    Some.prototype.isSome = function() {
      return true;
    };
    Some.prototype.map = function(func) {
      return new Some(func(this._value));
    };
    Some.prototype.flatMap = function(func) {
      return func(this._value);
    };
    Some.prototype.filter = function(predicate) {
      return predicate(this._value) ? this : exports2.none;
    };
    Some.prototype.toArray = function() {
      return [this._value];
    };
    Some.prototype.orElse = function(value) {
      return this;
    };
    Some.prototype.valueOrElse = function(value) {
      return this._value;
    };
    exports2.isOption = function(value) {
      return value === exports2.none || value instanceof Some;
    };
    exports2.fromNullable = function(value) {
      if (value == null) {
        return exports2.none;
      }
      return new Some(value);
    };
  }
});

// node_modules/lop/lib/parsing-results.js
var require_parsing_results = __commonJS({
  "node_modules/lop/lib/parsing-results.js"(exports2, module2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = {
      failure: function(errors, remaining) {
        if (errors.length < 1) {
          throw new Error("Failure must have errors");
        }
        return new Result({
          status: "failure",
          remaining,
          errors
        });
      },
      error: function(errors, remaining) {
        if (errors.length < 1) {
          throw new Error("Failure must have errors");
        }
        return new Result({
          status: "error",
          remaining,
          errors
        });
      },
      success: function(value, remaining, source) {
        return new Result({
          status: "success",
          value,
          source,
          remaining,
          errors: []
        });
      },
      cut: function(remaining) {
        return new Result({
          status: "cut",
          remaining,
          errors: []
        });
      }
    };
    var Result = /* @__PURE__ */ __name(function(options) {
      this._value = options.value;
      this._status = options.status;
      this._hasValue = options.value !== void 0;
      this._remaining = options.remaining;
      this._source = options.source;
      this._errors = options.errors;
    }, "Result");
    Result.prototype.map = function(func) {
      if (this._hasValue) {
        return new Result({
          value: func(this._value, this._source),
          status: this._status,
          remaining: this._remaining,
          source: this._source,
          errors: this._errors
        });
      } else {
        return this;
      }
    };
    Result.prototype.changeRemaining = function(remaining) {
      return new Result({
        value: this._value,
        status: this._status,
        remaining,
        source: this._source,
        errors: this._errors
      });
    };
    Result.prototype.isSuccess = function() {
      return this._status === "success" || this._status === "cut";
    };
    Result.prototype.isFailure = function() {
      return this._status === "failure";
    };
    Result.prototype.isError = function() {
      return this._status === "error";
    };
    Result.prototype.isCut = function() {
      return this._status === "cut";
    };
    Result.prototype.value = function() {
      return this._value;
    };
    Result.prototype.remaining = function() {
      return this._remaining;
    };
    Result.prototype.source = function() {
      return this._source;
    };
    Result.prototype.errors = function() {
      return this._errors;
    };
  }
});

// node_modules/lop/lib/errors.js
var require_errors2 = __commonJS({
  "node_modules/lop/lib/errors.js"(exports2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    exports2.error = function(options) {
      return new Error2(options);
    };
    var Error2 = /* @__PURE__ */ __name(function(options) {
      this.expected = options.expected;
      this.actual = options.actual;
      this._location = options.location;
    }, "Error");
    Error2.prototype.describe = function() {
      var locationDescription = this._location ? this._location.describe() + ":\n" : "";
      return locationDescription + "Expected " + this.expected + "\nbut got " + this.actual;
    };
    Error2.prototype.lineNumber = function() {
      return this._location.lineNumber();
    };
    Error2.prototype.characterNumber = function() {
      return this._location.characterNumber();
    };
  }
});

// node_modules/lop/lib/lazy-iterators.js
var require_lazy_iterators = __commonJS({
  "node_modules/lop/lib/lazy-iterators.js"(exports2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var fromArray = exports2.fromArray = function(array) {
      var index = 0;
      var hasNext = /* @__PURE__ */ __name(function() {
        return index < array.length;
      }, "hasNext");
      return new LazyIterator({
        hasNext,
        next: function() {
          if (!hasNext()) {
            throw new Error("No more elements");
          } else {
            return array[index++];
          }
        }
      });
    };
    var LazyIterator = /* @__PURE__ */ __name(function(iterator) {
      this._iterator = iterator;
    }, "LazyIterator");
    LazyIterator.prototype.map = function(func) {
      var iterator = this._iterator;
      return new LazyIterator({
        hasNext: function() {
          return iterator.hasNext();
        },
        next: function() {
          return func(iterator.next());
        }
      });
    };
    LazyIterator.prototype.filter = function(condition) {
      var iterator = this._iterator;
      var moved = false;
      var hasNext = false;
      var next;
      var moveIfNecessary = /* @__PURE__ */ __name(function() {
        if (moved) {
          return;
        }
        moved = true;
        hasNext = false;
        while (iterator.hasNext() && !hasNext) {
          next = iterator.next();
          hasNext = condition(next);
        }
      }, "moveIfNecessary");
      return new LazyIterator({
        hasNext: function() {
          moveIfNecessary();
          return hasNext;
        },
        next: function() {
          moveIfNecessary();
          var toReturn = next;
          moved = false;
          return toReturn;
        }
      });
    };
    LazyIterator.prototype.first = function() {
      var iterator = this._iterator;
      if (this._iterator.hasNext()) {
        return iterator.next();
      } else {
        return null;
      }
    };
    LazyIterator.prototype.toArray = function() {
      var result = [];
      while (this._iterator.hasNext()) {
        result.push(this._iterator.next());
      }
      return result;
    };
  }
});

// node_modules/lop/lib/rules.js
var require_rules = __commonJS({
  "node_modules/lop/lib/rules.js"(exports2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var _2 = require_underscore_umd();
    var options = require_option();
    var results = require_parsing_results();
    var errors = require_errors2();
    var lazyIterators = require_lazy_iterators();
    exports2.token = function(tokenType, value) {
      var matchValue = value !== void 0;
      return function(input) {
        var token = input.head();
        if (token && token.name === tokenType && (!matchValue || token.value === value)) {
          return results.success(token.value, input.tail(), token.source);
        } else {
          var expected = describeToken({ name: tokenType, value });
          return describeTokenMismatch(input, expected);
        }
      };
    };
    exports2.tokenOfType = function(tokenType) {
      return exports2.token(tokenType);
    };
    exports2.firstOf = function(name, parsers) {
      if (!_2.isArray(parsers)) {
        parsers = Array.prototype.slice.call(arguments, 1);
      }
      return function(input) {
        return lazyIterators.fromArray(parsers).map(function(parser) {
          return parser(input);
        }).filter(function(result) {
          return result.isSuccess() || result.isError();
        }).first() || describeTokenMismatch(input, name);
      };
    };
    exports2.then = function(parser, func) {
      return function(input) {
        var result = parser(input);
        if (!result.map) {
          console.log(result);
        }
        return result.map(func);
      };
    };
    exports2.sequence = function() {
      var parsers = Array.prototype.slice.call(arguments, 0);
      var rule = /* @__PURE__ */ __name(function(input) {
        var result = _2.foldl(parsers, function(memo, parser) {
          var result2 = memo.result;
          var hasCut = memo.hasCut;
          if (!result2.isSuccess()) {
            return { result: result2, hasCut };
          }
          var subResult = parser(result2.remaining());
          if (subResult.isCut()) {
            return { result: result2, hasCut: true };
          } else if (subResult.isSuccess()) {
            var values;
            if (parser.isCaptured) {
              values = result2.value().withValue(parser, subResult.value());
            } else {
              values = result2.value();
            }
            var remaining = subResult.remaining();
            var source2 = input.to(remaining);
            return {
              result: results.success(values, remaining, source2),
              hasCut
            };
          } else if (hasCut) {
            return { result: results.error(subResult.errors(), subResult.remaining()), hasCut };
          } else {
            return { result: subResult, hasCut };
          }
        }, { result: results.success(new SequenceValues(), input), hasCut: false }).result;
        var source = input.to(result.remaining());
        return result.map(function(values) {
          return values.withValue(exports2.sequence.source, source);
        });
      }, "rule");
      rule.head = function() {
        var firstCapture = _2.find(parsers, isCapturedRule);
        return exports2.then(
          rule,
          exports2.sequence.extract(firstCapture)
        );
      };
      rule.map = function(func) {
        return exports2.then(
          rule,
          function(result) {
            return func.apply(this, result.toArray());
          }
        );
      };
      function isCapturedRule(subRule) {
        return subRule.isCaptured;
      }
      __name(isCapturedRule, "isCapturedRule");
      return rule;
    };
    var SequenceValues = /* @__PURE__ */ __name(function(values, valuesArray) {
      this._values = values || {};
      this._valuesArray = valuesArray || [];
    }, "SequenceValues");
    SequenceValues.prototype.withValue = function(rule, value) {
      if (rule.captureName && rule.captureName in this._values) {
        throw new Error('Cannot add second value for capture "' + rule.captureName + '"');
      } else {
        var newValues = _2.clone(this._values);
        newValues[rule.captureName] = value;
        var newValuesArray = this._valuesArray.concat([value]);
        return new SequenceValues(newValues, newValuesArray);
      }
    };
    SequenceValues.prototype.get = function(rule) {
      if (rule.captureName in this._values) {
        return this._values[rule.captureName];
      } else {
        throw new Error('No value for capture "' + rule.captureName + '"');
      }
    };
    SequenceValues.prototype.toArray = function() {
      return this._valuesArray;
    };
    exports2.sequence.capture = function(rule, name) {
      var captureRule = /* @__PURE__ */ __name(function() {
        return rule.apply(this, arguments);
      }, "captureRule");
      captureRule.captureName = name;
      captureRule.isCaptured = true;
      return captureRule;
    };
    exports2.sequence.extract = function(rule) {
      return function(result) {
        return result.get(rule);
      };
    };
    exports2.sequence.applyValues = function(func) {
      var rules = Array.prototype.slice.call(arguments, 1);
      return function(result) {
        var values = rules.map(function(rule) {
          return result.get(rule);
        });
        return func.apply(this, values);
      };
    };
    exports2.sequence.source = {
      captureName: "\u2603source\u2603"
    };
    exports2.sequence.cut = function() {
      return function(input) {
        return results.cut(input);
      };
    };
    exports2.optional = function(rule) {
      return function(input) {
        var result = rule(input);
        if (result.isSuccess()) {
          return result.map(options.some);
        } else if (result.isFailure()) {
          return results.success(options.none, input);
        } else {
          return result;
        }
      };
    };
    exports2.zeroOrMoreWithSeparator = function(rule, separator) {
      return repeatedWithSeparator(rule, separator, false);
    };
    exports2.oneOrMoreWithSeparator = function(rule, separator) {
      return repeatedWithSeparator(rule, separator, true);
    };
    var zeroOrMore = exports2.zeroOrMore = function(rule) {
      return function(input) {
        var values = [];
        var result;
        while ((result = rule(input)) && result.isSuccess()) {
          input = result.remaining();
          values.push(result.value());
        }
        if (result.isError()) {
          return result;
        } else {
          return results.success(values, input);
        }
      };
    };
    exports2.oneOrMore = function(rule) {
      return exports2.oneOrMoreWithSeparator(rule, noOpRule);
    };
    function noOpRule(input) {
      return results.success(null, input);
    }
    __name(noOpRule, "noOpRule");
    var repeatedWithSeparator = /* @__PURE__ */ __name(function(rule, separator, isOneOrMore) {
      return function(input) {
        var result = rule(input);
        if (result.isSuccess()) {
          var mainRule = exports2.sequence.capture(rule, "main");
          var remainingRule = zeroOrMore(exports2.then(
            exports2.sequence(separator, mainRule),
            exports2.sequence.extract(mainRule)
          ));
          var remainingResult = remainingRule(result.remaining());
          return results.success([result.value()].concat(remainingResult.value()), remainingResult.remaining());
        } else if (isOneOrMore || result.isError()) {
          return result;
        } else {
          return results.success([], input);
        }
      };
    }, "repeatedWithSeparator");
    exports2.leftAssociative = function(leftRule, rightRule, func) {
      var rights;
      if (func) {
        rights = [{ func, rule: rightRule }];
      } else {
        rights = rightRule;
      }
      rights = rights.map(function(right) {
        return exports2.then(right.rule, function(rightValue) {
          return function(leftValue, source) {
            return right.func(leftValue, rightValue, source);
          };
        });
      });
      var repeatedRule = exports2.firstOf.apply(null, ["rules"].concat(rights));
      return function(input) {
        var start = input;
        var leftResult = leftRule(input);
        if (!leftResult.isSuccess()) {
          return leftResult;
        }
        var repeatedResult = repeatedRule(leftResult.remaining());
        while (repeatedResult.isSuccess()) {
          var remaining = repeatedResult.remaining();
          var source = start.to(repeatedResult.remaining());
          var right = repeatedResult.value();
          leftResult = results.success(
            right(leftResult.value(), source),
            remaining,
            source
          );
          repeatedResult = repeatedRule(leftResult.remaining());
        }
        if (repeatedResult.isError()) {
          return repeatedResult;
        }
        return leftResult;
      };
    };
    exports2.leftAssociative.firstOf = function() {
      return Array.prototype.slice.call(arguments, 0);
    };
    exports2.nonConsuming = function(rule) {
      return function(input) {
        return rule(input).changeRemaining(input);
      };
    };
    var describeToken = /* @__PURE__ */ __name(function(token) {
      if (token.value) {
        return token.name + ' "' + token.value + '"';
      } else {
        return token.name;
      }
    }, "describeToken");
    function describeTokenMismatch(input, expected) {
      var error3;
      var token = input.head();
      if (token) {
        error3 = errors.error({
          expected,
          actual: describeToken(token),
          location: token.source
        });
      } else {
        error3 = errors.error({
          expected,
          actual: "end of tokens"
        });
      }
      return results.failure([error3], input);
    }
    __name(describeTokenMismatch, "describeTokenMismatch");
  }
});

// node_modules/lop/lib/StringSource.js
var require_StringSource = __commonJS({
  "node_modules/lop/lib/StringSource.js"(exports2, module2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var StringSource = module2.exports = function(string, description) {
      var self2 = {
        asString: function() {
          return string;
        },
        range: function(startIndex, endIndex) {
          return new StringSourceRange(string, description, startIndex, endIndex);
        }
      };
      return self2;
    };
    var StringSourceRange = /* @__PURE__ */ __name(function(string, description, startIndex, endIndex) {
      this._string = string;
      this._description = description;
      this._startIndex = startIndex;
      this._endIndex = endIndex;
    }, "StringSourceRange");
    StringSourceRange.prototype.to = function(otherRange) {
      return new StringSourceRange(this._string, this._description, this._startIndex, otherRange._endIndex);
    };
    StringSourceRange.prototype.describe = function() {
      var position = this._position();
      var description = this._description ? this._description + "\n" : "";
      return description + "Line number: " + position.lineNumber + "\nCharacter number: " + position.characterNumber;
    };
    StringSourceRange.prototype.lineNumber = function() {
      return this._position().lineNumber;
    };
    StringSourceRange.prototype.characterNumber = function() {
      return this._position().characterNumber;
    };
    StringSourceRange.prototype._position = function() {
      var self2 = this;
      var index = 0;
      var nextNewLine = /* @__PURE__ */ __name(function() {
        return self2._string.indexOf("\n", index);
      }, "nextNewLine");
      var lineNumber = 1;
      while (nextNewLine() !== -1 && nextNewLine() < this._startIndex) {
        index = nextNewLine() + 1;
        lineNumber += 1;
      }
      var characterNumber = this._startIndex - index + 1;
      return { lineNumber, characterNumber };
    };
  }
});

// node_modules/lop/lib/Token.js
var require_Token = __commonJS({
  "node_modules/lop/lib/Token.js"(exports2, module2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = function(name, value, source) {
      this.name = name;
      this.value = value;
      if (source) {
        this.source = source;
      }
    };
  }
});

// node_modules/lop/lib/bottom-up.js
var require_bottom_up = __commonJS({
  "node_modules/lop/lib/bottom-up.js"(exports2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var rules = require_rules();
    var results = require_parsing_results();
    exports2.parser = function(name, prefixRules, infixRuleBuilders) {
      var self2 = {
        rule,
        leftAssociative,
        rightAssociative
      };
      var infixRules = new InfixRules(infixRuleBuilders.map(createInfixRule));
      var prefixRule = rules.firstOf(name, prefixRules);
      function createInfixRule(infixRuleBuilder) {
        return {
          name: infixRuleBuilder.name,
          rule: lazyRule(infixRuleBuilder.ruleBuilder.bind(null, self2))
        };
      }
      __name(createInfixRule, "createInfixRule");
      function rule() {
        return createRule(infixRules);
      }
      __name(rule, "rule");
      function leftAssociative(name2) {
        return createRule(infixRules.untilExclusive(name2));
      }
      __name(leftAssociative, "leftAssociative");
      function rightAssociative(name2) {
        return createRule(infixRules.untilInclusive(name2));
      }
      __name(rightAssociative, "rightAssociative");
      function createRule(infixRules2) {
        return apply.bind(null, infixRules2);
      }
      __name(createRule, "createRule");
      function apply(infixRules2, tokens) {
        var leftResult = prefixRule(tokens);
        if (leftResult.isSuccess()) {
          return infixRules2.apply(leftResult);
        } else {
          return leftResult;
        }
      }
      __name(apply, "apply");
      return self2;
    };
    function InfixRules(infixRules) {
      function untilExclusive(name) {
        return new InfixRules(infixRules.slice(0, ruleNames().indexOf(name)));
      }
      __name(untilExclusive, "untilExclusive");
      function untilInclusive(name) {
        return new InfixRules(infixRules.slice(0, ruleNames().indexOf(name) + 1));
      }
      __name(untilInclusive, "untilInclusive");
      function ruleNames() {
        return infixRules.map(function(rule) {
          return rule.name;
        });
      }
      __name(ruleNames, "ruleNames");
      function apply(leftResult) {
        var currentResult;
        var source;
        while (true) {
          currentResult = applyToTokens(leftResult.remaining());
          if (currentResult.isSuccess()) {
            source = leftResult.source().to(currentResult.source());
            leftResult = results.success(
              currentResult.value()(leftResult.value(), source),
              currentResult.remaining(),
              source
            );
          } else if (currentResult.isFailure()) {
            return leftResult;
          } else {
            return currentResult;
          }
        }
      }
      __name(apply, "apply");
      function applyToTokens(tokens) {
        return rules.firstOf("infix", infixRules.map(function(infix) {
          return infix.rule;
        }))(tokens);
      }
      __name(applyToTokens, "applyToTokens");
      return {
        apply,
        untilExclusive,
        untilInclusive
      };
    }
    __name(InfixRules, "InfixRules");
    exports2.infix = function(name, ruleBuilder) {
      function map(func) {
        return exports2.infix(name, function(parser) {
          var rule = ruleBuilder(parser);
          return function(tokens) {
            var result = rule(tokens);
            return result.map(function(right) {
              return function(left, source) {
                return func(left, right, source);
              };
            });
          };
        });
      }
      __name(map, "map");
      return {
        name,
        ruleBuilder,
        map
      };
    };
    var lazyRule = /* @__PURE__ */ __name(function(ruleBuilder) {
      var rule;
      return function(input) {
        if (!rule) {
          rule = ruleBuilder();
        }
        return rule(input);
      };
    }, "lazyRule");
  }
});

// node_modules/lop/lib/regex-tokeniser.js
var require_regex_tokeniser = __commonJS({
  "node_modules/lop/lib/regex-tokeniser.js"(exports2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Token = require_Token();
    var StringSource = require_StringSource();
    exports2.RegexTokeniser = RegexTokeniser;
    function RegexTokeniser(rules) {
      rules = rules.map(function(rule) {
        return {
          name: rule.name,
          regex: new RegExp(rule.regex.source, "g")
        };
      });
      function tokenise(input, description) {
        var source = new StringSource(input, description);
        var index = 0;
        var tokens = [];
        while (index < input.length) {
          var result = readNextToken(input, index, source);
          index = result.endIndex;
          tokens.push(result.token);
        }
        tokens.push(endToken(input, source));
        return tokens;
      }
      __name(tokenise, "tokenise");
      function readNextToken(string, startIndex, source) {
        for (var i2 = 0; i2 < rules.length; i2++) {
          var regex = rules[i2].regex;
          regex.lastIndex = startIndex;
          var result = regex.exec(string);
          if (result) {
            var endIndex = startIndex + result[0].length;
            if (result.index === startIndex && endIndex > startIndex) {
              var value = result[1];
              var token = new Token(
                rules[i2].name,
                value,
                source.range(startIndex, endIndex)
              );
              return { token, endIndex };
            }
          }
        }
        var endIndex = startIndex + 1;
        var token = new Token(
          "unrecognisedCharacter",
          string.substring(startIndex, endIndex),
          source.range(startIndex, endIndex)
        );
        return { token, endIndex };
      }
      __name(readNextToken, "readNextToken");
      function endToken(input, source) {
        return new Token(
          "end",
          null,
          source.range(input.length, input.length)
        );
      }
      __name(endToken, "endToken");
      return {
        tokenise
      };
    }
    __name(RegexTokeniser, "RegexTokeniser");
  }
});

// node_modules/lop/index.js
var require_lop = __commonJS({
  "node_modules/lop/index.js"(exports2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    exports2.Parser = require_parser().Parser;
    exports2.rules = require_rules();
    exports2.errors = require_errors2();
    exports2.results = require_parsing_results();
    exports2.StringSource = require_StringSource();
    exports2.Token = require_Token();
    exports2.bottomUp = require_bottom_up();
    exports2.RegexTokeniser = require_regex_tokeniser().RegexTokeniser;
    exports2.rule = function(ruleBuilder) {
      var rule;
      return function(input) {
        if (!rule) {
          rule = ruleBuilder();
        }
        return rule(input);
      };
    };
  }
});

// node_modules/mammoth/lib/styles/document-matchers.js
var require_document_matchers = __commonJS({
  "node_modules/mammoth/lib/styles/document-matchers.js"(exports2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    exports2.paragraph = paragraph;
    exports2.run = run;
    exports2.table = table3;
    exports2.bold = new Matcher("bold");
    exports2.italic = new Matcher("italic");
    exports2.underline = new Matcher("underline");
    exports2.strikethrough = new Matcher("strikethrough");
    exports2.allCaps = new Matcher("allCaps");
    exports2.smallCaps = new Matcher("smallCaps");
    exports2.highlight = highlight;
    exports2.commentReference = new Matcher("commentReference");
    exports2.lineBreak = new BreakMatcher({ breakType: "line" });
    exports2.pageBreak = new BreakMatcher({ breakType: "page" });
    exports2.columnBreak = new BreakMatcher({ breakType: "column" });
    exports2.equalTo = equalTo;
    exports2.startsWith = startsWith;
    function paragraph(options) {
      return new Matcher("paragraph", options);
    }
    __name(paragraph, "paragraph");
    function run(options) {
      return new Matcher("run", options);
    }
    __name(run, "run");
    function table3(options) {
      return new Matcher("table", options);
    }
    __name(table3, "table");
    function highlight(options) {
      return new HighlightMatcher(options);
    }
    __name(highlight, "highlight");
    function Matcher(elementType, options) {
      options = options || {};
      this._elementType = elementType;
      this._styleId = options.styleId;
      this._styleName = options.styleName;
      if (options.list) {
        this._listIndex = options.list.levelIndex;
        this._listIsOrdered = options.list.isOrdered;
      }
    }
    __name(Matcher, "Matcher");
    Matcher.prototype.matches = function(element) {
      return element.type === this._elementType && (this._styleId === void 0 || element.styleId === this._styleId) && (this._styleName === void 0 || element.styleName && this._styleName.operator(this._styleName.operand, element.styleName)) && (this._listIndex === void 0 || isList(element, this._listIndex, this._listIsOrdered)) && (this._breakType === void 0 || this._breakType === element.breakType);
    };
    function HighlightMatcher(options) {
      options = options || {};
      this._color = options.color;
    }
    __name(HighlightMatcher, "HighlightMatcher");
    HighlightMatcher.prototype.matches = function(element) {
      return element.type === "highlight" && (this._color === void 0 || element.color === this._color);
    };
    function BreakMatcher(options) {
      options = options || {};
      this._breakType = options.breakType;
    }
    __name(BreakMatcher, "BreakMatcher");
    BreakMatcher.prototype.matches = function(element) {
      return element.type === "break" && (this._breakType === void 0 || element.breakType === this._breakType);
    };
    function isList(element, levelIndex, isOrdered) {
      return element.numbering && element.numbering.level == levelIndex && element.numbering.isOrdered == isOrdered;
    }
    __name(isList, "isList");
    function equalTo(value) {
      return {
        operator: operatorEqualTo,
        operand: value
      };
    }
    __name(equalTo, "equalTo");
    function startsWith(value) {
      return {
        operator: operatorStartsWith,
        operand: value
      };
    }
    __name(startsWith, "startsWith");
    function operatorEqualTo(first, second) {
      return first.toUpperCase() === second.toUpperCase();
    }
    __name(operatorEqualTo, "operatorEqualTo");
    function operatorStartsWith(first, second) {
      return second.toUpperCase().indexOf(first.toUpperCase()) === 0;
    }
    __name(operatorStartsWith, "operatorStartsWith");
  }
});

// node_modules/mammoth/lib/styles/parser/tokeniser.js
var require_tokeniser = __commonJS({
  "node_modules/mammoth/lib/styles/parser/tokeniser.js"(exports2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var lop = require_lop();
    var RegexTokeniser = lop.RegexTokeniser;
    exports2.tokenise = tokenise;
    var stringPrefix = "'((?:\\\\.|[^'])*)";
    function tokenise(string) {
      var identifierCharacter = "(?:[a-zA-Z\\-_]|\\\\.)";
      var tokeniser = new RegexTokeniser([
        { name: "identifier", regex: new RegExp("(" + identifierCharacter + "(?:" + identifierCharacter + "|[0-9])*)") },
        { name: "dot", regex: /\./ },
        { name: "colon", regex: /:/ },
        { name: "gt", regex: />/ },
        { name: "whitespace", regex: /\s+/ },
        { name: "arrow", regex: /=>/ },
        { name: "equals", regex: /=/ },
        { name: "startsWith", regex: /\^=/ },
        { name: "open-paren", regex: /\(/ },
        { name: "close-paren", regex: /\)/ },
        { name: "open-square-bracket", regex: /\[/ },
        { name: "close-square-bracket", regex: /\]/ },
        { name: "string", regex: new RegExp(stringPrefix + "'") },
        { name: "unterminated-string", regex: new RegExp(stringPrefix) },
        { name: "integer", regex: /([0-9]+)/ },
        { name: "choice", regex: /\|/ },
        { name: "bang", regex: /(!)/ }
      ]);
      return tokeniser.tokenise(string);
    }
    __name(tokenise, "tokenise");
  }
});

// node_modules/mammoth/lib/style-reader.js
var require_style_reader = __commonJS({
  "node_modules/mammoth/lib/style-reader.js"(exports2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var _2 = require_underscore_umd();
    var lop = require_lop();
    var documentMatchers = require_document_matchers();
    var htmlPaths = require_html_paths();
    var tokenise = require_tokeniser().tokenise;
    var results = require_results();
    exports2.readHtmlPath = readHtmlPath;
    exports2.readDocumentMatcher = readDocumentMatcher;
    exports2.readStyle = readStyle;
    function readStyle(string) {
      return parseString(styleRule, string);
    }
    __name(readStyle, "readStyle");
    function createStyleRule() {
      return lop.rules.sequence(
        lop.rules.sequence.capture(documentMatcherRule()),
        lop.rules.tokenOfType("whitespace"),
        lop.rules.tokenOfType("arrow"),
        lop.rules.sequence.capture(lop.rules.optional(lop.rules.sequence(
          lop.rules.tokenOfType("whitespace"),
          lop.rules.sequence.capture(htmlPathRule())
        ).head())),
        lop.rules.tokenOfType("end")
      ).map(function(documentMatcher, htmlPath) {
        return {
          from: documentMatcher,
          to: htmlPath.valueOrElse(htmlPaths.empty)
        };
      });
    }
    __name(createStyleRule, "createStyleRule");
    function readDocumentMatcher(string) {
      return parseString(documentMatcherRule(), string);
    }
    __name(readDocumentMatcher, "readDocumentMatcher");
    function documentMatcherRule() {
      var sequence = lop.rules.sequence;
      var identifierToConstant = /* @__PURE__ */ __name(function(identifier, constant) {
        return lop.rules.then(
          lop.rules.token("identifier", identifier),
          function() {
            return constant;
          }
        );
      }, "identifierToConstant");
      var paragraphRule = identifierToConstant("p", documentMatchers.paragraph);
      var runRule = identifierToConstant("r", documentMatchers.run);
      var elementTypeRule = lop.rules.firstOf(
        "p or r or table",
        paragraphRule,
        runRule
      );
      var styleIdRule = lop.rules.sequence(
        lop.rules.tokenOfType("dot"),
        lop.rules.sequence.cut(),
        lop.rules.sequence.capture(identifierRule)
      ).map(function(styleId) {
        return { styleId };
      });
      var styleNameMatcherRule = lop.rules.firstOf(
        "style name matcher",
        lop.rules.then(
          lop.rules.sequence(
            lop.rules.tokenOfType("equals"),
            lop.rules.sequence.cut(),
            lop.rules.sequence.capture(stringRule)
          ).head(),
          function(styleName) {
            return { styleName: documentMatchers.equalTo(styleName) };
          }
        ),
        lop.rules.then(
          lop.rules.sequence(
            lop.rules.tokenOfType("startsWith"),
            lop.rules.sequence.cut(),
            lop.rules.sequence.capture(stringRule)
          ).head(),
          function(styleName) {
            return { styleName: documentMatchers.startsWith(styleName) };
          }
        )
      );
      var styleNameRule = lop.rules.sequence(
        lop.rules.tokenOfType("open-square-bracket"),
        lop.rules.sequence.cut(),
        lop.rules.token("identifier", "style-name"),
        lop.rules.sequence.capture(styleNameMatcherRule),
        lop.rules.tokenOfType("close-square-bracket")
      ).head();
      var listTypeRule = lop.rules.firstOf(
        "list type",
        identifierToConstant("ordered-list", { isOrdered: true }),
        identifierToConstant("unordered-list", { isOrdered: false })
      );
      var listRule = sequence(
        lop.rules.tokenOfType("colon"),
        sequence.capture(listTypeRule),
        sequence.cut(),
        lop.rules.tokenOfType("open-paren"),
        sequence.capture(integerRule),
        lop.rules.tokenOfType("close-paren")
      ).map(function(listType, levelNumber) {
        return {
          list: {
            isOrdered: listType.isOrdered,
            levelIndex: levelNumber - 1
          }
        };
      });
      function createMatcherSuffixesRule(rules) {
        var matcherSuffix = lop.rules.firstOf.apply(
          lop.rules.firstOf,
          ["matcher suffix"].concat(rules)
        );
        var matcherSuffixes = lop.rules.zeroOrMore(matcherSuffix);
        return lop.rules.then(matcherSuffixes, function(suffixes) {
          var matcherOptions = {};
          suffixes.forEach(function(suffix) {
            _2.extend(matcherOptions, suffix);
          });
          return matcherOptions;
        });
      }
      __name(createMatcherSuffixesRule, "createMatcherSuffixesRule");
      var paragraphOrRun = sequence(
        sequence.capture(elementTypeRule),
        sequence.capture(createMatcherSuffixesRule([
          styleIdRule,
          styleNameRule,
          listRule
        ]))
      ).map(function(createMatcher, matcherOptions) {
        return createMatcher(matcherOptions);
      });
      var table3 = sequence(
        lop.rules.token("identifier", "table"),
        sequence.capture(createMatcherSuffixesRule([
          styleIdRule,
          styleNameRule
        ]))
      ).map(function(options) {
        return documentMatchers.table(options);
      });
      var bold = identifierToConstant("b", documentMatchers.bold);
      var italic = identifierToConstant("i", documentMatchers.italic);
      var underline = identifierToConstant("u", documentMatchers.underline);
      var strikethrough = identifierToConstant("strike", documentMatchers.strikethrough);
      var allCaps = identifierToConstant("all-caps", documentMatchers.allCaps);
      var smallCaps = identifierToConstant("small-caps", documentMatchers.smallCaps);
      var highlight = sequence(
        lop.rules.token("identifier", "highlight"),
        lop.rules.sequence.capture(lop.rules.optional(lop.rules.sequence(
          lop.rules.tokenOfType("open-square-bracket"),
          lop.rules.sequence.cut(),
          lop.rules.token("identifier", "color"),
          lop.rules.tokenOfType("equals"),
          lop.rules.sequence.capture(stringRule),
          lop.rules.tokenOfType("close-square-bracket")
        ).head()))
      ).map(function(color) {
        return documentMatchers.highlight({
          color: color.valueOrElse(void 0)
        });
      });
      var commentReference = identifierToConstant("comment-reference", documentMatchers.commentReference);
      var breakMatcher = sequence(
        lop.rules.token("identifier", "br"),
        sequence.cut(),
        lop.rules.tokenOfType("open-square-bracket"),
        lop.rules.token("identifier", "type"),
        lop.rules.tokenOfType("equals"),
        sequence.capture(stringRule),
        lop.rules.tokenOfType("close-square-bracket")
      ).map(function(breakType) {
        switch (breakType) {
          case "line":
            return documentMatchers.lineBreak;
          case "page":
            return documentMatchers.pageBreak;
          case "column":
            return documentMatchers.columnBreak;
          default:
        }
      });
      return lop.rules.firstOf(
        "element type",
        paragraphOrRun,
        table3,
        bold,
        italic,
        underline,
        strikethrough,
        allCaps,
        smallCaps,
        highlight,
        commentReference,
        breakMatcher
      );
    }
    __name(documentMatcherRule, "documentMatcherRule");
    function readHtmlPath(string) {
      return parseString(htmlPathRule(), string);
    }
    __name(readHtmlPath, "readHtmlPath");
    function htmlPathRule() {
      var capture = lop.rules.sequence.capture;
      var whitespaceRule = lop.rules.tokenOfType("whitespace");
      var freshRule = lop.rules.then(
        lop.rules.optional(lop.rules.sequence(
          lop.rules.tokenOfType("colon"),
          lop.rules.token("identifier", "fresh")
        )),
        function(option) {
          return option.map(function() {
            return true;
          }).valueOrElse(false);
        }
      );
      var separatorRule = lop.rules.then(
        lop.rules.optional(lop.rules.sequence(
          lop.rules.tokenOfType("colon"),
          lop.rules.token("identifier", "separator"),
          lop.rules.tokenOfType("open-paren"),
          capture(stringRule),
          lop.rules.tokenOfType("close-paren")
        ).head()),
        function(option) {
          return option.valueOrElse("");
        }
      );
      var tagNamesRule = lop.rules.oneOrMoreWithSeparator(
        identifierRule,
        lop.rules.tokenOfType("choice")
      );
      var styleElementRule = lop.rules.sequence(
        capture(tagNamesRule),
        capture(lop.rules.zeroOrMore(attributeOrClassRule)),
        capture(freshRule),
        capture(separatorRule)
      ).map(function(tagName, attributesList, fresh, separator) {
        var attributes = {};
        var options = {};
        attributesList.forEach(function(attribute) {
          if (attribute.append && attributes[attribute.name]) {
            attributes[attribute.name] += " " + attribute.value;
          } else {
            attributes[attribute.name] = attribute.value;
          }
        });
        if (fresh) {
          options.fresh = true;
        }
        if (separator) {
          options.separator = separator;
        }
        return htmlPaths.element(tagName, attributes, options);
      });
      return lop.rules.firstOf(
        "html path",
        lop.rules.then(lop.rules.tokenOfType("bang"), function() {
          return htmlPaths.ignore;
        }),
        lop.rules.then(
          lop.rules.zeroOrMoreWithSeparator(
            styleElementRule,
            lop.rules.sequence(
              whitespaceRule,
              lop.rules.tokenOfType("gt"),
              whitespaceRule
            )
          ),
          htmlPaths.elements
        )
      );
    }
    __name(htmlPathRule, "htmlPathRule");
    var identifierRule = lop.rules.then(
      lop.rules.tokenOfType("identifier"),
      decodeEscapeSequences
    );
    var integerRule = lop.rules.tokenOfType("integer");
    var stringRule = lop.rules.then(
      lop.rules.tokenOfType("string"),
      decodeEscapeSequences
    );
    var escapeSequences = {
      "n": "\n",
      "r": "\r",
      "t": "	"
    };
    function decodeEscapeSequences(value) {
      return value.replace(/\\(.)/g, function(match, code) {
        return escapeSequences[code] || code;
      });
    }
    __name(decodeEscapeSequences, "decodeEscapeSequences");
    var attributeRule = lop.rules.sequence(
      lop.rules.tokenOfType("open-square-bracket"),
      lop.rules.sequence.cut(),
      lop.rules.sequence.capture(identifierRule),
      lop.rules.tokenOfType("equals"),
      lop.rules.sequence.capture(stringRule),
      lop.rules.tokenOfType("close-square-bracket")
    ).map(function(name, value) {
      return { name, value, append: false };
    });
    var classRule = lop.rules.sequence(
      lop.rules.tokenOfType("dot"),
      lop.rules.sequence.cut(),
      lop.rules.sequence.capture(identifierRule)
    ).map(function(className) {
      return { name: "class", value: className, append: true };
    });
    var attributeOrClassRule = lop.rules.firstOf(
      "attribute or class",
      attributeRule,
      classRule
    );
    function parseString(rule, string) {
      var tokens = tokenise(string);
      var parser = lop.Parser();
      var parseResult = parser.parseTokens(rule, tokens);
      if (parseResult.isSuccess()) {
        return results.success(parseResult.value());
      } else {
        return new results.Result(null, [results.warning(describeFailure(string, parseResult))]);
      }
    }
    __name(parseString, "parseString");
    function describeFailure(input, parseResult) {
      return "Did not understand this style mapping, so ignored it: " + input + "\n" + parseResult.errors().map(describeError).join("\n");
    }
    __name(describeFailure, "describeFailure");
    function describeError(error3) {
      return "Error was at character number " + error3.characterNumber() + ": Expected " + error3.expected + " but got " + error3.actual;
    }
    __name(describeError, "describeError");
    var styleRule = createStyleRule();
  }
});

// node_modules/mammoth/lib/options-reader.js
var require_options_reader = __commonJS({
  "node_modules/mammoth/lib/options-reader.js"(exports2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    exports2.readOptions = readOptions;
    var _2 = require_underscore_umd();
    var defaultStyleMap = exports2._defaultStyleMap = [
      "p.Heading1 => h1:fresh",
      "p.Heading2 => h2:fresh",
      "p.Heading3 => h3:fresh",
      "p.Heading4 => h4:fresh",
      "p.Heading5 => h5:fresh",
      "p.Heading6 => h6:fresh",
      "p[style-name='Heading 1'] => h1:fresh",
      "p[style-name='Heading 2'] => h2:fresh",
      "p[style-name='Heading 3'] => h3:fresh",
      "p[style-name='Heading 4'] => h4:fresh",
      "p[style-name='Heading 5'] => h5:fresh",
      "p[style-name='Heading 6'] => h6:fresh",
      "p[style-name='heading 1'] => h1:fresh",
      "p[style-name='heading 2'] => h2:fresh",
      "p[style-name='heading 3'] => h3:fresh",
      "p[style-name='heading 4'] => h4:fresh",
      "p[style-name='heading 5'] => h5:fresh",
      "p[style-name='heading 6'] => h6:fresh",
      // Apple Pages
      "p.Heading => h1:fresh",
      "p[style-name='Heading'] => h1:fresh",
      "r[style-name='Strong'] => strong",
      "p[style-name='footnote text'] => p:fresh",
      "r[style-name='footnote reference'] =>",
      "p[style-name='endnote text'] => p:fresh",
      "r[style-name='endnote reference'] =>",
      "p[style-name='annotation text'] => p:fresh",
      "r[style-name='annotation reference'] =>",
      // LibreOffice
      "p[style-name='Footnote'] => p:fresh",
      "r[style-name='Footnote anchor'] =>",
      "p[style-name='Endnote'] => p:fresh",
      "r[style-name='Endnote anchor'] =>",
      "p:unordered-list(1) => ul > li:fresh",
      "p:unordered-list(2) => ul|ol > li > ul > li:fresh",
      "p:unordered-list(3) => ul|ol > li > ul|ol > li > ul > li:fresh",
      "p:unordered-list(4) => ul|ol > li > ul|ol > li > ul|ol > li > ul > li:fresh",
      "p:unordered-list(5) => ul|ol > li > ul|ol > li > ul|ol > li > ul|ol > li > ul > li:fresh",
      "p:ordered-list(1) => ol > li:fresh",
      "p:ordered-list(2) => ul|ol > li > ol > li:fresh",
      "p:ordered-list(3) => ul|ol > li > ul|ol > li > ol > li:fresh",
      "p:ordered-list(4) => ul|ol > li > ul|ol > li > ul|ol > li > ol > li:fresh",
      "p:ordered-list(5) => ul|ol > li > ul|ol > li > ul|ol > li > ul|ol > li > ol > li:fresh",
      "r[style-name='Hyperlink'] =>",
      "p[style-name='Normal'] => p:fresh",
      // Apple Pages
      "p.Body => p:fresh",
      "p[style-name='Body'] => p:fresh"
    ];
    var standardOptions = exports2._standardOptions = {
      externalFileAccess: false,
      transformDocument: identity,
      includeDefaultStyleMap: true,
      includeEmbeddedStyleMap: true
    };
    function readOptions(options) {
      options = options || {};
      return _2.extend({}, standardOptions, options, {
        customStyleMap: readStyleMap(options.styleMap),
        readStyleMap: function() {
          var styleMap = this.customStyleMap;
          if (this.includeEmbeddedStyleMap) {
            styleMap = styleMap.concat(readStyleMap(this.embeddedStyleMap));
          }
          if (this.includeDefaultStyleMap) {
            styleMap = styleMap.concat(defaultStyleMap);
          }
          return styleMap;
        }
      });
    }
    __name(readOptions, "readOptions");
    function readStyleMap(styleMap) {
      if (!styleMap) {
        return [];
      } else if (_2.isString(styleMap)) {
        return styleMap.split("\n").map(function(line) {
          return line.trim();
        }).filter(function(line) {
          return line !== "" && line.charAt(0) !== "#";
        });
      } else {
        return styleMap;
      }
    }
    __name(readStyleMap, "readStyleMap");
    function identity(value) {
      return value;
    }
    __name(identity, "identity");
  }
});

// node_modules/mammoth/browser/unzip.js
var require_unzip = __commonJS({
  "node_modules/mammoth/browser/unzip.js"(exports2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var promises = require_promises();
    var zipfile = require_zipfile();
    exports2.openZip = openZip;
    function openZip(options) {
      if (options.arrayBuffer) {
        return promises.resolve(zipfile.openArrayBuffer(options.arrayBuffer));
      } else {
        return promises.reject(new Error("Could not find file in options"));
      }
    }
    __name(openZip, "openZip");
  }
});

// node_modules/mammoth/lib/underline.js
var require_underline = __commonJS({
  "node_modules/mammoth/lib/underline.js"(exports2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var htmlPaths = require_html_paths();
    var Html2 = require_html();
    exports2.element = element;
    function element(name) {
      return function(html) {
        return Html2.elementWithTag(htmlPaths.element(name), [html]);
      };
    }
    __name(element, "element");
  }
});

// node_modules/mammoth/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/mammoth/lib/index.js"(exports2) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var _2 = require_underscore_umd();
    var docxReader = require_docx_reader();
    var docxStyleMap = require_style_map();
    var DocumentConverter = require_document_to_html().DocumentConverter;
    var convertElementToRawText = require_raw_text().convertElementToRawText;
    var readStyle = require_style_reader().readStyle;
    var readOptions = require_options_reader().readOptions;
    var unzip = require_unzip();
    var Result = require_results().Result;
    exports2.convertToHtml = convertToHtml;
    exports2.convertToMarkdown = convertToMarkdown;
    exports2.convert = convert;
    exports2.extractRawText = extractRawText;
    exports2.images = require_images();
    exports2.transforms = require_transforms();
    exports2.underline = require_underline();
    exports2.embedStyleMap = embedStyleMap;
    exports2.readEmbeddedStyleMap = readEmbeddedStyleMap;
    function convertToHtml(input, options) {
      return convert(input, options);
    }
    __name(convertToHtml, "convertToHtml");
    function convertToMarkdown(input, options) {
      var markdownOptions = Object.create(options || {});
      markdownOptions.outputFormat = "markdown";
      return convert(input, markdownOptions);
    }
    __name(convertToMarkdown, "convertToMarkdown");
    function convert(input, options) {
      options = readOptions(options);
      return unzip.openZip(input).tap(function(docxFile) {
        return docxStyleMap.readStyleMap(docxFile).then(function(styleMap) {
          options.embeddedStyleMap = styleMap;
        });
      }).then(function(docxFile) {
        return docxReader.read(docxFile, input, options).then(function(documentResult) {
          return documentResult.map(options.transformDocument);
        }).then(function(documentResult) {
          return convertDocumentToHtml(documentResult, options);
        });
      });
    }
    __name(convert, "convert");
    function readEmbeddedStyleMap(input) {
      return unzip.openZip(input).then(docxStyleMap.readStyleMap);
    }
    __name(readEmbeddedStyleMap, "readEmbeddedStyleMap");
    function convertDocumentToHtml(documentResult, options) {
      var styleMapResult = parseStyleMap(options.readStyleMap());
      var parsedOptions = _2.extend({}, options, {
        styleMap: styleMapResult.value
      });
      var documentConverter = new DocumentConverter(parsedOptions);
      return documentResult.flatMapThen(function(document2) {
        return styleMapResult.flatMapThen(function(styleMap) {
          return documentConverter.convertToHtml(document2);
        });
      });
    }
    __name(convertDocumentToHtml, "convertDocumentToHtml");
    function parseStyleMap(styleMap) {
      return Result.combine((styleMap || []).map(readStyle)).map(function(styleMap2) {
        return styleMap2.filter(function(styleMapping) {
          return !!styleMapping;
        });
      });
    }
    __name(parseStyleMap, "parseStyleMap");
    function extractRawText(input) {
      return unzip.openZip(input).then(docxReader.read).then(function(documentResult) {
        return documentResult.map(convertElementToRawText);
      });
    }
    __name(extractRawText, "extractRawText");
    function embedStyleMap(input, styleMap) {
      return unzip.openZip(input).tap(function(docxFile) {
        return docxStyleMap.writeStyleMap(docxFile, styleMap);
      }).then(function(docxFile) {
        return docxFile.toArrayBuffer();
      }).then(function(arrayBuffer) {
        return {
          toArrayBuffer: function() {
            return arrayBuffer;
          },
          toBuffer: function() {
            return Buffer.from(arrayBuffer);
          }
        };
      });
    }
    __name(embedStyleMap, "embedStyleMap");
    exports2.styleMapping = function() {
      throw new Error(`Use a raw string instead of mammoth.styleMapping e.g. "p[style-name='Title'] => h1" instead of mammoth.styleMapping("p[style-name='Title'] => h1")`);
    };
  }
});

// src/embedding/openai-client.ts
var openai_client_exports = {};
__export(openai_client_exports, {
  getEmbedding: () => getEmbedding
});
async function getEmbedding(text, env3) {
  const response = await fetch("https://api.openai.com/v1/embeddings", {
    method: "POST",
    headers: {
      "Authorization": `Bearer ${env3.OPENAI_API_KEY}`,
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      model: env3.OPENAI_MODEL || "text-embedding-3-large",
      input: text,
      dimensions: parseInt(env3.EMBEDDING_DIMENSIONS || "1536")
    })
  });
  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`OpenAI API error: ${response.status} ${response.statusText} - ${errorText}`);
  }
  const data = await response.json();
  return data.data[0].embedding;
}
var init_openai_client = __esm({
  "src/embedding/openai-client.ts"() {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    __name(getEmbedding, "getEmbedding");
  }
});

// src/index.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// src/handlers/ingest-civil-code.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// src/chunking/statute-chunker.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// src/chunking/utils.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function slidingWindowChunk(text, size, overlap) {
  const chunks = [];
  let start = 0;
  while (start < text.length) {
    chunks.push(text.slice(start, start + size));
    start += size - overlap;
  }
  return chunks;
}
__name(slidingWindowChunk, "slidingWindowChunk");
function extractStatuteReferences(text) {
  const refs = [];
  const regex = /\s*(\d+)/g;
  let match;
  while ((match = regex.exec(text)) !== null) {
    refs.push(`\xA7${match[1]}`);
  }
  return [...new Set(refs)];
}
__name(extractStatuteReferences, "extractStatuteReferences");
function estimateTokens(text) {
  return text.length / 4;
}
__name(estimateTokens, "estimateTokens");

// src/chunking/statute-chunker.ts
function chunkStatute(text, baseMetadata) {
  const chunks = [];
  const sectionRegex = /\s*(\d+)/g;
  const sections = text.split(sectionRegex);
  for (let i2 = 1; i2 < sections.length; i2 += 2) {
    const sectionNum = sections[i2];
    const sectionText = sections[i2 + 1];
    if (!sectionText || sectionText.trim().length < 20)
      continue;
    const fullSectionText = sectionText.trim();
    const estimatedTokens = estimateTokens(fullSectionText);
    if (estimatedTokens > 1e3) {
      const subChunks = slidingWindowChunk(fullSectionText, 4e3, 400);
      subChunks.forEach((subChunk, subIdx) => {
        chunks.push({
          id: `statute_${sectionNum}_${subIdx}`,
          text: subChunk,
          metadata: {
            type: "statute",
            section: sectionNum,
            sub_chunk: subIdx,
            ...baseMetadata
          }
        });
      });
    } else {
      chunks.push({
        id: `statute_${sectionNum}`,
        text: fullSectionText,
        metadata: {
          type: "statute",
          section: sectionNum,
          ...baseMetadata
        }
      });
    }
  }
  return chunks;
}
__name(chunkStatute, "chunkStatute");

// src/services/queue-service.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var QueueService = class {
  constructor(db) {
    this.db = db;
  }
  async addChunks(chunks, priority = 0) {
    const timestamp = (/* @__PURE__ */ new Date()).toISOString();
    const BATCH_SIZE = 50;
    for (let i2 = 0; i2 < chunks.length; i2 += BATCH_SIZE) {
      const batch = chunks.slice(i2, i2 + BATCH_SIZE);
      const statements = batch.map(
        (chunk) => this.db.prepare(`
            INSERT INTO processing_queue
            (chunk_id, chunk_text, chunk_metadata, status, priority, retry_count, created_at)
            VALUES (?, ?, ?, 'pending', ?, 0, ?)
          `).bind(
          chunk.id,
          chunk.text,
          JSON.stringify(chunk.metadata),
          priority,
          timestamp
        )
      );
      await this.db.batch(statements);
    }
    return chunks.length;
  }
  async getNextBatch(batchSize = 10) {
    const result = await this.db.prepare(`
        SELECT * FROM processing_queue
        WHERE status = 'pending'
        ORDER BY priority DESC, created_at ASC
        LIMIT ?
      `).bind(batchSize).all();
    return result.results;
  }
  async markProcessing(chunkIds) {
    for (const id of chunkIds) {
      await this.db.prepare(`
          UPDATE processing_queue
          SET status = 'processing'
          WHERE chunk_id = ?
        `).bind(id).run();
    }
  }
  async markCompleted(chunkId) {
    const timestamp = (/* @__PURE__ */ new Date()).toISOString();
    await this.db.prepare(`
        UPDATE processing_queue
        SET status = 'completed', processed_at = ?
        WHERE chunk_id = ?
      `).bind(timestamp, chunkId).run();
  }
  async markFailed(chunkId, errorMessage) {
    await this.db.prepare(`
        UPDATE processing_queue
        SET status = 'failed',
            retry_count = retry_count + 1,
            error_message = ?
        WHERE chunk_id = ?
      `).bind(errorMessage, chunkId).run();
  }
  async retryFailed() {
    await this.db.prepare(`
        UPDATE processing_queue
        SET status = 'pending',
            error_message = NULL
        WHERE status = 'failed' AND retry_count < 3
      `).run();
  }
  async getStats() {
    const result = await this.db.prepare(`
        SELECT
          SUM(CASE WHEN status = 'pending' THEN 1 ELSE 0 END) as pending,
          SUM(CASE WHEN status = 'processing' THEN 1 ELSE 0 END) as processing,
          SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END) as completed,
          SUM(CASE WHEN status = 'failed' THEN 1 ELSE 0 END) as failed,
          COUNT(*) as total
        FROM processing_queue
      `).first();
    return result;
  }
  async clearCompleted() {
    await this.db.prepare(`DELETE FROM processing_queue WHERE status = 'completed'`).run();
  }
  async clearAll() {
    await this.db.prepare(`DELETE FROM processing_queue`).run();
  }
};
__name(QueueService, "QueueService");

// src/handlers/ingest-civil-code.ts
async function ingestCivilCode(request, env3, ctx) {
  if (request.method !== "POST") {
    return new Response("Method not allowed", { status: 405 });
  }
  try {
    const formData = await request.formData();
    const file = formData.get("file");
    const useR2 = formData.get("useR2") === "true";
    let fileBuffer;
    let fileName = "";
    if (useR2) {
      const filename = formData.get("filename");
      const object = await env3.DOCUMENTS.get(filename);
      if (!object) {
        return new Response("File not found in R2", { status: 404 });
      }
      fileBuffer = await object.arrayBuffer();
      fileName = filename;
    } else {
      if (!file) {
        return new Response("No file provided", { status: 400 });
      }
      fileBuffer = await file.arrayBuffer();
      fileName = file.name;
    }
    const fileText = fileName.endsWith(".docx") ? await extractDOCXText(fileBuffer) : await extractPDFText(fileBuffer);
    const chunks = chunkStatute(fileText, {
      type: "civil_code",
      version_date: "2025-07-01",
      source: "czech_civil_code_2012"
    });
    console.log(`Created ${chunks.length} chunks from civil code`);
    const queueService = new QueueService(env3.DB);
    const added = await queueService.addChunks(chunks, 0);
    return new Response(
      JSON.stringify({
        status: "queued",
        total_chunks: chunks.length,
        chunks_added: added,
        message: "Civil code chunks added to processing queue. Processing will happen via cron job."
      }),
      {
        headers: { "Content-Type": "application/json" }
      }
    );
  } catch (error3) {
    console.error("Error ingesting civil code:", error3);
    return new Response(
      JSON.stringify({ error: error3.message }),
      {
        status: 500,
        headers: { "Content-Type": "application/json" }
      }
    );
  }
}
__name(ingestCivilCode, "ingestCivilCode");
async function extractPDFText(buffer) {
  const { extractText: extractText2 } = await Promise.resolve().then(() => (init_dist(), dist_exports));
  const { text } = await extractText2(new Uint8Array(buffer));
  return text;
}
__name(extractPDFText, "extractPDFText");
async function extractDOCXText(buffer) {
  const mammoth = await Promise.resolve().then(() => __toESM(require_lib3()));
  const result = await mammoth.extractRawText({ arrayBuffer: buffer });
  return result.value;
}
__name(extractDOCXText, "extractDOCXText");

// src/handlers/ingest-decision.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// src/chunking/decision-chunker.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function parseDecision(text) {
  const lines = text.split("\n");
  let case_id = "";
  let court = "";
  let date = "";
  let ecli = "";
  let decision_number = "";
  let decision_type = "";
  let legal_area = "";
  let pravni_veta = "";
  for (let i2 = 0; i2 < lines.length; i2++) {
    const line = lines[i2].trim();
    if (line.includes("sp. zn.")) {
      const match = line.match(/sp\.\s*zn\.\s*([\d\s\w\/]+)/);
      if (match)
        case_id = match[1].trim();
    }
    if (line.includes("ECLI:")) {
      const match = line.match(/ECLI:([\w\d\.:]+)/);
      if (match)
        ecli = match[1].trim();
    }
    if (line.startsWith("Soud:")) {
      court = line.replace("Soud:", "").trim();
    }
    if (line.includes("Datum rozhodnut\xED:") || line.includes("Datum rozhodnut")) {
      const match = line.match(/\d{2}\.\d{2}\.\d{4}/);
      if (match) {
        const parts = match[0].split(".");
        date = `${parts[2]}-${parts[1]}-${parts[0]}`;
      }
    }
    if (line.includes("\u010C\xEDslo rozhodnut\xED:") || line.includes("slo rozhodnut")) {
      const match = line.match(/\d+\/\d+/);
      if (match)
        decision_number = match[0];
    }
    if (line.includes("Typ rozhodnut\xED:") || line.includes("Typ rozhodnut")) {
      decision_type = line.split(":")[1]?.trim() || "";
    }
    if (line.startsWith("Hesla:")) {
      legal_area = line.replace("Hesla:", "").trim();
    }
    if (line.includes("Pr\xE1vn\xED v\u011Bta:") || line.includes("vn") && line.includes("ta:")) {
      let veta = "";
      for (let j2 = i2 + 1; j2 < lines.length; j2++) {
        const nextLine = lines[j2].trim();
        if (nextLine.startsWith("Soud:") || nextLine.startsWith("Datum"))
          break;
        if (nextLine.length > 20) {
          veta += nextLine + " ";
          if (nextLine.endsWith("."))
            break;
        }
      }
      pravni_veta = veta.trim();
      break;
    }
  }
  const sections = extractStatuteReferences(text);
  return {
    case_id: case_id || "unknown",
    court: court || "Nejvy\u0161\u0161\xED soud",
    date: date || (/* @__PURE__ */ new Date()).toISOString().split("T")[0],
    ecli,
    decision_number,
    decision_type,
    legal_area,
    pravni_veta: pravni_veta || text.slice(0, 500),
    full_text: text,
    sections_referenced: sections
  };
}
__name(parseDecision, "parseDecision");
function chunkDecision(text, metadata) {
  const chunks = [];
  const parsed = parseDecision(text);
  const caseIdSafe = metadata.case_id.replace(/\s+/g, "_");
  const statuteRefs = extractStatuteReferences(text);
  chunks.push({
    id: `decision_${caseIdSafe}_principle`,
    text: parsed.pravni_veta,
    metadata: {
      type: "judicial",
      subtype: "principle",
      case_id: metadata.case_id,
      court: metadata.court,
      date: metadata.date,
      statute_refs: statuteRefs,
      is_binding: metadata.is_binding ?? true,
      en_banc: metadata.en_banc,
      citation_count: metadata.citation_count || 0,
      overruled: metadata.overruled || false,
      cites: metadata.cites
    }
  });
  chunks.push({
    id: `decision_${caseIdSafe}_full`,
    text: parsed.full_text,
    metadata: {
      type: "judicial",
      subtype: "full_decision",
      case_id: metadata.case_id,
      court: metadata.court,
      date: metadata.date,
      statute_refs: statuteRefs,
      is_binding: metadata.is_binding ?? true,
      en_banc: metadata.en_banc,
      citation_count: metadata.citation_count || 0,
      overruled: metadata.overruled || false,
      cites: metadata.cites
    }
  });
  return chunks;
}
__name(chunkDecision, "chunkDecision");

// src/weights/calculator.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var COURT_WEIGHTS = {
  "Nejvy\u0161\u0161\xED soud": 10,
  "Supreme Court": 10,
  "Vrchn\xED soud": 5,
  "High Court": 5,
  "Krajsk\xFD soud": 2,
  "Regional Court": 2,
  "Okresn\xED soud": 1,
  "District Court": 1
};
function calculateDecisionWeight(metadata) {
  let weight = 1;
  const courtWeight = COURT_WEIGHTS[metadata.court] || 1;
  weight *= courtWeight;
  const decisionDate = new Date(metadata.date);
  const now = /* @__PURE__ */ new Date();
  const yearsOld = (now.getTime() - decisionDate.getTime()) / (1e3 * 60 * 60 * 24 * 365.25);
  const recency = Math.exp(-0.15 * yearsOld);
  weight *= recency;
  const citationCount = metadata.citation_count || 0;
  const citationFactor = 1 + Math.log1p(citationCount) * 0.2;
  weight *= citationFactor;
  if (metadata.is_binding) {
    weight *= 2;
  }
  if (metadata.en_banc) {
    weight *= 1.5;
  }
  if (metadata.overruled) {
    weight *= 0.1;
  }
  return weight;
}
__name(calculateDecisionWeight, "calculateDecisionWeight");

// src/services/decision-service.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var DecisionService = class {
  constructor(db) {
    this.db = db;
  }
  async storeDecision(parsed, weight) {
    const timestamp = (/* @__PURE__ */ new Date()).toISOString();
    await this.db.prepare(`
        INSERT INTO decisions
        (case_id, court, date, ecli, decision_number, decision_type, legal_area,
         pravni_veta, full_text, sections_referenced, weight, is_binding, en_banc,
         citation_count, overruled, indexed_at)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
      `).bind(
      parsed.case_id,
      parsed.court,
      parsed.date,
      parsed.ecli || null,
      parsed.decision_number || null,
      parsed.decision_type || null,
      parsed.legal_area || null,
      parsed.pravni_veta,
      parsed.full_text,
      JSON.stringify(parsed.sections_referenced),
      weight,
      1,
      0,
      0,
      0,
      timestamp
    ).run();
  }
  async getDecision(case_id) {
    const result = await this.db.prepare("SELECT * FROM decisions WHERE case_id = ?").bind(case_id).first();
    return result;
  }
  async listDecisions(limit = 50) {
    const result = await this.db.prepare("SELECT * FROM decisions ORDER BY date DESC LIMIT ?").bind(limit).all();
    return result.results;
  }
  async getDecisionsBySection(section) {
    const result = await this.db.prepare(`
        SELECT * FROM decisions
        WHERE sections_referenced LIKE ?
        ORDER BY weight DESC, date DESC
      `).bind(`%"\xA7${section}"%`).all();
    return result.results;
  }
  async updateCitationCount(case_id, count3) {
    await this.db.prepare("UPDATE decisions SET citation_count = ? WHERE case_id = ?").bind(count3, case_id).run();
  }
  async addCitation(citing_case_id, cited_case_id) {
    await this.db.prepare(`
        INSERT INTO citations (citing_case_id, cited_case_id)
        VALUES (?, ?)
        ON CONFLICT DO NOTHING
      `).bind(citing_case_id, cited_case_id).run();
  }
  async getCitedBy(case_id) {
    const result = await this.db.prepare("SELECT citing_case_id FROM citations WHERE cited_case_id = ?").bind(case_id).all();
    return result.results.map((r2) => r2.citing_case_id);
  }
  async getCites(case_id) {
    const result = await this.db.prepare("SELECT cited_case_id FROM citations WHERE citing_case_id = ?").bind(case_id).all();
    return result.results.map((r2) => r2.cited_case_id);
  }
};
__name(DecisionService, "DecisionService");

// src/handlers/ingest-decision.ts
async function ingestDecision(request, env3, ctx) {
  if (request.method !== "POST") {
    return new Response("Method not allowed", { status: 405 });
  }
  try {
    const formData = await request.formData();
    const file = formData.get("file");
    const metadataJson = formData.get("metadata");
    if (!file) {
      return new Response("File required", { status: 400 });
    }
    const pdfBuffer = await file.arrayBuffer();
    const pdfText = await extractPDFText2(pdfBuffer);
    const parsed = parseDecision(pdfText);
    const metadata = metadataJson ? { ...JSON.parse(metadataJson), ...parsed } : {
      case_id: parsed.case_id,
      court: parsed.court,
      date: parsed.date,
      is_binding: true,
      citation_count: 0
    };
    await env3.DOCUMENTS.put(
      `decisions/${metadata.case_id.replace(/\s+/g, "_")}.pdf`,
      pdfBuffer,
      {
        customMetadata: {
          case_id: metadata.case_id,
          court: metadata.court,
          date: metadata.date
        }
      }
    );
    const weight = calculateDecisionWeight(metadata);
    const decisionService = new DecisionService(env3.DB);
    await decisionService.storeDecision(parsed, weight);
    const chunks = chunkDecision(pdfText, metadata);
    console.log(`Created ${chunks.length} chunks from decision ${metadata.case_id}`);
    const chunksWithWeight = chunks.map((chunk, idx) => {
      const isPrinciple = chunk.metadata.subtype === "principle";
      const chunkWeight = isPrinciple ? weight * 1.2 : weight;
      return {
        ...chunk,
        metadata: {
          ...chunk.metadata,
          weight: chunkWeight
        }
      };
    });
    const queueService = new QueueService(env3.DB);
    const added = await queueService.addChunks(chunksWithWeight, 10);
    if (metadata.cites && metadata.cites.length > 0) {
      for (const citedCase of metadata.cites) {
        await decisionService.addCitation(metadata.case_id, citedCase);
      }
    }
    return new Response(
      JSON.stringify({
        status: "queued",
        case_id: metadata.case_id,
        chunks: chunks.length,
        weight,
        queued: added,
        pravni_veta: parsed.pravni_veta,
        sections_referenced: parsed.sections_referenced
      }),
      {
        headers: { "Content-Type": "application/json" }
      }
    );
  } catch (error3) {
    console.error("Error ingesting decision:", error3);
    return new Response(
      JSON.stringify({ error: error3.message, stack: error3.stack }),
      {
        status: 500,
        headers: { "Content-Type": "application/json" }
      }
    );
  }
}
__name(ingestDecision, "ingestDecision");
async function extractPDFText2(buffer) {
  const { extractText: extractText2 } = await Promise.resolve().then(() => (init_dist(), dist_exports));
  const { text } = await extractText2(new Uint8Array(buffer));
  return text;
}
__name(extractPDFText2, "extractPDFText");

// src/handlers/query.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_openai_client();
async function queryTopology(request, env3, ctx) {
  if (request.method !== "POST") {
    return new Response("Method not allowed", { status: 405 });
  }
  try {
    const body = await request.json();
    const { question, topK = 20, filter } = body;
    if (!question) {
      return new Response(
        JSON.stringify({ error: "Question is required" }),
        { status: 400, headers: { "Content-Type": "application/json" } }
      );
    }
    const queryEmbedding = await getEmbedding(question, env3);
    const queryOptions = {
      topK,
      returnMetadata: true
    };
    if (filter) {
      queryOptions.filter = filter;
    }
    const results = await env3.VECTORIZE.query(queryEmbedding, queryOptions);
    const statutes = results.matches.filter((m2) => m2.metadata?.type === "statute");
    const judicial = results.matches.filter((m2) => m2.metadata?.type === "judicial");
    const weightedResults = results.matches.map((match) => ({
      id: match.id,
      score: match.score,
      weighted_score: match.score * (match.metadata?.weight || 1),
      metadata: match.metadata
    })).sort((a2, b2) => b2.weighted_score - a2.weighted_score);
    return new Response(
      JSON.stringify({
        query: question,
        total_results: results.matches.length,
        results: {
          all: weightedResults.slice(0, 10),
          statutes: statutes.slice(0, 5),
          judicial: judicial.slice(0, 5)
        }
      }),
      {
        headers: { "Content-Type": "application/json" }
      }
    );
  } catch (error3) {
    console.error("Error querying topology:", error3);
    return new Response(
      JSON.stringify({ error: error3.message }),
      {
        status: 500,
        headers: { "Content-Type": "application/json" }
      }
    );
  }
}
__name(queryTopology, "queryTopology");

// src/handlers/recompute-weights.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
async function recomputeWeights(request, env3, ctx) {
  if (request.method !== "POST") {
    return new Response("Method not allowed", { status: 405 });
  }
  try {
    const body = await request.json();
    const { case_ids } = body;
    if (!case_ids || !Array.isArray(case_ids)) {
      return new Response(
        JSON.stringify({ error: "case_ids array is required" }),
        { status: 400, headers: { "Content-Type": "application/json" } }
      );
    }
    const updated = [];
    for (const caseId of case_ids) {
      const vectors = await env3.VECTORIZE.query([], {
        filter: { case_id: caseId },
        returnMetadata: true,
        topK: 1e3
      });
      if (vectors.matches && vectors.matches.length > 0) {
        const firstMatch = vectors.matches[0];
        const metadata = firstMatch.metadata;
        const newWeight = calculateDecisionWeight(metadata);
        for (const match of vectors.matches) {
          const updatedMetadata = {
            ...match.metadata,
            weight: newWeight,
            weight_updated_at: (/* @__PURE__ */ new Date()).toISOString()
          };
          await env3.VECTORIZE.upsert([
            {
              id: match.id,
              values: match.vector || [],
              metadata: updatedMetadata
            }
          ]);
        }
        updated.push(caseId);
      }
    }
    return new Response(
      JSON.stringify({
        status: "completed",
        updated_cases: updated,
        count: updated.length
      }),
      {
        headers: { "Content-Type": "application/json" }
      }
    );
  } catch (error3) {
    console.error("Error recomputing weights:", error3);
    return new Response(
      JSON.stringify({ error: error3.message }),
      {
        status: 500,
        headers: { "Content-Type": "application/json" }
      }
    );
  }
}
__name(recomputeWeights, "recomputeWeights");

// src/handlers/synthesize.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
async function synthesizeInterpretation(request, env3, ctx) {
  if (request.method !== "POST") {
    return new Response("Method not allowed", { status: 405 });
  }
  try {
    const body = await request.json();
    const { question, facts, topK = 10 } = body;
    if (!question) {
      return new Response(
        JSON.stringify({ error: "Question is required" }),
        { status: 400, headers: { "Content-Type": "application/json" } }
      );
    }
    const { getEmbedding: getEmbedding2 } = await Promise.resolve().then(() => (init_openai_client(), openai_client_exports));
    const queryEmbedding = await getEmbedding2(question, env3);
    const results = await env3.VECTORIZE.query(queryEmbedding, {
      topK,
      returnMetadata: true
    });
    const statutes = results.matches.filter((m2) => m2.metadata?.type === "statute" || m2.metadata?.type === "civil_code").slice(0, 5);
    const cases = results.matches.filter((m2) => m2.metadata?.type === "judicial").slice(0, 5);
    const statuteContext = statutes.map((s2) => `\xA7${s2.metadata.section}: ${s2.metadata.text}`).join("\n\n");
    const caseContext = cases.length > 0 ? cases.map(
      (c2) => `Case ${c2.metadata.case_id} (weight: ${c2.metadata.weight}): ${c2.metadata.text}`
    ).join("\n\n") : "No relevant case law found yet.";
    const factsContext = facts ? `

Client Facts:
${JSON.stringify(facts, null, 2)}` : "";
    const systemPrompt = `You are an expert in Czech civil law. Analyze the provided statutory provisions and case law to answer legal questions.

Instructions:
1. Start with the statutory foundation (what the law says)
2. Note any judicial interpretations (how courts have applied it)
3. Apply to the specific facts if provided
4. Provide a confidence assessment
5. Explain your reasoning clearly

Be precise, cite sections, and indicate uncertainty where appropriate.`;
    const userPrompt = `STATUTORY LAW:
${statuteContext}

CASE LAW:
${caseContext}
${factsContext}

QUESTION:
${question}

Provide a comprehensive legal analysis.`;
    const response = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${env3.OPENAI_API_KEY}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        model: "gpt-4o-mini",
        messages: [
          { role: "system", content: systemPrompt },
          { role: "user", content: userPrompt }
        ],
        temperature: 0.3
      })
    });
    if (!response.ok) {
      throw new Error(`OpenAI API error: ${response.statusText}`);
    }
    const completion = await response.json();
    const analysis = completion.choices[0].message.content;
    return new Response(
      JSON.stringify({
        question,
        facts,
        statutory_foundation: statutes.map((s2) => ({
          section: `\xA7${s2.metadata.section}`,
          text: s2.metadata.text,
          relevance: s2.score
        })),
        case_law: cases.map((c2) => ({
          case_id: c2.metadata.case_id,
          weight: c2.metadata.weight,
          text: c2.metadata.text,
          relevance: c2.score
        })),
        analysis,
        metadata: {
          model: "gpt-4o-mini",
          statutes_found: statutes.length,
          cases_found: cases.length
        }
      }),
      {
        headers: { "Content-Type": "application/json" }
      }
    );
  } catch (error3) {
    console.error("Error in synthesis:", error3);
    return new Response(
      JSON.stringify({ error: error3.message }),
      {
        status: 500,
        headers: { "Content-Type": "application/json" }
      }
    );
  }
}
__name(synthesizeInterpretation, "synthesizeInterpretation");

// src/services/processor-service.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_openai_client();

// src/embedding/prompts.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function prepareStatuteText(text, metadata) {
  const chapter = metadata.chapter ? ` - ${metadata.chapter}` : "";
  return `Legal Statute - Civil Code Section \xA7${metadata.section}${chapter}

${text}

[This is a statutory provision from Czech Civil Code, effective ${metadata.version_date}]`;
}
__name(prepareStatuteText, "prepareStatuteText");
function prepareDecisionText(text, metadata) {
  const refs = metadata.statute_refs?.length > 0 ? metadata.statute_refs.join(", ") : "general principles";
  const year = new Date(metadata.date).getFullYear();
  return `Court Decision - ${metadata.court} (${year})
Case: ${metadata.case_id}
Interprets: ${refs}

${text}

[This is judicial interpretation from Czech ${metadata.court}]`;
}
__name(prepareDecisionText, "prepareDecisionText");

// src/services/processor-service.ts
var ProcessorService = class {
  constructor(queueService, env3) {
    this.queueService = queueService;
    this.env = env3;
  }
  async processNextBatch(batchSize = 10) {
    const items = await this.queueService.getNextBatch(batchSize);
    if (items.length === 0) {
      const stats2 = await this.queueService.getStats();
      return {
        processed: 0,
        failed: 0,
        remaining: stats2.pending
      };
    }
    await this.queueService.markProcessing(items.map((i2) => i2.chunk_id));
    let processed = 0;
    let failed = 0;
    for (const item of items) {
      try {
        await this.processItem(item);
        await this.queueService.markCompleted(item.chunk_id);
        processed++;
      } catch (error3) {
        console.error(`Failed to process ${item.chunk_id}:`, error3.message);
        await this.queueService.markFailed(item.chunk_id, error3.message);
        failed++;
      }
    }
    const stats = await this.queueService.getStats();
    return {
      processed,
      failed,
      remaining: stats.pending
    };
  }
  async processItem(item) {
    const metadata = JSON.parse(item.chunk_metadata);
    let preparedText;
    if (metadata.type === "statute") {
      preparedText = prepareStatuteText(item.chunk_text, metadata);
    } else {
      preparedText = prepareDecisionText(item.chunk_text, metadata);
    }
    const embedding = await getEmbedding(preparedText, this.env);
    const weight = metadata.type === "statute" ? 1 : metadata.weight || 1;
    await this.env.VECTORIZE.upsert([{
      id: item.chunk_id,
      values: embedding,
      metadata: {
        ...metadata,
        weight,
        text: item.chunk_text,
        indexed_at: (/* @__PURE__ */ new Date()).toISOString(),
        embedding_model: this.env.OPENAI_MODEL || "text-embedding-3-large"
      }
    }]);
  }
};
__name(ProcessorService, "ProcessorService");

// src/index.ts
var corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
  "Access-Control-Allow-Headers": "Content-Type, Authorization"
};
var src_default = {
  async fetch(request, env3, ctx) {
    const url = new URL(request.url);
    if (request.method === "OPTIONS") {
      return new Response(null, { headers: corsHeaders });
    }
    try {
      switch (url.pathname) {
        case "/api/ingest/civil-code":
          return await ingestCivilCode(request, env3, ctx);
        case "/api/ingest/decision":
          return await ingestDecision(request, env3, ctx);
        case "/api/query":
          return await queryTopology(request, env3, ctx);
        case "/api/synthesize":
          return await synthesizeInterpretation(request, env3, ctx);
        case "/api/weights/recompute":
          return await recomputeWeights(request, env3, ctx);
        case "/api/queue/stats":
          return await handleQueueStats(env3);
        case "/api/queue/process":
          return await handleProcessQueue(env3);
        case "/api/queue/clear":
          return await handleClearQueue(env3);
        case "/api/health":
          return new Response(
            JSON.stringify({
              status: "ok",
              timestamp: (/* @__PURE__ */ new Date()).toISOString(),
              version: "1.0.0"
            }),
            {
              headers: { ...corsHeaders, "Content-Type": "application/json" }
            }
          );
        case "/":
          return new Response(
            JSON.stringify({
              service: "Legal Topology API",
              version: "1.0.0",
              endpoints: [
                "POST /api/ingest/civil-code",
                "POST /api/ingest/decision",
                "POST /api/query",
                "POST /api/weights/recompute",
                "GET /api/health"
              ]
            }),
            {
              headers: { ...corsHeaders, "Content-Type": "application/json" }
            }
          );
        default:
          return new Response(
            JSON.stringify({ error: "Not Found" }),
            {
              status: 404,
              headers: { ...corsHeaders, "Content-Type": "application/json" }
            }
          );
      }
    } catch (error3) {
      console.error("Worker error:", error3);
      return new Response(
        JSON.stringify({
          error: error3.message,
          stack: error3.stack
        }),
        {
          status: 500,
          headers: { ...corsHeaders, "Content-Type": "application/json" }
        }
      );
    }
  },
  async scheduled(event, env3, ctx) {
    console.log("[Scheduled] Processing queue...");
    try {
      const queueService = new QueueService(env3.DB);
      const processor = new ProcessorService(queueService, env3);
      const result = await processor.processNextBatch(50);
      console.log("[Scheduled] Batch processed:", result);
      if (result.remaining > 0) {
        console.log(`[Scheduled] ${result.remaining} items remaining in queue`);
      } else {
        console.log("[Scheduled] Queue is empty");
      }
    } catch (error3) {
      console.error("[Scheduled] Processing failed:", error3);
    }
  }
};
async function handleQueueStats(env3) {
  try {
    const queueService = new QueueService(env3.DB);
    const stats = await queueService.getStats();
    return new Response(
      JSON.stringify(stats),
      { headers: { ...corsHeaders, "Content-Type": "application/json" } }
    );
  } catch (error3) {
    return new Response(
      JSON.stringify({ error: error3.message }),
      { status: 500, headers: { ...corsHeaders, "Content-Type": "application/json" } }
    );
  }
}
__name(handleQueueStats, "handleQueueStats");
async function handleProcessQueue(env3) {
  try {
    const queueService = new QueueService(env3.DB);
    const processor = new ProcessorService(queueService, env3);
    const result = await processor.processNextBatch(50);
    return new Response(
      JSON.stringify(result),
      { headers: { ...corsHeaders, "Content-Type": "application/json" } }
    );
  } catch (error3) {
    return new Response(
      JSON.stringify({ error: error3.message }),
      { status: 500, headers: { ...corsHeaders, "Content-Type": "application/json" } }
    );
  }
}
__name(handleProcessQueue, "handleProcessQueue");
async function handleClearQueue(env3) {
  try {
    const queueService = new QueueService(env3.DB);
    await queueService.clearAll();
    return new Response(
      JSON.stringify({ status: "cleared" }),
      { headers: { ...corsHeaders, "Content-Type": "application/json" } }
    );
  } catch (error3) {
    return new Response(
      JSON.stringify({ error: error3.message }),
      { status: 500, headers: { ...corsHeaders, "Content-Type": "application/json" } }
    );
  }
}
__name(handleClearQueue, "handleClearQueue");
export {
  src_default as default
};
/*! Bundled license information:

unpdf/dist/index.mjs:
  (**
   * Derived from the PDF.js project by the Mozilla Foundation.
   * @see https://github.com/mozilla/pdf.js/blob/b8de9a372f9bbf7e33adb362eeae5ef1919dba73/src/display/canvas_factory.js#L18
   * @license Apache-2.0
   *)

jszip/dist/jszip.min.js:
  (*!
  
  JSZip v3.10.1 - A JavaScript class for generating and reading zip files
  <http://stuartk.com/jszip>
  
  (c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
  Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.
  
  JSZip uses the library pako released under the MIT license :
  https://github.com/nodeca/pako/blob/main/LICENSE
  *)
*/
//# sourceMappingURL=index.js.map
